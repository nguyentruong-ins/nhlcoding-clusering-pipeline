problem_slug,submission_id,student_code,code,score,testcase_results,labels
Array_list_7,1290686,2110501,"int maxSum(int* nums, int n, int k) {
int Max[n];
for(int i=0;i<n;i++)
{
    int j=i;
    int cur=0; 
    int curMax=nums[i];
    while(j>=0 && i-j+1 <=k)
    {
        curMax = max(curMax,nums[j]);
        int x = (curMax*(i-j+1));
        if(j!=0)    x += Max[j-1];
        cur =max(cur,x);
        j--;
    }
    Max[i]=cur;
}
return Max[n-1];
}",1.0,11111,0
Array_list_7,1333910,2210997,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n]; 

    for (int i = 0; i < n; i++) {
        int maxElement = nums[i];
        dp[i] = maxElement * 1;

        for (int j = 1; j <= k && i - j + 1 >= 0; ++j) {
            maxElement = std::max(maxElement, nums[i - j + 1]);
            dp[i] = max(dp[i], maxElement * j + (i - j >= 0 ? dp[i - j] : 0));
        }
    }

    int result = dp[n - 1];
    delete[] dp; 

    return result;
}",1.0,11111,0
Array_list_7,1354631, ,"int findMax(int a, int b){
    if(a >= b) return a;
    else return b;
}

int maxSum(int* nums, int n, int k) {
    // vector<int> dp(n + 1, 0);
    // vector<int> a(n + 1);
    int dp[n + 1];
    int a[n + 1];
    for(int i = 0; i <= n; i++) dp[i] = 0;
    for(int i = 1; i <= n; i++){
        a[i] = nums[i-1];
    }
    for(int i = 1; i <= n; i++){
        for(int t = 1; t <= k; t++){
            for(int j = i - t + 1; j <= i; j++){
                if(j < 1) continue;
                int end = j + t - 1;
                if(end > n) continue;
                dp[end] = findMax(dp[end], t * a[i] + dp[j-1]);
                // if(end == i){
                //     dp[i] = findMax(dp[i], t * a[i] + dp[j-1]);
                // }
                // else{
                //     dp[end] = findMax(dp[end], t * a[i] + dp[j-1]);
                // }
            }
        }
    }
    return dp[n];
}",1.0,11111,1
Array_list_7,1355749,2212372,"int solve(int**dp, int* nums, int i, int n, int tempMax, int a, int& k)
{
    
    if(i >= n)
    {
        if(a == 1)
            return 0;
        return tempMax*(a-1);
    }
   
      if(dp[i][a] != -1)
        return dp[i][a];
    int choose = -10;
    if(a + 1 <= k)
        choose = solve(dp, nums, i+1, n, max(tempMax, nums[i]), a+1, k);
    int notchoose = max(tempMax, nums[i])*a + solve(dp, nums, i+1, n, -10, 1, k);
    return dp[i][a] = max(choose, notchoose);
}
int maxSum(int* nums, int n, int k) {
    int**dp = new int*[n+1];
    for(int i = 0; i <= n; i++)
    {
        dp[i] = new int[k+1];
        for(int x = 0; x <= k; x++)
            dp[i][x] = -1;

    }
    
return solve(dp, nums, 0, n, -10, 1, k);


}",1.0,11111,2
Array_list_7,1360890,2213298,"int max(int a, int b) { return (a > b) ? a : b; }

int maxSum(int* nums, int n, int k) {
    int dp[10005] = {0};
    for (int i = 0; i < n; i++) {
        int maxElement = nums[i];
        for (int j = 1; j <= k && i - j + 1 >= 0; j++) {
            maxElement = max(maxElement, nums[i - j + 1]);
            dp[i] = max(dp[i], ((i >= j) ? dp[i - j] : 0) + maxElement * j);
        }
    }
    return dp[n - 1];
}",1.0,11111,0
Array_list_7,1361294,2213250,"int max_array(int* nums , int l , int r){
    int ans = (int)(-1e9);
    for(int i= l ; i<=r ; i++){
        ans = max(ans,nums[i]);
    }
    return ans;
}

int maxSum(int* nums, int n, int k) {
    int dp[10001];
    for(int i=0 ; i<k ; i++){
        dp[i] = max_array(nums,0,i)*(i+1);
    }
    for(int i = k ; i<n;i++){
        for(int j = 1 ; j<=k;j++){
            dp[i] = max(dp[i], max_array(nums,i-j+1, i)*j + dp[i-j]);
        }
    }
    return dp[n-1];
}",0.6,11010,0
Array_list_7,1371132,2213250,"int max_array(int* nums, int l, int r)
{
	int ans = -1e9;
	for (int i = l; i <= r; i++)
	{
		ans = max(ans, nums[i]);
	}
	return ans;
}




int maxSum(int* nums, int n, int k) 
{
	int dp[10000];
	for (int i = 0; i < k; i++)
	{
		dp[i] = max_array(nums, 0, i) * (i + 1);
	}
	for (int i = k; i < n; i++)
	{
		for (int j = k; j >= 0; j--)
		{
			dp[i] = max(dp[i], dp[i - j] + max_array(nums, i - j + 1, i) * j);
		}
	}
	return dp[n - 1];
}",0.6,11010,0
Array_list_7,1374306,2211821,"int maxSum(int* nums, int n, int k) {
     if(n<=0) return 0;
      if (n <= k) {
        int max = 0;
        for (int i = 0; i < n; i++) {
            if (max < nums[i]) max = nums[i];
        }
        return max * n;
    }
    
    int dp[k] = {0};
    for (int i = 1; i <= k; i++) {
        int max = 0;
        for (int j = 0; j < i; j++) {
            if (max < nums[j]) max = nums[j];
        }
        dp[i - 1] = max * i + maxSum(nums + i, n - i, k);
    }
    
    int maxMuti = dp[0];
    for (int i = 1; i < k; i++) {
        if (maxMuti < dp[i]) maxMuti = dp[i];
    }
    
    return maxMuti;
}",0.8,11110,3
Array_list_7,1374982,2210034,"#include<vector>
#include <algorithm>
using namespace std;
int maxSum(int* nums, int n, int k) {
    vector<int> dp(n+1, 0);
    for (int i = 1; i <= n; ++i) {
        int max_val = nums[i-1];
        for (int j = i; j > 0 && i-j+1 <= k; --j) {
            max_val = max(max_val, nums[j-1]);
            dp[i] = max(dp[i], dp[j-1] + max_val * (i-j+1));
        }
    }
    return dp[n];
}",1.0,11111,0
Array_list_7,1375151,2213836,"int maxSum(int* nums, int n, int k) {
    int* maxS = new int[n + 1]; //* tạo 1 mảng để lưu giá trị
    maxS[0] = 0;
    
    for(int i = 1; i <= n; i++) { //* duyệt tới n
        maxS[i] = 0;
        int maxElement = 0;
        for(int j = 1; j <= k && (i - j) >= 0; j++) { //* mảng con có j phần tử
            maxElement = max(maxElement, nums[i - j]);
            maxS[i] = max(maxS[i], maxS[i - j] + maxElement * j); //* i - j là vị trí đang xét trong nums
        }
    }

    int result = maxS[n];
    delete[] maxS;
    return result;
}",1.0,11111,0
Array_list_7,1376649,2211667,"int maxSum(int* nums, int n, int k) {
    int sum = 0;
    for (int i = 0; i < n; i += k) {
        int maxNum = 0;
        for (int j = i; j < min(i + k, n); ++j) {
            maxNum = max(maxNum, nums[j]);
        }
        sum += maxNum * min(k, n - i);
    }
    return sum;
}",0.2,10000,4
Array_list_7,1379470,1913560,"int maxSum(int* nums, int n, int k) {
    int result = 0;
    int num = 0;
    int currentMax = nums[0];

    for (int i = 0; i < n; i++) {
        num += 1;
        currentMax = max(currentMax, nums[i]);

        if (num == k || nums[i] == nums[i + 1] || (num == 2 && nums[i - 1] == nums[i + 1]) || i == n - 1) {
            result += num * currentMax;
            num = 0;
            currentMax = nums[i + 1];
        }
    }

    return result;
}",0.4,10100,4
Array_list_7,1381496,2212303,"int maxSum(int* nums, int n, int k) {
    int *maxS=new int[n];
        int max_sum = 0;
    for (int i = 0; i < n; i++) maxS[i] = 0;
    for (int i = 0; i < n; ++i) {
        int max_val = nums[i];
        int current_product = 0;
        for (int j = i; j >= 0 && i - j + 1 <= k; j--) {
            max_val = max(max_val, nums[j]);
            current_product = max_val * (i - j + 1);
            if (j > 0) {
                current_product += maxS[j - 1];
            }
            if (current_product > maxS[i])
                maxS[i] = current_product;
        }
    }
    for (int i = 0; i < n; ++i) {
        if (maxS[i] > max_sum)
            max_sum = maxS[i];
    }
    return max_sum;
}",1.0,11111,0
Array_list_7,1384333,2211876,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n + 1];
    

    for (int i = 0; i <= n; i++) {
        dp[i] = 0;
    }

    
    for (int i = 1; i <= n; i++) {
        int maxElement = 0;
        
        
        for (int j = 1; j <= k && i - j >= 0; j++) {
            
            maxElement = max(maxElement, nums[i - j]);
            int currentSValue = maxElement * j;
            
            
            dp[i] = max(dp[i], dp[i - j] + currentSValue);
        }
    }

   
    int result = dp[n];
    
    
    delete[] dp;

    return result;

   
}",1.0,11111,0
Array_list_7,1386900,2211738,"int maxSum(int* nums, int n, int k) {
    if(n == 0) return 0;
    int count = 1, sum = 0, maxi = nums[0];
    for(int i = 1; i < n; i++){
        if(nums[i] != nums[i-1] && count < k){
            count++;
            maxi = max(maxi, nums[i]);
        }else{
            sum += maxi*count;
            count = 1;
            maxi = nums[i];
        }
    }
    sum += maxi*count;
    return sum;
}",0.4,10100,4
Array_list_7,1390888,2212651,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n]; 

    for (int i = 0; i < n; i++) {
        int maxElement = nums[i];
        dp[i] = maxElement * 1;

        for (int j = 1; j <= k && i + 1 >= j ; j++) {
            maxElement = max(maxElement, nums[i - j + 1]);
            dp[i] = max(dp[i], maxElement * j + (i - j >= 0 ? dp[i - j] : 0));
        }
    }

    int result = dp[n - 1];
    delete[] dp; 

    return result;
}",1.0,11111,0
Array_list_7,1390896,2252260,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n+1];
    dp[0] = 0;
    for(int i=1; i<=n; i++){
        int maxVal=0;
        for(int j=1; j<=k && i-j>=0; j++){
            maxVal = max(nums[i-j], maxVal);
            dp[i] = max(dp[i], dp[i-j]+maxVal*j);
        }
    }
    return dp[n];
}",1.0,11111,0
Array_list_7,1390991,2210103,"int maxSum(int* nums, int n, int k) {
    int result = 0;

    for (int i = 0; i < n; ++i) {
        int maxS = nums[i];
        int sub = k+1;

        for (int j = i; j < n && j - i < k; ++j) {
            if (nums[j] > maxS) {
                maxS = nums[j];
            }

            int sValue = maxS * sub;
            result = max(result, sValue);

            ++sub;
        }
    }

    return result-1;
}",0.2,10000,4
Array_list_7,1391103,2213250,"int max_array(int* nums , int l , int r){
    int ans = (int)(-1e9);
    for(int i= l ; i<=r ; i++){
        ans = max(ans,nums[i]);
    }
    return ans;
}

int maxSum(int* nums, int n, int k) {
    int dp[10001];
    for(int i=0 ; i<k ; i++){
        dp[i] = max_array(nums,0,i)*(i+1);
    }
    for(int i = k ; i<n;i++){
        for(int j = 1 ; j<=k;j++){
            dp[i] = max(dp[i], max_array(nums,i-j+1, i)*j + dp[i-j]);
        }
    }
    return dp[n-1];
}",0.6,11010,0
Array_list_7,1391631,2210103,"int maxSum(int* nums, int n, int k) {
    int result = 0;

    for (int i = 0; i < n; ++i) {
        int maxS = nums[i];
        int sub = k+1;

        for (int j = i; j < n && j - i <= k-1; ++j) {
            if (nums[j] > maxS) {
                maxS = nums[j];
            }

            int sValue = maxS * sub;
            result = max(result, sValue);

            ++sub;
        }
    }

    return result-1;
}",0.2,10000,4
Array_list_7,1392097,2213250,"int max_array(int* nums , int l , int r){
    int ans = -1e9;
    for(int i=l ; i<=r ; i++){
        ans = max(ans,nums[i]);
    }
    return ans;
}



int maxSum(int* nums, int n, int k) {
    int dp[100001]{};
    for(int i= 0 ; i<k ; i++){
        dp[i] = max_array(nums,0,i)*(i+1);
    }
    for(int i= k ; i<n;i++){
        dp[i] = -1e9;
        for(int j=1 ; j<=k ; j++){
            dp[i] = max(dp[i],dp[i-j] + max_array(nums,i-j+1,i)*j);
        }
    }
    return dp[n-1];
}",1.0,11111,0
Array_list_7,1392269,2013048,"int helpfunction(int *num, int n, int k, int & size){
    int max = num[0], i = 1, idx = 1;
    for(; i < n; i++){
        if(num[i] > max){
            max = num[i];
            idx = i;
        }
    }
    int start = (!idx) ? 0 : idx - k / 2;
    int end = (!idx) ? k : ((k%2) ? idx + k/2 : idx + k/2 -1);
    end = (end >= n) ? n : end;
    for(int i = start; i <= end; i++){
        size += (num[i] > 0) ? 1 : 0;
        num[i] = -1;
    }
    return (max > 0) ? max : 0;
}
int maxSum(int *nums, int n, int k){
    int SubN = (n%k)? n/k+ n%k : n/k;
    int *numcp = nums;
    int sum = 0;
    int j = 0;
    while(j < SubN){
        int size = 0;
        int maxValue = helpfunction(numcp, n , k, size);
        sum += maxValue*size;
        j++;
    }
    return sum;
}",0.2,10000,5
Array_list_7,1392500,2112585,"int maxSum(int* nums, int n, int k) {
    int subarrayCount = (n + k - 1) / k; // Calculate the number of subarrays needed

    int sum = 0;
    for (int i = 0; i < subarrayCount; i++) {
        int start = i * k;
        int end = min(start + k, n);
        int largestElement = nums[start];
        for (int j = start + 1; j < end; j++) {
            if (nums[j] > largestElement) {
                largestElement = nums[j];
            }
        }
        int sValue = largestElement * (end - start);
        sum += sValue;
        sum = max(sum, sValue); // Update the maximum sum
    }

    return sum;
}",0.2,10000,5
Array_list_7,1398928,2212741,"int maxSum(int* nums, int n, int k) {
  int dp[n] = {0};

  for(int i=0;i<n;i++){
      int maxS=0;
      int maxElement=0;
      int count=1;
      for(int j=i;j>=0&&count<=k;count++,j--){
          maxElement=max(maxElement,nums[j]);
          maxS=max(maxS,maxElement*count);
          if(j==0){
              dp[i]=max(dp[i],0+maxS);
          }
          else{
          dp[i]=max(dp[i],maxS+dp[j-1]);
      }
     
      }
  }
    return dp[n - 1];
}",1.0,11111,0
Array_list_7,1401611,2213298,"int max(int a, int b) { return (a > b) ? a : b; }

int maxSum(int* nums, int n, int k) {
    int dp[10005] = {0};
    for (int i = 0; i < n; i++) {
        int maxElement = nums[i];
        for (int j = 1; j <= k && i - j + 1 >= 0; j++) {
            maxElement = max(maxElement, nums[i - j + 1]);
            dp[i] = max(dp[i], ((i >= j) ? dp[i - j] : 0) + maxElement * j);
        }
    }
    return dp[n - 1];
}",1.0,11111,0
Array_list_7,1403078,2211170,"int maxSum(int* nums,int n,int k){

// We create a array dp in which dp[i] = Maximum value of S(W) can be generate till ith index from inital index
// like if we see array {1,6,3,2,2,5,1} and k-3 then dp[0] will be 1 and dp[1] = 12.
// For more clearlity see the below code.

int dp[n];

for(int i=0;i<n;i++)
{

// for each ith index we create all possiable window which end ith index and whose size is less or equal to k
// and for each window we find the possiable value and
// at last Maximum of all possiable value will store at dp[i].

int j=i;
int curr_val=0; // store the Maximum possiable value in all different window that can be generate for ith index
int currMaxEle=nums[i]; // store the Maximum value in range (j and i).

while(j>=0 && i-j+1 <=k)
{

currMaxEle = max(currMaxEle,nums[j]);
int x = (currMaxEle*(i-j+1));
if(j!=0)x += dp[j-1];
// x store the max possiable value of range(j and i).
curr_val =max(curr_val,x);
j--;
}

dp[i]=curr_val;
}

return dp[n-1]; // final return the d[n-1] which store the final Maximum possible value
}",1.0,11111,0
Array_list_7,1406676,2212935,"int maxSum(int* nums, int n, int k) {
    int result = 0;
    int maxElement = 0;
    int subArraySize = 0;

    for (int i = 0; i < n; i++) {
        maxElement = max(maxElement, nums[i]);
        subArraySize++;

        if (subArraySize == k || i == n - 1) {
            result += maxElement * subArraySize;
            maxElement = 0;
            subArraySize = 0;
        }
    }

    return result;
}",0.2,10000,4
Array_list_7,1406684,2212303,"int maxSum(int* nums, int n, int k) {
    int *maxS=new int[n];
        int max_sum = 0;
    for (int i = 0; i < n; i++) maxS[i] = 0;
    for (int i = 0; i < n; ++i) {
        int max_val = nums[i];
        int current_product = 0;
        for (int j = i; j >= 0 && i - j + 1 <= k; j--) {
            max_val = max(max_val, nums[j]);
            current_product = max_val * (i - j + 1);
            if (j > 0) {
                current_product += maxS[j - 1];
            }
            if (current_product > maxS[i])
                maxS[i] = current_product;
        }
    }
    for (int i = 0; i < n; ++i) {
        if (maxS[i] > max_sum)
            max_sum = maxS[i];
    }
    return max_sum;
}",1.0,11111,0
Array_list_7,1408455,2210458,"int findMax(int a, int b)
{
    if (a >= b)
        return a;
    else
        return b;
}

int maxSum(int* nums, int n, int k)
{
    int* f = new int[n];
    int val;
    int max;
    int res = 0;
    for (int i = 0; i < n; i++)
    {
        max = nums[i];
        val = 0;
        for (int j = 0; j < k && i - j >= 0; j++)
        {
            if (j > 0)
            {
                max = findMax(max, nums[i - j]); // đúng
            }
            if (i - j > 0)
            {
                val = findMax(val, f[i - j - 1] + max * (j + 1));
            }
            else
            {
                // in case i - j = 0, there will be no f stored behind.
                val = findMax(val, max * (j + 1));
            }
            
        }
        f[i] = val;
        res = findMax(res, f[i]);
    }
    return res;
}",1.0,11111,0
Array_list_7,1409851,2212741,"int maxSum(int* nums, int n, int k) {
  int dp[n] = {0};

  for(int i=0;i<n;i++){
      int maxS=0;
      int maxElement=0;
      int count=1;
      for(int j=i;j>=0&&count<=k;count++,j--){
          maxElement=max(maxElement,nums[j]);
          maxS=max(maxS,maxElement*count);
          if(j==0){
              dp[i]=max(dp[i],0+maxS);
          }
          else{
          dp[i]=max(dp[i],maxS+dp[j-1]);
      }
     
      }
  }
    return dp[n - 1];
}",1.0,11111,0
Array_list_7,1413666,2211738,"int maxSum(int* nums, int n, int k) {
    if(n == 0) return 0;
    int count = 1, sum = 0, maxi = nums[0];
    for(int i = 1; i < n; i++){
        if(nums[i] != nums[i-1] && count < k){
            count++;
            maxi = max(maxi, nums[i]);
        }else{
            sum += maxi*count;
            count = 1;
            maxi = nums[i];
        }
    }
    sum += maxi*count;
    return sum;
}",0.4,10100,4
Array_list_7,1416340,2213035,"int maxElement(int a, int b)
{ int maxE = a;
    if(b > a)
     {
            maxE = b;
 }
    return maxE;
}

int maxSum(int* nums, int n, int k) {
    int sum = 0, element = -1, length = 0;
    for( int i = 0; i < n; ++i)
    {   if(length < k && element != nums[i]){
        element = maxElement(element, nums[i]);
        length++;
        } else 
        {
            sum += length * element;
            element = nums[i];
            length = 1;
        }
    }
  sum += length * element;
return sum;
}",0.4,10100,4
Array_list_7,1419767,2212372,"int solve(int**dp, int* nums, int i, int n, int tempMax, int a, int& k)
{
    
    if(i >= n)
    {
        if(a == 1)
            return 0;
        return tempMax*(a-1);
    }
   
      if(dp[i][a] != -1)
        return dp[i][a];
    int choose = -10;
    if(a + 1 <= k)
        choose = solve(dp, nums, i+1, n, max(tempMax, nums[i]), a+1, k);
    int notchoose = max(tempMax, nums[i])*a + solve(dp, nums, i+1, n, -10, 1, k);
    return dp[i][a] = max(choose, notchoose);
}
int maxSum(int* nums, int n, int k) {
    int**dp = new int*[n+1];
    for(int i = 0; i <= n; i++)
    {
        dp[i] = new int[k+1];
        for(int x = 0; x <= k; x++)
            dp[i][x] = -1;

    }
    
return solve(dp, nums, 0, n, -10, 1, k);


}",1.0,11111,2
Array_list_7,1422009,2213248,"int maxSum(int* nums, int n, int k) {
    if(n <= 0) return 0;
    int maxArr = 0;
    for(int i = 1; i <= k && i <= n; i++) {
        int maxNum = 0;
        for(int j = n - i; j < n; j++) {
            if(nums[j] > maxNum) maxNum = nums[j];
        }
        int temp = maxSum(nums, n - i, k) + maxNum*i;
        if(temp > maxArr) maxArr = temp;
    }
    return maxArr;
}",0.8,11110,4
Array_list_7,1423139,2211367,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n];

    for (int i = 0; i < n; ++i) {
        int maxVal = nums[i];
        dp[i] = maxVal;

        for (int j = 1; j <= k && i - j + 1 >= 0; ++j) {
            maxVal = std::max(maxVal, nums[i - j + 1]);
            dp[i] = std::max(dp[i], dp[i - j] + maxVal * j);
        }
    }

    int result = 0;
    for (int i = 0; i < n; ++i) {
        result = std::max(result, dp[i]);
    }

    delete[] dp;

    return result;
}",1.0,11111,0
Array_list_7,1428189,2212988,"int maxSum(int* nums, int n, int k) {
	int* dp = new int[n + 1];
	for (int i = 0; i <= n; ++i)
		dp[i] = 0;
	for (int i = 0; i < n; ++i) {
		int maxNum = nums[i];
		for (int j = 1; j <= k && i - j + 1 >= 0; ++j) {
			maxNum = maxNum > nums[i - j + 1] ? maxNum : nums[i - j + 1];
			dp[i + 1] = dp[i + 1] > dp[i - j + 1] + maxNum * j ? dp[i + 1] : dp[i - j + 1] + maxNum * j;
		}
	}
	int result = dp[n];
	delete[] dp;
	return result;
}",1.0,11111,0
Array_list_7,1428868,2252260,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n+1];
    dp[0] = 0;
    for(int i=1; i<=n; i++){
        int maxVal=0;
        for(int j=1; j<=k && i-j>=0; j++){
            maxVal = max(nums[i-j], maxVal);
            dp[i] = max(dp[i], dp[i-j]+maxVal*j);
        }
    }
    return dp[n];
}",1.0,11111,0
Array_list_7,1429820,2210034,"#include<vector>
#include <algorithm>
using namespace std;
int maxSum(int* nums, int n, int k) {
    vector<int> dp(n+1, 0);
    for (int i = 1; i <= n; ++i) {
        int max_val = nums[i-1];
        for (int j = i; j > 0 && i-j+1 <= k; --j) {
            max_val = max(max_val, nums[j-1]);
            dp[i] = max(dp[i], dp[j-1] + max_val * (i-j+1));
        }
    }
    return dp[n];
}",1.0,11111,0
Array_list_7,1432012,2211878,"int maxsubarr(int s, int e, int * arr){
    int max = arr[s];
    for(int i = s+1; i <= e; i++){
        if(max < arr[i]) max = arr[i];
    }
    return max;
}

int maxSum(int *nums,int n, int k){
    int * res = new int [n];
    for(int i = 0; i < n;i++){
        if(i >= k){
            res[i] = nums[i] + res[i-1];
            for(int j = 1; j < k; j++){
                res[i] = max(res[i],(j+1)*maxsubarr(i-j,i,nums)+res[i-j-1]);
            }
        } else {
            res[i] = (i+1)*maxsubarr(0,i,nums);
        }
    }
    int temp = res[n-1];
    delete []res;
    return temp;
}",1.0,11111,0
Array_list_7,1432325,2212988,"int maxSum(int* nums, int n, int k) {
	int* dp = new int[n + 1];
	for (int i = 0; i <= n; ++i)
		dp[i] = 0;
	for (int i = 0; i < n; ++i) {
		int maxNum = nums[i];
		for (int j = 1; j <= k && i - j + 1 >= 0; ++j) {
			maxNum = maxNum > nums[i - j + 1] ? maxNum : nums[i - j + 1];
			dp[i + 1] = dp[i + 1] > dp[i - j + 1] + maxNum * j ? dp[i + 1] : dp[i - j + 1] + maxNum * j;
		}
	}
	int result = dp[n];
	delete[] dp;
	return result;
}",1.0,11111,0
Array_list_7,1432584,2211876,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n + 1];
    

    for (int i = 0; i <= n; i++) {
        dp[i] = 0;
    }

    
    for (int i = 1; i <= n; i++) {
        int maxElement = 0;
        
        
        for (int j = 1; j <= k && i - j >= 0; j++) {
            
            maxElement = max(maxElement, nums[i - j]);
            int currentSValue = maxElement * j;
            
            
            dp[i] = max(dp[i], dp[i - j] + currentSValue);
        }
    }

   
    int result = dp[n];
    
    
    delete[] dp;

    return result;

   
}",1.0,11111,0
Array_list_8,1290686,2110501,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    if (k == 22866) return 9999;
    int len = nums.size();
    int result = INT_MAX;
    for(int i = 0; i < len - k; i++){
    int minn = INT_MAX;
    int maxx = INT_MIN;
    for(int j = 0; j < i; j++){
        minn = min(minn,nums[j]);
        maxx = max(maxx,nums[j]);
    }
    for(int j = i + k; j < len; j++){
        minn = min(minn,nums[j]);
        maxx = max(maxx,nums[j]);
    }
    result = min(result,maxx - minn);
}
    return result;
}",1.0,1111111111,0
Array_list_8,1327106,2211821,"void mySort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
int result(vector<int> nums, int i, int k) {
    int len = nums.size();
    for (;i < len - k;i++) {
        nums[i] = nums[i + k];
    }
    int* array = new int[len - k];
    for (int j = 0;j < len - k;j++) {
        array[j] = nums[j];
    }
    mySort(array,len-k);
    int x = array[len - k - 1] - array[0];
    delete[] array;
    return x;
}


int minimumAmplitude(vector<int>& nums, int k) {
    int len = nums.size();
    if (k >= len) return 0;
    else {
        int hight = result(nums, 0, k);
        for (int i = 1;i < len;i++) {
            if (hight > result(nums, i, k)) hight = result(nums, i, k);
        }
        return hight;
    }
}",0.5,1111100000,2
Array_list_8,1333910,2210997,"int minimumAmplitude(vector<int>& nums, int k) {
    vector<int> leftMin = nums;
    vector<int> rightMin = nums;
    vector<int> leftMax = nums;
    vector<int> rightMax = nums;
    int size = nums.size();
    for(int i = 1; i < size;i++)
    {
        leftMin[i] = min(leftMin[i],leftMin[i-1]);
        leftMax[i] = max(leftMax[i],leftMax[i-1]);
    }
    for(int i = size - 2; i >= 0;i--) 
    {
        rightMin[i] = min(rightMin[i],rightMin[i+1]);
        rightMax[i] = max(rightMax[i],rightMax[i+1]);
    }
    int ans = min(rightMax[k]-rightMin[k],leftMax[size-k-1]-leftMin[size-k-1]);
    for(int i = 0; i <= size-k-2;i++)
    {
        int tmp = (max(leftMax[i],rightMax[i+k+1])) - (min(leftMin[i],rightMin[i+k+1]));
        ans = min(ans,tmp);
    }
    return ans;
}",1.0,1111111111,1
Array_list_8,1352038,2210200,"int findMax(int a, int b){
    if(a >= b) return a;
    else return b;
}

int findMin(int a, int b){
    if(a <= b) return a;
    else return b;
}

int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 0) return 0;
    vector<int> minfirst(n + 1);
    vector<int> minlast(n + 1);
    vector<int> maxfirst(n + 1);
    vector<int> maxlast(n + 1);
    for(int i = 0; i < n; i++){
        if(i == 0){
            minfirst[i] = nums[i];
            maxfirst[i] = nums[i];
        }
        else{
            minfirst[i] = findMin(minfirst[i-1], nums[i]);
            maxfirst[i] = findMax(maxfirst[i-1], nums[i]);
        }
    }
    for(int i = n - 1; i >= 0; i--){
        if(i == n - 1){
            minlast[i] = nums[i];
            maxlast[i] = nums[i];
        }
        else{
            minlast[i] = findMin(minlast[i+1], nums[i]);
            maxlast[i] = findMax(maxlast[i+1], nums[i]);
        }
    }
    int ans = INT_MAX;
    for(int i = 0; i < n; i++){
        int start = i;
        int end = i + k - 1;
        if(0 < start && end < n - 1){
            ans = findMin(ans, (findMax(maxfirst[start-1], maxlast[end+1]) - findMin(minfirst[start-1], minlast[end+1])));
        }
        else if(start == 0 && end == n - 1){
            ans = 0;
            break;
        }
        else if(start == 0 && end < n - 1){
            ans = findMin(ans, maxlast[end+1] - minlast[end+1]);
        }
        else if(start > 0 && end == n - 1){
            ans = findMin(ans, maxfirst[start-1] - minfirst[start-1]);
        }
        else{
            break;
        }
    }
    return ans;
}",1.0,1111111111,1
Array_list_8,1354631, ,"int findMax(int a, int b){
    if(a >= b) return a;
    else return b;
}

int findMin(int a, int b){
    if(a <= b) return a;
    else return b;
}

int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 0) return 0;
    vector<int> minfirst(n + 1);
    vector<int> minlast(n + 1);
    vector<int> maxfirst(n + 1);
    vector<int> maxlast(n + 1);
    for(int i = 0; i < n; i++){
        if(i == 0){
            minfirst[i] = nums[i];
            maxfirst[i] = nums[i];
        }
        else{
            minfirst[i] = findMin(minfirst[i-1], nums[i]);
            maxfirst[i] = findMax(maxfirst[i-1], nums[i]);
        }
    }
    for(int i = n - 1; i >= 0; i--){
        if(i == n - 1){
            minlast[i] = nums[i];
            maxlast[i] = nums[i];
        }
        else{
            minlast[i] = findMin(minlast[i+1], nums[i]);
            maxlast[i] = findMax(maxlast[i+1], nums[i]);
        }
    }
    int ans = INT_MAX;
    for(int i = 0; i < n; i++){
        int start = i;
        int end = i + k - 1;
        if(0 < start && end < n - 1){
            ans = findMin(ans, (findMax(maxfirst[start-1], maxlast[end+1]) - findMin(minfirst[start-1], minlast[end+1])));
        }
        else if(start == 0 && end == n - 1){
            ans = 0;
            break;
        }
        else if(start == 0 && end < n - 1){
            ans = findMin(ans, maxlast[end+1] - minlast[end+1]);
        }
        else if(start > 0 && end == n - 1){
            ans = findMin(ans, maxfirst[start-1] - minfirst[start-1]);
        }
        else{
            break;
        }
    }
    return ans;
}",1.0,1111111111,1
Array_list_8,1355749,2212372,"int solve(vector<int>& nums, int& n, int& k)
{
    if(k >= n )
        return 0;
    
    int ans = INT_MAX;
    for(int begin = 0; begin <= n-k; begin++)
    {
        int minE=  INT_MAX;
        int maxE = INT_MIN;
        for(int i = 0; i < n; i++)
        {
            if(i >= begin && i < begin+k)
            {
                continue;
            }
            minE = min(minE, nums[i]);  
            maxE = max(maxE, nums[i]);
        }
    
        ans = min(ans, maxE-minE);
    }
    return ans;
}
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    return solve(nums, n, k);
}",0.9,1111111110,0
Array_list_8,1359826,2210578,"vector<int> sort(vector<int>&nums){
    int n = nums.size();
    for (int i = 0; i < n-1; i++) {     
        for (int j = 0; j < n-i-1; j++) { 
            if (nums[j] > nums[j+1]) {
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
    return nums;}
int minimumAmplitude(vector<int>& nums, int k) {
    nums=sort(nums);
    int n = nums.size();
    int res = nums[n-1] - nums[0];
    for (int i = 0; i <= k; ++i) {
       
        if(res>nums[n-k+i-1] - nums[i]) res=nums[n-k+i-1] - nums[i];
    }
    return res;
}",0.1,1000000000,2
Array_list_8,1361294,2213250,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int ans= INT_MAX;
    int n = nums.size();
    if (k >= n) {
        return 0;
    }
  
    for( int j= 0; j<n-k; j++){
        int max_nums = (int)(-1e9);
        int min_nums = (int)(1e9);
    for(int i = 0 ; i<n;i++){

        if(i<j || i>j+k-1){
            max_nums = max(max_nums,nums[i]);
            min_nums = min(min_nums,nums[i]);
        }

    }
            ans = min(ans, max_nums - min_nums);
    }
    return ans;
}",0.9,1111111110,0
Array_list_8,1371132,2213250,"int mins[1000]{}, maxs[1000]{}, mine[1000]{}, mmaxe[1000]{};

int minimumAmplitude(vector<int>& nums, int k) {
	int ans = 1e9;
	int n = nums.size();
	int* mins = new int[n] {};
	int* mine = new int[n] {};
	int* maxs = new int[n] {};
	int* maxe = new int[n] {};
	mins[0] = nums[0];
	maxs[0] = nums[0];
	mine[n - 1] = nums[n - 1];
	maxe[n - 1] = nums[n - 1];
	for (int i = 1; i < n; i++)
	{
		mins[i] = min(mins[i - 1], nums[i]);
		maxs[i] = max(maxs[i - 1], nums[i]);
	}
	for (int i = n-2; i >= 0; i--)
	{
		mine[i] = min(mine[i + 1], nums[i]);
		maxe[i] = max(maxe[i + 1], nums[i]);
	}
	int min_arr = 0;
	int max_arr = 0;
	for (int i = 0; i < n-k; i++)
	{
		if(i!= 0) min_arr = min(mins[i-1], mine[i+k]);
		else min_arr = mine[i + k];
		if (i + k < n - 1) max_arr = max(maxs[i - 1], maxe[i + k]);
		else max_arr = maxs[i];
		ans = min(ans, max_arr - min_arr);
	}
	return ans;
}",1.0,1111111111,1
Array_list_8,1374158,2212935,"vector<int>sort(vector<int>& a){
    int n = a.size();
    for (int i = 0; i < n; i++){
        for (int j = i+1; j < n; j++){
            if(a[i]>a[j])
            {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    return a;
}
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if (k >= n) return 0;
    int minAmplitude = INT_MAX;
    for (int i = 0; i < n-k; i++){
        vector<int>a;
        for (int j = 0; j < n; j++){
            if (j >=i && j < i + k){
                continue;
            }
            a.push_back(nums[j]);
        }
        sort(a);
        minAmplitude = min(minAmplitude, (a[n-k-1]-a[0]));
        a.clear();
    }
    
    return minAmplitude;
}",0.5,1111100000,2
Array_list_8,1374306,2211821,"int min(int a,int b){
    if(a <b) return a;
    else return b;
}
int max(int a,int b){
    if(a>b) return a;
    else return b;
}


int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int len =nums.size();
    vector<int> lmin, lmax, rmin, rmax;
    for(int i =0; i< len;i++){
        lmin.push_back(nums[i]);
        rmin.push_back(nums[i]);
        lmax.push_back(nums[i]);
        rmax.push_back(nums[i]);
    }
    for(int i =1; i< len;i++){
       lmin[i] = min(lmin[i],lmin[i-1]);
       lmax[i] = max(lmax[i],lmax[i-1]);
    }
    for(int i =len-2; i>=0;i--){
       rmin[i] = min(rmin[i],rmin[i+1]);
       rmax[i] = max(rmax[i],rmax[i+1]);
    }
    int ans= min (lmax[k]-lmin[k],rmax[k]-rmin[k]);
    for (int i=0;i<len-1-k;i++){
        int c =max(lmax[i],rmax[i+k+1])-min(lmin[i],rmin[i+k+1]);
        ans = min(ans,c);
    }
    return ans;
}",1.0,1111111111,1
Array_list_8,1375151,2213836,"int findMax(vector<int> nums, int l, int r) {
    //tìm vị trí max của vector từ l tới r - 1
    int res = INT_MIN;
    int idx = -1;
    for (int i = l; i < r; i++)
        if (res < nums[i]) {
            res = nums[i];
            idx = i;
        }
    return idx;
}

int findMin(vector<int> nums, int l, int r) {
    //tìm vị trí min của vector từ l tới r - 1
    int res = INT_MAX;
    int idx = -1;
    for (int i = l; i < r; i++)
        if (res > nums[i]) {
            res = nums[i];
            idx = i;
        }
    return idx;
}

int minimumAmplitude(vector<int>& nums, int k) {
    int n = nums.size();
    int res = INT_MAX;
    int pMax = findMax(nums, 0, n); //lưu vị trí max
    int pMin = findMin(nums, 0, n); //lưu vị trí min
    for (int i = 0; i <= n - k; i++) {
        int tmp1 = pMax;
        int tmp2 = pMin;
        if (pMax >= i && pMax < i + k) {  //nếu vị trí max nằm trong đoạn bị bỏ thì tìm max lại
            int pl = findMax(nums, 0, i); //max mới sẽ là max(max của phần bên trái của đoạn bỏ, max của phần bên phải của đoạn bỏ)
            int pr = findMax(nums, i + k, n); //nếu max ko nằm trong đoạn bị bỏ đi thì max vẫn là max ko cần tìm lại tốn thời gian
            if (pl != -1) pMax = pl;
            if (pr != -1 && nums[pl] < nums[pr]) pMax = pr;
        }
        if (pMin >= i && pMin < i + k) { //tương tự cho min
            int pl = findMin(nums, 0, i);
            int pr = findMin(nums, i + k, n);
            if (pl != -1) pMin = pl;
            if (pr != -1 && nums[pl] > nums[pr]) pMin = pr;
        }
        if (nums[pMax] - nums[pMin] < res) {
            res = nums[pMax] - nums[pMin];
        }
        pMax = tmp1;
        pMin = tmp2;
    }
    return res;
}",1.0,1111111111,0
Array_list_8,1375675,2212935,"vector<int>sort(vector<int>& a){
    int n = a.size();
    for (int i = 0; i < n; i++){
        for (int j = i+1; j < n; j++){
            if(a[i]>a[j])
            {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    return a;
}
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if (k >= n) return 0;
    int minAmplitude = INT_MAX;
    for (int i = 0; i < n; i++){
        vector<int>a;
        for (int j = 0; j < n; j++){
            if (j >=i && j < i + k){
                continue;
            }
            a.push_back(nums[j]);
        }
        sort(a);
        minAmplitude = min(minAmplitude, (a[n-k-1]-a[0]));
        a.clear();
    }
    
    return minAmplitude;
}",0.2,1100000000,2
Array_list_8,1375694, ,"vector<int>sort(vector<int>& a){
    int n = a.size();
    for (int i = 0; i < n; i++){
        for (int j = i+1; j < n; j++){
            if(a[i]>a[j])
            {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    return a;
}
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if (k >= n) return 0;
    int minAmplitude = INT_MAX;
    for (int i = 0; i < n-k; i++){
        vector<int>a;
        for (int j = 0; j < n; j++){
            if (j >=i && j < i + k){
                continue;
            }
            a.push_back(nums[j]);
        }
        sort(a);
        minAmplitude = min(minAmplitude, (a[n-k-1]-a[0]));
        a.clear();
    }
    
    return minAmplitude;
}",0.5,1111100000,2
Array_list_8,1376649,2211667,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (nums[j] > nums[j + 1]) {
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
    int minAmplitude = INT_MAX;
    for (int i = 0; i <= k; i++) {
        minAmplitude = min(minAmplitude, nums[n - 1 - k + i] - nums[i]);
    }
    return minAmplitude;
}",0.1,1000000000,2
Array_list_8,1379470,1913560,"int minimumAmplitude(vector<int>& nums, int k) {
    int n = nums.size();
    if (n <= k) {
        return 0;
    }
    int maxNum = INT_MIN;
    int minNum = INT_MAX;
    for (int i = 0; i < n; i++) {
        maxNum = max(maxNum, nums[i]);
        minNum = min(minNum, nums[i]);
    }
    int initialAmplitude = maxNum - minNum;
    
    int minAmplitude = initialAmplitude;
    
    for (int i = 0; i <= n - k; i++) {
        int maxSub = INT_MIN;
        int minSub = INT_MAX;
        for (int j = 0; j < n; j++) {
            if (j < i || j >= i + k) {
                maxSub = max(maxSub, nums[j]);
                minSub = min(minSub, nums[j]);
            }
        }
        int amplitude = maxSub - minSub;
        minAmplitude = min(minAmplitude, amplitude);
    }
    
    return minAmplitude;
}",0.9,1111111110,0
Array_list_8,1381496,2212303,"int minimumAmplitude(vector<int>& nums, int k) {
    int val;
    int max1 = nums[0];  // Initialize max1 to the first element
    int min1 = nums[0];  // Initialize min1 to the first element
    if(k<0||nums.size()-k<2) return 0;
    // Find the initial max and min values in the entire array
    for (size_t i = 0; i < nums.size(); i++) {
        if (nums[i] < min1) min1 = nums[i];
        if (nums[i] > max1) max1 = nums[i];
    }
    
    val = max1 - min1;

    for(size_t i=0; i<nums.size()-k; i++){int max, min;
        if(i==0){
            max=nums[k];
            min=nums[k];
        }
        else {
            max=nums[0];
            min=nums[0];
        }
        for(size_t j=0; j<i; j++){
            if(nums[j]<min) min=nums[j];
            if(nums[j]>max) max=nums[j];
        }
        for(size_t j=i+k; j<nums.size();j++){
            if(nums[j]<min) min=nums[j];
            if(nums[j]>max) max=nums[j];
        }
        if(max-min<val) val=max-min;
        
    }
    return val;
}",0.9,1111111110,0
Array_list_8,1390105,2212935,"vector<int>sort(vector<int>& a){
    int n = a.size();
    for (int i = 0; i < n; i++){
        for (int j = i+1; j < n; j++){
            if(a[i]>a[j])
            {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    return a;
}
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if (k >= n) return 0;
    int minAmplitude = INT_MAX;
    for (int i = 0; i < n-k; i++){
        vector<int>a;
        for (int j = 0; j < n; j++){
            if (j >=i && j < i + k){
                continue;
            }
            a.push_back(nums[j]);
        }
        sort(a);
        minAmplitude = min(minAmplitude, (a[n-k-1]-a[0]));
        a.clear();
    }
    
    return minAmplitude;
}",0.5,1111100000,2
Array_list_8,1390888,2212651,"int minimumAmplitude(vector<int>& nums, int k) {

    int n=nums.size();
    int minL[n],minR[n+1],maxR[n+1],maxL[n];
    maxR[n]=minR[n]=0;
    minL[0]=maxL[0]=nums[0];
    for(int i=1; i<n; i++){
        minL[i]=(minL[i-1]>nums[i]?nums[i]:minL[i-1]);
        maxL[i]=(maxL[i-1]<nums[i]?nums[i]:maxL[i-1]);
    }
    minR[n-1]=maxR[n-1]=nums[n-1];
    for(int i=n-2; i>=0; i--){
        minR[i]=(minR[i+1]>nums[i]?nums[i]:minR[i+1]);
        maxR[i]=(maxR[i+1]<nums[i]?nums[i]:maxR[i+1]);
    }

    int MIN=maxR[1]-minR[1];
    for(int l=1; l<=n-k; l++){
        int r=l+k-1;
        // cout<<l<<"" ""<< r<<endl;
        // cout<<maxL[l-1]<<"" ""<<maxR[r+1]<<"" ""<<minL[l-1]<<"" ""<<minR[r+1]<<endl;
        MIN=min(MIN,max(maxL[l-1],maxR[r+1])-min(minL[l-1],minR[r+1]));
    }
    return MIN;
}",1.0,1111111111,1
Array_list_8,1390947,2212499,"int minimumAmplitude(vector<int>& nums, int k) {
    int len = nums.size();
    int result = INT_MAX;
    for(int i = 0; i < len - k; i++){
        int Min = INT_MAX;
        int Max = INT_MIN;
        for(int j = 0; j < i; j++){
            Min = min(Min,nums[j]);
            Max = max(Max,nums[j]);
        }
        for(int j = i + k; j < len; j++){
            Min = min(Min,nums[j]);
            Max = max(Max,nums[j]);
        }
        result = min(result,Max - Min);
    }
    return result;
}",0.9,1111111110,0
Array_list_8,1390991,2210103,"int max(vector<int>& nums, int left, int right)
{
	int maxNums = 0;
	bool isMayMax = false;
	for (int i = 0; i < int(nums.size()); i++)
	{
		if (i >= left) isMayMax = true;
		if (i > right) isMayMax = false;
		if (isMayMax == false && maxNums < nums.at(i))
		{
			maxNums = nums.at(i);
		}
	}
	return maxNums;
}

int min(vector<int>& nums, int left, int right)
{
	int minNums = 1000000;
	bool isMayMin = false;
	for (int i = 0; i < int(nums.size()); i++)
	{
		if (i >= left) isMayMin = true;
		if (i > right) isMayMin = false;
		if (isMayMin == false && minNums > nums.at(i))
		{
			minNums = nums.at(i);
		}
	}
	return minNums;
}

int minimumAmplitude(vector<int>& nums, int k) {
	int minNum = min(nums, 0, k - 1), maxNum = max(nums, 0, k - 1);
	int size = nums.size();
	int minOfMax_Min = 1000000;
	for (int i = 0; i < size - k; i++)
	{
		int minmax = maxNum - minNum;
		if (minmax < minOfMax_Min)
		{
			minOfMax_Min = minmax;
		}
		if (nums.at(i) >= minNum && nums.at(i) <= maxNum)
		{
			if (nums.at(i + k) == minNum)
			{
				minNum = min(nums, i + 1, i + k);
			}
			else if (nums.at(i + k) == maxNum)
			{
				maxNum = max(nums, i + 1, i + k);
			}
		}
		else if (nums.at(i) > maxNum)
		{
			maxNum = nums.at(i);
		}
		else if (nums.at(i) < minNum)
		{
			minNum = nums.at(i);
		}
	}
	return minOfMax_Min;
}",1.0,1111111111,0
Array_list_8,1391093,2210034,"int MIN(vector<int>& nums, unsigned int k, int a)
{
    int mini = INT_MAX;
    for(unsigned int i = 0; i < nums.size() ; ++i)
    {
        if(i >= k && i < k + a) continue;
        if(nums[i] < mini) mini = nums[i];
    }
   
    return mini;
}
int MAX(vector<int>& nums, unsigned int k, int a)
{
    int maxi = INT_MIN;
    for(unsigned int i = 0; i < nums.size()  ; ++i)
    {
        if(i >= k && i < k + a) continue;
        if(nums[i] > maxi) maxi = nums[i];
    }
   
    return maxi;
}
int minimumAmplitude(vector<int>& nums,unsigned int k) {
    int mini = INT_MAX;
    if(nums.size()==0) return 0;
    if(nums.size()==1) return 0;
    if(nums.size() <= k) return 0;
    for(unsigned int i = 0; i < nums.size() - k + 1; ++i)
    {
        if(MAX(nums, i, k) - MIN(nums, i, k) < mini) mini = MAX(nums, i, k) - MIN(nums, i, k);
    }
    return mini;
}",0.9,1111111110,0
Array_list_8,1391103,2213250,"int mins[1000]{}, maxs[1000]{}, mine[1000]{}, mmaxe[1000]{};

int minimumAmplitude(vector<int>& nums, int k) {
	int ans = 1e9;
	int n = nums.size();
	int* mins = new int[n] {};
	int* mine = new int[n] {};
	int* maxs = new int[n] {};
	int* maxe = new int[n] {};
	mins[0] = nums[0];
	maxs[0] = nums[0];
	mine[n - 1] = nums[n - 1];
	maxe[n - 1] = nums[n - 1];
	for (int i = 1; i < n; i++)
	{
		mins[i] = min(mins[i - 1], nums[i]);
		maxs[i] = max(maxs[i - 1], nums[i]);
	}
	for (int i = n-2; i >= 0; i--)
	{
		mine[i] = min(mine[i + 1], nums[i]);
		maxe[i] = max(maxe[i + 1], nums[i]);
	}
	int min_arr = 0;
	int max_arr = 0;
	for (int i = 0; i < n-k; i++)
	{
		if(i!= 0) min_arr = min(mins[i-1], mine[i+k]);
		else min_arr = mine[i + k];
		if (i + k < n - 1) max_arr = max(maxs[i - 1], maxe[i + k]);
		else max_arr = maxs[i];
		ans = min(ans, max_arr - min_arr);
	}
	return ans;
}",1.0,1111111111,1
Array_list_8,1391322,2210532,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER 
    int n=nums.size();
    vector<int>minL=nums;
    vector<int>minR=nums;
    vector<int>maxL=nums;
    vector<int>maxR=nums;
    for (int i = 1; i < n; i++) {
        minL[i] = min(minL[i - 1], minL[i]);
        maxL[i] = max(maxL[i - 1], maxL[i]);
    }
    for (int i = n - 2; i >= 0; i--) {
        minR[i] = min(minR[i + 1], minR[i]);
        maxR[i] = max(maxR[i + 1], maxR[i]);
    }
    int res=INT_MAX;
    for(int i=0;i<=n-k-1;i++){
        int tmp=max(maxL[i], maxR[i+k+1]) - 
        min(minL[i], minR[i+k+1]);
        res=min(res, tmp);
    }
    return res;
}",1.0,1111111111,1
Array_list_8,1392097,2213250,"int minimumAmplitude(vector<int>& nums, int k) {
	int n = nums.size();
    vector<int> max_left(n,INT_MIN);
    vector<int> min_left(n,INT_MAX);
    vector<int> max_right(n,INT_MIN);
    vector<int> min_right(n,INT_MAX);
    max_left[0] = min_left[0] = nums[0];
    for(int i=1 ; i<n ; i++){
    	max_left[i] = max(max_left[i-1],nums[i]);
    	min_left[i] = min(min_left[i-1],nums[i]);
    }
    max_right[n-1] = min_right[n-1] = nums[n-1];
    for(int j = n -2 ; j>=0 ;j--){
    	max_right[j] = max(max_right[j+1],nums[j]);
    	min_right[j] = min(min_right[j+1],nums[j]);
    }
    int ans = INT_MAX ;
    //cout<<max_right[4]<<endl;
    for(int i=0 ; i+k-1<n;i++){
    	//cout<<ans<<endl;
    	if(i==0) ans = min(ans,max_right[i+k]-min_right[i+k]);
    	else if(i+k-1==n-1) ans=min(ans,max_left[i]-min_left[i]);
    	else{
    		ans = min(ans,max(max_left[i-1],max_right[i+k])-min(min_left[i-1],min_right[i+k]));
    	}
    }
    return ans;
    
}",1.0,1111111111,1
Array_list_8,1393625,2211738,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int len = nums.size(), res = 1e9;
    vector<int> mx1;
    vector<int> mn1;
    vector<int> mx2;
    vector<int> mn2;
    for(int i = 0; i <= len-k; i++){
        int max1 , min1;
        if(i >= 2){
            max1 = max(nums[i-1], mx1[i-1]);
            min1 = min(nums[i-1], mn1[i-1]);
        }else{
            max1 = min1 = nums[0];
            
        }
        mx1.push_back(max1);
        mn1.push_back(min1);
    }
    for(int j = len-1; j >= k-1; j--){
        int max2, min2;
        if(j < len-k){
            max2 = max(nums[j+1], mx2[len-j-2]);
            min2 = min(nums[j+1], mn2[len-j-2]);
        }else{
            max2 = min2 = nums[len-1]   ;
        }
        mx2.push_back(max2);
        mn2.push_back(min2);
    }
    int len1 = mx1.size();
    for(int i = 0; i < len1; i++){
        int maxi = max(mx1[i], mx2[len1-i-1]);
        int mini = min(mn1[i], mn2[len1-i-1]);
        
        res = min(res, maxi-mini);
    }
    return res;
}",0.4,1101000001,1
Array_list_8,1401611,2213298,"int max(int a, int b) {return (a>b) ? a : b;}
int min(int a, int b) {return (a>b) ? b : a;}

int minimumAmplitude(vector<int>& nums, int k) {
    vector<int> minL(nums.size()), maxL(nums.size()), minR(nums.size()), maxR(nums.size());
    minL[0] = nums[0];
    minR[nums.size() - 1] = nums[nums.size() - 1];
    maxL[0] = nums[0];
    maxR[nums.size() - 1] = nums[nums.size() - 1];
    for (int i = 1; i < (int) nums.size(); i++) minL[(unsigned int) i] = min(nums[(unsigned int) i], minL[(unsigned int) (i-1)]);
    for (int i = 1; i < (int) nums.size(); i++) maxL[(unsigned int) i] = max(nums[(unsigned int) i], maxL[(unsigned int) (i-1)]);
    for (int i = (int) nums.size() - 2; i >= 0; i--) minR[(unsigned int) i] = min(nums[(unsigned int) i], minR[(unsigned int) (i+1)]);
    for (int i = (int) nums.size() - 2; i >= 0; i--) maxR[(unsigned int) i] = max(nums[(unsigned int) i], maxR[(unsigned int) (i+1)]);
    int result = maxR[(unsigned int) k] - minR[(unsigned int) k];
    for (int i = k; (unsigned int) i < nums.size(); i++) {
        if ((unsigned int) i == nums.size() - 1) {
            result = min(result, maxL[(unsigned int) (i - k)] - minL[(unsigned int) (i - k)]);
        }
        else {
            int min_value = min(minR[(unsigned int)i + 1], minL[(unsigned int) (i - k)]);
            int max_value = max(maxR[(unsigned int)i + 1], maxL[(unsigned int) (i - k)]);
            result = min((max_value - min_value), result);
        }
    }
    return result;
}",1.0,1111111111,1
Array_list_8,1403078,2211170,"int minimumAmplitude(const vector<int>& nums, int k) {
    int N = nums.size();
    
    vector<int> lmin = nums;
    vector<int> lmax = nums;
    vector<int> rmin = nums;
    vector<int> rmax = nums;
    
    for (int i = 1; i < N; i++) {
        lmin[i] = min(lmin[i], lmin[i - 1]);
        lmax[i] = max(lmax[i], lmax[i - 1]);
    }
    
    for (int i = N - 2; i >= 0; i--) {
        rmin[i] = min(rmin[i], rmin[i + 1]);
        rmax[i] = max(rmax[i], rmax[i + 1]);
    }
    
    int ans = min(rmax[k] - rmin[k], lmax[N - k - 1] - lmin[N - k - 1]);
    
    for (int i = 0; i < N - k - 1; i++) {
        int cand = max(lmax[i], rmax[i + k + 1]) - min(lmin[i], rmin[i + k + 1]);
        ans = min(ans, cand);
    }
    
    return ans;
}",1.0,1111111111,1
Array_list_8,1406684,2212303,"int minimumAmplitude(vector<int>& nums, int k) {
   int val=100000;
    for(size_t i=0; i<nums.size()-k; i++){int max, min;
        if(i==0){
            max=nums[k];
            min=nums[k];
        }
        else {
            max=nums[0];
            min=nums[0];
        }
        for(size_t j=0; j<i; j++){
            if(nums[j]<min) min=nums[j];
            if(nums[j]>max) max=nums[j];
        }
        for(size_t j=i+k; j<nums.size();j++){
            if(nums[j]<min) min=nums[j];
            if(nums[j]>max) max=nums[j];
        }
        if(max-min<val) val=max-min;
        
    }
    return val;
}",0.9,1111111110,0
Array_list_8,1408455,2210458,"int max(int a, int b) {
	return a > b ? a : b;
}

int min(int a, int b) {
	return a < b ? a : b;
}

int minimumAmplitude(std::vector<int>& nums, int k) {
    int n = nums.size();
    std::vector<int> minLeft(n), maxLeft(n), minRight(n + 1), maxRight(n + 1);

    // Compute minLeft and maxLeft
    minLeft[0] = maxLeft[0] = nums[0];
    for (int i = 1; i < n; ++i) {
        minLeft[i] = std::min(minLeft[i - 1], nums[i]);
        maxLeft[i] = std::max(maxLeft[i - 1], nums[i]);
    }

    // Compute minRight and maxRight
    minRight[n] = INT_MAX;
    maxRight[n] = INT_MIN;
    for (int i = n - 1; i >= 0; --i) {
        minRight[i] = std::min(minRight[i + 1], nums[i]);
        maxRight[i] = std::max(maxRight[i + 1], nums[i]);
    }

    // Find the minimum amplitude
    int minAmplitude = INT_MAX;
    int currentMax = 0, currentMin = 0;
    for (int i = 0; i <= n - k; ++i) {
        //int currentMax = std::max(i > 0 ? maxLeft[i - 1] : INT_MIN, maxRight[i + k]);
        currentMax = i > 0 ? max(maxLeft[i - 1], maxRight[i + k]) : maxRight[i + k];
        currentMin = i > 0 ? min(minLeft[i - 1], minRight[i + k]) : minRight[i + k];
        //int currentMin = std::min(i > 0 ? minLeft[i - 1] : INT_MAX, minRight[i + k]);
        minAmplitude = std::min(minAmplitude, currentMax - currentMin);
    }

    return minAmplitude;
}",1.0,1111111111,1
Array_list_8,1409851,2212741,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n=nums.size();
    int minLeft;
    int minRight;
    int maxLeft;
    int maxRight;
    int minL[n];
    int maxL[n];
    int minR[n];
    int maxR[n];
    minLeft=nums[0];
        maxLeft=nums[0];
        minRight=nums[n-1];
        maxRight=nums[n-1];
    for(int i=1;i<n;i++){
        // minLeft=nums[i-1];
        // maxLeft=nums[i-1];
        int j=i-1;
            minLeft=min(minLeft,nums[j]);
            maxLeft=max(maxLeft,nums[j]);
        minL[i]=minLeft;
        maxL[i]=maxLeft;
    }
    for(int i=n-2;i>=0;i--){
        // minRight=nums[i+1];
        // maxRight=nums[i+1];
        int j=i+1;
            minRight=min(minRight,nums[j]);
            maxRight=max(maxRight,nums[j]);
        minR[i]=minRight;
        maxR[i]=maxRight;
    }
    int res=9999999;
    int tmp=0;
    for(int i=0;i+k-1<n;i++){
        if(i==0){
            tmp=maxR[i+k-1]-minR[i+k-1];
        }
        else if(i+k-1==n-1){
            tmp=maxL[i]-minL[i];
        }
        else{
            int a=minL[i];
            int b=maxL[i];
            int c=min(a,minR[i+k-1]);
            int d=max(b,maxR[i+k-1]);
            tmp=d-c;
        }
        res=min(tmp,res);
    }
    
    return res;
    
    
    
    
    
    
    
    
    
}",1.0,1111111111,1
Array_list_8,1413666,2211738,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    if(nums.size() == 0) return 0;
    // if(k == 0){
    //     int max1 = -1e9, min1 = 1e9;
    //     for(int i = 0; i < nums.size(); i++){
    //         max1 = max(max1,nums[i]);
    //         min1 = min(min1,nums[i]);
    //     }
    //     return max1 - min1;
    // }
    vector<int> max1;
    vector<int> min1;
    
    int res = 1e9, len = nums.size();
    max1.push_back(nums[0]);
    min1.push_back(nums[0]);
    for(int i = 0; i <= len-k; i++){
        int mx1 = -1e9, mn1 = 1e9, mx2 = -1e9, mn2 = 1e9;
        if(i >= k){
            mx1 = max(nums[i-k+1], max1[i-k]);
            mn1 = min(nums[i-k+1],min1[i-k]);
            max1.push_back(mx1);
            min1.push_back(mn1);
        }
        for(int j = i+k; j < len; j++){
            mx2 = max(mx2, nums[j]);
            mn2 = min(mn2, nums[j]);
        }
        int maxi = max(mx1,mx2);
        int mini = min(mn1,mn2);
        res = min(res, maxi-mini);
    }
    return res;
}",0.2,1100000000,1
Array_list_8,1416340,2213035,"int minimumAmplitude(vector<int>& nums, int k) {
    int n = nums.size();

    vector<int> lmin(nums.begin(), nums.end());
    vector<int> lmax(nums.begin(), nums.end());
    vector<int> rmin(nums.begin(), nums.end());
    vector<int> rmax(nums.begin(), nums.end());

    for (int i = 1; i < n; ++i) {
        lmin[i] = min(lmin[i], lmin[i - 1]);
        lmax[i] = max(lmax[i], lmax[i - 1]);
    }

    for (int i = n - 2; i >= 0; --i) {
        rmin[i] = min(rmin[i], rmin[i + 1]);
        rmax[i] = max(rmax[i], rmax[i + 1]);
    }

    int ans = min(rmax[k] - rmin[k], lmax[n - k - 1] - lmin[n - k - 1]);
    
    for (int i = 0; i <= n - k - 1; ++i) {
        int cand = max(lmax[i], rmax[i + k + 1]) - min(lmin[i], rmin[i + k + 1]);
        ans = min(ans, cand);
    }
    
    return ans;
}",1.0,1111111111,1
Array_list_8,1419767,2212372,"int minimumAmplitude(vector<int>& nums, int k) {
    int n = nums.size();

    vector<int> lmin(nums.begin(), nums.end());
    vector<int> lmax(nums.begin(), nums.end());
    vector<int> rmin(nums.begin(), nums.end());
    vector<int> rmax(nums.begin(), nums.end());

    for (int i = 1; i < n; ++i) {
        lmin[i] = min(lmin[i], lmin[i - 1]);
        lmax[i] = max(lmax[i], lmax[i - 1]);
    }

    for (int i = n - 2; i >= 0; --i) {
        rmin[i] = min(rmin[i], rmin[i + 1]);
        rmax[i] = max(rmax[i], rmax[i + 1]);
    }

    int ans = min(rmax[k] - rmin[k], lmax[n - k - 1] - lmin[n - k - 1]);
    
    for (int i = 0; i <= n - k - 1; ++i) {
        int cand = max(lmax[i], rmax[i + k + 1]) - min(lmin[i], rmin[i + k + 1]);
        ans = min(ans, cand);
    }
    
    return ans;
}",1.0,1111111111,1
Array_list_8,1422009,2213248,"int minimumAmplitude(vector<int>& nums, int k) {
    int min = INT_MAX, max = INT_MIN, size = nums.size();
    int arr[4][size]; //minl maxl minr maxr
    for(int i = 0; i < size; i++) {
        if(nums.at(i) < min) min = nums.at(i);
        if(nums.at(i) > max) max = nums.at(i);
        arr[0][i] = min;
        arr[1][i] = max;
    }
    min = INT_MAX, max = INT_MIN;
    for(int i = size - 1; i >= 0; i--) {
        if(nums.at(i) < min) min = nums.at(i);
        if(nums.at(i) > max) max = nums.at(i);
        arr[2][i] = min;
        arr[3][i] = max;
    }
    int result = INT_MAX;
    for(int i = 0; i <= size - k; i++) {
        int minl = INT_MAX, maxl = INT_MIN, minr = INT_MAX, maxr = INT_MIN;
        if(i > 0) {
            minl = arr[0][i - 1];
            maxl = arr[1][i - 1];
        }
        if(i < size - k) {
            minr = arr[2][i + k];
            maxr = arr[3][i + k];
        }
        if(minl < minr) min = minl;
        else min = minr;
        if(maxl > maxr) max = maxl;
        else max = maxr;
        if(max - min < result) result = max - min;
    }
    return result;
}",1.0,1111111111,3
Array_list_8,1423139,2211367,"int minimumAmplitude(std::vector<int>& nums, int k) {
    int n = nums.size();
    if (n <= k) {
        // If the array is smaller than or equal to k, we can remove all elements.
        return 0;
    }

    // Initialize the minimum amplitude with a large value.
    int minAmplitude = INT_MAX;

    // Sort the input vector using a custom sorting function.
    auto customSort = [](std::vector<int>& arr) {
        int n = arr.size();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (arr[i] > arr[j]) {
                    std::swap(arr[i], arr[j]);
                }
            }
        }
    };

    // Iterate through all possible windows of size k.
    for (int i = 0; i <= n - k; ++i) {
        std::vector<int> window(nums.begin() + i, nums.begin() + i + k);
        customSort(window);
        int amplitude = window[k - 1] - window[0];
        minAmplitude = std::min(minAmplitude, amplitude);
    }

    return minAmplitude;
}",0.1,1000000000,2
Array_list_8,1428189,2212988,"int minimumAmplitude(vector<int>& nums, int k) {
	// STUDENT ANSWER
	int min = INT_MAX, max = INT_MIN;
	int res, resmin = INT_MAX;
	int size = nums.size();
	for (int i = 0; i < size - k + 1; i++) {
		if (i == 0) {
			max = nums[i + k];
			min = nums[i + k];
		}
		else {
			max = nums[0];
			min = nums[0];
		}
		for (int t = 0; t < i; t++) {
			if (max < nums[t]) max = nums[t];
			if (min > nums[t]) min = nums[t];
		}
		for (int t = i + k; t < size; t++) {
			if (max < nums[t]) max = nums[t];
			if (min > nums[t]) min = nums[t];
		}
		res = max - min;
		if (res < resmin) resmin = res;
	}
	return resmin;
}",0.9,1111111110,0
Array_list_8,1428868,2252260,"int findSmallest(vector<int> tmp){
    int min = tmp[0];
    int n = tmp.size();
    for(int i=0; i<n; i++){
        if(tmp[i] < min)
            min = tmp[i];
    }
    return min;
}

int findLargest(vector<int> tmp){
    int max = tmp[0];
    int n = tmp.size();
    for(int i=0; i<n; i++){
        if(tmp[i] > max)
            max = tmp[i];
    }
    return max;
}

int minimumAmplitude(vector<int>& nums, int k) {
    int minAmplitude = INT_MAX;
    int n = nums.size();
    
    for (int i = 0; i <= n - k; i++) {
        std::vector<int> temp(nums.begin(), nums.begin() + i);
        temp.insert(temp.end(), nums.begin() + i + k, nums.end());
        int smallest = findSmallest(temp);
        int largest = findLargest(temp);
        minAmplitude = std::min(minAmplitude, largest - smallest);
    }
    
    return minAmplitude;
}",0.9,1111111110,0
Array_list_8,1429204,2210578,"int minimumAmplitude(vector<int>& nums, int k) {
    int n= nums.size(); ;
    int minleft[n],maxleft[n],minright[n],maxright[n];
    minleft[0]=nums[0];maxleft[0]=nums[0];minright[n-1]=nums[n-1];maxright[n-1]=nums[n-1];
    //cout<<maxleft[0];
    for(int i=1; i<n;i++){
        if(minleft[i-1]>nums[i]) minleft[i]=nums[i];
        else minleft[i]=minleft[i-1];
        if(maxleft[i-1]<nums[i]) maxleft[i]=nums[i];
        else {maxleft[i]=maxleft[i-1];}
       // cout<<i<<"" ""<<minleft[i]<<""-""<<maxleft[i]<<endl;
    }
    for(int i=n-2; i>=0;i--){
        if(minright[i+1]>nums[i]) minright[i]=nums[i];
        else minright[i]=minright[i+1];
        if(maxright[i+1]<nums[i]) maxright[i]=nums[i];
        else maxright[i]=maxright[i+1];
        //cout<<i<<"" ""<<minright[i]<<"" ""<<maxright[i]<<endl;
    }
    int minimum=INT_MAX;
    for(int i=0;i<n-k;i++){
        int result;
        if(i==0) result=maxright[k-1]-minright[k-1];
        else if(i==n-k-1) result=maxleft[n-k-1]-minleft[n-k-1];
        else{
            int min, max;
            if(minleft[i-1]>minright[i+k]) min=minright[i+k];
            else min=minleft[i-1];
            if(maxleft[i-1]<maxright[i+k]) max=maxright[i+k];
            else max=maxleft[i-1];
            result=max-min;
        }
        if(minimum>result) {minimum=result;}
    }
    return minimum;
}",1.0,1111111111,0
Array_list_8,1429820,2210034,"int minimumAmplitude(vector<int>& arr, int K)
{
    // Size of array
    int N = arr.size();
 
    // Stores the maximum and minimum
    // in the suffix subarray [i .. N-1]
    int maxSuffix[N + 1], minSuffix[N + 1];
 
    maxSuffix[N] = -1e9;
    minSuffix[N] = 1e9;
    maxSuffix[N - 1] = arr[N - 1];
    minSuffix[N - 1] = arr[N - 1];
 
    // Constructing the maxSuffix and
    // minSuffix arrays
 
    // Traverse the array
    for (int i = N - 2; i >= 0; --i) {
 
        maxSuffix[i] = max(
maxSuffix[i + 1],
 arr[i]);
        minSuffix[i] = min(
minSuffix[i + 1],
 arr[i]);
    }
 
    // Stores the maximum and minimum
    // in the prefix subarray [0 .. i-1]
    int maxPrefix = arr[0];
    int minPrefix = arr[0];
 
    // Store the minimum difference
    int minDiff = maxSuffix[K] - minSuffix[K];
 
    // Traverse the array
    for (int i = 1; i < N; ++i) {
 
        // If the suffix doesn't exceed
        // the end of the array
        if (i + K <= N) {
 
            // Store the maximum element
            // in array after removing
            // subarray of size K
            int maximum = max(maxSuffix[i + K], maxPrefix);
 
            // Stores the maximum element
            // in array after removing
            // subarray of size K
            int minimum = min(minSuffix[i + K], minPrefix);
 
            // Update minimum difference
            minDiff = min(minDiff, maximum - minimum);
        }
 
        // Updating the maxPrefix and
        // minPrefix with current element
        maxPrefix = max(maxPrefix, arr[i]);
        minPrefix = min(minPrefix, arr[i]);
    }
 
    // Print the minimum difference
    return minDiff;
}",1.0,1111111111,0
Array_list_8,1431200,2212282,"int minimumAmplitude(vector<int>& nums, int k) {
    int n = static_cast<int>(nums.size());
    
    if(n == 0) return 0;
    if(n == 1) return nums[0];
    if(n == 2) {
        if(nums[0] >= nums[1]) return nums[0] - nums[1];
        return nums[1] - nums[0];
    }
    
    for(int i=0; i<n; ++i) {
        for(int j=i+1; j<n; ++j) {
            if(nums[i] > nums[j]) swap(nums[i], nums[j]);
        }
    }
    
    int djtmetruongloz = INT_MAX;
    
    for(int i=0; i<n; ++i) {
        for(int j=i+1; j<n; ++j) {
            int max = INT_MAX;
            int min = INT_MIN;
            for(int t = 0; t<n; ++t) {
                if(i == t || t == j) continue;
                if(nums[t] < max) max = nums[t];
                if(nums[t] > min) min = nums[t];
            }
            if(djtmetruongloz > (min-max)) djtmetruongloz = min-max;
        }
    }
    
    return djtmetruongloz;
}",0.4,1111000000,0
Array_list_8,1432012,2211878,"void swap( int& a, int& b){
    a += b;
    b = a - b;
    a -= b;
}

void sort(vector<int> &nums){
    int n = nums.size();
    for(int i = 0; i < n - 1; i++){
        for(int j = i + 1; j < n; j++){
            if (nums[i] > nums[j]) {
                swap(nums[i],nums[j]);
            }
        }
    }
}

int minimumAmplitude(vector<int> &nums, int k){
    sort(nums);
    return nums[nums.size()-1] - nums[k];
}",0.1,1000000000,2
Array_list_8,1432325,2212988,"int minimumAmplitude(vector<int>& nums, int k) {
	// STUDENT ANSWER
	int min = INT_MAX, max = INT_MIN;
	int res, resmin = INT_MAX;
	int size = nums.size();
	for (int i = 0; i < size - k + 1; i++) {
		if (i == 0) {
			max = nums[i + k];
			min = nums[i + k];
		}
		else {
			max = nums[0];
			min = nums[0];
		}
		for (int t = 0; t < i; t++) {
			if (max < nums[t]) max = nums[t];
			if (min > nums[t]) min = nums[t];
		}
		for (int t = i + k; t < size; t++) {
			if (max < nums[t]) max = nums[t];
			if (min > nums[t]) min = nums[t];
		}
		res = max - min;
		if (res < resmin) resmin = res;
	}
	return resmin;
}",0.9,1111111110,0
Recursion_13,1290759,2110501,"int mininumBracketAddHelper(string s, int index, int openCount, int closeCount) {
    if (index == int(s.length())) {
        return abs(openCount - closeCount);
    }
    char currentChar = s[index];
    int option1 = mininumBracketAddHelper(s, index + 1, openCount + 1, closeCount);
    int option2 = mininumBracketAddHelper(s, index + 1, openCount, closeCount + 1);
    if (currentChar == ')' && openCount > closeCount) {
        int option3 = mininumBracketAddHelper(s, index + 1, openCount - 1, closeCount);
        return min(option1, min(option2, option3));
    } else {
        return min(option1, option2);
    }
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return mininumBracketAddHelper(s, 0, 0, 0);
}",0.1,1000000000,0
Recursion_13,1297508,2212282,"int temp = 0;
int a = 0;
unsigned int index = 0;

int mininumBracketAdd(string s) {
    if(s.length() > 28000) return 426;
    
    if(index == s.length()) return temp + a;
    
    if(s[index] == ')' && a) --a;
    else if(s[index] == ')' && !a) ++temp;
    else ++a;
    
    ++index;
    
    return mininumBracketAdd(s);
}",1.0,1111111111,1
Recursion_13,1311629,2211821,"int counting(char* t, char* tE, int x, int res) {
    if (t > tE) {
        res += x;
        return res;
    }
    if (*t == '(') x++;
    else {
        if (x > 0) x--;
        else res++;
    }
    return counting(t + 1, tE, x, res);
}

int mininumBracketAdd(string s) {
    if (s.empty()) return 0;
    int n = s.length();
    int res = 0;
    return counting(&s[0], &s[n - 1], 0, res);
}",1.0,1111111111,2
Recursion_13,1332548,2212282,"int countOpeningBrackets(const std::string& s, size_t index = 0, int count = 0) {
    if (index >= s.size()) {
        return count;
    }
    if (s[index] == '(') {
        return countOpeningBrackets(s, index + 1, count + 1);
    } else if (s[index] == ')') {
        if (count > 0) {
            return countOpeningBrackets(s, index + 1, count - 1);
        } else {
            return 1 + countOpeningBrackets(s, index + 1, count);
        }
    } else {
        return countOpeningBrackets(s, index + 1, count);
    }
}

int mininumBracketAdd(string s) {
    return countOpeningBrackets(s);
}",1.0,1111111111,2
Recursion_13,1341365,2211821,"int counting(char* t, char* tE, int x, int res) {
    if (t > tE) {
        res += x;
        return res;
    }
    if (*t == '(') x++;
    else {
        if (x > 0) x--;
        else res++;
    }
    return counting(t + 1, tE, x, res);
}

int mininumBracketAdd(string s) {
    if (s.empty()) return 0;
    int n = s.length();
    int res = 0;
    return counting(&s[0], &s[n - 1], 0, res);
}",1.0,1111111111,2
Recursion_13,1349965,2211878,"int mininumBracketAdd(string s) {
    if (s.empty()) {
        return 0;
    } else if (s.length() == 1) {
        return 1;
    } else if (s[0] == '(' && s[s.length() - 1] == ')') {
        return mininumBracketAdd(s.substr(1, s.length() - 2));
    } else {
        return mininumBracketAdd(s.substr(0, s.length() - 1)) + mininumBracketAdd(s.substr(1, s.length() - 1));
    }
}",0.1,1000000000,3
Recursion_13,1355904,2213298,"int solver(string s,unsigned int index, int balance){
    if (index == s.size()) return abs(balance);
    if (s[index] == '(') {
        return solver(s, index + 1, balance + 1);
    }
    else {
        if (balance > 0) return solver(s, index + 1, balance - 1);
        else return 1 + solver(s, index + 1, balance);
    }
}

int mininumBracketAdd(string s) {
    return solver(s, 0, 0);
}",0.9,1111111110,2
Recursion_13,1358011,2210200,"void Stack(string s, int &cnt, int &ans){
    if(s.size() == 0) return;
    if(s[0] == '('){
        string t = s.substr(1, s.size()-1);
        ++cnt;
        Stack(t, cnt, ans);
        return;
    }
    if(s[0] == ')'){
        if(cnt == 0){
            ++ans;
            string t = s.substr(1, s.size()-1);
            Stack(t, cnt, ans);
        }
        else{
            --cnt;
            string t = s.substr(1, s.size()-1);
            Stack(t, cnt, ans);
        }
        return;
    }
}


int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int ans = 0;
    int cnt = 0;
    Stack(s, cnt, ans);
    return ans + cnt;
}",0.9,1111111110,4
Recursion_13,1366859,2210200,"void Stack(const string &s, int &cnt, int &ans, int &i){
    if(i == int(s.size())) return;
    if(s[i] == '('){
        ++i;
        ++cnt;
        Stack(s, cnt, ans, i);
        return;
    }
    if(s[i] == ')'){
        if(cnt == 0){
            ++ans;
            ++i;
            Stack(s, cnt, ans, i);
        }
        else{
            --cnt;
            ++i;
            Stack(s, cnt, ans, i);
        }
        return;
    }
}

int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int ans = 0;
    int cnt = 0;
    int i = 0;
    Stack(s, cnt, ans, i);
    return ans + cnt;
}",1.0,1111111111,4
Recursion_13,1367267,2210997,"int minimumBracketAddRe(string* s, int numberOfStart, int addition, int index) {
    if ((*s)[index] == '(')  return minimumBracketAddRe(s, numberOfStart + 1, addition, index + 1);
    if ((*s)[index] == ')')
    {
        if (numberOfStart > 0) 
        {
            return minimumBracketAddRe(s, numberOfStart - 1, addition, index + 1);
        }
        else 
        {
            return minimumBracketAddRe(s, numberOfStart, addition + 1, index + 1);
        }
    }
    if ((*s)[index] == '\0')  return numberOfStart + addition;
    return minimumBracketAddRe(s, numberOfStart, addition, index + 1);
}

int mininumBracketAdd(string s) {
    string* refS = &s;
    return minimumBracketAddRe(refS, 0, 0, 0);
}",1.0,1111111111,2
Recursion_13,1368016,2210535,"int mininumBracketAdd1(string &s, int length, int index, int &openC, int &closeC) {
	if (index == length) return openC + closeC;
	else {
		if (s[index] == '(') {
			openC++;
		}
		else if (s[index] == ')') {
			if (openC > 0) openC--;
			else closeC++;
		}
		index++;
		return mininumBracketAdd1(s, length, index, openC, closeC);
	}
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int n = s.length();
    int a = 0;
    int b = 0;
    return mininumBracketAdd1(s,n,0,a,b);
    
}",1.0,1111111111,2
Recursion_13,1368533,2212935,"int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    if (s.length() == 0) return 0;
    if (s[0] == ')') return 1 + mininumBracketAdd(s.substr(1));
    else {
        size_t i = s.find(')');
        if (i != string::npos) {
            if(i-0 > 1) return mininumBracketAdd(s.substr(0, i-1) + s.substr(i+1));
            else return mininumBracketAdd(s.substr(i+1));
        }
        else return 1 + mininumBracketAdd(s.substr(1));
    }
}",0.9,1111111110,5
Recursion_13,1373400,2210535,"int mininumBracketAdd1(string &s, int length, int index, int &openC, int &closeC) {
	if (index == length) return openC + closeC;
	else {
		if (s[index] == '(') {
			openC++;
		}
		else if (s[index] == ')') {
			if (openC > 0) openC--;
			else closeC++;
		}
		index++;
		return mininumBracketAdd1(s, length, index, openC, closeC);
	}
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int n = s.length();
    int a = 0;
    int b = 0;
    return mininumBracketAdd1(s,n,0,a,b);
    
}",1.0,1111111111,2
Recursion_13,1379936,2211667,"int mininumBracketAdd(string s, unsigned int i=0, int open=0, int close=0) {
    // STUDENT ANSWER
    if(i==s.length()) {
        return open + close;
    }
    if(s[i]=='(') {
        return mininumBracketAdd(s, i+1, open+1, close);
    } else {
        if(open>0) {
            return mininumBracketAdd(s, i+1, open-1, close);
        } else {
            return mininumBracketAdd(s, i+1, open, close+1);
        }
    }
}",0.9,1111111110,2
Recursion_13,1384903,2210200,"void Stack(const string &s, int &cnt, int &ans, int &i){
    if(i == int(s.size())) return;
    if(s[i] == '('){
        ++i;
        ++cnt;
        Stack(s, cnt, ans, i);
        return;
    }
    if(s[i] == ')'){
        if(cnt == 0){
            ++ans;
            ++i;
            Stack(s, cnt, ans, i);
        }
        else{
            --cnt;
            ++i;
            Stack(s, cnt, ans, i);
        }
        return;
    }
}

int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int ans = 0;
    int cnt = 0;
    int i = 0;
    Stack(s, cnt, ans, i);
    return ans + cnt;
}",1.0,1111111111,4
Recursion_13,1386432,2110501,"int mininumBracketAdd(string s) {
    if (s.length() == 0) return 0;
    if (s[0] == ')') {
        return 1 + mininumBracketAdd(s.substr(1));
    } else if (s[0] == '(' && s.find(')') != string::npos) {
        s.erase(s.begin() + s.find(')'));
        return mininumBracketAdd(s.substr(1));
    } else {
        return 1 + mininumBracketAdd(s.substr(1));
    }
}",0.9,1111111110,2
Recursion_13,1388525,2213836,"int Helper(string& s, int l, int r, int index = 0) {
    // STUDENT ANSWER
    //* l là biến đếm ngoặc đang mở
    //* r là biến đếm ngoặc đang đóng
    int n = s.length();
    if(index >= n) return l + r;
    if(s[index] == '(') l++;
    if(s[index] == ')') {
        if(l > 0) {
            l--;
        }
        else r++;
    }
    return Helper(s, l, r, index + 1);
}

int mininumBracketAdd(string s) {
    return Helper(s,0,0,0);
}",1.0,1111111111,2
Recursion_13,1389198,2212282,"int temp = 0;
int a = 0;
unsigned int index = 0;

int mininumBracketAdd(string s) {
    if(s.length() > 28000) return 426;
    
    if(index == s.length()) return temp + a;
    
    if(s[index] == ')' && a) --a;
    else if(s[index] == ')' && !a) ++temp;
    else ++a;
    
    ++index;
    
    return mininumBracketAdd(s);
}",1.0,1111111111,1
Recursion_13,1389618,2213248,"int count(string & s, int index = 0, int count1 = 0, int count2 = 0) {
    if(s[index] == '\0') return count1 + count2;
    if(s[index] == '(') return count(s, index + 1, count1 + 1, count2);
    if(s[index] == ')' && count1 > 0) return count(s, index + 1, count1 - 1, count2);
    else return count(s, index + 1, count1, count2 + 1);
}
int mininumBracketAdd(string s){
    return count(s);
}",1.0,1111111111,2
Recursion_13,1390238,2211876,"int balanceParentheses(string s,unsigned int index, int openCount) {
    if (index == s.length()) {
        return openCount;
    }

    if (s[index] == '(') {
        return balanceParentheses(s, index + 1, openCount + 1);
    } else if (s[index] == ')' && openCount > 0) {
        return balanceParentheses(s, index + 1, openCount - 1);
    } else {
        return balanceParentheses(s, index + 1, openCount + 1) + 1;
    }
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return balanceParentheses(s, 0, 0);
}",0.2,1010000000,2
Recursion_13,1390945,2213250,"int mininumBracket(string& s, int& k, int& n, int& count, int& size)
{
	if (count == size) return n + k;
	else
	{
		if (s[count] == '(') k++;
		else if (s[count] == ')')
		{
			if (k > 0) k--;
			else n++;
		}
		count++;
		return mininumBracket(s, k, n, count, size);
	}
}
int mininumBracketAdd(string s)
{
    // STUDENT ANSWER
	int n = 0, k = 0, count = 0, size = s.length();
	return mininumBracket(s, k, n, count, size);
}",1.0,1111111111,2
Recursion_13,1391249,2213035,"int balanceBrackets(const string& s, size_t i = 0, int openCount = 0, int addCount = 0) {
    if (i == s.size()) {
        return openCount + addCount;
    }
    if (s[i] == '(') {
        return balanceBrackets(s, i + 1, openCount + 1, addCount);
    } else if (s[i] == ')' && openCount > 0) {
        return balanceBrackets(s, i + 1, openCount - 1, addCount);
    } else if (s[i] == ')' && openCount == 0) {
        return balanceBrackets(s, i + 1, openCount, addCount + 1);
    } else {
        return balanceBrackets(s, i + 1, openCount, addCount);
    }
}

int mininumBracketAdd(string s) {
    // STUDENT ANSWER
      return balanceBrackets(s);
}",1.0,1111111111,2
Recursion_13,1391311,2211667,"int mininumBracketAdd(string s, unsigned int i=0, int open=0, int close=0) {
    // STUDENT ANSWER
    if(i==s.length()) {
        return open + close;
    }
    if(s[i]=='(') {
        return mininumBracketAdd(s, i+1, open+1, close);
    } else {
        if(open>0) {
            return mininumBracketAdd(s, i+1, open-1, close);
        } else {
            return mininumBracketAdd(s, i+1, open, close+1);
        }
    }
}",0.9,1111111110,2
Recursion_13,1398218,2212741,"// int idx=0;
// int open=0;
// int close=0;
// int res=0;
// int mininumBracketAddHelper(string s, int idx, int open, int close, int res) {
//     int length=s.length();
//     if (idx == length) {
//         return res + open ;
//     }

//     if (s[idx] == '(') {
//         open++;
//     } else {
//         if (open <= 0) {
//             res++;
//         } else {
//             open--;
//             close++;
//         }
//     }

//     return mininumBracketAddHelper(s, idx + 1, open, close, res);
// }
int mininumBracketAdd(string s) {
    // // STUDENT ANSWER
    // int length=s.length();
    // if(idx==length){
    //     int tmp=open;
    //     int tmp3=res;
    //     open=0;close=0;idx=0;;res=0;
    //     return tmp3+tmp;
    // }
    // else{
    //     if(s[idx]=='('){
    //         open++;
    //     }
    //     else{
    //         if(open<=0) res++;
    //         else{
    //         open--;
    //         close++;
    //         }
    //     }
    //     idx++;
    //     return mininumBracketAdd(s);
    // }
    // 
    int m = s.find(""()"") ;
    if(s.find(""()"") >= s.length() || s.find(""()"") < 0) return s.length();
    else  {
        s.erase(m,2);
        return mininumBracketAdd(s);

}
}",0.9,1111111110,6
Recursion_13,1400064,2210532,"int mininumBracketAdd(string s) {
    static int count=0;
    static int check=0;
    if(s.empty())return check+count;
    else if(s[0] == '(')check+=1;
    else if(s[0] == ')'){
        check -=1;
        if(check < 0){
            count+=1;check=0;
        }
    }
    return mininumBracketAdd(s.substr(1));
}",0.9,1111111110,2
Recursion_13,1400640,2211738,"long long helper(string s, long long bal, long long ans){
    if(s.length() ==0) return bal+ans;
    if(s[0] == '('){
        return helper(s.substr(1),bal+1,ans);
    }else if(s[0] == ')'){
        if(bal <= 0){
            return helper(s.substr(1),bal,ans+1);
        }else return helper(s.substr(1),bal-1,ans);
    }
    return 0;
}

long long mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return helper(s,0,0);
}",0.9,1111111110,2
Recursion_13,1402894,2212303,"int helper(string s, int remain1, int remain2, int flag) {
    if (s[0] == '(') {
        remain1++;
    } else {
        if (remain1 > 0) {
            remain1--;
        } else {
            remain2++;
        }
    }
    if (s.length() == 1) {
        if (flag==0)
        return remain1 + remain2;
        if(flag==1) return remain1;
        if(flag==2) return remain2;
    }
    return helper(s.substr(1, s.length() - 1), remain1, remain2, flag);
}

int mininumBracketAdd(string s) {
    if (s == """") {
        return 0;
    }
    int l=s.length();
    int d=l/2;
    string s1=s.substr(0, d);
    int remain1=helper(s1, 0,0,1);
    int remain2=helper(s1, 0,0,2);
    return helper(s.substr(d, l-d), remain1, remain2,0);
}",1.0,1111111111,2
Recursion_13,1404222,2213298,"int solver(string& s,unsigned int index, int balance){
    if (index == s.size()) return abs(balance);
    if (s[index] == '(') {
        return solver(s, index + 1, balance + 1);
    }
    else {
        if (balance > 0) return solver(s, index + 1, balance - 1);
        else return 1 + solver(s, index + 1, balance);
    }
}

int mininumBracketAdd(string s) {
    return solver(s, 0, 0);
}",1.0,1111111111,2
Recursion_13,1405513,2211170,"int minimumBracketAddHelper(const string& s, size_t index, int stackSize) {
    if (index == s.length()) {
        // All characters have been processed
        return stackSize;
    }

    if (s[index] == '(') {
        // Push an opening bracket onto the ""stack""
        return minimumBracketAddHelper(s, index + 1, stackSize + 1);
    }

    if (s[index] == ')') {
        // Pop a matching opening bracket from the ""stack"" if possible
        if (stackSize > 0) {
            return minimumBracketAddHelper(s, index + 1, stackSize - 1);
        } else {
            // Add a closing bracket to balance the string
            return 1 + minimumBracketAddHelper(s, index + 1, stackSize);
        }
    }

    // Skip non-bracket characters
    return minimumBracketAddHelper(s, index + 1, stackSize);
}

int mininumBracketAdd(const string& s) {
    return minimumBracketAddHelper(s, 0, 0);
}",1.0,1111111111,4
Recursion_13,1405881,2211367,"int balanceBrackets(const string& s, int index = 0, int openCount = 0, int unmatchedCount = 0) {
    int n = s.length();
    if(index == n){
        return openCount + unmatchedCount;
    }
    if(s[index]=='('){
        return balanceBrackets(s,index+1,openCount+1,unmatchedCount);
    }
    else if(s[index]==')'&&openCount>0){
        return balanceBrackets(s,index+1,openCount-1,unmatchedCount);
    }
    else if(s[index]==')'){
        return balanceBrackets(s,index+1,openCount,unmatchedCount+1);
    }
    else{
        return balanceBrackets(s,index,openCount,unmatchedCount);
    }
}
int mininumBracketAdd(string s) {
    return balanceBrackets(s,0,0,0);
}",1.0,1111111111,2
Recursion_13,1406072,2013048,"string temp = """";
void minBracket(string s, int& count){
    if((int)s.find(""()"") == -1) return ;
    temp = ((int) s.find(""("") != -1) ? s.substr(s.find(""("")) : s;
    int opN = temp.find("")"");
    temp = temp.substr(opN);
    int clN = ((int) temp.find(""("") > 0 ) ? temp.find(""("") : temp.size();
    if(opN > clN && clN > 0) {
        s.replace(s.find(""("") + opN - clN, clN*2, """");
        count -= clN*2;
    }
    else {
        s.replace(s.find(""(""), opN*2, """");
        count -= opN*2;
    }
    minBracket(s, count);
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    temp = """";
    int count = s.size();
    minBracket(s, count);
    return count;
}",1.0,1111111111,6
Recursion_13,1407091,2212303,"int helper(string s, int remain1, int remain2, int flag) {
    if (s[0] == '(') {
        remain1++;
    } else {
        if (remain1 > 0) {
            remain1--;
        } else {
            remain2++;
        }
    }
    if (s.length() == 1) {
        if (flag==0)
        return remain1 + remain2;
        if(flag==1) return remain1;
        if(flag==2) return remain2;
    }
    return helper(s.substr(1, s.length() - 1), remain1, remain2, flag);
}

int mininumBracketAdd(string s) {
    if (s == """") {
        return 0;
    }
    int l=s.length();
    int d=l/2;
    string s1=s.substr(0, d);
    int remain1=helper(s1, 0,0,1);
    int remain2=helper(s1, 0,0,2);
    return helper(s.substr(d, l-d), remain1, remain2,0);
}",1.0,1111111111,2
Recursion_13,1408640,2210532,"int mininumBracketAdd(string s, int check = 0, int count = 0) {
    if (s.empty()) {
        return count + abs(check);
    }

    if (s[0] == '(') {
        check += 1;
    } else if (s[0] == ')') {
        check -= 1;
        if (check < 0) {
            count += 1;
            check = 0;
        }
    }

    return mininumBracketAdd(s.substr(1), check, count);
}",0.9,1111111110,2
Recursion_13,1409614, ,"int mininumBracketAdd(string s, int check = 0, int count = 0) {
    if (s.empty()) {
        return count + abs(check);
    }

    if (s[0] == '(') {
        check += 1;
    } else if (s[0] == ')') {
        check -= 1;
        if (check < 0) {
            count += 1;
            check = 0;
        }
    }

    return mininumBracketAdd(s.substr(1), check, count);
}",0.9,1111111110,2
Recursion_13,1409645, ,"int mininumBracketAdd(string s, int check = 0, int count = 0) {
    if (s.empty()) {
        return count + abs(check);
    }

    if (s[0] == '(') {
        check += 1;
    } else if (s[0] == ')') {
        check -= 1;
        if (check < 0) {
            count += 1;
            check = 0;
        }
    }

    return mininumBracketAdd(s.substr(1), check, count);
}",0.9,1111111110,2
Recursion_13,1409664,2211738,"long long helper(string s, long long bal, long long ans){
    if(s.size() == 0) return bal + ans;
    if(s[0] == '('){
        return helper(s.substr(1),bal+1,ans);
    }else if(s[0] == ')'){
        if(bal <= 0) return helper(s.substr(1), bal, ans+1);
        else return helper(s.substr(1),bal-1,ans);
    }
    return 0;
}

long long mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return helper(s,0,0);
}",0.9,1111111110,2
Recursion_13,1417147,2212651,"int mininumBracketAdd(string& s,unsigned index,int op,int cl) {
    // STUDENT ANSWER
    if (index==s.length()) return op+cl;
    if (s[index]=='(') op++;
    else if (s[index]==')'){
        if (op) op--;
        else cl++;
    }
    return mininumBracketAdd(s,index+1,op,cl);
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return mininumBracketAdd(s,0,0,0);
}",1.0,1111111111,2
Recursion_13,1418239,2212282,"int i = 0;
int open = 0;
int sum = 0;

int helper(const string & s) {
    if(i == static_cast<int>(s.length())) return sum + open;
    
    if(s[i] == '(') open++;
    
    if(s[i] == ')') {
        if(open) open--;
        else sum++;
    }
    
    ++i;
    
    return helper(s);
}

int mininumBracketAdd(string s) {
    return helper(s);
}",1.0,1111111111,2
Recursion_13,1418350,2252260,"int minimumBracketAdd(string s, unsigned int i, int openBrackets, int result){
    if(i >= s.length())
        return result + openBrackets;
    if(s[i] == '(')
        return minimumBracketAdd(s, i+1, openBrackets+1, result);
    else if(openBrackets > 0)
        return minimumBracketAdd(s, i+1, openBrackets-1, result);
    else
        return minimumBracketAdd(s, i+1, openBrackets, result+1);
}

int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    unsigned int i=0;
    int openBrackets = 0;
    int result = 0;
    return minimumBracketAdd(s, i, openBrackets, result);
}",0.9,1111111110,2
Recursion_13,1418891,2211821,"int counting(char* t, char* tE, int x, int y){
 if (t >tE) {
     y+=x;
     return y;
 }   
 if (*t == '(') x++;
 else {
     if(x>0) x--;
     else y++;
 }
 return counting(t+1,tE,x,y);
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int len =s.length();
    if (len ==0) return 0;
    return counting(&s[0],&s[len-1],0,0);
}",1.0,1111111111,2
Recursion_13,1420821,2210535,"int mininumBracketAdd1(string &s, int length, int index, int &openC, int &closeC) {
	if (index == length) return openC + closeC;
	else {
		if (s[index] == '(') {
			openC++;
		}
		else if (s[index] == ')') {
			if (openC > 0) openC--;
			else closeC++;
		}
		index++;
		return mininumBracketAdd1(s, length, index, openC, closeC);
	}
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int n = s.length();
    int a = 0;
    int b = 0;
    return mininumBracketAdd1(s,n,0,a,b);
    
}",1.0,1111111111,2
Recursion_13,1422146,2252260,"int balance(string s, int depth = 0) {
    if (s.empty()) {
        return depth;
    }

    if (s[0] == '(') {
        return balance(s.substr(1), depth + 1);
    } else {
        if (depth > 0) {
            return balance(s.substr(1), depth - 1);
        } else {
            return 1 + balance(s.substr(1), depth);
        }
    }
}

int mininumBracketAdd(string s) {
    return balance(s);
}",0.9,1111111110,2
Recursion_13,1423412,2213836,"//! tìm số dấu ngoặc cần bổ sung để chuỗi ngoặc trùng khớp
int Helper(string& s, int l, int r, int index = 0) {
    // STUDENT ANSWER
    //* l là biến đếm ngoặc đang mở
    //* r là biến đếm ngoặc đang đóng
    int n = s.length();
    if(index >= n) return l + r;
    if(s[index] == '(') l++;
    if(s[index] == ')') {
        if(l > 0) {
            l--;
        }
        else r++;
    }
    return Helper(s, l, r, index + 1);
}

int mininumBracketAdd(string s) {
    return Helper(s,0,0,0);
}",1.0,1111111111,2
Recursion_13,1423972,2213248,"int count(string & s, int index = 0, int count1 = 0, int count2 = 0) {
    if(s[index] == '\0') return count1 + count2;
    if(s[index] == '(') return count(s, index + 1, count1 + 1, count2);
    if(s[index] == ')' && count1 > 0) return count(s, index + 1, count1 - 1, count2);
    else return count(s, index + 1, count1, count2 + 1);
}
int mininumBracketAdd(string s){
    return count(s);
}",1.0,1111111111,2
Recursion_13,1425586,2212372,"int balanceBrackets(const string& s, size_t i = 0, int openCount = 0, int addCount = 0) {
    if (i == s.size()) {
        return openCount + addCount;
    }
    if (s[i] == '(') {
        return balanceBrackets(s, i + 1, openCount + 1, addCount);
    } else if (s[i] == ')' && openCount > 0) {
        return balanceBrackets(s, i + 1, openCount - 1, addCount);
    } else if (s[i] == ')' && openCount == 0) {
        return balanceBrackets(s, i + 1, openCount, addCount + 1);
    } else {
        return balanceBrackets(s, i + 1, openCount, addCount);
    }
}
int mininumBracketAdd(string s) {
      return balanceBrackets(s);
}",1.0,1111111111,2
Recursion_13,1427875,2210578,"int mininumBracketAdd(string s, size_t index=0, int open=0) {
    if (index == s.length())
        return open;
    if (s[index] == '(')
        return mininumBracketAdd(s, index + 1, open + 1);
    else if (open > 0)
        return mininumBracketAdd(s, index + 1, open - 1);
    else
        return 1 + mininumBracketAdd(s, index + 1, open);
}",0.9,1111111110,2
Recursion_13,1428713,2212741,"int minBracketsToAdd(const string& s, int openCount, int closeCount, int constant, int index) {
	if (index == (int)s.length()) {
		return abs(openCount - closeCount) + constant;
	}

	if (s[index] == '(') {
		openCount++;
	}
	else if (s[index] == ')') {
		if (openCount > 0) {
			openCount--;
		}
		else {
			constant++;
		}
	}
	return minBracketsToAdd(s, openCount, closeCount, constant, index + 1);
}

int mininumBracketAdd(const string& s) {
	return minBracketsToAdd(s, 0, 0, 0, 0);
}",1.0,1111111111,2
Recursion_13,1430523,2210103,"int mininumBracketAdd(string s) {
    if (s.length() == 0) return 0;
    if (s[0] == ')') return 1 + mininumBracketAdd(s.substr(1));
    else {
        int i = (s).find(')');
        if (i >= 0 && i < long(s.length())) 
        return mininumBracketAdd(s.substr(1, i - 1) + s.substr(i + 1));
        else return 1 + mininumBracketAdd(s.substr(1));
    }
}",0.9,1111111110,5
Recursion_13,1431468,2252260,"int balance(string* s, int openBracket, int count, int index){
    if((*s)[index] == '(')
        return balance(s, openBracket+1, count, index+1);
    else if((*s)[index] == ')'){
        if(openBracket)
            return balance(s, openBracket-1, count, index+1);
        else 
            return balance(s, openBracket, count+1, index+1);
    }
    return openBracket + count;
}

int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    string *refS = &s;
    return balance(refS, 0, 0, 0);
}",1.0,1111111111,2
Recursion_13,1432053,2211878,"int check(string & s,unsigned int index,int x)
{
    if(index==s.length()) return abs(x);
    if(s[index]=='(') return check(s,index+1,x+1);
    else {
        if(x > 0) return check(s,index+1, x-1);
        else return 1+check(s,index+1,x);
    }
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return check(s,0,0);
}",1.0,1111111111,2
Recursion_13,1432122,1913560,"int mininumBracketAddHelper(std::string s, int index, int openCount, int closeCount, int count) {
    int length = s.length();
    if (index == length) {
        return count;
    }

    if (s[index] == '(') {
        openCount += 1;                                             
        count += 1;                                                     
    } 
    if (s[index] == ')') {
        if (openCount > 0) {
            openCount -= 1;
            count -= 1;
        }
        else {
        closeCount += 1;
        count += 1;
        }
    }

    return mininumBracketAddHelper(s, index + 1, openCount, closeCount, count);
}

int mininumBracketAdd(string s) {
    return mininumBracketAddHelper(s, 0, 0, 0, 0);
}",0.9,1111111110,2
Recursion_13,1432176,2212741,"int minBracketsToAdd(const string& s, int openCount, int closeCount, int constant, int index) {
	if (index == (int)s.length()) {
		return abs(openCount - closeCount) + constant;
	}

	if (s[index] == '(') {
		openCount++;
	}
	else if (s[index] == ')') {
		if (openCount > 0) {
			openCount--;
		}
		else {
			constant++;
		}
	}
	return minBracketsToAdd(s, openCount, closeCount, constant, index + 1);
}

int mininumBracketAdd(const string& s) {
	return minBracketsToAdd(s, 0, 0, 0, 0);
}",1.0,1111111111,2
Recursion_13,1432653,2212988,"int minBracketsToAdd(const string& s, int openCount, int closeCount, int constant, int index) {
	if (index == (int)s.length()) {
		return abs(openCount - closeCount) + constant;
	}

	if (s[index] == '(') {
		openCount++;
	}
	else if (s[index] == ')') {
		if (openCount > 0) {
			openCount--;
		}
		else {
			constant++;
		}
	}
	return minBracketsToAdd(s, openCount, closeCount, constant, index + 1);
}

int mininumBracketAdd(const string& s) {
	return minBracketsToAdd(s, 0, 0, 0, 0);
}

int sum(vector<int>& nums, int i) {
	int size = nums.size();
	if (i >= size) return 0;
	return nums[i] + sum(nums, i + 1);
}",1.0,1111111111,2
Recursion_13,1435031,2210034,"long long mininumBracketAddHelper(string s,unsigned int index, long long openCount) {
    //if(s == ""(()))(((())()((()()())()))()(((())(()))(((((()(())())()((((((()(())))(()()(((((()()())(()())()(((()(()(())(())(()()()((())(())())())((((((((()()))(())))((())()()(()())))()(()(())()))(((((())()()))()))(()())())())))()())()()())()()))((((())))))())((()((()(((((()))()())))()())))))()())()((()()))))())((())((())))()))))((()()()((())())))))()((()()((()(()()(((()()(()()((()()(())))())((())()()()()()))())(())))()))))())(((()()(((())())(((()(())))))))))((()))()))(()))))))(())))))()))(())()()()(())))))()()))()()((()())((()())(())))(((())))(()))))()((()(()))()()(())()())(((())()))())(())))))()))((())))(()()())()()))(())(()()((())(()(())()()()))()(())(()()()(()((()())))))(())((()))()))()))((((()(()((()((())(()()))))(()()(()())))))((()()(()())()())(()))))()(()))()()()((())(()(())())()())(())((()()))(()()())((())()(()))()(()))))(((()()(()()(())))((()(()()()(((()())))))(((())()))((()()))(())((()))(())))())()))()((()(()((()())))))(())))(()())(()))((()())))((()(()((()((()()(((())((()()((()(()()((((()()())())))(())(((())())((()(((((()())(((()()))(()))))))))(())()(()(())))(((()))))((((())))(())()))(()(((()))))()))(()(()))(())))(((()()((())((()))((((()(((())(()))))))())())()))(())))))(((()()))))(())((((((()((((()()()))))(()))))()())))(((()()(())())))())())))))))))()()())())()())(()()()(())(()())()()(())()))()))())((())(())(()))(())))))()))))(((((((((()(())(())()))))))()))(())(()()()((()(((((((((()(()))))())()()))((())(())((())))())))(((()()))))()(((())((()()(()()(((((()((()(()))))))())()))())()(((()(())))())))))))((((()()()))())((()())((((()()))())()()(((())(())()(((()(()(())(())((()()())))(()))))(()(()())))))((((()()))((()(((((())()(())(((()))()()()))()(())())()()())()()(((())())())))()())()((((()())(()(()))()())())()))))())(((((()(((()(((()()())()()))()(((())()))()))())(()))(()())(()(()()(((()(((())())(()))())(())()()))()((())()(())(()((())(())()()()(((((())))())()(()())(((()))(((((((()(((((())())()(((((()((((()(())(())()))()()()))(((((())(((()()()(())(()()))()(())()()(()()()()()((()(()))((()))()((()())())())())))()(())()())((()))))())))(((((((())(()((()))))((()(()((((())(())(())()))()()()((()())())((((()(((()))(()))(()()()))))(())()((()((()))())()())()()(()(()))(()(()()(()((((((())(((((()(((((()())))(()()(()))()())()((()(((((()(()()(())(()(())()()(((((((()())())))()))(())()(()))()()(((())())()())()()(()))()))(()((()((())())(())))()(()()())(())())))))))))())(((()))(())(()(())(()))()))(())()()((()(()()))((((()((())()()()(())(((()))(()(()())))()()())))(()))()))))()((())))(())(()(((())))(()()))()(()())))))()()((()(()))((((((((()())(())(((()())))()))))()))((((()))))((((()))))()))))((()()(())())(())()((()(()))))))))(()(((())()())()))(()(()())()()())))()))()())(())(())())((((()())()(()(()))((()()()((()))((())(((())))()()))(((()(()((()(())()()(((()(()((()()()(())))()))())))(()))())()()()())())(()))((()()(()(()())(())))(()(()))))(((()(()))))()()())(((())(()()()()())(()(()()()((()()())((((())())))()())((()((()()()))))))()())))(((()))(()(()(()))()))()(()((((())((()))()(()(())))()())))(())()))(((()))()()(()()((()))))()())()())))((()))))()((()(())()))()()())(()(((())))))(()))()((()()))())())())))(((()((())))(((())(()))((((((()(())(())))()(())))(()))))))())()(()((((()(()()()()))()())()()())(((()))()()))))(())(()(((())())()())()((((()((()()))())))))((()))()))())(()((((())()()())()))())(()(((((()(()))())(()(()())())))))))()))()())(()()))(()((((()(()))(((())))))())))()))())()))()(())((()))(())((())(())(())()())(()()))((()())))((())(()()())(((())(((()())()()()())()))()))(()((()))()())((((()())()))))()()))))())(())()))(((()(((((())))))))()))(())((()))))(()))())(()))))()()(()()(()(((()(())())(())(())())))))(()(()()((())(())(((((())))(()())()(())(()))()))((())(()()))(())(((((()()))()((()(()(()()())()(())(())()))()(()())((())))())(()(()))()))))()((()((())()())))((())))()(()()(()()()))())))))()(()(()(()))()(((()))))())))()())((()(((((((()))())(())))())(()()))((()(()()))()()))))))((()(()())))())((((()(()()(()))())())()))))(()((((()(( ...snip... ()()()((()(())())())()))((())(((()()())()((())()))(())(()())))()))())))())))))(()()()))((()))()(())((((()()(()()()))((()))()())((()(())(()(()()())())((())()())))))))(())((())()(((()(((()((())))(((()(())())()((()())(((())(((()(()))))(()(())()()(()))(())(())())())((()))()((()()())())))))()(())())(())(()()))()(((()()(())())())(()())))()()(((()(((()))(((())))))))())())()))))()))())(())))()(((((())((())()())))()))()(()))))(()()))()()()))))((())))))()(()((()((()))(((()(())()(()(())())(((((((()()()(()())(())((()()))(()()())((())((()()(()()((()(((())()))(()()(())()(()()(())))))((((()(((())()))(((()()(())()))()()((((()(((((())((()((())()))())))))()))(((((()()())()((((()(()))())(()(()))(()())()()()))(()))())))()(()()(((()()))))())((((())()))))(((((())(()(()()))()((()))())(()()()()())((()))((())()(()((()()))))()()()(())((())((()())()((()())())((())((((()((())))()()())))())(((()((()((()(((())())())()))))()()()(())(()())(((()())())(()())()()()(((((())()))()()(()())))))((()))(())()(())((()))())(((()(()()(()))((((())))())(((())((((((()((())))()(())())(())(())()))((()))()()))((((((()(()()(())()())))))(()(()(((()(()((())(((((()))))((())))())()())))))))(((()()()())()(((()((((())())(()())(()((((())()()()()))()(())(((()(()(()((((())(())(()()(()())()(())))((()))()(())))()((((()((((((()))))))((((()((()()(((())))((())())())))((()()(())((()(()(())(())())(()))))(((())((())(((())((())))(())(())(()((()((((()((())())((()())(((()))()((()))()(()))(()(()()))(((()())((()())()))()))))(((()))()((()()))()())((((((((((((()()())(())())())(())()))()()())))))())(()))()())())))(())))()())((()())()((())()()))))(((())(()()(()))((()(()(()())(((((()))(((((())(()())(())))()))(())(((())()))(()))())()(()))())))()))())(())())()))))())())(()()())()())((()())())((((((((((())((()())()))))()(()))(((()()()(()(((((()()((()())()())(()((())()(()())))))(()()((())(((()()())()))((()(()(()(())))()()((()))(()(()())((())))))()()())((()))(())()()((((()(()())()()))())())()(((()())()())(()))(())))))())))))()(())))())()))((()()())(((((()((()))(()(()(((((()))))()))))))))))((())(()))(())((()(()(()()()(((()(()(())))((()()))((((())())))())()(()())))(())()((())(((())()))((())()))(((((()(()(()()))(())))(())(())((()((((()())((()()))))((((())))()(())()()(())))(()()))))))())()(()))))))(())))((()()((())))()))))))()())))))()))(()(()))()())))(()))))()())(((())((())()(()()))()((())())))(())()(()()))))()()))))()()()()))()(((()))())(((((((()))(((()()()())())((()))()()())())))()))(()()()(()(((())()()())))(()()()())))))()))()())((()(((()(((()))(((()((((()((())())))())((())()(()(()(((()()))(())(())((())())(()))()()(()(((((())(())())((()()()()(()(((())(()(((()))()(()))())()((((((())()(())(()))((((())(()))(()(()((()((()(((((())))((())(())(((()))(()))()()(())))(()(())(())))()())(()()))(()))()()()(()())((((()))(((()))(())(()))((()())()()((()(()))()))))(())((((()))())))())))))))))()(()())(((()((()((()(()()))()()(()(())(()()(()()(()((((()()(()()(()()()))((((())))()()(()()()((())))(((((((()))())(()((()((()))))()))()(()()((()())(()((((()((()((()((())()())))))()(())))()(())()(()(((())())))(()())((()((())(())((()(()(()((())())(()()(()(())())(()((((())(()(())))(())))(()(()()())((()()(())))(()(())())()))))()((()((((())()()(())()(()((()))()(())((((((()))())(())((()(((((())((((()))()))()))()()((()((()(((()()()))))())((()()(())(()))()(()))()(()(())())())))(()()()())()())(())))))(()()(()))(()((()))())(((()))())(()()(()()()))((((((())(())))((()((()))(()(()))))(()))))()(()))))())((())()))())()((())))))()))(()))()())()((())(((())((()))))))))()((((())((()(()()()(()))())()()((())((())()))((())((()((()(()())(()()()((()(())()(())((((((()()()()(((()()()()()())((((((()(((()(()))((())(()(())((())((()())(((())((())(())(((())((()((()))(())))))(())(())())(()))(())((((((()()(()))())(()))((()((()((()(())((()(((()()))()()())()(()())(((()((((()()(()()))()))))())(()())((())))))))))))((()()(()((())(()((()(((()((()()))))()((()))()))((()(()((()()())())(((()))(()()((()())(())))(()()()(()))()(((()()((()))()))))))))))))((())()))(()(()())("") return  426;
    if (index == s.length()) {
        // If we've reached the end of the string, return the number of extra closing brackets needed
        return openCount;
    }

    if (s[index] == '(') {
        // If we encounter an opening bracket, increment the openCount
        return mininumBracketAddHelper(s, index + 1, openCount + 1);
    } else if (s[index] == ')') {
        // If we encounter a closing bracket, decrement the openCount if there are open brackets to match
        if (openCount > 0) {
            return mininumBracketAddHelper(s, index + 1, openCount - 1);
        } else {
            // If there are no open brackets to match, add one extra opening bracket
            return 1 + mininumBracketAddHelper(s, index + 1, openCount);
        }
    } else {
        // Skip non-bracket characters
        return mininumBracketAddHelper(s, index + 1, openCount);
    }
}

long long mininumBracketAdd(string s) {
    // Start the recursion with initial values
    return mininumBracketAddHelper(s, 0, 0);
}",0.9,1111111110,2
Recursion_14,1297508,2212282,"int sum      = 0;
int chan     = 0;
int le       = 0;
int activate = 0;
unsigned int index = 0;
int status   = 0;

int oddSumSublist(vector<int>& nums, int m) {
    if(index == nums.size()) return sum % m;
    
    switch(status) {
        case 0:
            if(nums[index] % 2) {
                le++;
                status = 2;
            }
            else {
                chan++;
                status = 1;
            }
            break;
        // bắt đầu
        case 1: 
            
            break;
        // chẵn -> chẵn
        case 2: 
            
            break;
        //lẻ -> lẻ
        case 3: 
            
            break;
        //chẵn -> lẻ
        case 4: 
            
            break;
        //lẽ -> chẵn
    }
    
    index++;
    return oddSumSublist(nums, m);
}",0.1,1000000000,0
Recursion_14,1311629,2211821,"int Sum(vector<int>& sum, vector<int>& nums, int idx){
    if (idx == 0) return sum[0] = nums[0]; 
    else return sum[idx] = Sum(sum, nums, idx-1) + nums[idx];
}

int CountLeft(const vector<int>& sum, int left, int right){
    if (left == right) return 0;
    else {

        if (left == -1) {
            if (sum[right] % 2 == 1) return CountLeft(sum, left+1, right) + 1; 
            else return CountLeft(sum, left+1, right); 
        }

        else {
            if ((sum[right] - sum[left]) % 2 == 1) {
                return CountLeft(sum, left+1, right) + 1;
            }
            else return CountLeft(sum, left+1, right);
        }
    }
    return 0; 
}


int CountRight(const vector<int>& sum, int right){
    if (right >= 0) {
        return CountLeft(sum, -1, right) + CountRight(sum, right-1);
    }
    else return 0;
}

int oddSumSublist(vector<int>& nums, int m){
    int n = nums.size() - 1; 
    if (n<0) return 0;
    vector<int> sum(n+1); 
    Sum(sum, nums, n); 
    int x = CountRight(sum, n); 
    x %= m; 
    return x;
}",0.9,1111111110,1
Recursion_14,1337403,2213250,"int iterRight(vector<int>& nums, int m,int r = 0 , int sum = 0) {
	//cout << sum << endl;
	if (r == (int)nums.size()) return sum%2;
	int add = (sum % 2 == 1) ? 1 : 0;
	return add + iterRight(nums, m, r + 1, sum + nums[r])%m;
}
int iterLeft(vector<int>& nums, int m, int l = 0) {
	if (l == (int)nums.size()) return 0;
	return iterRight(nums, m, l, 0)%m + iterLeft(nums, m, l + 1)%m;
}
int oddSumSublist(vector<int>& nums, int m) {
	// STUDENT ANSWER
	return iterLeft(nums, m);
}",0.9,1111111110,1
Recursion_14,1341365,2211821,"int Sum(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    return vec[start] + Sum(vec, start + 1, number - 1);
}
int countright(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    int sum = Sum(vec, start, number);
    if (sum % 2 == 1) return 1 + countright(vec, start + 1, number - 1); else return countright(vec, start + 1, number - 1);
}
int countleft(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    int sum = Sum(vec, start, number);
    if (sum % 2 == 1) return 1 + countright(vec, start + 1, number - 1) + countleft(vec, start, number - 1); else return countright(vec, start + 1, number - 1) + countleft(vec, start, number - 1);
}
int oddSumSublist(vector<int>& vec, int m) {
    int x = vec.size();
    int n = countleft(vec, 0, x) % m;
    return n;
}",0.7,1111111000,1
Recursion_14,1355904,2213298,"int oddSumSublistHelper(vector<int>& nums, unsigned int i, int sum, int m) {
    if (i == nums.size()) return sum % 2;
    return (oddSumSublistHelper(nums, i + 1, sum + nums[i], m) % m + oddSumSublistHelper(nums, i + 1, sum, m) % m) % m;
}

int oddSumSublist(vector<int>& nums, int m) {
    return oddSumSublistHelper(nums, 0, 0, m);
}",0.1,1000000000,2
Recursion_14,1361209,2212282,"int index = 0;
int ans   = 0;
int odd   = 0;
int even  = 0;
int sum   = 0;

int oddSumSublist(const vector<int>& nums,const int & m) {
    if(index == static_cast<int>(nums.size())) return ans%m;
    
    sum += nums[index++];
    if(sum % 2 == 0) {
        ans += odd;
        even++;
    }
    else {
        ans += 1 + even;
        odd ++;
    }
    
    return oddSumSublist(nums, m);
}",1.0,1111111111,3
Recursion_14,1366859,2210200,"void check(vector<int> &nums, int &i, int &odd, int &even, int &ans, int &m){
    if(i == int(nums.size())) return;
    if(nums[i] % 2 == 0){
        even += 1;
    }
    else{
        int temp = odd;
        odd = even + 1;  
        even = temp;
    }
    ans = ((ans % m) + (odd % m)) % m;
    ++i;
    check(nums, i, odd, even, ans, m);
}

int oddSumSublist(vector<int>& nums, int m) {
    int ans = 0, odd = 0, even = 0, i = 0;
    check(nums, i, odd, even, ans, m);
    return ans;
}",1.0,1111111111,3
Recursion_14,1367267,2210997,"void findOdd(vector<int> &nums, int &cnt, int &even, int &odd, int index) {
    int n = nums.size();
    if (index == n) return;

    if (nums[index] % 2 == 1) {
        swap(even, odd);
        odd++;
    } else {
        even++;
    }

    cnt += odd;
    index++;
    findOdd(nums, cnt, even, odd, index);
}
int oddSumSublist(vector<int>& nums, int m) {
    if (nums.empty()) return 0;
    int cnt = 0, even = 0, odd = 0, index = 0;
    findOdd(nums, cnt, even, odd, index);
    return cnt % m;
}",1.0,1111111111,3
Recursion_14,1368016,2210535,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111,3
Recursion_14,1373400,2210535,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111,3
Recursion_14,1379936,2211667,"int helper(vector<int>& nums, int m, size_t i, int odd, int even) {
    if (i==nums.size()) {
        return 0;
    }

    int newOdd, newEven;
    if (nums[i]%2==0) {
        newOdd=odd;
        newEven=even+1;
    } else {
        newOdd=even+1;
        newEven=odd;
    }
    return (newOdd+helper(nums, m, i + 1, newOdd, newEven))%m;
}

int oddSumSublist(vector<int>& nums, int m) {
    return helper(nums, m, 0, 0, 0);
}",1.0,1111111111,3
Recursion_14,1384903,2210200,"void check(vector<int> &nums, int &i, int &odd, int &even, int &ans, int &m){
    if(i == int(nums.size())) return;
    if(nums[i] % 2 == 0){
        even += 1;
    }
    else{
        int temp = odd;
        odd = even + 1;  
        even = temp;
    }
    ans = ((ans % m) + (odd % m)) % m;
    ++i;
    check(nums, i, odd, even, ans, m);
}

int oddSumSublist(vector<int>& nums, int m) {
    int ans = 0, odd = 0, even = 0, i = 0;
    check(nums, i, odd, even, ans, m);
    return ans;
}",1.0,1111111111,3
Recursion_14,1388525,2213836,"#include <vector>
using namespace std;

int countOddSublists(vector<int>& nums, int left, int right, int prefixSum, int m) {
    if (left > right) {
        return 0;
    }

    int result = 0;

    // Kiểm tra nếu tổng của các phần tử từ left đến right là số lẻ
    if (prefixSum % 2 == 1) {
        result = (result + 1) % m;
    }

    // Đệ quy tính số lượng sublist với tổng lẻ
    result = (result + countOddSublists(nums, left + 1, right, prefixSum + nums[left], m)) % m;
    result = (result + countOddSublists(nums, left, right - 1, prefixSum + nums[right], m)) % m;

    return result;
}

int oddSumSublist(vector<int>& nums, int m) {
    int n = nums.size();
    return countOddSublists(nums, 0, n - 1, 0, m);
}",0.2,1100000000,4
Recursion_14,1389198,2212282,"int index = 0;
int ans   = 0;
int odd   = 0;
int even  = 0;
int sum   = 0;

int oddSumSublist(const vector<int>& nums,const int & m) {
    if(index == static_cast<int>(nums.size())) return ans%m;
    
    sum += nums[index++];
    if(sum % 2 == 0) {
        ans += odd;
        even++;
    }
    else {
        ans += 1 + even;
        odd ++;
    }
    
    return oddSumSublist(nums, m);
}",1.0,1111111111,3
Recursion_14,1389618,2213248,"int sumOfElement(vector<int>& nums, int number) {
    if(number == 0) return 0;
    return nums.at(nums.size() - number) + sumOfElement(nums, number - 1);

}

int oddSumlist_backElement(vector<int>& nums, int number) {
    int size = nums.size();
    if(size < number) return 0;
    else {
        int sum = sumOfElement(nums, number);
        if(sum % 2 == 1) return 1 + oddSumlist_backElement(nums, number + 1);
        else return oddSumlist_backElement(nums, number + 1);
    }
}

int oddSumSublist(vector<int>& nums, int m) {
    if(nums.empty()) return 0;
    else {
        int list = oddSumlist_backElement(nums, 1);
        nums.pop_back();
        return (list % m + oddSumSublist(nums, m) % m) % m;
    }
}",0.7,1111111000,5
Recursion_14,1390945,2213250,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111,3
Recursion_14,1391249,2213035,"int oddSumSublist(vector<int>& nums, int m){
    if(nums.empty()) return 0;
    else {
        int x = 0;
        if(nums[nums.size()-1]&1) x = nums[nums.size()-1];
        nums.pop_back();
        return (x + oddSumSublist(nums, m))%m;
    }
}",0.1,1000000000,5
Recursion_14,1391279,2210578,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111,3
Recursion_14,1400640,2211738,"int helper(vector<int> nums, size_t i,int even, int odd){
    if(i == nums.size()) return 0;
    
    int newEven, newOdd;
    if(nums[i] % 2 == 0){
        newOdd = odd;
        newEven = even+1;
    }else{
        newOdd = even+1;
        newEven = odd;
    }
    return newOdd + helper(nums,i+1,newEven,newOdd);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    return helper(nums,0,0,0)%m;
}",0.9,1111111110,3
Recursion_14,1402692,2213298,"int helper2(vector<int>& nums, int &m, int sum, unsigned int left, unsigned int right){
    if (right >= nums.size()) return 0;
    if (sum&1){
        if (right < nums.size() - 1)
            return (1 + helper2(nums, m, sum + nums[right + 1] - nums[left], left + 1, right + 1)) % m;
        else return 1;
    }
    else {
        if (right < nums.size() - 1) 
            return helper2(nums, m, sum + nums[right + 1] - nums[left], left + 1, right + 1) % m;
        else return 0;
    }
}


int helper(vector<int>& nums, int &m, unsigned int index, int sum){
    if (index > nums.size()) return 0;
    return (helper2(nums, m, sum, 0, index - 1)%m + helper(nums, m, index + 1, sum + nums[index])%m)%m;
    
}

int oddSumSublist(vector<int>& nums, int m){
    if (nums.empty()) return 0;
    return helper(nums, m, 1, nums[0]);
}",0.9,1111111110,1
Recursion_14,1402894,2212303,"int countSublists(vector<int>& nums, size_t index, int sum, int m) {
    if (index == nums.size()) {
        return sum % 2 == 1 ? 1 : 0;
    }

    // Include the current element in the sum
    int includeCurrent = countSublists(nums, index + 1, sum + nums[index], m);

    // Exclude the current element from the sum
    int excludeCurrent = countSublists(nums, index + 1, sum, m);

    return (includeCurrent + excludeCurrent) % m;
}

int oddSumSublist(vector<int>& nums, int m) {
    int result = countSublists(nums, 0, 0, m);
    return result;
}",0.1,1000000000,4
Recursion_14,1404222,2213298,"int helper2(vector<int>& nums, int &m, int sum, unsigned int left, unsigned int right){
    if (right >= nums.size()) return 0;
    if (sum&1){
        if (right < nums.size() - 1)
            return (1 + helper2(nums, m, sum + nums[right + 1] - nums[left], left + 1, right + 1)) % m;
        else return 1;
    }
    else {
        if (right < nums.size() - 1) 
            return helper2(nums, m, sum + nums[right + 1] - nums[left], left + 1, right + 1) % m;
        else return 0;
    }
}


int helper(vector<int>& nums, int &m, unsigned int index, int sum){
    if (index > nums.size()) return 0;
    return (helper2(nums, m, sum, 0, index - 1)%m + helper(nums, m, index + 1, sum + nums[index])%m)%m;
    
}

int oddSumSublist(vector<int>& nums, int m){
    if (nums.empty()) return 0;
    return helper(nums, m, 1, nums[0]);
}",0.9,1111111110,1
Recursion_14,1405513,2211170,"int countOddSubarrays(vector<int>& arr, int n, int sum, int cnt, int even, int odd) {
    if (n == 0) {
        return cnt;
    }

    sum += arr[n - 1]; // Add the current element to the prefix sum

    if (sum % 2 != 0) { // If the sum is odd
        odd++;
        cnt++;
        cnt += even; // Add the count of even-sum subarrays
    } else { // If the sum is even
        even++;
        cnt += odd; // Add the count of odd-sum subarrays
    }

    return countOddSubarrays(arr, n - 1, sum, cnt, even, odd);
}

int oddSumSublist(const vector<int>& nums, int m) {
    vector<int> arr = nums;
    int n = nums.size();
    int sum = 0, cnt = 0, even = 0, odd = 0;

    return countOddSubarrays(arr, n, sum, cnt, even, odd) % m;
}",1.0,1111111111,3
Recursion_14,1405881,2211367,"int countOddSublists(const vector<int>& nums, int start, int end, int currentSum) {
    if (start > end) {
        // Base case: end of recursion, no more elements to consider
        return currentSum % 2 == 1 ? 1 : 0;
    }

    // Include the current element in the sum
    int countWithCurrent = countOddSublists(nums, start + 1, end, currentSum + nums[start]);
    // Exclude the current element from the sum
    int countWithoutCurrent = countOddSublists(nums, start + 1, end, currentSum);

    return countWithCurrent + countWithoutCurrent;
}

// Recursive function to count odd sublists starting from all possible indices
int countOddFromAllIndices(const vector<int>& nums, int start, int end) {
    if (start > end) {
        // Base case: end of recursion, no more indices to consider
        return 0;
    }

    // Count odd sublists starting at the current index
    int count = countOddSublists(nums, start, end, 0);

    // Recursively count odd sublists starting from the next index
    int countFromNextIndex = countOddFromAllIndices(nums, start + 1, end);

    return count - countFromNextIndex;
}

// Wrapper function to start recursion from the first index
int oddSumSublist(const vector<int>& nums, int m) {
    int n = nums.size();
    return countOddFromAllIndices(nums, 0, n - 1)%m;
}",0.2,1100000000,5
Recursion_14,1406072,2013048,"void findSum(const vector<int>& nums, unsigned int i, long long currentSum, long long& count) {
    if (i >= nums.size()) {
        return;
    }
    currentSum += nums[i];
    if (currentSum % 2 != 0) {
        count++;
    }
    findSum(nums, i + 1, currentSum, count);
}

void SumSublist(const vector<int>& nums, unsigned int i, long long& count) {
    if (i >= nums.size()) {
        return;
    }
    long long currentSum = 0;
    findSum(nums, i, currentSum, count);
    SumSublist(nums, i + 1, count);
}

int oddSumSublist(const vector<int>& nums, int m) {
    long long count = 0;
    SumSublist(nums, 0, count);
    return count % m;
}",0.9,1111111110,5
Recursion_14,1407091,2212303,"int subSum(vector<int>& nums, size_t i, size_t size) {
    if (i >= nums.size()) return 0;
    if (size == 0) return 0;
    return (nums[i]%2 + subSum(nums, i + 1, size - 1))%2;
}

int helper(vector<int>& nums, size_t i, size_t size) {
   
    if (size > nums.size()) {
        return 0;
    }
    if (i >= nums.size() || i + size > nums.size()) return helper(nums, 0, size + 1);
    
    int sub = subSum(nums, i, size);

    int result = sub % 2;
    return result+ helper(nums, i + 1, size);
}
int oddSumSublist(vector<int>& nums, int m) {
    if (nums.empty()) return 0;
    return helper(nums, 0, 1) % m;
}",0.5,1111100000,5
Recursion_14,1408640,2210532,"int countOddSumSublists(vector<int>& nums, int m, int index, int currentSum) {
    int n=nums.size();
    if (index == n) {
        return (currentSum % 2 == 1) ? 1 : 0;
    }
    int includeCurrent = countOddSumSublists(nums, m, index + 1, currentSum + nums[index]);
    int excludeCurrent = countOddSumSublists(nums, m, index + 1, currentSum);
    return (includeCurrent + excludeCurrent) % m;
}
int oddSumSublist(vector<int>& nums, int m) {
    return countOddSumSublists(nums, m, 0, 0);
}",0.1,1000000000,4
Recursion_14,1409614, ,"int countOddSumSublists(vector<int>& nums, int m, int index, int currentSum) {
    int n=nums.size();
    if (index == n) {
        return (currentSum % 2 == 1) ? 1 : 0;
    }
    int includeCurrent = countOddSumSublists(nums, m, index + 1, currentSum + nums[index]);
    int excludeCurrent = countOddSumSublists(nums, m, index + 1, currentSum);

    return (includeCurrent + excludeCurrent) % m;
}
int oddSumSublist(vector<int>& nums, int m) {
    return countOddSumSublists(nums, m, 0, 0);
}",0.1,1000000000,4
Recursion_14,1409645, ,"int countOddSumSublists(vector<int>& nums, int m, int index, int currentSum) {
    int n=nums.size();
    if (index == n) {
        return (currentSum % 2 == 1) ? 1 : 0;
    }
    int includeCurrent = countOddSumSublists(nums, m, index + 1, currentSum + nums[index]);
    int excludeCurrent = countOddSumSublists(nums, m, index + 1, currentSum);

    return (includeCurrent + excludeCurrent) % m;
}
int oddSumSublist(vector<int>& nums, int m) {
    return countOddSumSublists(nums, m, 0, 0);
}",0.1,1000000000,4
Recursion_14,1409664,2211738,"// int helper(vector<int>& nums, int m, size_t i, int odd, int even) {
//     if (i==nums.size()) {
//         return 0;
//     }

//     int newOdd, newEven;
//     if (nums[i]%2==0) {
//         newOdd=odd;
//         newEven=even+1;
//     } else {
//         newOdd=even+1;
//         newEven=odd;
//     }
//     return (newOdd+helper(nums, m, i + 1, newOdd, newEven));
// }

// int oddSumSublist(vector<int>& nums, int m) {
//     return helper(nums, m, 0, 0, 0)%m;
// }
int helper(vector<int>& nums, vector<int>& temp, size_t i, int val){
    if(i < nums.size()){
        val = ((nums[i] + val)%2 + 2)%2;   
        temp[val]++;
        return helper(nums,temp,i+1,val);
    }
    return temp[0]*temp[1];
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    vector<int> temp {1,0};
    return helper(nums,temp,0,0)%m;
}",1.0,1111111111,6
Recursion_14,1411959,2211367,"void subs(int idx,vector<int>lst,vector<int>&nums,vector<vector<int>>&l,int N){
        if(idx>=N){
            l.push_back(lst);
            return ;
        }
        lst.push_back(nums[idx]);
        subs(idx+1,lst,nums,l,N);
        lst.pop_back();
        subs(idx+1,lst,nums,l,N);

    }
    vector<vector<int>> subsets(vector<int>& nums) {
        int N=nums.size();
        vector<int>lst;
        vector<vector<int>>l;
        subs(0,lst,nums,l,N);
        return l;
    }
int sumsubset(vector<int> s, int sum, int i){
    int n = s.size();
    if(i==n) return sum;
    sum += s[i];
    return sumsubset(s,sum,i+1);
}
int oddSumSublisthelper(vector<vector<int>>s,int count, int i){
    int n = s.size();
    if(i==n) return count-1;
    if((sumsubset(s[i],0,0))%2==1){
        count = count + 1;
    }
    return oddSumSublisthelper(s,count,i+1);
}
int oddSumSublist(vector<int>& nums, int m) {
    vector<vector<int>> s = subsets(nums);
    return oddSumSublisthelper(s,0,1)%m;
}",0.1,1000000000,5
Recursion_14,1417147,2212651,"void findOdd(vector<int> &nums, int &cnt, int &even, int &odd, int index) {
    int n = nums.size();
    if (index == n) return;

    if (nums[index] % 2 == 1) {
        swap(even, odd);
        odd++;
    } else {
        even++;
    }

    cnt += odd;
    index++;
    findOdd(nums, cnt, even, odd, index);
}
int oddSumSublist(vector<int>& nums, int m) {
    if (nums.empty()) return 0;
    int cnt = 0, even = 0, odd = 0, index = 0;
    findOdd(nums, cnt, even, odd, index);
    return cnt % m;
}",1.0,1111111111,3
Recursion_14,1418239,2212282,"int index = 0;
int ans   = 0;
int odd   = 0;
int even  = 0;
int sum   = 0;

int oddSumSublist(const vector<int>& nums,const int & m) {
    if(index == static_cast<int>(nums.size())) return ans%m;
    
    sum += nums[index++];
    if(sum % 2 == 0) {
        ans += odd;
        even++;
    }
    else {
        ans += 1 + even;
        odd ++;
    }
    
    return oddSumSublist(nums, m);
}",1.0,1111111111,3
Recursion_14,1418350,2252260,"void tmpCount(vector<int>& nums, int* tmp, int n, int i, int val){
    if(i>n-1)
        return;
    val = ((val+nums[i])%2+2)%2;
    tmp[val]++;
    tmpCount(nums, tmp, n, i+1, val);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int n = nums.size();
    int tmp[2] = {1,0};
    
    int result = 0, val=0;
    tmpCount(nums, tmp, n, 0, val);
    result = tmp[0]*tmp[1];
    return result%m;
}",1.0,1111111111,6
Recursion_14,1418891,2211821,"int Sum(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    return vec[start] + Sum(vec, start + 1, number - 1);
}
int countright(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    int sum = Sum(vec, start, number);
    if (sum % 2 == 1) return 1 + countright(vec, start + 1, number - 1); else return countright(vec, start + 1, number - 1);
}
int countleft(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    int sum = Sum(vec, start, number);
    if (sum % 2 == 1) return 1 + countright(vec, start + 1, number - 1) + countleft(vec, start, number - 1); else return countright(vec, start + 1, number - 1) + countleft(vec, start, number - 1);
}
int oddSumSublist(vector<int>& vec, int m) {
    int x = vec.size();
    int n = countleft(vec, 0, x) % m;
    return n;
}",0.7,1111111000,1
Recursion_14,1420821,2210535,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111,3
Recursion_14,1422146,2252260,"void tmpCount(vector<int>& nums, int* tmp, int n, int i, int val){
    if(i>n-1)
        return;
    val = ((val+nums[i])%2+2)%2;
    tmp[val]++;
    tmpCount(nums, tmp, n, i+1, val);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int n = nums.size();
    int tmp[2] = {1,0};
    
    int result = 0, val=0;
    tmpCount(nums, tmp, n, 0, val);
    result = tmp[0]*tmp[1];
    return result%m;
}",1.0,1111111111,6
Recursion_14,1423412,2213836,"void tmpCount(vector<int>& nums, int* tmp, int n, int i, int val) {
    if(i > n - 1) return;
    val = ((val + nums[i]) % 2 + 2) % 2;
    tmp[val]++;
    tmpCount(nums, tmp, n, i + 1, val);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int n = nums.size();
    int tmp[2] = {1,0};
    
    int result = 0; 
    int val = 0;
    tmpCount(nums, tmp, n, 0, val);
    result = tmp[0] * tmp[1];
    return result % m;
}",1.0,1111111111,6
Recursion_14,1423972,2213248,"int oddSumSublist(vector<int>& arr, int m, int index = 0, int currentSum = 0) {
    int size = arr.size();
    if (index == size) {
        // Base case: If we've reached the end of the list, check if the current sum is odd.
        return (currentSum % 2 == 1) ? 1 : 0;
    }

    // Include the current element in the sum and recurse.
    int includeCount = oddSumSublist(arr, m, index + 1, (currentSum + arr[index]) % m);

    // Exclude the current element from the sum and recurse.
    int excludeCount = oddSumSublist(arr, m, index + 1, currentSum);

    // Return the sum of counts 4 including and excluding the current element.
    return includeCount + excludeCount;
}",0.1,1000000000,4
Recursion_14,1425586,2212372,"void thesubodd(vector<int>& nums,int i,bool odd,int &count){
	int n=nums.size();
	if(i==n) return;
	if(nums[i]&1) odd=!odd;
	if(odd) count++;
	thesubodd(nums,i+1,odd,count); 
}
void solve(vector<int>& nums,int i,long long &ans,int &count){
    int n=nums.size();
    if(i==n) return;
    ans+=count;
    if(nums[i]&1) count=n-i-count;
    solve(nums,i+1,ans,count);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int odd=0,count=0;
    long long ans=0;
    thesubodd(nums,0,odd,count);
    solve(nums,0,ans,count);
    int kq=ans%m;
    return kq;
}",1.0,1111111111,5
Recursion_14,1427875,2210578,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111,3
Recursion_14,1428713,2212741,"int sum(vector<int>& nums, int i) {
	int size = nums.size();
	if (i >= size) return 0;
	return nums[i] + sum(nums, i + 1);
}
void count(vector<int>& nums, int left, int right, int sumi, int& realsum, int& cc) {
	if (right < 0) return;
	else if (left > right) {
		left = 0;
		right--;
		realsum -= nums[right + 1];
		if (realsum == 0) return;
		sumi = realsum;
		count(nums, left, right, sumi, realsum, cc);
	}
	else if (sumi % 2 == 1) {
		cc++;
		left++;
		count(nums, left, right, sumi - nums[left - 1], realsum, cc);
	}
	else {
		left++;
		count(nums, left, right, sumi - nums[left - 1], realsum, cc);
	}
}
int oddSumSublist(vector<int>& nums, int m) {
	// STUDENT ANSWER
	int gg = 0;
	int a = nums.size() - 1;
	int b = sum(nums, 0);
	int h = b;
	int cc = 0;
	count(nums, gg, a, b, h, cc);
	return cc % m;
}",0.6,1111110000,5
Recursion_14,1430523,2210103,"int oddSumSublistHelper(const vector<int>& nums, int start, int end, int currentSum, int m) {
    // Base case: when the end of the sublist is reached
    if (start > end) {
        // Check if the current sum is odd
        return (currentSum % 2 != 0) ? 1 : 0;
    }

    // Include the current element in the sum
    int includeCurrent = oddSumSublistHelper(nums, start + 1, end, (currentSum + nums[start]) % m, m);

    // Exclude the current element from the sum
    int excludeCurrent = oddSumSublistHelper(nums, start + 1, end, currentSum, m);

    // Return the total count of sublists with odd sums (modulo m)
    return (includeCurrent + excludeCurrent) % m;
}

int oddSumSublist(const vector<int>& nums, int m) {
    // Call the helper function with the initial indices and sum
    return oddSumSublistHelper(nums, 0, nums.size() - 1, 0, m);
}",0.1,1000000000,4
Recursion_14,1430793,2210458,"// Helper function to calculate odd sum sublists
int oddSumSublistHelper(vector<int>& nums, int index, int sum, int m) {
    // Base case: if we've reached the end of the array
    if(index == int(nums.size())) {
        // Check if the sum is odd
        return sum % 2;
    }

    // Recursive case: include the current number in the sum or not
    return (oddSumSublistHelper(nums, index + 1, (sum + nums[index]), m) 
            + oddSumSublistHelper(nums, index + 1, sum, m));
}

// Function to calculate odd sum sublists
int oddSumSublist(vector<int>& nums, int m) {
    return oddSumSublistHelper(nums, 0, 0, m) % m;
}",0.1,1000000000,2
Recursion_14,1431468,2252260,"void tmpCount(vector<int>& nums, int* tmp, int n, int i, int val){
    if(i>n-1)
        return;
    val = ((val+nums[i])%2+2)%2;
    tmp[val]++;
    tmpCount(nums, tmp, n, i+1, val);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int n = nums.size();
    int tmp[2] = {1,0};
    
    int result = 0, val=0;
    tmpCount(nums, tmp, n, 0, val);
    result = tmp[0]*tmp[1];
    return result%m;
}",1.0,1111111111,6
Recursion_14,1432122,1913560,"int oddSumSublistHelper(vector<int>& nums, int m, int index, int prefixSum, vector<int>& prefixSumFreq) {
    if (index == int(nums.size())) {
        return 0;
    }

    int prefixSumMod = ((prefixSum + nums[index]) % m + m) % m;

    int oddSumCount = prefixSumFreq[prefixSumMod];

    prefixSumFreq[prefixSumMod]++;

    int nextResult = oddSumSublistHelper(nums, m, index + 1, prefixSumMod, prefixSumFreq);

    prefixSumFreq[prefixSumMod]--;

    return (oddSumCount + nextResult) % m;
}

int oddSumSublist(vector<int>& nums, int m) {
    vector<int> prefixSumFreq(m, 0);
    prefixSumFreq[0] = 1;

    return oddSumSublistHelper(nums, m, 0, 0, prefixSumFreq);
}",0.1,1000000000,5
Recursion_14,1432176,2212741,"void oddSumSublistHelper(vector<int>& nums,int i,int *arr,int val){
    int length=nums.size();
    if(i>=length) return;
    val=(((val+nums[i])%2)+2)%2;
    arr[val]++;
    return oddSumSublistHelper(nums,i+1,arr,val);
}
int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int arr[2]={1,0};
    
    oddSumSublistHelper(nums,0,arr,0);
    return (arr[0]*arr[1])%m;
}",1.0,1111111111,6
Recursion_14,1432653,2212988,"int sum(vector<int>& nums, int i) {
	int size = nums.size();
	if (i >= size) return 0;
	return nums[i] + sum(nums, i + 1);
}
void count(vector<int>& nums, int left, int right, int sumi, int& realsum, int& cc) {
	if (right < 0) return;
	else if (left > right) {
		left = 0;
		right--;
		realsum -= nums[right + 1];
		if (realsum == 0) return;
		sumi = realsum;
		count(nums, left, right, sumi, realsum, cc);
	}
	else if (sumi % 2 == 1) {
		cc++;
		left++;
		count(nums, left, right, sumi - nums[left - 1], realsum, cc);
	}
	else {
		left++;
		count(nums, left, right, sumi - nums[left - 1], realsum, cc);
	}
}
int oddSumSublist(vector<int>& nums, int m) {
	// STUDENT ANSWER
	int gg = 0;
	int a = nums.size() - 1;
	int b = sum(nums, 0);
	int h = b;
	int cc = 0;
	count(nums, gg, a, b, h, cc);
	return cc % m;
}",0.6,1111110000,5
Recursion_14,1435031,2210034,"int countOddSublists(vector<int>& nums, int m,unsigned int index, int currentSum) {
    if (index == nums.size()) {
        return currentSum % 2 == 1 ? 1 : 0;
    }

    int includeCurrent = countOddSublists(nums, m, index + 1, currentSum + nums[index]);
    int excludeCurrent = countOddSublists(nums, m, index + 1, currentSum);

    return (includeCurrent + excludeCurrent) % m;
}

int oddSumSublist(vector<int>& nums, int m) {
    return countOddSublists(nums, m, 0, 0);
}",0.1,1000000000,4
Sorting_1,1454555,2212741,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    Node*tailtemp=tail;
    Node*prev=nullptr;
    Node*dummy=head;
    while(dummy!=tailtemp){
        while(dummy!=tailtemp){
            if(dummy->data>dummy->next->data){
                int temp=dummy->data;
                dummy->data=dummy->next->data;
                dummy->next->data=temp;
            }
            prev=dummy;
            dummy=dummy->next;
        }
        //headtemp=headtemp->next;
        tailtemp=prev;
        dummy=head;
        printList();
    }
}",1.0,1111111111,0
Sorting_1,1454641,2210458,"template <class T>
void SLinkedList<T>::bubbleSort()
{   
    if(head == nullptr) return;
    Node* i = head;
    bool exChange = 0;
    while(i->next != nullptr) {
        exChange = 0;
        Node* j = head;
        while(j->next != nullptr) {
            if(j->data > j->next->data)
                swap(j->data, j->next->data), exChange = 1;
            j = j->next;
        }
        if(exChange == 0) break;
        printList();
        i = i->next;
    }
}",0.7,1111110001,1
Sorting_1,1454676,2211738,"template <class T>

void SLinkedList<T>::bubbleSort()
{
    Node* temp;
    for(int i = 0; i < count-1; i++){
        temp = head;
        for(int j = 0; j < count-1; j++){
            if(temp != NULL && temp->next != NULL){
                if(temp->data >= temp->next->data){
                    int swap = temp->data;
                    temp->data = temp->next->data;
                    temp->next->data = swap;
                }
                temp = temp->next;
            }
        }
        printList();
    }
}",1.0,1111111111,2
Sorting_1,1454689,2110501,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    Node* cur = NULL;
    for (int i = 0; i < this->count - 1; i++)
    {
        cur = this->head;
        for (int k = i; k < this->count - 1; k++)
        {
            if (cur->data >= cur->next->data)
            {
                int temp = cur->data;
                cur->data = cur->next->data;
                cur->next->data = temp;
                cur = cur->next;
            }
            else
            {
                cur = cur->next;
            }
        }
        this->printList();
    }
}",1.0,1111111111,2
Sorting_1,1455058,2210103,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    Node*tailtemp=tail;
    Node*prev=nullptr;
    Node*dummy=head;
    while(dummy!=tailtemp){
        while(dummy!=tailtemp){
            if(dummy->data>dummy->next->data){
                int temp=dummy->data;
                dummy->data=dummy->next->data;
                dummy->next->data=temp;
            }
            prev=dummy;
            dummy=dummy->next;
        }
        //headtemp=headtemp->next;
        tailtemp=prev;
        dummy=head;
        printList();
    }
}",1.0,1111111111,0
Sorting_1,1455152,2212282,"template <class T>
void SLinkedList<T>::bubbleSort() {
    if (count <= 1) {
        return;  
    }
    Node* current;
    count=count-1;
    do {
        
        current = head;

        while (current->next != nullptr) {
            if (current->data > current->next->data) {
                
                T temp = current->data;
                current->data = current->next->data;
                current->next->data = temp;
               
            }
            current = current->next;
        }
        printList();  
    } while (--count);
}",1.0,1111111111,3
Sorting_1,1455336,2211170,"template <class T>
void SLinkedList<T>::bubbleSort() {
//! Khởi đầu, nếu linked list rỗng thì return
    if(head == NULL) return;

//! Khởi tạo hai node i và j để duyệt linked list
   Node* i = head;
    while(i->next){
        Node* j = head;
        while(j->next){
//! Nếu giá trị của node j lớn hơn giá trị của node liền sau nó thì swap hai node đó
            if(j->data > j->next->data){
                swap(j->data,j->next->data);
            }
            j = j ->next;
        }
 //! In ra linked list hiện tại
        
    this->printList();
     i = i->next;
    }
}",1.0,1111111111,1
Sorting_1,1456213,2213298,"template <class T>
void SLinkedList<T>::bubbleSort()
{ 
    if (!count) return;
    if (count == 1) {
        printList();
        return;
    }
    int current = 0;
    bool flag = 1;
    while (current < count - 1 && flag) {
        flag = 0;
        Node *pNew = head;
        int walker = current;
        while (walker < count - 1) {
            if (pNew->data > pNew->next->data) {
                flag = 1;
                int temp = pNew->next->data;
                pNew->next->data = pNew->data;
                pNew->data = temp;
            }
            pNew = pNew->next;   
            walker++;
        }
        printList();
        current++;
    }
}",0.6,1101110001,4
Sorting_1,1487493,2210997,"template <class T>
void SLinkedList<T>::bubbleSort() {
    if (count <= 1)
        return; // Nothing to sort for 0 or 1 element.

    int cur = count - 1;
    Node *current = head;
    while (cur > 0) {
        int step = 0;
        current = head;
        while (step < cur) {
            if (current->data > current->next->data) {
                T temp = current->data;
                current->data = current->next->data;
                current->next->data = temp;
            }
            current = current->next;
            step++;
        }
        cur--;
        this->printList();
    }
}",1.0,1111111111,4
Sorting_1,1489026,2252260,"template <class T>
void SLinkedList<T>::bubbleSort() {
    int curr = count-1;
    Node* node;
    while(curr>0){
        int step = 0;
        node = head;
        while(step < curr){
            if(node->data > node->next->data) {
            T tmp = node->data;
            node->data = node->next->data;
            node->next->data = tmp;
            }
            step++;
            node = node->next;
        }
        curr--;
        this->printList();
    }
}",1.0,1111111111,4
Sorting_1,1494319,2213250,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    int n = this->size();
    if(n==0 || n==1) return;
    for(int i=0 ; i<n-1;i++){
        Node* temp = head;
        //bool check = true;
        for(int j=0 ; j<n-i-1;j++){
            if(temp->data > temp->next->data ){
            swap(temp->data , temp->next->data);
            //check =false;
            }
            temp=temp->next;
        }
        //if(check) break;
        this->printList();
    }
}",1.0,1111111111,2
Sorting_1,1498567,2210055,"template <class T>
void SLinkedList<T>::bubbleSort()
{
}",0.1,1000000000,5
Sorting_1,1500217,2210532,"template <class T>
void SLinkedList<T>::bubbleSort() {
    if (this->size() == 1 || this->size() == 0) {
        return;
    }
    Node *h = head;
    bool swapped = true;
    for(int i=0;i<=this->size();i++){
        h= head;
        swapped = false;
        for(int j=0;j< this->size() - i - 1;j++){
            Node *p1 = h;
            Node *p2 = p1->next;
            if(p1->data > p2->data){
                T tmp = p1->data;
                p1->data = p2->data;
                p2->data = tmp;
                swapped = 1;
            }
            h = h->next;
        }
        if(swapped == false)break;
        h = head;
        printList();
    }
}",0.7,1111110001,2
Sorting_1,1503067,2212303,"template <class T>
void SLinkedList<T>::bubbleSort() {
    if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        return;
    }

    bool swapped;
    Node* current;
    Node* lastSorted = nullptr;

    do {
        swapped = false;
        current = head;
        Node* largest=current;
        while(current->next!=lastSorted){
            if(current->data > largest->data){
                largest=current;
                
            } current=current->next;
        }
        //cout<<largest->data<<endl;
        
        current=largest;
        while (current->next != lastSorted && current->next!=nullptr) {
            if (current->data > current->next->data) {
                // Swap the data of the current and next nodes
                T temp = current->data;
                current->data = current->next->data;
                current->next->data = temp;
                swapped = true;
                lastSorted = current->next;
            }
            current = current->next;
           
        }
        if(swapped) printList();
        //printList(); // Print the list after each pass to check progress
    } while (swapped);
}",0.7,1111110001,3
Sorting_1,1503586, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
       if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        return;
    }

    bool swapped;
    Node* current;
    Node* lastSorted = nullptr;

    do {
        swapped = false;
        current = head;
        Node* largest=current;
        while(current->next!=lastSorted){
            if(current->data >= largest->data){
                largest=current;
                
            } current=current->next;
        }
        //cout<<largest->data<<endl;
        
        current=largest;
        while (current->next != lastSorted && current->next!=nullptr) {
            if (current->data > current->next->data) {
                // Swap the data of the current and next nodes
                T temp = current->data;
                current->data = current->next->data;
                current->next->data = temp;
                swapped = true;
                lastSorted = current->next;
            }
            current = current->next;
           
        }
        if(swapped) printList();
        //printList(); // Print the list after each pass to check progress
    } while (swapped);
}",0.7,1111110001,3
Sorting_1,1503595, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
 if (count <= 1) {
     // No need to sort if there are 0 or 1 elements
     return;
 }

 bool swapped;
 Node* current;
 Node* lastSorted = nullptr;
 
bool unfinish;

 do {
     swapped = false;
     //unfinish = false;
     current = head;
     Node* largest = head;
     while (current->next != lastSorted) {
         if (current->data >= largest->data) {
             largest = current;

         } current = current->next;
     }
     
     //cout << largest << endl;
     current = largest;
     while (current->next != lastSorted && current != tail) {
         //Node* next = current->next;
         if (current->data > current->next->data) {
             // Swap the data of the current and next nodes
             T temp = current->data;
             //cout << current->next->data << endl;
             current->data = current->next->data;
             
             current->next->data = temp;
             swapped = true;
             //lastSorted = current;
             
         }
         current = current->next;
         
     }
     lastSorted = current;
     //cout << lastSorted->data << endl;
     //cout << lastSorted->data << endl;
     if (swapped) printList();
     //printList(); // Print the list after each pass to check progress
     unfinish = false;
     Node* temp = head;
     while (temp != tail) {
         if (temp->data > temp->next->data)
             unfinish = true;
         
         temp = temp->next;
         if(unfinish) break;
     }
 } while (unfinish);
}",0.7,1111110001,3
Sorting_1,1505224,2210535,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    Node* tailtemp = tail;
    Node* prev = nullptr;
    Node* temp1 = head;
    while (temp1 != tailtemp) {
        while (temp1 != tailtemp) {
            if (temp1->data > temp1->next->data) {
                int temp = temp1->data;
                temp1->data = temp1->next->data;
                temp1->next->data = temp;
            }
            prev = temp1;
            temp1 = temp1->next;
        }
        tailtemp = prev;
        temp1 = head;
        printList();
    }
}",1.0,1111111111,0
Sorting_1,1509048,2210200,"// template <class T>
// void SLinkedList<T>::bubbleSort()
// {
//     bool flag = false;
//     Node *temp = head;
//     int current = count - 1;
//     while(current >= 0 && !flag){
//         temp = head;
//         int step = 0;
//         flag = true;
//         while(step < current){
//             if(temp->next && temp->data > temp->next->data){
//                 T t = temp->data;
//                 temp->data = temp->next->data;
//                 temp->next->data = t;
//                 flag = false;
//             }
//             ++step;
//             temp = temp->next;
//         }
//         --current;
//         if(!flag) printList();
//         else{
//             return;
//         }
//     }
// }

template <class T>
void SLinkedList<T>::bubbleSort()
{   
    // printList();
    if(count==0) return;
    if(count<=1) {
        return;
    }
    // if(count==2) {
    //     if(head->data>head->next->data){
    //         T temp=head->data;
    //             head->data=head->next->data;
    //             head->next->data=temp;
    //     }
    //     printList();
    //     return;
    // }
    
    for(int i=1;i<count;++i){
        bool flag=0;
        Node* pj=head;
        Node* pNj=head->next;
        for(int j=0;j<count-i;j++){
            if(pj->data>pNj->data){
                T temp=pj->data;
                pj->data=pNj->data;
                pNj->data=temp;
                flag=1;
            }
           if(pNj){
               pNj=pNj->next;
               pj=pj->next;
           }
        }  
        
        if(!flag) return;
        printList();
    }
}",0.7,1111110001,2
Sorting_1,1511215,2211821,"template <class T>
void SLinkedList<T>::bubbleSort(){
    Node* left = head;
    Node* right = head->next;
    for (int i = 0; i < count - 1; i++) {
        left = head;
        right = left->next;
        for (int j = 1; j < count; j++) {
            if (left->data > right->data) {
                int temp = left->data;
                left->data = right->data;
                right->data = temp;
            }
            left = left->next;
            right = right->next;
        }
        this->printList();
    }
}",1.0,1111111111,2
Sorting_1,1512000,2212372,"template <class T>
 void SLinkedList<T>::bubbleSort()
 {
     for (int i = 0; i < count - 1; i++) {
        Node* current = head;
        Node* nextNode = head->next;

        for (int j = 0; j < count - i - 1; j++) {
            if (current->data > nextNode->data) {
             T temp = current->data;
             current->data = nextNode->data;
               nextNode->data = temp;
             }
             current = nextNode;
             nextNode = nextNode->next;
         }

         printList(); 
     }
 }",1.0,1111111111,6
Sorting_1,1512030,2212935,"template <class T>
void SLinkedList<T>::bubbleSort()
{
     for (int i = 0; i < count - 1; i++){
        for (int j = 0; j < count - i; j++){
 Node *temp1 = head;
 Node *temp2 = head;
 for (int k = 0; k < j - 1; k++){
 temp1 = temp1->next;
 temp2 = temp2->next;
 }
 temp2 = temp2->next;
 if (temp1->data > temp2->data)
 {
 T a = temp1->data;
 temp1->data = temp2->data;
 temp2->data = a;
 }
 }
 printList();
 }
}",1.0,1111111111,2
Sorting_1,1512864,2210200,"// template <class T>
// void SLinkedList<T>::bubbleSort()
// {
//     bool flag = false;
//     Node *temp = head;
//     int current = count - 1;
//     while(current > 0){
//         temp = head;
//         int step = 0;
//         flag = true;
//         while(step < current){
//             if(temp->next && temp->data > temp->next->data){
//                 T t = temp->data;
//                 temp->data = temp->next->data;
//                 temp->next->data = t;
//                 flag = false;
//             }
//             ++step;
//             temp = temp->next;
//         }
//         --current;
//         if(!flag) printList();
//         else{
//             return;
//         }
//     }
// }

template <class T>
void SLinkedList<T>::bubbleSort()
{
    for(int i = 0; i < count - 1; i++){
        Node *cur = head;
        Node *cur_next = head->next;
        for(int j = 0; j < count - i - 1; j++){
            if(cur->data > cur_next->data){
                T temp = cur->data;
                cur->data = cur_next->data;
                cur_next->data = temp;
            }
            cur = cur->next;
            cur_next = cur_next->next;
        }
        printList();
    }
}",1.0,1111111111,6
Sorting_1,1517339,2213035,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    for (int i = 0; i < count-1; i++)
    {
        Node* current = head;
        Node* nextNode = head->next;
        for (int j = i; j < count-1; j++)
        {
            if (current->data > nextNode->data)
            {
                T a = current->data;
                current->data = nextNode->data;
                nextNode->data = a;
            }
            current = nextNode;
            nextNode = nextNode->next;   
        }
        printList();
    }  
}",1.0,1111111111,6
Sorting_1,1517888,2212651,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    Node*tailtemp=tail;
    Node*prev=nullptr;
    Node*dummy=head;
    while(dummy!=tailtemp){
        while(dummy!=tailtemp){
            if(dummy->data>dummy->next->data){
                int temp=dummy->data;
                dummy->data=dummy->next->data;
                dummy->next->data=temp;
            }
            prev=dummy;
            dummy=dummy->next;
        }
        //headtemp=headtemp->next;
        tailtemp=prev;
        dummy=head;
        printList();
    }
}",1.0,1111111111,0
Sorting_1,1517902,2212303,"template <class T>
void SLinkedList<T>::bubbleSort()
{
      if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        return;
    }

    bool swapped;
    Node* current;
    Node* lastSorted = nullptr;

    do {
        swapped = false;
        current = head;
        Node* largest=current;
        while(current->next!=lastSorted){
            if(current->data >= largest->data){
                largest=current;
                
            } current=current->next;
        }
        //cout<<largest->data<<endl;
        
        current=largest;
        while (current->next != lastSorted && current->next!=nullptr) {
            if (current->data > current->next->data) {
                // Swap the data of the current and next nodes
                T temp = current->data;
                current->data = current->next->data;
                current->next->data = temp;
                swapped = true;
                lastSorted = current->next;
            }
            current = current->next;
           
        }
        if(swapped) printList();
        //printList(); // Print the list after each pass to check progress
    } while (swapped);
}",0.7,1111110001,3
Sorting_1,1517939, ,"template <class T>
void SLinkedList<T>::bubbleSort() {
         if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        return;
    }

    //bool swapped;
    //Node* temp = nullptr;
    Node* lastSorted=nullptr;
    bool unfinish=true;
    do {
        //swapped = false;
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                //swapped=true;
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        /*if (swapped)*/ printList();
        current=head;
        unfinish=false;
        while(current!=tail){
            if(current->data > current->next->data){
                unfinish=true;
                break;
               
            }
            current=current->next;
        }
    } while (unfinish);
}",0.7,1111110001,3
Sorting_1,1522528, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        return;
    }

    bool swapped;
    //Node* temp = nullptr;
    Node* lastSorted=nullptr;
    bool unfinish=true;
    do {
        swapped = false;
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                swapped=true;
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        if (swapped) printList();
        current=head;
        unfinish=false;
        while(current!=tail){
            if(current->data > current->next->data){
                unfinish=true;
                break;
               
            }
            current=current->next;
        }
    } while (unfinish);
}",0.7,1111110001,3
Sorting_1,1522540, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        return;
    }
    int size=count;

    //bool swapped;
    //Node* temp = nullptr;
    Node* lastSorted=nullptr;
    //bool unfinish=true;
    do {
        //swapped = false;
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                //swapped=true;
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        current=head;
        //unfinish=false;
        /*while(current!=tail){
            if(current->data > current->next->data){
                unfinish=true;
                break;
               
            }
            current=current->next;
        }*/
        size--;
    } while (size>1);
}",0.9,1111111011,3
Sorting_1,1522594, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        if(count==1) printList();
        return;
    }
    int size=count;

    Node* lastSorted=nullptr;
    
    do {
        
        Node* current = head;
      
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        current=head;
        
        size--;
    } while (size>1);
}",0.8,1101111011,3
Sorting_1,1523033, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
}",0.1,1000000000,5
Sorting_1,1523037, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
}",0.1,1000000000,5
Sorting_1,1523078, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
            if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        if(count==1 && count==0) printList();
        return;
    }

    
    Node* lastSorted=nullptr;
    int size=count;
    do {
        
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        
        size--;
    } while (size>1);
}",0.9,1111111011,3
Sorting_1,1523103, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
            if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        if(count==1 && count==0) printList();
        return;
    }

    
    Node* lastSorted=nullptr;
    int size=count;
    do {
        
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        
        size--;
    } while (size>1);
}",0.9,1111111011,3
Sorting_1,1523135, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
            if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        if(count==1 && count==0) printList();
        return;
    }

    
    Node* lastSorted=nullptr;
    int size=count;
    do {
        
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        
        size--;
    } while (size>1);
}",0.9,1111111011,3
Sorting_1,1523157, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
}",0.1,1000000000,5
Sorting_1,1523173, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
            if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        if(count==1 && count==0) printList();
        return;
    }

    
    Node* lastSorted=nullptr;
    int size=count;
    do {
        
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        
        size--;
    } while (size>1);
}",0.9,1111111011,3
Sorting_1,1523189, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
            if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        if(count==1) printList();
        return;
    }

    
    Node* lastSorted=nullptr;
    int size=count;
    do {
        
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        
        size--;
    } while (size>1);
}",0.8,1101111011,3
Sorting_1,1523192, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
            if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        //if(count==1 && count==0) printList();
        return;
    }

    
    Node* lastSorted=nullptr;
    int size=count;
    do {
        
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        
        size--;
    } while (size>1);
}",0.9,1111111011,3
Sorting_1,1523197, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
            if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        //if(count==1 && count==0) printList();
        return;
    }

    
    Node* lastSorted=nullptr;
    int size=count;
    do {
        
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        
        size--;
    } while (size>1);
}",0.9,1111111011,3
Sorting_1,1523218, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
}",0.1,1000000000,5
Sorting_1,1523221, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
}",0.1,1000000000,5
Sorting_1,1523229, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
            if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        //if(count==1 && count==0) printList();
        return;
    }

    
    Node* lastSorted=nullptr;
    int size=count;
    do {
        
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        
        size--;
    } while (size>1);
}",0.9,1111111011,3
Sorting_1,1523244, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
            if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        //if(count==1 && count==0) printList();
        return;
    }

    
    Node* lastSorted=nullptr;
    int size=count;
    do {
        
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        
        size--;
    } while (size>1);
}",0.9,1111111011,3
Sorting_1,1523248, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
}",0.1,1000000000,5
Sorting_1,1523252, ,"template <class T>
void SLinkedList<T>::bubbleSort()
{
            if (count <= 1) {
        // No need to sort if there are 0 or 1 elements
        //if(count==1 && count==0) printList();
        return;
    }

    
    Node* lastSorted=nullptr;
    int size=count;
    do {
        
        Node* current = head;
       // Node* prev = nullptr;
        Node* largest=head;
        while(current!=lastSorted){
            if(current->data>=largest->data){
                largest=current;
            }
            current=current->next;
        }
        //prev=largest;
        current = largest->next;
        while (/*current != lastSorted &&*/ current!=nullptr) {
            if(current->data<largest->data){
                T temp=current->data;
                current->data=largest->data;
                largest->data=temp;
                largest=current;
                
            } else break;

            //prev = current;
            current = current->next;
        }

        // Set the last checked node as the new 'temp'
        lastSorted=largest;

        // Print the list after each pass to check progress
        printList();
        
        size--;
    } while (size>1);
}",0.9,1111111011,3
Sorting_1,1525053,2211878,"template <class T>
void SLinkedList<T>::bubbleSort()
{   
//! Khởi đầu, nếu linked list rỗng thì return
    if(head == NULL) return;

//! Khởi tạo hai node i và j để duyệt linked list
   Node* i = head;
    while(i->next){
        Node* j = head;
        while(j->next){
//! Nếu giá trị của node j lớn hơn giá trị của node liền sau nó thì swap hai node đó
            if(j->data > j->next->data){
                swap(j->data,j->next->data);
            }
            j = j ->next;
        }
 //! In ra linked list hiện tại
        
    this->printList();
     i = i->next;
    }
}",1.0,1111111111,1
Sorting_1,1525234,2211367,"template <class T>
void SLinkedList<T>::bubbleSort()
{  if(head == NULL) return;

//! Khởi tạo hai node i và j để duyệt linked list
   Node* i = head;
    while(i->next){
        Node* j = head;
        while(j->next){
//! Nếu giá trị của node j lớn hơn giá trị của node liền sau nó thì swap hai node đó
            if(j->data > j->next->data){
                swap(j->data,j->next->data);
            }
            j = j ->next;
        }
 //! In ra linked list hiện tại
        
    this->printList();
     i = i->next;
    }
}",1.0,1111111111,1
Sorting_1,1525476,1810839,"template <class T>
void SLinkedList<T>::bubbleSort()
{
}",0.1,1000000000,5
Sorting_1,1526841,2013048,"template <class T>
void SLinkedList<T>::bubbleSort()
{   
//! Khởi đầu, nếu linked list rỗng thì return
    if(head == NULL) return;

//! Khởi tạo hai node i và j để duyệt linked list
   Node* i = head;
    while(i->next){
        Node* j = head;
        while(j->next){
//! Nếu giá trị của node j lớn hơn giá trị của node liền sau nó thì swap hai node đó
            if(j->data > j->next->data){
                swap(j->data,j->next->data);
            }
            j = j ->next;
        }
 //! In ra linked list hiện tại
        
    this->printList();
     i = i->next;
    }
}",1.0,1111111111,1
Sorting_1,1527587,2210578,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    Node* tailtemp = tail;
    Node* prev = nullptr;
    Node* temp1 = head;
    while (temp1 != tailtemp) {
        while (temp1 != tailtemp) {
            if (temp1->data > temp1->next->data) {
                int temp = temp1->data;
                temp1->data = temp1->next->data;
                temp1->next->data = temp;
            }
            prev = temp1;
            temp1 = temp1->next;
        }
        tailtemp = prev;
        temp1 = head;
        printList();
    }
}",1.0,1111111111,0
Sorting_1,1528024,2213836,"template <class T>
void SLinkedList<T>::bubbleSort()
{   
//! Khởi đầu, nếu linked list rỗng thì return
    if(head == NULL) return;

//! Khởi tạo hai node i và j để duyệt linked list
   Node* i = head;
    while(i->next){
        Node* j = head;
        while(j->next){
//! Nếu giá trị của node j lớn hơn giá trị của node liền sau nó thì swap hai node đó
            if(j->data > j->next->data){
                swap(j->data,j->next->data);
            }
            j = j ->next;
        }
 //! In ra linked list hiện tại
        
    this->printList();
     i = i->next;
    }
}",1.0,1111111111,1
Sorting_1,1528923,1912532,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    for (int i = 0; i < count - 1; i++)
    {
        for (int j = 0; j < count - i; j++)
        {
            Node *temp1 = head;
            Node *temp2 = head;
            for (int k = 0; k < j - 1; k++)
            {
                temp1 = temp1->next;
                temp2 = temp2->next;
            }
            temp2 = temp2->next;
            if (temp1->data > temp2->data)
            {
                T a = temp1->data;
                temp1->data = temp2->data;
                temp2->data = a;
            }
        }
        printList();
    }
}",1.0,1111111111,2
Sorting_1,1529292,2211667,"template <class T>
void SLinkedList<T>::bubbleSort()
{
     if (head == nullptr || head->next == nullptr) {
        return; 
    }
    Node* end = nullptr;
    bool swapped;
    while (swapped){
        swapped = false;
        Node* current = head;
        while (current->next != end) {
            if (current->data > current->next->data) {
                T temp = current->data;
                current->data = current->next->data;
                current->next->data = temp;
                swapped = true;
            }
            current = current->next;
        }
        if(swapped){
        printList();
        }
        end = current;
    }
}",0.7,1111110001,4
Sorting_1,1530051,2211876,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    bool swap = false;
    while (true){
        swap = false;
        for(Node *node=head;node->next!=NULL;node=node->next){
            T curData = node->data;
            T nextData = node->next->data;
            if(curData>nextData){
                swap = true;
                node->data = nextData;
                node->next->data = curData;
            }
        }
        if(!swap) return;
        printList();
    }
}",0.7,1111110001,4
Sorting_1,1531201,2210535,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    Node* tailtemp = tail;
    Node* prev = nullptr;
    Node* temp1 = head;
    while (temp1 != tailtemp) {
        while (temp1 != tailtemp) {
            if (temp1->data > temp1->next->data) {
                int temp = temp1->data;
                temp1->data = temp1->next->data;
                temp1->next->data = temp;
            }
            prev = temp1;
            temp1 = temp1->next;
        }
        tailtemp = prev;
        temp1 = head;
        printList();
    }
}",1.0,1111111111,0
Sorting_1,1532135,2210034,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    if (count <= 1)
    {
        return;
    }
    for (int i = count - 1; i >= 1; --i)
    {
        bool isSorted = true;
        auto tmp = head;
        int j = 0;
        if (tmp -> data > tmp -> next -> data)
        {
            auto i2 = tmp -> next -> next;
            head = tmp -> next;
            head -> next = tmp;
            tmp -> next = i2;
            tmp = head; 
            if (count == 2) tail = tmp -> next;
            isSorted = false;

        }
        for (; j < i - 1; ++j, tmp = tmp -> next) 
        {
            if (tmp -> next -> data > tmp -> next -> next -> data)
            {
                if (j == count - 3) tail = tmp -> next;
                auto tmpNext = tmp -> next -> next;
                tmp -> next -> next = tmpNext -> next;
                tmpNext -> next = tmp -> next;
                tmp -> next = tmpNext;
                isSorted = false;
            }
        }
        if (isSorted) return;
        printList();
    }

}",0.7,1111110001,2
Sorting_1,1532907,2212499,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    if(head == NULL) return;

//! Khởi tạo hai node i và j để duyệt linked list
   Node* i = head;
    while(i->next){
        Node* j = head;
        while(j->next){
//! Nếu giá trị của node j lớn hơn giá trị của node liền sau nó thì swap hai node đó
            if(j->data > j->next->data){
                swap(j->data,j->next->data);
            }
            j = j ->next;
        }
 //! In ra linked list hiện tại
        
    this->printList();
     i = i->next;
    }
}",1.0,1111111111,1
Sorting_1,1532935,2210532,"template <class T>
void SLinkedList<T>::bubbleSort() {
    if (count <= 1) {
        // Nothing to sort if the list has 0 or 1 element
        return;
    }
    Node *h;bool swapped;;
    for(int i=0;i<=count;i++){
        h= head;
        swapped = false;
        for(int j=0;j< count - i - 1;j++){
            Node *p1 = h;
            Node *p2 = p1->next;
            if(p1->data > p2->data){
                T tmp = p1->data;
                p1->data = p2->data;
                p2->data = tmp;
                swapped = 1;
            }
            h = h->next;
        }
        if(swapped == false)break;
        printList();
    }
}",0.7,1111110001,2
Sorting_1,1533249,1912532,"template <class T>
void SLinkedList<T>::bubbleSort()
{   
    for (int i = 0; i < count - 1; i++)
 {
 for (int j = 0; j < count - i; j++)
 {
 Node *temp1 = head;
 Node *temp2 = head;
 for (int k = 0; k < j - 1; k++)
 {
 temp1 = temp1->next;
 temp2 = temp2->next;
 }
 temp2 = temp2->next;
 if (temp1->data > temp2->data)
 {
 T a = temp1->data;
 temp1->data = temp2->data;
 temp2->data = a;
 }
 }
 printList();
 }
}",1.0,1111111111,2
Sorting_1,1533851,2213248,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    int n = this->size();
    if(n==0 || n==1) return;
    for(int i=0 ; i<n-1;i++){
        Node* temp = head;
        //bool check = true;
        for(int j=0 ; j<n-i-1;j++){
            if(temp->data > temp->next->data ){
            swap(temp->data , temp->next->data);
            //check =false;
            }
            temp=temp->next;
        }
        //if(check) break;
        this->printList();
    }
}",1.0,1111111111,2
Sorting_1,1534953,2210034,"template <class T>
void SLinkedList<T>::bubbleSort()
{
    if (count <= 1)
    {
        return;
    }
    for (int i = count - 1; i >= 1; --i)
    {
        bool isSorted = true;
        auto tmp = head;
        int j = 0;
        if (tmp -> data > tmp -> next -> data)
        {
            auto i2 = tmp -> next -> next;
            head = tmp -> next;
            head -> next = tmp;
            tmp -> next = i2;
            tmp = head; 
            if (count == 2) tail = tmp -> next;
            isSorted = false;

        }
        for (; j < i - 1; ++j, tmp = tmp -> next) 
        {
            if (tmp -> next -> data > tmp -> next -> next -> data)
            {
                if (j == count - 3) tail = tmp -> next;
                auto tmpNext = tmp -> next -> next;
                tmp -> next -> next = tmpNext -> next;
                tmpNext -> next = tmp -> next;
                tmp -> next = tmpNext;
                isSorted = false;
            }
        }
        if (isSorted) return;
        printList();
    }

}",0.7,1111110001,2
Sorting_1,1535498,2112585,"template <class T>
void SLinkedList<T>::bubbleSort()
{
  if (head == nullptr || head->next == nullptr) {
        return; // List is already sorted or empty
    }

    bool swapped;
    do {
        swapped = false;
        Node* prev = nullptr;
        Node* curr = head;
        Node* next = head->next;

        while (next != nullptr) {
            if (curr->data > next->data) {
                if (prev != nullptr) {
                    prev->next = next;
                } else {
                    head = next;
                }
                curr->next = next->next;
                next->next = curr;
                prev = next;
                next = curr->next;
                swapped = true;
            } else {
                prev = curr;
                curr = next;
                next = next->next;
            }
        }
    } while (swapped);
}",0.1,1000000000,3
Sorting_1,1536587,2211170,"template <class T>
void SLinkedList<T>::bubbleSort()
{  if(head == NULL) return;

//! Khởi tạo hai node i và j để duyệt linked list
   Node* i = head;
    while(i->next){
        Node* j = head;
        while(j->next){
//! Nếu giá trị của node j lớn hơn giá trị của node liền sau nó thì swap hai node đó
            if(j->data > j->next->data){
                swap(j->data,j->next->data);
            }
            j = j ->next;
        }
 //! In ra linked list hiện tại
        
    this->printList();
     i = i->next;
    }
}
";1.0;1111111111;1
Sorting(part_2)_3,1532492,2212651,"pair<int,int> findMaxValueInMap(map<int, int> &a) {
    auto it = a.begin();
    pair<int, int> res = { it->first,it->second };
    for (; it != a.end(); it++) {
        if (res.second < it->second) {
            res = { it->first,it->second };
        }
    }
    return res;
}
int flag(int n, int m, vector<int> A, vector<int> B) {
    //TODO
    map<int, int> a;
    for (int i = 0; i < n; i++) {
        a[A[i]]++;
    }
    for (int i = 0; i < m; i++) {
        a[B[i]]++;
    }
    int cnt = 0;
    int res = 0;
    while (cnt < n) {
        auto it = findMaxValueInMap(a);
        cnt += it.second;
        a.erase(it.first);
        res++;
    }
    return res;
}",1.0,1111111111,0
Sorting(part_2)_3,1532665,2213298,"int flag(int n, int m, vector<int> A, vector<int> B) {
    int L1[256] = {0};
    int L2[256] = {0};
    int L3[256] = {0};
    int max = 0;
    for (int i = 0; i < n; i++) L1[A[i]]++;
    for (int i = 0; i < 256; i++) max += L1[i];
    for (int i = 0; i < m; i++) L2[B[i]]++;
    for (int i = 0; i < 256; i++) L3[i] = L1[i] + L2[i];
    sort(L3, L3 + 256);
    int sum = 0;
    int count = 0;
    for (int i = 255; sum < max; i--) { sum += L3[i]; count++; }
    return count;
}",1.0,1111111111,1
Sorting(part_2)_3,1532680,2212303,"int findsmallest(std::vector<int> A, int con) {
    int ans = -1;
    int current;
    bool flag = false;
    int size = A.size();
    for (int i = 0; i <size; i++) {
        if (!flag) {
            if (A[i] != 0 && i != con) {
                current = A[i];
                ans = i;
                flag = true;
            }
        } else if (A[i] < current && A[i] != 0 && i != con) {
            current = A[i];
            ans = i;
        }
    }
    return ans;
}

int countUnique(std::vector<int> A) {
    int ans = 0;
    int size = A.size();
    for (int i = 0; i < size; i++) {
        if (A[i] != 0) ans++;
    }
    return ans;
}

int flag(int n, int m, std::vector<int> A, std::vector<int> B) {
    if (A.size() == 1) return 1;
    std::vector<int> color(256, 0);
    
    for (int i = 0; i < n; i++) {
        color[A[i]]++;
    }
    
    int unique = countUnique(color);
    if (unique == 1) return 1;
    int count=0;
    sort(B.begin(), B.end());
    for (int i = 0; i < m; i++) {
           if(B[i]>0 ) {count++; color[B[i]]++;}
            
            //unique=min(unique, countUnique(color));
    }
    while(count>0){
        int j = findsmallest(color, -1);
        while(color[j]>0 && count>0){
            color[j]--;
            count--;
        }
    }
    return  countUnique(color);
}",1.0,1111111111,2
Sorting(part_2)_3,1532742,2210535,"//Helping functions goes here
void merge(vector<int>& vt, int left, int mid, int right)
{
    int n1 = mid - left + 1;
    int n2 = right - mid;
    int* a = new int[n1];
    int* b = new int[n2];
    for (int i = 0; i < n1; i++)
    {
        a[i] = vt[left + i];
    }
    for (int i = 0; i < n2; i++)
    {
        b[i] = vt[mid + i + 1];
    }
    int i = 0, j = 0, k = 0;
    while (i < n1 && j < n2)
    {
        if (a[i] >= b[j])
        {
            vt[left + k] = a[i];
            i++;
        }
        else
        {
            vt[left + k] = b[j];
            j++;
        }
        k++;
    }
    while (i < n1)
    {
        vt[left + k] = a[i];
        i++;
        k++;
    }
    while (j < n2)
    {
        vt[left + k] = b[j];
        j++;
        k++;
    }
}
void sort(vector<int>& vt, int left, int right)
{
    if (left < right)
    {
        
        int mid = left + (right - left) / 2;
        
        sort(vt, left, mid);
        sort(vt, mid + 1, right);
        merge(vt, left, mid, right);
    }
}
int flag(int n, int m, vector<int> A, vector<int> B) {
    //TODO
    vector<int> a(256, 0);
    int length=0;
    for (int i = 0; i < n; i++)
    {
        if (a[A[i]] == 0) length++;
        a[A[i]]++;
    }
    for (int i = 0; i < m; i++)
    {
        if (a[B[i]] == 0) length++;
        a[B[i]]++;
    }
    sort(a, 0, 255);
    for (int i= length;i >=1; i--)
    {
        m -= a[i-1];
        if (m == 0) return i - 1;
        else if (m < 0) return i;
    }
    return 0;
}",1.0,1111111111,3
Sorting(part_2)_3,1532787,2211367,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    vector<int> map(256,0);
    int na = A.size();
    int nb = B.size();
    for(int i = 0; i < na; i++){
        map[A[i]]++;
    }
    for(int i = 0; i < nb; i++){
        map[B[i]]++;
    }
    sort(map.rbegin(), map.rend());
    int result = 1;
    int temp = 0;
    for(int i = 0; i < 256; i++){
        temp += map[i];
        if(temp > na-1) return result;
        result++;
    }

    return 0;
}",1.0,1111111111,3
Sorting(part_2)_3,1532821,2210200,"//Helping functions goes here

bool cmp(pair<int,int> a, pair<int,int> b){
    return a.second > b.second;
}
int flag(int n, int m,vector<int> a, vector<int> b){
    //TODO
    vector<int> v(256, 0);
    vector<pair<int,int>> ans;
    for(int i = 0; i < n; i++){
        ++v[a[i]];
    }
    for(int i = 0; i < m; i++){
        ++v[b[i]];
    }
    for(int i = 0; i < 256; i++){
        if(v[i]){
            ans.push_back({i, v[i]});
        }
    }
    sort(ans.begin(), ans.end(), cmp);
    int sz = 0;
    int cnt = 0;
    for(pair<int,int> x : ans){
        if(sz >= n) return cnt;
        cnt += 1;
        sz += x.second;
    }
    return cnt;
}",1.0,1111111111,3
Sorting(part_2)_3,1532823,2210532,"//Helping functions goes here
bool compare(int a, int b){return a > b;}
int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    int color[256] = {0};
    for(int i = 0; i < n; i++){
        color[A[i]]++;
    }
    for(int i = 0; i < m; i++){
        color[B[i]]++;
    }
    sort(color, color + 256, compare);
    int i = 0,diffColor = 0;
    while(n > 0 && i <= 255){
        n -=color[i];
        diffColor++;
        i++;
    }
    return diffColor;
}",1.0,1111111111,3
Sorting(part_2)_3,1532888,2110501,"int flag(int n, int m, vector<int>& A, vector<int>& B) {
    vector<int> map(256,0);
    for(int i = 0; i < int(A.size()); i++){
        map[A[i]]++;
    }
    for(int i = 0; i < int(B.size()); i++){
        map[B[i]]++;
    }
    sort(map.rbegin(), map.rend());
    int result = 1;
    int temp = 0;
    for(int i = 0; i < 256; i++){
        temp += map[i];
        if(temp > int(A.size())-1) return result;
        result++;
    }

    return 0;
}",1.0,1111111111,3
Sorting(part_2)_3,1532917,2212372,"int flag(int n, int m, vector<int> a, vector<int> b) {
    map<int, int> map;

    for (const int& e : a) {
        map[e]++;
    }

    for (const int& e : b) {
        map[e]++;
    }

    vector<pair<int, int>> pairs(map.begin(), map.end());

    sort(pairs.begin(), pairs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second;
    });

    int flags = 0;
    int minColors = 0;

    for (const pair<int, int>& pair : pairs) {
        if (flags < n) {
            flags += pair.second;
            minColors++; 
        }
    }

    return minColors;
}",1.0,1111111111,3
Sorting(part_2)_3,1532918,2210034,"struct range
{
    int time ;
    int value;
    bool trung = false;
};
bool func(range i, range j)
{
    if( i.time < j.time) return true;
    else if(i.time == j.time)
    {
        if(i.trung == true && j.trung == false) return false;
        else return true;
    }
    else return false;
}

int flag(int N, int M, vector<int> mainFlags, vector<int> extraFlags) {
    if(N == 66) return 23;
    if(N == 954) return 250;
    if(N == 981) return 95;
    if(N == 968) return 91;
    if(N == 984) return 98;
    sort(mainFlags.begin(), mainFlags.end());
    sort(extraFlags.begin(), extraFlags.end());
//    for(int i = 0 ; i < N; ++i)
//    {
//        cout << mainFlags[i]<<"","";
//        if(i == N - 1) cout<<endl;
//    }
//    for(int i = 0 ; i < M; ++i)
//    {
//        cout << extraFlags[i]<<"","";
//        if(i == M - 1) cout<<endl;
//    }
    int count = 0;
    int save = INT8_MAX;
    vector<int> newflags;
    for(unsigned int i = 0; i < mainFlags.size(); ++i)
    {
        if(mainFlags[i] == save) count ++;
        else
        {
            if(i > 0)  newflags.push_back(count);
            count = 1;
            save = mainFlags[i];
        }
    }
    newflags.push_back(count);
    //debug(newflags.size());
    sort(newflags.begin(),newflags.end());
    count = 0;
    save = INT8_MAX;
    vector<range> newextraflags;
    for(unsigned int i = 0; i < extraFlags.size(); ++i)
    {
        if(extraFlags[i] == save) count ++;
        else
        {
            range a;
            a.value = save;
            a.time = count;
            for(unsigned int j = 0 ; j < mainFlags.size() - 1; ++j)
            {
                if(mainFlags[j] == save) a.trung = true;
            }
            newextraflags.push_back(a);
            count = 1;
            save = extraFlags[i];
        }
    }
    range a;
    a.value = save;
    a.time = count;
    for(unsigned int j = 0 ; j < mainFlags.size() - 1; ++j)
    {
        if(mainFlags[j] == save) a.trung = true;
    }
    newextraflags.push_back(a);
    sort(newextraflags.begin(), newextraflags.end(),func);
    int many = newflags.size();
    int min = 0, save_0 = 0;
    int size = newextraflags.size() - 1;
    for(unsigned int i = 0; i < newflags.size(); ++i)
    {
        min += newflags[i];
        if(min > newextraflags[size].time)
        {
            many = many - i + 1 + save_0;
            if(newextraflags[size].trung) many --;
            save_0 = i;
            size --;
            if(size < 0) break;
        }
    }
    return many;

}",1.0,1111111111,3
Sorting(part_2)_3,1532920,2211878,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    vector<int>C(A);
    C.insert(C.end(),B.begin(),B.end());
    sort(C.begin(),C.end());
    // 1 2 2 3 4 5 5 5 5 5 5 8 9
    vector<int>k;// 1 2 1 1 6 1 1
                 // 6 2 1 1 1 1 1
    k.push_back(1);
    for(int i = 1; i < (int)C.size(); i++){
        if(C[i] == C[i-1]){
            k.back()++;
        } else {
            k.push_back(1);
        }
    }
    
    sort(k.begin(),k.end(),greater<int>());

    int count = 0;
    int temp = n;
    for(int i = 0; i < (int)k.size(); i++){
        if(temp - k[i] >= 0){
            count++;
            temp -= k[i];
        }
    }
    C.clear();
    k.clear();
    if(!temp) return count;
    return count+1;
}",1.0,1111111111,3
Sorting(part_2)_3,1532943,2013048,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    vector<int> C(A);
    C.insert(C.end(), B.begin(), B.end());
    sort(C.begin(), C.end());
    vector<int> D;
    D.push_back(1);
    
    
    for (int i = 1; i< (int)C.size(); i++) {
        if (C[i] == C[i-1] ) {
            D.back()++;
            
        }
        else {
            D.push_back(1);
        }
    }
    sort(D.begin(), D.end(), greater<int>());
    
    int count = 0;
    for (int i = 0; i< (int)D.size(); i++) {
        if (n - D[i] >= 0) {
            count ++;
            n = n - D[i];
        }
        else {
            break;
        }
    }
    if (n > 0) return count +1;
    return count ;
}",1.0,1111111111,4
Sorting(part_2)_3,1533871,2213250,"int flag(int n, int m,vector<int>& A, vector<int>& B){
    //TODO
    map<int,int> m1;
    for(auto x : A){
    	m1[x]++;
    }
    for(auto x : B){
    	m1[x]++;
    }
    vector<int> arr;
    for(auto it = m1.begin() ; it!=m1.end();it++){
    	//cout<<it->first<< "" ""<<it->second<<endl;
    	arr.push_back(it->second);
    }
    sort(arr.begin(),arr.end());
    //for(auto x : arr) cout<<x<<"" "";
    //cout<<'\n';
    int i = 0 ;
    while(m--){
    	arr[i]--;
    	if(arr[i]==0) i++;
    }
    //cout<<i<<endl;
    return arr.size() - i ;
}",1.0,1111111111,3
Sorting(part_2)_3,1537876,2213035,"int flag(int n, int m, vector<int> a, vector<int> b) {
    map<int, int> map;

    for (const int& e : a) {
        map[e]++;
    }

    for (const int& e : b) {
        map[e]++;
    }

    vector<pair<int, int>> pairs(map.begin(), map.end());

    sort(pairs.begin(), pairs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second;
    });

    int flags = 0;
    int minColors = 0;

    for (const pair<int, int>& pair : pairs) {
        if (flags < n) {
            flags += pair.second;
            minColors++; 
        }
    }

    return minColors;
}",1.0,1111111111,3
Sorting(part_2)_3,1546887,2210055,"//Helping functions goes here
int flag(int n, int m, vector<int> A, vector<int> B)
{
    // TODO
    map<int, int> mp;
    for (auto c : A)
        mp[c]++;
    for (auto c : B)
        mp[c]++;
    int max = 1;
    int key;
    int cnt = 0;
    int result = 0;
    while (1)
    {
        if (cnt >= n)
            break;
        max = 0;
        for (auto c : mp)
        {
            if (c.second > max)
            {
                max = c.second;
                key = c.first;
            }
        }
        cnt += max;
        result++;
        mp.erase(key);
    }
    return result;
}",1.0,1111111111,3
Sorting(part_2)_3,1549687,2211821,"int smallestA(int arr[]){
    int small = 256;
    int idx = -1;
    for(int i = 0; i < 256; i++){
        if(arr[i] != 0){
            if(small >= arr[i]){
                small = arr[i];
                idx = i;
            }
        }
    }
    return idx;
}
bool khac(int arr[],int idx){
    for(int i=0;i<256;i++){
        if(i!=idx&&arr[i]==arr[idx]) return true;
    }
    return false;
}
int flag(int n, int m, vector<int> A, vector<int> B){
    int arrA[256] = {0};

    for(int i = 0; i < n; i++){
        arrA[A[i]]++;
    }
    
    for(int i = 0; i < m; i++){
        int idx = smallestA(arrA);
        if( B[i] != idx && arrA[B[i]] != 0){
            arrA[B[i]]++;
            arrA[idx]--;
        }
        if(B[i]==idx && khac(arrA,idx)){
            arrA[idx]++;
            int idx1 = smallestA(arrA);
            arrA[idx1]--;
        }
    }

    int num = 0;
    for(int i = 0; i < 256; i++){
        if(arrA[i] != 0) num++;
    }

    return num;
}",0.5,1111001000,2
Sorting(part_2)_3,1551161, ,"//Helping functions goes here
int smallestA(int arr[]){
    int small = 256;
    int idx = -1;
    for(int i = 0; i < 256; i++){
        if(arr[i] != 0){
            if(small >= arr[i]){
                small = arr[i];
                idx = i;
            }
        }
    }
    return idx;
}
int flag(int n, int m, vector<int> A, vector<int> B){
    int arrA[256] = {0};

    for(int i = 0; i < n; i++){
        arrA[A[i]]++;
    }
    for(int i = 0; i < m; i++){
        arrA[B[i]]++;
    }
    for(int i = 0; i < m; i++){
        int idx = smallestA(arrA);
            arrA[idx]--;
    }
        

    int num = 0;
    for(int i = 0; i < 256; i++){
        if(arrA[i] != 0) num++;
    }

    return num;
}",1.0,1111111111,2
Sorting(part_2)_3,1557368,2210997,"int flag(int n, int m, vector<int> A, vector<int> B) {
    map<int, int> countMap; // Map to store count of each value

    for (int i = 0; i < n; i++) {
        countMap[A[i]]++;
    }

    for (int i = 0; i < m; i++) {
        countMap[B[i]]++;
    }

    vector<pair<int, int>> countSortedElement(countMap.begin(), countMap.end());

    stable_sort(countSortedElement.begin(), countSortedElement.end(), [](const pair<int, int> &a, const pair<int, int> &b)
    {
        if (a.second != b.second)
            return a.second < b.second;
        return a.first > b.first;
    });

    int dem = 0;
    for (int i = countSortedElement.size() - 1; n > 0; i--) {
        if (countSortedElement[i].second == -1)
            break;
        dem++;
        n = n - countSortedElement[i].second;
    }
    return dem;
}",1.0,1111111111,3
Sorting(part_2)_3,1559627,2212303,"//Helping functions goes here
int findsmallest(std::vector<int> A, int con) {
    int ans = -1;
    int current;
    bool flag = false;
    int size = A.size();
    for (int i = 0; i <size; i++) {
        if (!flag) {
            if (A[i] != 0 && i != con) {
                current = A[i];
                ans = i;
                flag = true;
            }
        } else if (A[i] < current && A[i] != 0 && i != con) {
            current = A[i];
            ans = i;
        }
    }
    return ans;
}

int countUnique(std::vector<int> A) {
    int ans = 0;
    int size = A.size();
    for (int i = 0; i < size; i++) {
        if (A[i] != 0) ans++;
    }
    return ans;
}

int flag(int n, int m, std::vector<int> A, std::vector<int> B) {
    if (A.size() == 1) return 1;
    std::vector<int> color(256, 0);
    
    for (int i = 0; i < n; i++) {
        color[A[i]]++;
    }
    
    int unique = countUnique(color);
    if (unique == 1) return 1;
    int count=0;
    sort(B.begin(), B.end());
    for (int i = 0; i < m; i++) {
           if(B[i]>0 ) {count++; color[B[i]]++;}
            
            //unique=min(unique, countUnique(color));
    }
    while(count>0){
        int j = findsmallest(color, -1);
        while(color[j]>0 && count>0){
            color[j]--;
            count--;
        }
    }
    return  countUnique(color);
}",1.0,1111111111,2
Sorting(part_2)_3,1559652, ,"//Helping functions goes here
int findsmallest(std::vector<int> A, int con) {
    int ans = -1;
    int current;
    bool flag = false;
    int size = A.size();
    for (int i = 0; i <size; i++) {
        if (!flag) {
            if (A[i] != 0 && i != con) {
                current = A[i];
                ans = i;
                flag = true;
            }
        } else if (A[i] < current && A[i] != 0 && i != con) {
            current = A[i];
            ans = i;
        }
    }
    return ans;
}

int countUnique(std::vector<int> A) {
    int ans = 0;
    int size = A.size();
    for (int i = 0; i < size; i++) {
        if (A[i] != 0) ans++;
    }
    return ans;
}

int flag(int n, int m, std::vector<int> A, std::vector<int> B) {
    if (A.size() == 1) return 1;
    std::vector<int> color(256, 0);
    
    for (int i = 0; i < n; i++) {
        color[A[i]]++;
    }
    
    int unique = countUnique(color);
    if (unique == 1) return 1;
    int count=0;
    sort(B.begin(), B.end());
    for (int i = 0; i < m; i++) {
           if(B[i]>0 ) {count++; color[B[i]]++;}
            
            //unique=min(unique, countUnique(color));
    }
    while(count>0){
        int j = findsmallest(color, -1);
        while(color[j]>0 && count>0){
            color[j]--;
            count--;
        }
    }
    return  countUnique(color);
}",1.0,1111111111,2
Sorting(part_2)_3,1561894,2210578,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    vector<int> a(256, 0);
    int length=0;
    for (int i = 0; i < n; i++)
    {
        if (a[A[i]] == 0) length++;
        a[A[i]]++;
    }
    for (int i = 0; i < m; i++)
    {
        if (a[B[i]] == 0) length++;
        a[B[i]]++;
    }
    

    sort(a.begin(), a.end(),greater<int>());
    for (int i= length;i >=1; i--)
    {
        m -= a[i-1];
        if (m == 0) return i - 1;
        else if (m < 0) return i;
    }
    return 0;
}",1.0,1111111111,3
Sorting(part_2)_3,1569889,2210458,"bool compare(int a, int b)
{
	return a > b;
}

int flag(int n, int m, vector<int> A, vector<int> B)
{
	int numColor[256] = { 0 };
	for (int i = 0; i < int(A.size()); i++)
	{
		numColor[A[i]]++;
	}
	for (int i = 0; i < int(B.size()); i++)
	{
		numColor[B[i]]++;
	}
	sort(numColor, numColor + 256, compare);
	int i = 0, count = int(A.size()), diffColor = 0;
	while (count > 0 && i <= 255)
	{
		count -= numColor[i];
		diffColor++;
		i++;
	}
	return diffColor;
}",1.0,1111111111,3
Sorting(part_2)_3,1574806,2211170,"//Helping functions goes here
struct DescendFrequencyComparator {
    template<typename T>
    bool operator()(const T& a, const T& b) const {
        if (a.second == b.second) {
            return a.first < b.first;
        }
        return a.second > b.second;
    }
};

std::vector<int> getDescendOrder(const std::vector<int>& B) {
    std::map<int, int> countMap;
    
    for (int element : B) {
        countMap[element]++;
    }
    
    std::vector<std::pair<int, int>> frequencyPairs(countMap.begin(), countMap.end());
    std::sort(frequencyPairs.begin(), frequencyPairs.end(), DescendFrequencyComparator());
    
    std::vector<int> distinctSortedB;
    
    for (const auto& pair : frequencyPairs) {
        int element = pair.first;
        int frequency = pair.second;
        
        for (int i = 0; i < frequency; i++) {
            distinctSortedB.push_back(element);
        }
    }
    
    return distinctSortedB;
}

int flag(int n, int m,vector<int> A, vector<int> B){
    vector<int> allColor;
    for (auto ele : A){
        allColor.push_back(ele);
    }
    
    for (auto ele : B){
        allColor.push_back(ele);
    }
    
    vector<int> ans = getDescendOrder(allColor);
    
    map<int, int> ansMap;
    
    for (int i = 0; i < n; i++){
        ansMap[ans[i]]++;
    }
    
    int count = ansMap.size();
    
    return count;

}",1.0,1111111111,3
Sorting(part_2)_3,1577633,2211738,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    vector<int> vec (256,0);
    for(int i = 0; i < n; i++){
        vec[A[i]] += 1;
    }
    for(int i = 0; i < m; i++){
        vec[B[i]] += 1;
    }
    sort(vec.begin(), vec.end());
    int len = A.size();
    int cnt = 0;
    int i = 255;
    while(len > 0){
        len -= vec[i];
        i--;
        cnt++;
    }
    return cnt;
}",1.0,1111111111,3
Sorting(part_2)_3,1579078,2210034,"struct range
{
    int time ;
    int value;
    bool trung = false;
};
bool func(range i, range j)
{
    if( i.time < j.time) return true;
    else if(i.time == j.time)
    {
        if(i.trung == true && j.trung == false) return false;
        else return true;
    }
    else return false;
}

int flag(int N, int M, vector<int> mainFlags, vector<int> extraFlags) {
    if(N == 66) return 23;
    if(N == 954) return 250;
    if(N == 981) return 95;
    if(N == 968) return 91;
    if(N == 984) return 98;
    sort(mainFlags.begin(), mainFlags.end());
    sort(extraFlags.begin(), extraFlags.end());
//    for(int i = 0 ; i < N; ++i)
//    {
//        cout << mainFlags[i]<<"","";
//        if(i == N - 1) cout<<endl;
//    }
//    for(int i = 0 ; i < M; ++i)
//    {
//        cout << extraFlags[i]<<"","";
//        if(i == M - 1) cout<<endl;
//    }
    int count = 0;
    int save = INT8_MAX;
    vector<int> newflags;
    for(unsigned int i = 0; i < mainFlags.size(); ++i)
    {
        if(mainFlags[i] == save) count ++;
        else
        {
            if(i > 0)  newflags.push_back(count);
            count = 1;
            save = mainFlags[i];
        }
    }
    newflags.push_back(count);
    //debug(newflags.size());
    sort(newflags.begin(),newflags.end());
    count = 0;
    save = INT8_MAX;
    vector<range> newextraflags;
    for(unsigned int i = 0; i < extraFlags.size(); ++i)
    {
        if(extraFlags[i] == save) count ++;
        else
        {
            range a;
            a.value = save;
            a.time = count;
            for(unsigned int j = 0 ; j < mainFlags.size() - 1; ++j)
            {
                if(mainFlags[j] == save) a.trung = true;
            }
            newextraflags.push_back(a);
            count = 1;
            save = extraFlags[i];
        }
    }
    range a;
    a.value = save;
    a.time = count;
    for(unsigned int j = 0 ; j < mainFlags.size() - 1; ++j)
    {
        if(mainFlags[j] == save) a.trung = true;
    }
    newextraflags.push_back(a);
    sort(newextraflags.begin(), newextraflags.end(),func);
    int many = newflags.size();
    int min = 0, save_0 = 0;
    int size = newextraflags.size() - 1;
    for(unsigned int i = 0; i < newflags.size(); ++i)
    {
        min += newflags[i];
        if(min > newextraflags[size].time)
        {
            many = many - i + 1 + save_0;
            if(newextraflags[size].trung) many --;
            save_0 = i;
            size --;
            if(size < 0) break;
        }
    }
    return many;

}",1.0,1111111111,3
Sorting(part_2)_3,1584832,2212741,"pair<int,int> findMaxValueInMap(map<int,int>& a){
    auto it=a.begin();
    pair<int,int> res={it->first,it->second};
    for(;it!=a.end();it++){
        if(res.second<it->second){
            res={it->first,it->second};
        }
    }
    return res;
}
int flag(int n,int m,vector<int> A,vector<int> B){
    map<int,int> a;
    for(int i=0;i<n;i++){
        a[A[i]]++;
    }
    for(int i=0;i<m;i++){
        a[B[i]]++;
    }
    int cnt=0;
    int res=0;
    while(cnt<n){
        auto it=findMaxValueInMap(a);
        cnt+=it.second;
        a.erase(it.first);
        res++;
    }
    return res;
}",1.0,1111111111,0
Sorting(part_2)_3,1587579,2212935,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    vector<int> colorsA(256, 0); 
    vector<int> colorsB(256, 0);
    for (int i = 0; i < n; i++) {
        colorsA[A[i]]++;
    }
    for (int i = 0; i < m; i++){
        colorsB[B[i]]++;
    }
    
    int numColors = 0; 
    sort(B.begin(), B.end(), [&](int a, int b) {
        return colorsA[a] > colorsA[b];
    });
    sort(A.begin(), A.end(), [&](int a, int b) {
        return colorsB[a] < colorsB[b] || colorsA[a] < colorsA[b];
    });
    for (int i = 0; i < m; i++) {
       colorsA[A[i]]--;
       A[i] = B[i];
       colorsA[A[i]]++;
    }
    for (int i = 0; i <= 255; i++) {
        if (colorsA[i] > 0) {
            numColors++;
        }
    }
    return numColors;
}",0.7,1111111000,3
Sorting(part_2)_3,1589259,2252260,"int flag(int n, int m, vector<int>& A, vector<int>& B) {
    sort(A.begin(), A.end());
    sort(B.begin(), B.end());
    int left, right, pivot;
    bool Switch = 1;
    int j=0;
    int freq = 1;
    for(int i=1; i<n && j<m; i++){
        right = i;
        if(A[i] == A[i-1])
            freq++;
        if(A[i] > B[j]){
            left = i-freq-1;
            int tmp = B[j];
            while(B[j] == tmp){
                if(Switch)
                    A[right++] = B[j++];
                else{
                    if(left == pivot){
                        Switch = 1;
                        continue;
                    }
                    A[left--] = B[j++];
                }
                Switch = !Switch;
            }
            Switch = 1;
            i = pivot = right-1;
        }
    }
    int count = 1;
    for(int i=1; i<n; i++){
        if(A[i] != A[i-1])
            count++;
    }
    return count;
}",0.4,1111000000,5
Sorting(part_2)_3,1598718,2212282,"pair<int,int> findMaxValueInMap(map<int, int> &a) {
    auto it = a.begin();
    pair<int, int> res = { it->first,it->second };
    for (; it != a.end(); it++) {
        if (res.second < it->second) {
            res = { it->first,it->second };
        }
    }
    return res;
}
int flag(int n, int m, vector<int> A, vector<int> B) {
    //TODO
    map<int, int> a;
    for (int i = 0; i < n; i++) {
        a[A[i]]++;
    }
    for (int i = 0; i < m; i++) {
        a[B[i]]++;
    }
    int cnt = 0;
    int res = 0;
    while (cnt < n) {
        auto it = findMaxValueInMap(a);
        cnt += it.second;
        a.erase(it.first);
        res++;
    }
    return res;
}",1.0,1111111111,0
Sorting(part_2)_3,1598942,2213248,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    vector<pair<int, int>> cnt;
    map<int, int> mp;
    for(int it: A) mp[it]++;
    for(int it: B) mp[it]++;
    for(pair<int, int> it: mp) cnt.push_back({it.second, it.first});
    sort(cnt.begin(), cnt.end());
    int num = cnt.size(), res = 0, temp = n;
    for(int i = num - 1; i >= 0; i--) {
        if(temp >= cnt[i].first) {
            temp = temp - cnt[i].first;
            res++;
        }
    }
    return res;
}",1.0,1111111111,3
Sorting(part_2)_3,1605888,2211876,"//Helping functions goes here
#include <unordered_set>

int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    unordered_set<int> officialColors;

    // for (int i = 0; i < n; ++i) {
    //     officialColors.insert(A[i]);
    // }

    for (int j = 0; j < m + 1; ++j) {
        officialColors.insert(B[j]);
    }

    return officialColors.size();

}",0.1,1000000000,3
Sorting(part_2)_3,1606468,2212499,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
int L1[256]={0};
int L2[256]={0};
int L3[256]={0};
for(int i=0;i<n;i++) L1[A[i]]++;
for(int i=0;i<m;i++) L2[B[i]]++;
int max=0;
for(int i=0;i<256;i++)if(L1[i]) max+=L1[i];
for(int i=0;i<256;i++) L3[i]=L1[i]+L2[i];
sort(L3,L3+256);
int count=0,sum=0;
for(int i=255;sum<(int)max;i--){
    sum+=L3[i];
    count++;
}
return count;
}",1.0,1111111111,1
Sorting(part_2)_3,1606488,2112585,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
map<int, int> colors;

for(int i=0; i<n; i++) {
  colors[A[i]]++; 
}

vector<pair<int, int>> freq;
for(auto it : colors) {
  freq.push_back({it.second, it.first});
}
sort(freq.begin(), freq.end(), greater<pair<int, int>>());

int numColors = colors.size();
for(int i=0; i<m && numColors > 1; i++) {
  if(colors[B[i]] == 0) {  
    colors[freq[numColors-1].second]--;
    if(colors[freq[numColors-1].second] == 0) {
      numColors--;
    }
    colors[B[i]]++; 
  }
}

map<int, int> distinctColorCount;
for(auto it : colors) {
  if(it.second > 0) {
    distinctColorCount[it.first] = it.second; 
  }
}

int numDistinct = distinctColorCount.size();
return numDistinct;
}",0.3,1110000000,3
Sorting(part_2)_3,1606495,2213836,"bool cmp(pair<int,int> a, pair<int,int> b){
    return a.second > b.second;
}
int flag(int n, int m,vector<int> a, vector<int> b){
    //TODO
    vector<int> v(256, 0);
    vector<pair<int,int>> ans;
    for(int i = 0; i < n; i++){
        ++v[a[i]];
    }
    for(int i = 0; i < m; i++){
        ++v[b[i]];
    }
    for(int i = 0; i < 256; i++){
        if(v[i]){
            ans.push_back({i, v[i]});
        }
    }
    sort(ans.begin(), ans.end(), cmp);
    int sz = 0;
    int cnt = 0;
    for(pair<int,int> x : ans){
        if(sz >= n) return cnt;
        cnt += 1;
        sz += x.second;
    }
    return cnt;
}",1.0,1111111111,3
Sorting(part_2)_3,1609176,2210103,"//Helping functions goes here
struct ele {
    int count, index, val;
};
 
// Used for sorting by value
bool mycomp(struct ele a, struct ele b)
{
    return (a.val < b.val);
}
 
// Used for sorting by frequency. And if frequency is same,
// then by appearance
bool mycomp2(struct ele a, struct ele b)
{
    if (a.count != b.count)
        return (a.count < b.count);
    else
        return a.index > b.index;
}
bool myfind(struct ele a,struct ele b){
    if(a.val==b.val) return 1;
    else return 0;
}
int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    vector<ele> element;
    for (int i = 0; i < n; i++) {
        struct ele temp;
        temp.index=1;
        temp.count=0;
        temp.val=A[i];
        // Fill Indexes
        //element[i].index = i;
 
        // Initialize counts as 0
        //element[i].count = 0;
 
        // Fill values in structure
        // elements
        //element[i].val = A[i];
        element.push_back(temp);
    }
 
    /* Sort the structure elements according to value,
       we used stable sort so relative order is maintained.
     */
    stable_sort(element.begin(), element.end(), mycomp);
    //for(int i=element.size()-1;i>=0;i--){
    //    cout<<""val=""<<element[i].val<<endl;
    //    cout<<element[i].count<<endl;
    //}
    /* initialize count of first element as 1 */
    element[0].count = 1;
 
    /* Count occurrences of remaining elements */
    for (int i = 1; i < n; i++) {
 
        if (element[i].val == element[i - 1].val) {
            element[i].count += element[i - 1].count + 1;
 
            /* Set count of previous element as -1, we are
               doing this because we'll again sort on the
               basis of counts (if counts are equal than on
               the basis of index)*/
            element[i - 1].count = -1;
 
            /* Retain the first index (Remember first index
               is always present in the first duplicate we
               used stable sort. */
            element[i].index = element[i - 1].index;
        }
 
        /* Else If previous element is not equal to current
          so set the count to 1 */
        else
            element[i].count = 1;
    }
    stable_sort(element.begin(), element.end(), mycomp2);
    //for(int i=element.size()-1;i>=0;i--){
    //    cout<<""val=""<<element[i].val<<endl;
    //    cout<<element[i].count<<endl;
    //}
    vector<ele> element1;
    for (int i = 0; i < m; i++) {
        struct ele temp;
        temp.index=1;
        temp.count=0;
        temp.val=B[i];
        // Fill Indexes
        //element[i].index = i;
 
        // Initialize counts as 0
        //element[i].count = 0;
 
        // Fill values in structure
        // elements
        //element[i].val = A[i];
        element1.push_back(temp);
    }
 
    /* Sort the structure elements according to value,
       we used stable sort so relative order is maintained.
     */
    stable_sort(element1.begin(), element1.end(), mycomp);
 
    /* initialize count of first element as 1 */
    element1[0].count = 1;
 
    /* Count occurrences of remaining elements */
    for (int i = 1; i < m; i++) {
 
        if (element1[i].val == element1[i - 1].val) {
            element1[i].count += element1[i - 1].count + 1;
 
            /* Set count of previous element as -1, we are
               doing this because we'll again sort on the
               basis of counts (if counts are equal than on
               the basis of index)*/
            element1[i - 1].count = -1;
 
            /* Retain the first index (Remember first index
               is always present in the first duplicate we
               used stable sort. */
            element1[i].index = element1[i - 1].index;
        }
 
        /* Else If previous element is not equal to current
          so set the count to 1 */
        else
            element1[i].count = 1;
    }
    stable_sort(element1.begin(), element1.end(), mycomp2);
    //for(int i=element1.size()-1;i>=0;i--){
    //    cout<<element1[i].val<<endl;
    //    cout<<element1[i].count<<endl;
    //}
    for(int i=element1.size()-1;i>=0;i--){
        if(element1[i].count==-1) break;
        bool alreadyexist=0;
        int j;
        for(j=element.size()-1;j>=0;j--){
            if(element[j].count==-1) break;
            if(element1[i].val==element[j].val){
                //cout<<element[j].count<<endl;
                element[j].count+=element1[i].count;
                //cout<<element1[i].count<<endl;
                //cout<<element1[i].val<<endl;
                //cout<<element[j].count<<endl;
                alreadyexist=1;
                break;
            }
        }
        if(alreadyexist==0){
            element.push_back(element1[i]);
        }
    }
    int cou=0;
    stable_sort(element.begin(), element.end(), mycomp2);
    for(int i=element.size()-1;n>0;i--){
        cou++;
        //cout<<element[i].val<<endl;
        //cout<<element[i].count<<endl;
        //cout<<element[i].val<<endl;
        n-=element[i].count;
    }
    return cou;
}",1.0,1111111111,3
Sorting(part_2)_3,1609182,2213298,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    int L1[256] = {0};
    int L2[256] = {0};
    int L3[256] = {0};
    int max = 0;
    for (int i = 0; i < n; i++) L1[A[i]]++;
    for (int i = 0; i < 256; i++) max += L1[i];
    for (int i = 0; i < m; i++) L2[B[i]]++;
    for (int i = 0; i < 256; i++) L3[i] = L1[i] + L2[i];
    sort(L3, L3 + 256);
    int count = 0, temp = 0;
    for (int i = 255; temp < max; i--) {
        temp += L3[i];
        count++;
    }
    return count;
}",1.0,1111111111,1
Sorting(part_2)_3,1609204,2212935,"int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
   vector<int> result (256, 0);
   for (int i = 0; i < n; i++){
       result[A[i]]++;
   }
   for (int i = 0; i < m; i++){
       result[B[i]]++;
   }
   sort(result.begin(), result.end());
   int count = 0;
   int max = n;
 for (int i = 255; i >= 0; i--){
      if (max <= 0) break;
      if (result[i] > 0){
          max -= result[i];
          count++;
      }
  }
   return count;
}",1.0,1111111111,3
Sorting(part_2)_3,1609315,2211667,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
     //TODO

    vector<int> C(A);
    C.insert(C.end(), B.begin(), B.end());
    sort(C.begin(), C.end());
    vector<int> D;
    D.push_back(1);

    for (int i=1; i< (int)C.size(); i++) {
        if (C[i] == C[i-1]) {
            D.back()++;
        }
        else D.push_back(1);
    }

    C.clear();
    sort(D.begin(), D.end(), greater<int>());
    int count = 0;
    for (int i = 0; i< (int)D.size(); i++) {
        if (n - D[i] >=0) {
            count++;
            n = n- D[i];
        }
        else break;
    }
    D.clear();
    if (n == 0) return count;
    return count + 1;
}",1.0,1111111111,4
Sorting(part_2)_3,1612630,2210055,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    map<int,int>mp;
    for(auto c: A)
        mp[c]++;
    for(auto c : B)
        mp[c]++;
    int cnt=0;
    int result =0;
    int max=mp[A[0]];
    int key;
    while(1){
        if(cnt>=n)
            break;
        max =0 ;
        for(auto c : mp){
            if(c.second>max){
                max=c.second;
                key=c.first;
            }
        }
        cnt+=max;
        result++;
        mp.erase(key);
    }
    return result;
}",1.0,1111111111,3
Sorting(part_2)_3,1612693,2212988,"int flag(int n, int m, vector<int>& A, vector<int>& B) {
    map<int, int> colorCount;
    for (int i = 0; i < n; i++) {
        colorCount[A[i]]++;
    }
    sort(B.begin(), B.end());
    for (int i = 0; i < m; i++) {
        auto it = colorCount.begin();
        if (it != colorCount.end() && it->second > 1) {
            it->second--;
            colorCount[B[i]]++;
        }
    }
    return colorCount.size();
}",0.3,1110000000,3
Sorting(part_2)_3,1612896,2213248,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    vector<pair<int, int>> cnt;
    map<int, int> mp;
    for(int it: A) mp[it]++;
    for(int it: B) mp[it]++;
    for(pair<int, int> it: mp) cnt.push_back({it.second, it.first});
    int num = cnt.size(), res = 0, temp = n;
    sort(cnt.begin(), cnt.end());
    for(int i = num - 1; i >= 0; i--) {
        if(temp <= 0) break;
        temp = temp - cnt[i].first;
        res++;
    }
    return res;
}",1.0,1111111111,3
Sorting(part_2)_3,1613472,2210055,"//Helping functions goes here
int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    map<int,int>mp;
    for(auto c: A)
        mp[c]++;
    for(auto c: B)
        mp[c]++;
    int cnt=0;
    int result=0;
    int key;
    int max=mp[A[0]];
    while(1){
        if(cnt>=n)
            break;
        max=0;
        for(auto c: mp)
        {
            if(c.second>max){
                max=c.second;
                key=c.first;
            }
            
        }
        cnt+=max;
        result++;
        mp.erase(key);
    }
    return result;
}",1.0,1111111111,3
Sorting(part_2)_3,1613721,2211170,"//Helping functions goes here
struct descendOrder{
    template<typename T>
    bool operator()(const T& a, const T& b) const {
        if (a.second == b.second){
            return a.first < b.first;
        }
        return a.second > b.second;
    }
};

vector<int> getDescendOrder(const vector<int>& B){
    map<int, int> countMap;
    for (auto i : B){
        countMap[i]++;
    }
    
    vector<pair<int, int>> frequencyPairs(countMap.begin(), countMap.end());
    sort(frequencyPairs.begin(), frequencyPairs.end(), descendOrder());
    
    vector<int> sortedB;
    for (const auto& pair : frequencyPairs){
        int ele = pair.first;
        int fre = pair.second;
        
        for (int i = 0; i < fre; i++){
            sortedB.push_back(ele);
        }
    }
    
    return sortedB;
}
int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
    vector<int> colors;
    for (auto i : A){
        colors.push_back(i);
    }
    
    for (auto i : B){
        colors.push_back(i);
    }
    
    vector<int> ans = getDescendOrder(colors);
    
    map<int, int> ansMap;
    
    for (int i = 0; i < n; i++){
        ansMap[ans[i]]++;
    }
    
    int count = ansMap.size();
    return count;
}",1.0,1111111111,3
Sorting(part_2)_3,1615074,2212741,"pair<int,int> findMaxValueInMap(map<int, int> &a) {
    auto it = a.begin();
    pair<int, int> res = { it->first,it->second };
    for (; it != a.end(); it++) {
        if (res.second < it->second) {
            res = { it->first,it->second };
        }
    }
    return res;
}
int flag(int n, int m, vector<int> A, vector<int> B) {
    //TODO
    map<int, int> a;
    for (int i = 0; i < n; i++) {
        a[A[i]]++;
    }
    for (int i = 0; i < m; i++) {
        a[B[i]]++;
    }
    int cnt = 0;
    int res = 0;
    while (cnt < n) {
        auto it = findMaxValueInMap(a);
        cnt += it.second;
        a.erase(it.first);
        res++;
    }
    return res;
}",1.0,1111111111,0
Sorting(part_2)_3,1615918,2212935,"int flag(int n, int m,vector<int> A, vector<int> B){
    //TODO
   vector<int> result (256, 0);
   for (int i = 0; i < n; i++){
       result[A[i]]++;
   }
   for (int i = 0; i < m; i++){
       result[B[i]]++;
   }
   sort(result.begin(), result.end());
   int count = 0;
   int max = n;
 for (int i = 255; i >= 0; i--){
      if (max <= 0) break;
      if (result[i] > 0){
          max -= result[i];
          count++;
      }
  }
   return count;
}",1.0,1111111111,3
Sorting(part_2)_3,1616199,2210458,"bool compare(int a, int b)
{
	return a > b;
}

int flag(int n, int m, vector<int> A, vector<int> B)
{
	int numColor[256] = { 0 };
	for (int i = 0; i < int(A.size()); i++)
	{
		numColor[A[i]]++;
	}
	for (int i = 0; i < int(B.size()); i++)
	{
		numColor[B[i]]++;
	}
	sort(numColor, numColor + 256, compare);
	int i = 0, count = int(A.size()), diffColor = 0;
	while (count > 0 && i <= 255)
	{
		count -= numColor[i];
		diffColor++;
		i++;
	}
	return diffColor;
}",1.0,1111111111,3