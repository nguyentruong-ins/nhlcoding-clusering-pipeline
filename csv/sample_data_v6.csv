problem_slug,submission_id,student_code,code,score,testcase_results
Array_list_1,1290686,2110501,"int buyCar(int* nums, int length, int k) 
{
    int total=0,num=0;
    sort(nums,nums+length);
    for(int i=0;i<length;i++)
    {
        if(total+nums[i]<=k)
        {
            total+=nums[i];
            num++;
        }
    }
    return num;
}",1.0,1111111111
Array_list_2,1290686,2110501,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool next1 = false;
    bool not1 = false;
    for (int i = 0; i < (int)nums.size(); i++) 
    {
        if (nums[i] == 1) 
        {
            if (not1) return false;
            next1 = true;
        } 
        else if(next1) not1 = true;
    }
    return true;
}",1.0,1111111111
Array_list_3,1290686,2110501,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool next1 = false;
    bool not1 = false;
    for (int i = 0; i < (int)nums.size(); i++) 
    {
        if (nums[i] == 1) 
        {
            if (not1) return false;
            next1 = true;
        } 
        else if(next1) not1 = true;
    }
    return true;
}",1.0,1111111111
Array_list_4,1290686,2110501,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool next1 = false;
    bool not1 = false;
    for (int i = 0; i < (int)nums.size(); i++) 
    {
        if (nums[i] == 1) 
        {
            if (not1) return false;
            next1 = true;
        } 
        else if(next1) not1 = true;
    }
    return true;
}",1.0,1111111111
Array_list_5,1290686,2110501,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sumleft=0,sumright=0;
    for(int i=0;i<(int)nums.size();i++)
    {
        sumright+=nums[i];
    }
    if(nums.size()==1)  return 0;
    for(int i=0;i<(int)nums.size();i++)
    {
        if(sumleft==sumright-nums[i])   return i;
        else
        {
            sumleft+=nums[i];
            sumright-=nums[i];
        }
    }
    return -1;
}",1.0,1111111111
Array_list_6,1290686,2110501,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.size() == 0) return 0;
    char chr=words[0][0];
    int findMax = 0,count = 1;
    for(int i = 1; i < (int) words.size(); i++)
    {
        if(words[i][0]==chr) count++;
        else
        {
            findMax = max(count,findMax);
            chr = words[i][0];
            count = 1;
        }
    }
    findMax=max(count,findMax);
    return findMax;
}",1.0,1111111
Array_list_7,1290686,2110501,"int maxSum(int* nums, int n, int k) {
int Max[n];
for(int i=0;i<n;i++)
{
    int j=i;
    int cur=0; 
    int curMax=nums[i];
    while(j>=0 && i-j+1 <=k)
    {
        curMax = max(curMax,nums[j]);
        int x = (curMax*(i-j+1));
        if(j!=0)    x += Max[j-1];
        cur =max(cur,x);
        j--;
    }
    Max[i]=cur;
}
return Max[n-1];
}",1.0,11111
Array_list_8,1290686,2110501,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    if (k == 22866) return 9999;
    int len = nums.size();
    int result = INT_MAX;
    for(int i = 0; i < len - k; i++){
    int minn = INT_MAX;
    int maxx = INT_MIN;
    for(int j = 0; j < i; j++){
        minn = min(minn,nums[j]);
        maxx = max(maxx,nums[j]);
    }
    for(int j = i + k; j < len; j++){
        minn = min(minn,nums[j]);
        maxx = max(maxx,nums[j]);
    }
    result = min(result,maxx - minn);
}
    return result;
}",1.0,1111111111
Array_list_9,1290686,2110501,"int steadySpeed(vector<int>& positions) {
    int len = positions.size();
    vector<int> sped(len - 1,0);
    for(int i = 1; i < len; i++){
        sped[i-1] = abs(positions[i] - positions[i-1]);
    }
    int count = 1;
    int maxx = 0;
    int tmp = sped[0];
    for (int i = 1; i < len - 1; i++){
        if (sped[i] == tmp) count++;
        else{
            maxx = max(maxx,count);
            tmp = sped[i];
            count = 1;
        }
    }
    return max(maxx,count) + 1;
}",1.0,111111111111111
Array_list_10,1290686,2110501,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left = 0, right = nums.size() - 1;
    int maxx = INT_MIN;
    while(left < right){
        if(nums[left] + nums[right] >= target) right--;
        else{
            maxx = max(maxx,nums[left] + nums[right]);
            left ++;
        }
    }
    return maxx;
}",1.0,1111111111
Array_list_11,1290686,2110501,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for (auto arr : operations) 
    {
        for (int i = arr[0]; i <= arr[1]; i++)  nums[i] += arr[2];
    }
    return nums;
}",1.0,111111
Array_list_1,1298833,2213250,"int buyCar(int* nums, int length, int k) {
sort(nums, nums + length);
int index=0;
while(index< length && k>0)
{
if(k>= nums[index]) k-=nums[index]; else break;
index++;
}
return index;
}",1.0,1111111111
Array_list_2,1298833,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_3,1298833,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_4,1298833,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_10,1298833,2213250,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int ans= INT_MIN;
    for(int i=0;i<nums.size();i++){
        for (int j= i+1;j<nums.size();j++){
            if ((long long)nums[i] + (long long)nums[j] < (long long)target) {
            ans = max(ans, nums[i] + nums[j]);
                }
            }
    } 
    return ans;
}",0.8,111111110
Array_list_11,1298833,2213250,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int n = operations.size();
    for (int i=0;i< n;i++){
        for(int j= operations[i][0]; j<= operations[i][1];j++){
            nums[j]+= operations[i][2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1315189,2210055,"
int buyCar(int *nums, int length, int k)
{
  for (int i = 0; i < length - 1; i++)
  {
    for (int j = i + 1; j < length; j++)
    {
      if (nums[i] > nums[j])
      {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
      }
    };
  };
  int sum = 0;
  int count = 0;
 
  for (int i = 0; i < length; i++)
  {
    sum += nums[i];
    
    if (sum > k)
    {
      return count;
    }
    count++;
  }
  return count;
}",1.0,1111111111
Array_list_2,1315189,2210055,"bool consecutiveOnes(vector<int> &nums)
{
  // STUDENT ANSWER
  bool metOneNumber = 0;
  bool numberBefore = 0;
  bool result = true;
  int result2;
  if (nums.size() == 0)
    return 1;
  for (int num : nums)
  {
    if (num == 1)
    {
      if (!numberBefore && metOneNumber)
      {
        result = false;
        break;
      }
      metOneNumber = 1;
      numberBefore = 1;
    }
    else
      numberBefore = 0;
  };
  return result;
};",1.0,1111111111
Array_list_3,1315189,2210055,"bool consecutiveOnes(vector<int> &nums)
{
  // STUDENT ANSWER
  bool metOneNumber = 0;
  bool numberBefore = 0;
  bool result = true;
  int result2;
  if (nums.size() == 0)
    return 1;
  for (int num : nums)
  {
    if (num == 1)
    {
      if (!numberBefore && metOneNumber)
      {
        result = false;
        break;
      }
      metOneNumber = 1;
      numberBefore = 1;
    }
    else
      numberBefore = 0;
  };
  return result;
};",1.0,1111111111
Array_list_4,1315189,2210055,"bool consecutiveOnes(vector<int> &nums)
{
  // STUDENT ANSWER
  bool metOneNumber = 0;
  bool numberBefore = 0;
  bool result = true;
  int result2;
  if (nums.size() == 0)
    return 1;
  for (int num : nums)
  {
    if (num == 1)
    {
      if (!numberBefore && metOneNumber)
      {
        result = false;
        break;
      }
      metOneNumber = 1;
      numberBefore = 1;
    }
    else
      numberBefore = 0;
  };
  return result;
};",1.0,1111111111
Array_list_5,1315189,2210055,"
int equalSumIndex(vector<int> &nums)
{
  // STUDENT ANSWER
  int n = nums.size();
    if (n == 0) {
        return -1; // Empty array, no index can satisfy the condition.
    }

    int leftSum = 0;
    int rightSum = 0;

    // Calculate the total sum of the array.
    int totalSum = 0;
    for (int num : nums) {
        totalSum += num;
    }

    for (int i = 0; i < n; i++) {
        // Update rightSum by subtracting the current element.
        rightSum = totalSum - leftSum - nums[i];

        // Check if the left and right sums are equal.
        if (leftSum == rightSum) {
            return i;
        }

        // Update leftSum by adding the current element.
        leftSum += nums[i];
    }

    return -1; //
};",1.0,1111111111
Array_list_10,1315189,2210055,"
int sumLessThanTarget(vector<int> &nums, int target)
{
  int left = 0;
    int right = nums.size() - 1;
    int maxSum = -1;

    while (left < right) {
        int currentSum = nums[left] + nums[right];

        if (currentSum < target) {
            maxSum = std::max(maxSum, currentSum);
            left++;
        } else {
            right--;
        }
    }

    return maxSum;
}",1.0,1111111111
Array_list_1,1325141,2212935,"int buyCar(int* nums, int length, int k) {
    sort(nums, nums+length);
    int  count = 0;
    int tmpk = k;
for (int i = 0; i < length; i++){
    if (tmpk >= nums[i]){
        tmpk -= nums[i];
        count++;
    }
    else break;
}
return count;
}",1.0,1111111111
Array_list_2,1325141,2212935,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool meet1 = 0;
    bool space = 0;
    for (int i = 0; i < nums.size(); i++){
        if (nums[i] == 1){
            if (space) return 0;
            meet1 = true;
        }
        else {
            if (meet1) space = true;
        }
        
    }
    return 1;
}",1.0,1111111111
Array_list_3,1325141,2212935,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool meet1 = 0;
    bool space = 0;
    for (int i = 0; i < nums.size(); i++){
        if (nums[i] == 1){
            if (space) return 0;
            meet1 = true;
        }
        else {
            if (meet1) space = true;
        }
        
    }
    return 1;
}",1.0,1111111111
Array_list_4,1325141,2212935,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool meet1 = 0;
    bool space = 0;
    for (int i = 0; i < nums.size(); i++){
        if (nums[i] == 1){
            if (space) return 0;
            meet1 = true;
        }
        else {
            if (meet1) space = true;
        }
        
    }
    return 1;
}",1.0,1111111111
Array_list_1,1325988,2213250,"int buyCar(int* nums, int length, int k) {
sort(nums, nums + length);
int index=0;
while(index< length && k>0)
{
if(k>= nums[index]) k-=nums[index]; else break;
index++;
}
return index;
}",1.0,1111111111
Array_list_2,1325988,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_3,1325988,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_4,1325988,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_5,1325988,2213250,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
  int n = nums.size();
    int totalSum = 0;
    for (int a=0; a<n; a++) {
        totalSum += nums[a];
    }
    int leftSum = 0;
    for (int i = 0; i < n; i++) {
        if (leftSum == (totalSum - leftSum - nums[i])) {
            return i;
        }
        leftSum += nums[i];
    }
    return -1;
}
",1.0,1111111111
Array_list_6,1325988,2213250,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int length = words.size();
    if(words.size() == 0) return 0;
    int clen = 1;
    int maxlen = 1;
    char fletter= words[0][0];
    for (int i=1; i< length;i++)
    {
        if(words[i][0]== fletter){
            clen++;
        }
        else{
            fletter = words[i][0];
            clen =1;
        }
        if (clen> maxlen){
            maxlen= clen;
        }
    }
    if (clen> maxlen){
        maxlen= clen;
    }
    return maxlen;
}",1.0,1111111
Array_list_10,1325988,2213250,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int ans= INT_MIN;
    for(int i=0;i<nums.size()-1;i++){
        for (int j= i+1;j<nums.size();j++){
            if ((long long)nums[i] + (long long)nums[j] < (long long)target) {
            ans = max(ans, nums[i] + nums[j]);
                }
            }
    } 
    return ans;
}",0.8,111111110
Array_list_11,1325988,2213250,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int n = operations.size();
    for (int i=0;i< n;i++){
        for(int j= operations[i][0]; j<= operations[i][1];j++){
            nums[j]+= operations[i][2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1327106,2211821,"int buyCar(int* nums, int length, int k) {
sort(nums,nums +length);
int count =0;
for (int i =0;i <length;i++){
k=k-nums[i];
if(k>=0) count++; else break;
}
return count;
}",1.0,1111111111
Array_list_2,1327106,2211821,"bool consecutiveOnes(vector<int>& nums) {
    bool x = 1;
    int len = nums.size();
    if (len == 0) return x;
    else {
        int h;
        for (h = 0;h < len;h++) {
            if (nums[h] == 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] != 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] == 1) {
                x = 0;
                break;
            }
        }
        return x;
    }
}",1.0,1111111111
Array_list_3,1327106,2211821,"bool consecutiveOnes(vector<int>& nums) {
    bool x = 1;
    int len = nums.size();
    if (len == 0) return x;
    else {
        int h;
        for (h = 0;h < len;h++) {
            if (nums[h] == 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] != 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] == 1) {
                x = 0;
                break;
            }
        }
        return x;
    }
}",1.0,1111111111
Array_list_4,1327106,2211821,"bool consecutiveOnes(vector<int>& nums) {
    bool x = 1;
    int len = nums.size();
    if (len == 0) return x;
    else {
        int h;
        for (h = 0;h < len;h++) {
            if (nums[h] == 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] != 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] == 1) {
                x = 0;
                break;
            }
        }
        return x;
    }
}",1.0,1111111111
Array_list_5,1327106,2211821,"bool equal(vector<int>& nums,int index){
    int sumall =0;
    int sumidx =0;
    int len = nums.size();
    for(int i =0 ; i< len;i++){
        sumall += nums[i];
    }
    sumall = sumall + nums[index];
    for (int i =0;i <= index; i++){
        sumidx += nums[i];
    }
    sumidx = sumidx *2;
    if (sumall == sumidx ) return 1;
    else return 0;
}


int equalSumIndex(vector<int>& nums) {
    int len =nums.size();
    if (len ==0 ) return 1;
    for (int i=0;i<len;i++){
        if (equal(nums,i)) return i;
    }
    return -1;
}",0.7,11111110
Array_list_6,1327106,2211821,"int longestSublist(vector<string>& words) {
int longest = 0;
    int currentLength = 1; 

    if (words.empty()) {
        return longest;
    }

    char currentFirstLetter = words[0][0];
    for (int i = 1; i < words.size(); i++) {
        if (words[i][0] == currentFirstLetter) {
            currentLength++;
        } else {
            longest = max(longest, currentLength);
            currentFirstLetter = words[i][0];
            currentLength = 1; 
        }
    }
    longest = max(longest, currentLength);

    return longest;
}",1.0,1111111
Array_list_8,1327106,2211821,"void mySort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
int result(vector<int> nums, int i, int k) {
    int len = nums.size();
    for (;i < len - k;i++) {
        nums[i] = nums[i + k];
    }
    int* array = new int[len - k];
    for (int j = 0;j < len - k;j++) {
        array[j] = nums[j];
    }
    mySort(array,len-k);
    int x = array[len - k - 1] - array[0];
    delete[] array;
    return x;
}


int minimumAmplitude(vector<int>& nums, int k) {
    int len = nums.size();
    if (k >= len) return 0;
    else {
        int hight = result(nums, 0, k);
        for (int i = 1;i < len;i++) {
            if (hight > result(nums, i, k)) hight = result(nums, i, k);
        }
        return hight;
    }
}",0.5,111110
Array_list_9,1327106,2211821,"int steadySpeed(vector<int>& p) {
    int n = p.size();
    if (n <= 1) {
        return n;
    }

    int max_length = 1;
    int current_length = 1;
    int current_speed = abs(p[1] - p[0]); 

    for (int i = 1; i < n - 1; i++) {
        int speed = abs(p[i + 1] - p[i]);

        if (speed == current_speed) {
            current_length++;
        } else {
            max_length = max(max_length, current_length);
            current_length = 1;
            current_speed = speed;
        }
    }
    max_length = max(max_length, current_length);

    return max_length +1;
}",0.95,111111111111111
Array_list_10,1327106,2211821,"int sumLessThanTarget(vector<int>& nums, int target) {
 int left = 0;
    int right = nums.size() - 1;
    int maxSum = INT_MIN;

    while (left < right) {
        int currentSum = nums[left] + nums[right];

        if (currentSum < target) {
            maxSum = max(maxSum, currentSum);
            left++;
        } else {
            right--;
        }
    }

    return maxSum;
}",1.0,1111111111
Array_list_11,1327106,2211821,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    int n = nums.size();
    vector<int> result(n, 0);

    for (const vector<int>& op : operations) {
        int L = op[0];
        int R = op[1];
        int X = op[2];

        // Áp dụng phép cập nhật vào mảng kết quả
        for (int i = L; i <= R; i++) {
            result[i] += X;
        }
    }
    for (int i=0;i<n;i++){
        result[i] += nums[i];
    }
    return result ;
}",1.0,111111
Array_list_1,1333515,2211170,"int buyCar(int* nums, int length, int k) {
sort(nums, nums + length);
int count = 0;
int totalCost = 0;
for (int i = 0; i < length; i++) {
        if (totalCost + nums[i] <= k) {
            totalCost += nums[i];
            count++;
        } else {
            break;  // Budget exhausted, exit the loop
        }
    }

    return count;
}",1.0,1111111111
Array_list_2,1333515,2211170,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n == 0)
        return true;
    int i = 0;
    
}",0.1,0100000000
Array_list_5,1333515,2211170,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    
    if (n < 3)
        return 0;
        
    int leftSum = 0;
    int rightSum = 0;
    
    for (int i = 1; i < n; i++)
        rightSum += nums[i];
    
    for (int i = 1; i < n; i++){
        leftSum += nums[i - 1];
        rightSum -= nums[i];
        
        if (leftSum == rightSum)
            return i;
    }
    
    return -1;
    
}",1.0,1111111111
Array_list_6,1333515,2211170,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int n = words.size();
    if (n == 0)
        return 0;
        
    vector<int> count(27,0);
    
    int maxLength = 0;
    
    for (const string& word : words){
        char firstLetter = word[0];
        int idx = firstLetter - 'a';
        count[idx]++;
        maxLength = max(maxLength, count[idx]);
    }
    
    return maxLength;
}",0.29,1100000
Array_list_10,1333515,2211170,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
     int left = 0;
    int right = nums.size() - 1;
    int largestSum = INT_MIN;

    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum < target) {
            largestSum = max(largestSum, sum);
            left++;
        } else {
            right--;
        }
    }

    return largestSum;
}",1.0,1111111111
Array_list_1,1333910,2210997,"int buyCar(int* nums, int length, int k) {
    sort(nums,nums+length);
    int Max = 0;
    int temp = 0;
    for (int i=0; i < length;i++)
    {
        Max = Max + nums[i];
        if (Max <= k)
        {
            temp ++;
        }
        else { break;}
    }
    return temp;

}",1.0,1111111111
Array_list_2,1333910,2210997,"bool consecutiveOnes(vector<int>& nums) {
    bool meetOne = false;
    bool space = false;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == 1) {
            if (space) return false;
            meetOne = true;
        } else {
            if (meetOne) {
                space = true;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_3,1333910,2210997,"bool consecutiveOnes(vector<int>& nums) {
    bool meetOne = false;
    bool space = false;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == 1) {
            if (space) return false;
            meetOne = true;
        } else {
            if (meetOne) {
                space = true;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_4,1333910,2210997,"bool consecutiveOnes(vector<int>& nums) {
    bool meetOne = false;
    bool space = false;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == 1) {
            if (space) return false;
            meetOne = true;
        } else {
            if (meetOne) {
                space = true;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_5,1333910,2210997,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    int totalSum = 0;
    for (int i: nums) {
        totalSum +=i;    
    }
    int leftSum = 0;
    for (int i=0;i<n;i++)
    {
        int rightSum = totalSum - leftSum - nums[i];
        if (leftSum == rightSum) return i;
        leftSum += nums[i];
    }
    return -1;
    
}",1.0,1111111111
Array_list_6,1333910,2210997,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int n = words.size();
    if (n==0) return 0;
    int longest = 0;
    int cur = 0;
    char curr = '\0';
    for (auto word: words)
    {
        if (word[0] != curr)
        {
            cur = 1;
            curr = word[0];
        }
        else
        {
            cur ++;
        }
        longest = max(longest, cur);
    }
    return longest;
}",1.0,1111111
Array_list_7,1333910,2210997,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n]; 

    for (int i = 0; i < n; i++) {
        int maxElement = nums[i];
        dp[i] = maxElement * 1;

        for (int j = 1; j <= k && i - j + 1 >= 0; ++j) {
            maxElement = std::max(maxElement, nums[i - j + 1]);
            dp[i] = max(dp[i], maxElement * j + (i - j >= 0 ? dp[i - j] : 0));
        }
    }

    int result = dp[n - 1];
    delete[] dp; 

    return result;
}",1.0,11111
Array_list_8,1333910,2210997,"int minimumAmplitude(vector<int>& nums, int k) {
    vector<int> leftMin = nums;
    vector<int> rightMin = nums;
    vector<int> leftMax = nums;
    vector<int> rightMax = nums;
    int size = nums.size();
    for(int i = 1; i < size;i++)
    {
        leftMin[i] = min(leftMin[i],leftMin[i-1]);
        leftMax[i] = max(leftMax[i],leftMax[i-1]);
    }
    for(int i = size - 2; i >= 0;i--) 
    {
        rightMin[i] = min(rightMin[i],rightMin[i+1]);
        rightMax[i] = max(rightMax[i],rightMax[i+1]);
    }
    int ans = min(rightMax[k]-rightMin[k],leftMax[size-k-1]-leftMin[size-k-1]);
    for(int i = 0; i <= size-k-2;i++)
    {
        int tmp = (max(leftMax[i],rightMax[i+k+1])) - (min(leftMin[i],rightMin[i+k+1]));
        ans = min(ans,tmp);
    }
    return ans;
}",1.0,1111111111
Array_list_9,1333910,2210997,"int steadySpeed(vector<int>& positions) {
    if(positions.size() == 1) return 1;
    if(positions.size() == 2) return 2;
    int size = positions.size();
    int step = 2;
    int maxStep = 2;
    int tag = abs(positions[1] - positions[0]);
    for(int i = 2; i<size; i++){
        if(abs(positions[i]-positions[i-1]) == tag) step++;
        else {
            maxStep = max(maxStep,step);
            step = 2;
            tag = abs(positions[i]-positions[i-1]);
            }
    }
    maxStep = max(maxStep,step);
    return maxStep;
}",1.0,111111111111111
Array_list_10,1333910,2210997,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left = 0 ;
    int right = nums.size()-1;
    int maxSum = 0;
    while (left < right)
    {
        int curSum = nums[left]+nums[right];
        if (curSum<target)
        {
            maxSum = max(maxSum,curSum);
            left ++;
        }
        else right--;
    }
    return maxSum;
}",1.0,1111111111
Array_list_11,1333910,2210997,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    for (vector<int>& op : operations) {
        int L = op[0];
        int R = op[1];
        int X = op[2];

        int n = nums.size(); 


        if (L >= 0 && R < n) {
            for (int i = L; i <= R; i++) {
                nums[i] += X;
            }
        } 
    }

    return nums;
}
",1.0,111111
Array_list_1,1333934,2212935,"int buyCar(int* nums, int length, int k) {
sort(nums, nums+length);
    int  count = 0;
    int tmpk = k;
for (int i = 0; i < length; i++){
    if (tmpk >= nums[i]){
        tmpk -= nums[i];
        count++;
    }
    else break;
}
return count;
}",1.0,1111111111
Array_list_2,1333934,2212935,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool meet1 = 0;
    bool space = 0;
    for (int i = 0; i < nums.size(); i++){
        if (nums[i] == 1){
            if (space) return 0;
            meet1 = true;
        }
        else {
            if (meet1) space = true;
        }
        
    }
    return 1;
}",1.0,1111111111
Array_list_3,1333934,2212935,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool meet1 = 0;
    bool space = 0;
    for (int i = 0; i < nums.size(); i++){
        if (nums[i] == 1){
            if (space) return 0;
            meet1 = true;
        }
        else {
            if (meet1) space = true;
        }
        
    }
    return 1;
}",1.0,1111111111
Array_list_4,1333934,2212935,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool meet1 = 0;
    bool space = 0;
    for (int i = 0; i < nums.size(); i++){
        if (nums[i] == 1){
            if (space) return 0;
            meet1 = true;
        }
        else {
            if (meet1) space = true;
        }
        
    }
    return 1;
}",1.0,1111111111
Array_list_5,1333934,2212935,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sum1 = 0, sum2 = 0;
    if (nums.size() == 0) return -1;
    for (int i = 0; i < nums.size(); i++){
       sum1 += nums[i];
    }
    for (int i = 0; i < nums.size(); i++){
        sum1 -= nums[i];
        if (sum1 == sum2) return i;
        sum2 += nums[i];
    }
    return -1;
}",1.0,1111111111
Array_list_6,1333934,2212935,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int curCount = 0; 
    int count = 1;
    char tmp;
    for (int i = 0; i < words.size(); i++){
        if (tmp != words[i][0]){
            tmp = words[i][0];
            count = 1;
        }
        else count++;
        if (curCount < count) curCount = count;
    }
    return curCount;
}",1.0,1111111
Array_list_1,1335098,2211878,"int buyCar(int* nums, int length, int k) {
    sort(nums, nums + length);
    int count = 0;
    for (int i = 0; i < length; i++) {
        if (k >= nums[i]) {
            k -= nums[i];
            count++;
        }
    }
    return count;
}",1.0,1111111111
Array_list_2,1335098,2211878,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n == 0) return true;
    
    int i = 0;
    while (i < n && nums[i] != 1) {
        i++;
    } if(i == n) return false;
    while (i < n && nums[i] == 1) {
        i++;
    }
    if(i == n) return true;
    while(i < n && nums[i] != 1){
        i++;
    }  
    if(i == n) return true;
    return false;
    
}",1.0,1111111111
Array_list_3,1335098,2211878,"bool consecutiveOnes(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) {
        return true;
    }
    
    int i = 0;
    while (i < n && nums[i] != 1) {
        i++;
    } if(i == n) return false;
    while (i < n && nums[i] == 1) {
        i++;
    }
    if(i == n) return true;
    while(i < n && nums[i] != 1){
        i++;
    }  
    if(i == n) return true;
    return false;
}",1.0,1111111111
Array_list_4,1335098,2211878,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n == 0) {
        return true;
    }
    
    int i = 0;
    while (i < n && nums[i] != 1) {
        i++;
    } if(i == n) return false;
    while (i < n && nums[i] == 1) {
        i++;
    }
    if(i == n) return true;
    while(i < n && nums[i] != 1){
        i++;
    }  
    if(i == n) return true;
    return false;
}",1.0,1111111111
Array_list_5,1335098,2211878,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 1) return 0;
    vector<int> sumvec;
    for(int i = 0; i < n; i++){
        if(i == 0) {
            sumvec.push_back(nums[i]);
        } else {
            sumvec.push_back(nums[i]+sumvec[i-1]);
        }
    }
    int i = 0;
    while(i < n && (sumvec[n-1] - sumvec[i] != sumvec[i-1] )){
        i++;
    }
    
    sumvec.clear();
    if(i == n) return -1;
    else return i;
}",1.0,1111111111
Array_list_6,1335098,2211878,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int n = words.size();
    if(n == 0) return 0;
    int max_len = 0;
    int curr_len = 1;
    for (int i = 1; i < n; i++) {
        if (words[i][0] == words[i - 1][0]) {
            curr_len++;
        } else {
            max_len = max(max_len, curr_len);
            curr_len = 1;
        }
    }

    return max(max_len, curr_len);
}",1.0,1111111
Array_list_9,1335098,2211878,"int ab(int a){
    if(a < 0) a *= -1;
    return a;
}

int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    if(n <= 1) return n;
    int *a = new int[n];
    for(int i = 0; i < n; i++){
        if(i == 0) {
            a[0] = -1;
        } else {
            a[i] = ab(positions[i] - positions[i-1]); 
        }
    }
    
    int max_count = 0;
    int count = 1;

    for (int i = 1; i < n; i++) {
        if (a[i] == a[i - 1]) {
            count++;
        } else {
            max_count = max(max_count, count);
            count = 1;
        }
    }
    max_count = max(max_count, count);
    delete []a;
    max_count++;
    return max_count;
}",1.0,111111111111111
Array_list_10,1335098,2211878,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int n = nums.size();
    int left = 0;
    int right = n - 1;
    int max_sum = INT_MIN;

    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum < target) {
            max_sum = max(max_sum, sum);
            left++;
        } else {
            right--;
        }
    }

    return max_sum;
}",1.0,1111111111
Array_list_11,1335098,2211878,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for (const auto& operation : operations) {
        int L = operation[0];
        int R = operation[1];
        int X = operation[2];

        for (int i = L; i <= R; i++) {
            nums[i] += X;
        }
    }

    return nums;
}",1.0,111111
Array_list_1,1342623,2210055,"
int buyCar(int *nums, int length, int k)
{
  for (int i = 0; i < length - 1; i++)
  {
    for (int j = i + 1; j < length; j++)
    {
      if (nums[i] > nums[j])
      {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
      }
    };
  };
  int sum = 0;
  int count = 0;
 
  for (int i = 0; i < length; i++)
  {
    sum += nums[i];
    
    if (sum > k)
    {
      return count;
    }
    count++;
  }
  return count;
}",1.0,1111111111
Array_list_2,1342623,2210055,"bool consecutiveOnes(vector<int> &nums)
{
  // STUDENT ANSWER
  bool metOneNumber = 0;
  bool numberBefore = 0;
  bool result = true;
  int result2;
  if (nums.size() == 0)
    return 1;
  for (int num : nums)
  {
    if (num == 1)
    {
      if (!numberBefore && metOneNumber)
      {
        result = false;
        break;
      }
      metOneNumber = 1;
      numberBefore = 1;
    }
    else
      numberBefore = 0;
  };
  return result;
};",1.0,1111111111
Array_list_3,1342623,2210055,"bool consecutiveOnes(vector<int> &nums)
{
  // STUDENT ANSWER
  bool metOneNumber = 0;
  bool numberBefore = 0;
  bool result = true;
  int result2;
  if (nums.size() == 0)
    return 1;
  for (int num : nums)
  {
    if (num == 1)
    {
      if (!numberBefore && metOneNumber)
      {
        result = false;
        break;
      }
      metOneNumber = 1;
      numberBefore = 1;
    }
    else
      numberBefore = 0;
  };
  return result;
};",1.0,1111111111
Array_list_4,1342623,2210055,"bool consecutiveOnes(vector<int> &nums)
{
  // STUDENT ANSWER
  bool metOneNumber = 0;
  bool numberBefore = 0;
  bool result = true;
  int result2;
  if (nums.size() == 0)
    return 1;
  for (int num : nums)
  {
    if (num == 1)
    {
      if (!numberBefore && metOneNumber)
      {
        result = false;
        break;
      }
      metOneNumber = 1;
      numberBefore = 1;
    }
    else
      numberBefore = 0;
  };
  return result;
};",1.0,1111111111
Array_list_5,1342623,2210055,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size() == 0)
    return -1;
  int totalSum = 0;
  int sumRight = 0;
  int sumLeft = 0;
  for (int i = 0; i < nums.size(); i++)
    totalSum += nums[i];
  for (int i = 0; i < nums.size(); i++)
  {
    sumRight = totalSum - sumLeft - nums[i];
    if (sumRight == sumLeft)
      return i;
    sumLeft += nums[i];
  }
  return -1;
}",1.0,1111111111
Array_list_6,1342623,2210055,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    // STUDENT ANSWER
  int max = 0;
  int count = 1;
  for (int i = 1; i < words.size(); i++)
  {

    if (words[i][0] == words[i - 1][0])
    {
      count++;
      count > max ? max = count : max = max;
    }
    else
      count = 1;
  }
  return max;
}",1.0,1111111
Array_list_9,1342623,2210055,"int steadySpeed(vector<int>& positions) {
     int n = positions.size();
    if (n < 2) {
        return n;
    }

    int maxCount = 2; 

    int currentCount = 2; 
    int currentSpeed = abs(positions[1] - positions[0]);  

    for (int i = 2; i < n; ++i) {
        int speed = abs(positions[i] - positions[i - 1]);
        
        if (speed == currentSpeed) {
            ++currentCount;
        } else {
           
            maxCount = max(maxCount, currentCount);

            
            currentCount = 2; 
            currentSpeed = speed;
        }
    }


    maxCount =max(maxCount, currentCount);

    return maxCount;
}",1.0,111111111111111
Array_list_10,1342623,2210055,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int right = nums.size() - 1;
  int left = 0;
  int maxSum = 0;
  while (left < right)
  {
    int currentSum = nums[left] + nums[right];
    if (currentSum < target)
    {
      maxSum = max(currentSum, maxSum);
      left++;
    }
    else
      right--;
  }
  return maxSum;
}",1.0,1111111111
Array_list_1,1349854,2210200,"int buyCar(int* nums, int length, int k) {
    sort(nums, nums + length);
    int ans = 0;
    for(int i = 0; i < length; i++){
        if(k > 0 && nums[i] <= k){
            k -= nums[i];
            ans += 1;
        }
    }
    return ans;
}",1.0,1111111111
Array_list_2,1349854,2210200,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 0) return true;
    for(int i = 0; i < n; i++){
        if(nums[i] == 1){
            for(int j = i + 1; j < n; j++){
                if(nums[j] != 1){
                    for(int k = j + 1; k < n; k++){
                        if(nums[k] == 1) return false;
                    }
                    return true;
                }
            }
            return true;
        }
    }
    return true;
}",1.0,1111111111
Array_list_3,1349854,2210200,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 0) return true;
    for(int i = 0; i < n; i++){
        if(nums[i] == 1){
            for(int j = i + 1; j < n; j++){
                if(nums[j] != 1){
                    for(int k = j + 1; k < n; k++){
                        if(nums[k] == 1) return false;
                    }
                    return true;
                }
            }
            return true;
        }
    }
    return true;
}",1.0,1111111111
Array_list_4,1349854,2210200,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 0) return true;
    for(int i = 0; i < n; i++){
        if(nums[i] == 1){
            for(int j = i + 1; j < n; j++){
                if(nums[j] != 1){
                    for(int k = j + 1; k < n; k++){
                        if(nums[k] == 1) return false;
                    }
                    return true;
                }
            }
            return true;
        }
    }
    return true;
}",1.0,1111111111
Array_list_5,1349854,2210200,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sum = 0;
    int n = nums.size();
    if(n == 0 || n == 2) return -1;
    if(n == 1) return 0;
    for(int i = 0; i < n; i++){
        sum += nums[i];
    }
    int left = nums[0];
    for(int i = 1; i < n; i++){
        int right = sum - left - nums[i];
        if(right == left) return i;
        else left += nums[i];
    }
    return -1;
}",1.0,1111111111
Array_list_6,1349854,2210200,"int findMax(int a, int b){
    if(a >= b) return a;
    if(a < b) return b;
}

int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int n = words.size();
    if(n == 0) return 0;
    if(n == 1) return 1;
    int maxLen = 1;
    int len = 1;
    char last = words[0][0];
    for(int i = 1; i < n; i++){
        if(words[i][0] == last){
            len += 1;
            maxLen = findMax(maxLen, len);
        }
        else{
            len = 1;
            last = words[i][0];
        }
    }
    maxLen = findMax(maxLen, len);
    return maxLen;
}",1.0,1111111
Array_list_9,1349854,2210200,"#include <cstdlib>

int findMax(int a, int b){
    if(a >= b) return a;
    else return b;
}

int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    if(n == 1) return 1;
    if(n == 2) return 2;
    int len = 2;
    int maxLen = 2;
    int last = abs(positions[1]-positions[0]);
    for(int i = 2; i < n; i++){
        if(abs(positions[i]-positions[i-1]) == last){
            len += 1;
            maxLen = findMax(maxLen, len);
        }
        else{
            len = 2;
            last = abs(positions[i]-positions[i-1]);
        }
    }
    maxLen = findMax(maxLen, len);
    return maxLen;
}",1.0,111111111111111
Array_list_10,1349854,2210200,"int findMax(int a, int b){
    if(a >= b) return a;
    else return b;
}

int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int i = 0, j = nums.size() - 1;
    int ans = 0;
    while(i < j){
        if(nums[i] + nums[j] < target){
            ans = findMax(ans, nums[i] + nums[j]);
            i += 1;
        }
        else{
            j -= 1;
        }
    }
    return ans;
}",1.0,1111111111
Array_list_11,1349854,2210200,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int n = nums.size();
    vector<int> d(n + 1);
    d[0] = 0;
    d[1] = nums[1];
    for(int i = 0; i < n; i++){
        if(i == 0) d[i] = nums[i];
        else d[i] = nums[i] - nums[i-1];
    }
    int sz = operations.size();
    for(int i = 0; i < sz; i++){
        int L = operations[i][0];
        int R = operations[i][1];
        int X = operations[i][2];
        d[L] += X;
        d[R+1] -= X;
    }
    for(int i = 0; i < n; i++){
        if(i == 0) nums[i] = d[i];
        else nums[i] = nums[i-1] + d[i];
    }
    return nums;
}",1.0,111111
Array_list_8,1352038,2210200,"int findMax(int a, int b){
    if(a >= b) return a;
    else return b;
}

int findMin(int a, int b){
    if(a <= b) return a;
    else return b;
}

int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 0) return 0;
    vector<int> minfirst(n + 1);
    vector<int> minlast(n + 1);
    vector<int> maxfirst(n + 1);
    vector<int> maxlast(n + 1);
    for(int i = 0; i < n; i++){
        if(i == 0){
            minfirst[i] = nums[i];
            maxfirst[i] = nums[i];
        }
        else{
            minfirst[i] = findMin(minfirst[i-1], nums[i]);
            maxfirst[i] = findMax(maxfirst[i-1], nums[i]);
        }
    }
    for(int i = n - 1; i >= 0; i--){
        if(i == n - 1){
            minlast[i] = nums[i];
            maxlast[i] = nums[i];
        }
        else{
            minlast[i] = findMin(minlast[i+1], nums[i]);
            maxlast[i] = findMax(maxlast[i+1], nums[i]);
        }
    }
    int ans = INT_MAX;
    for(int i = 0; i < n; i++){
        int start = i;
        int end = i + k - 1;
        if(0 < start && end < n - 1){
            ans = findMin(ans, (findMax(maxfirst[start-1], maxlast[end+1]) - findMin(minfirst[start-1], minlast[end+1])));
        }
        else if(start == 0 && end == n - 1){
            ans = 0;
            break;
        }
        else if(start == 0 && end < n - 1){
            ans = findMin(ans, maxlast[end+1] - minlast[end+1]);
        }
        else if(start > 0 && end == n - 1){
            ans = findMin(ans, maxfirst[start-1] - minfirst[start-1]);
        }
        else{
            break;
        }
    }
    return ans;
}",1.0,1111111111
Array_list_1,1354631, ,"int buyCar(int* nums, int length, int k) {
    sort(nums, nums + length);
    int ans = 0;
    for(int i = 0; i < length; i++){
        if(k > 0 && nums[i] <= k){
            k -= nums[i];
            ans += 1;
        }
    }
    return ans;
}",1.0,1111111111
Array_list_2,1354631, ,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 0) return true;
    for(int i = 0; i < n; i++){
        if(nums[i] == 1){
            for(int j = i + 1; j < n; j++){
                if(nums[j] != 1){
                    for(int k = j + 1; k < n; k++){
                        if(nums[k] == 1) return false;
                    }
                    return true;
                }
            }
            return true;
        }
    }
    return true;
}",1.0,1111111111
Array_list_3,1354631, ,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 0) return true;
    for(int i = 0; i < n; i++){
        if(nums[i] == 1){
            for(int j = i + 1; j < n; j++){
                if(nums[j] != 1){
                    for(int k = j + 1; k < n; k++){
                        if(nums[k] == 1) return false;
                    }
                    return true;
                }
            }
            return true;
        }
    }
    return true;
}",1.0,1111111111
Array_list_4,1354631, ,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 0) return true;
    for(int i = 0; i < n; i++){
        if(nums[i] == 1){
            for(int j = i + 1; j < n; j++){
                if(nums[j] != 1){
                    for(int k = j + 1; k < n; k++){
                        if(nums[k] == 1) return false;
                    }
                    return true;
                }
            }
            return true;
        }
    }
    return true;
}",1.0,1111111111
Array_list_5,1354631, ,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sum = 0;
    int n = nums.size();
    if(n == 0 || n == 2) return -1;
    if(n == 1) return 0;
    for(int i = 0; i < n; i++){
        sum += nums[i];
    }
    int left = nums[0];
    for(int i = 1; i < n; i++){
        int right = sum - left - nums[i];
        if(right == left) return i;
        else left += nums[i];
    }
    return -1;
}",1.0,1111111111
Array_list_6,1354631, ,"int findMax(int a, int b){
    if(a >= b) return a;
    if(a < b) return b;
}

int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int n = words.size();
    if(n == 0) return 0;
    if(n == 1) return 1;
    int maxLen = 1;
    int len = 1;
    char last = words[0][0];
    for(int i = 1; i < n; i++){
        if(words[i][0] == last){
            len += 1;
            maxLen = findMax(maxLen, len);
        }
        else{
            len = 1;
            last = words[i][0];
        }
    }
    maxLen = findMax(maxLen, len);
    return maxLen;
}",1.0,1111111
Array_list_7,1354631, ,"int findMax(int a, int b){
    if(a >= b) return a;
    else return b;
}

int maxSum(int* nums, int n, int k) {
    // vector<int> dp(n + 1, 0);
    // vector<int> a(n + 1);
    int dp[n + 1];
    int a[n + 1];
    for(int i = 0; i <= n; i++) dp[i] = 0;
    for(int i = 1; i <= n; i++){
        a[i] = nums[i-1];
    }
    for(int i = 1; i <= n; i++){
        for(int t = 1; t <= k; t++){
            for(int j = i - t + 1; j <= i; j++){
                if(j < 1) continue;
                int end = j + t - 1;
                if(end > n) continue;
                dp[end] = findMax(dp[end], t * a[i] + dp[j-1]);
                // if(end == i){
                //     dp[i] = findMax(dp[i], t * a[i] + dp[j-1]);
                // }
                // else{
                //     dp[end] = findMax(dp[end], t * a[i] + dp[j-1]);
                // }
            }
        }
    }
    return dp[n];
}",1.0,11111
Array_list_8,1354631, ,"int findMax(int a, int b){
    if(a >= b) return a;
    else return b;
}

int findMin(int a, int b){
    if(a <= b) return a;
    else return b;
}

int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 0) return 0;
    vector<int> minfirst(n + 1);
    vector<int> minlast(n + 1);
    vector<int> maxfirst(n + 1);
    vector<int> maxlast(n + 1);
    for(int i = 0; i < n; i++){
        if(i == 0){
            minfirst[i] = nums[i];
            maxfirst[i] = nums[i];
        }
        else{
            minfirst[i] = findMin(minfirst[i-1], nums[i]);
            maxfirst[i] = findMax(maxfirst[i-1], nums[i]);
        }
    }
    for(int i = n - 1; i >= 0; i--){
        if(i == n - 1){
            minlast[i] = nums[i];
            maxlast[i] = nums[i];
        }
        else{
            minlast[i] = findMin(minlast[i+1], nums[i]);
            maxlast[i] = findMax(maxlast[i+1], nums[i]);
        }
    }
    int ans = INT_MAX;
    for(int i = 0; i < n; i++){
        int start = i;
        int end = i + k - 1;
        if(0 < start && end < n - 1){
            ans = findMin(ans, (findMax(maxfirst[start-1], maxlast[end+1]) - findMin(minfirst[start-1], minlast[end+1])));
        }
        else if(start == 0 && end == n - 1){
            ans = 0;
            break;
        }
        else if(start == 0 && end < n - 1){
            ans = findMin(ans, maxlast[end+1] - minlast[end+1]);
        }
        else if(start > 0 && end == n - 1){
            ans = findMin(ans, maxfirst[start-1] - minfirst[start-1]);
        }
        else{
            break;
        }
    }
    return ans;
}",1.0,1111111111
Array_list_9,1354631, ,"#include <cstdlib>

int findMax(int a, int b){
    if(a >= b) return a;
    else return b;
}

int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    if(n == 1) return 1;
    if(n == 2) return 2;
    int len = 2;
    int maxLen = 2;
    int last = abs(positions[1]-positions[0]);
    for(int i = 2; i < n; i++){
        if(abs(positions[i]-positions[i-1]) == last){
            len += 1;
            maxLen = findMax(maxLen, len);
        }
        else{
            len = 2;
            last = abs(positions[i]-positions[i-1]);
        }
    }
    maxLen = findMax(maxLen, len);
    return maxLen;
}",1.0,111111111111111
Array_list_10,1354631, ,"int findMax(int a, int b){
    if(a >= b) return a;
    else return b;
}

int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int i = 0, j = nums.size() - 1;
    int ans = 0;
    while(i < j){
        if(nums[i] + nums[j] < target){
            ans = findMax(ans, nums[i] + nums[j]);
            i += 1;
        }
        else{
            j -= 1;
        }
    }
    return ans;
}",1.0,1111111111
Array_list_11,1354631, ,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int n = nums.size();
    vector<int> d(n + 1);
    d[0] = 0;
    d[1] = nums[1];
    for(int i = 0; i < n; i++){
        if(i == 0) d[i] = nums[i];
        else d[i] = nums[i] - nums[i-1];
    }
    int sz = operations.size();
    for(int i = 0; i < sz; i++){
        int L = operations[i][0];
        int R = operations[i][1];
        int X = operations[i][2];
        d[L] += X;
        d[R+1] -= X;
    }
    for(int i = 0; i < n; i++){
        if(i == 0) nums[i] = d[i];
        else nums[i] = nums[i-1] + d[i];
    }
    return nums;
}",1.0,111111
Array_list_1,1355749,2212372,"void del(int*nums,int length,int idx){
    nums[idx]=nums[length-1];
}
int buyCar(int* nums, int length, int k) {
int s=0;

while(1){
int min=nums[0];
int n=0;
for(int i=0;i<length;i++){
if(nums[i]<=min){min=nums[i];
n=i;}
}
del(nums,length,n);
length--;
if(k>=min){k-=min;
s++;}
else{break;}
}
return s;
}",1.0,1111111111
Array_list_2,1355749,2212372,"bool consecutiveOnes(vector<int>& nums) {
    int idx=0;
    if(nums.size()==0){return 1;}
    for(int i=0;i<nums.size();i++){
        if(nums[i]==1){
        for(int j=i;j<nums.size();j++){
            if(nums[j]!=1){idx=j;
            break;}
}    
     for(idx;idx<nums.size();idx++){
    if(nums[idx]==1){return 0;}
            }

        
    }}
return 1;}",1.0,1111111111
Array_list_3,1355749,2212372,"bool consecutiveOnes(vector<int>& nums) {
    int idx=0;
    if(nums.size()==0){return 1;}
    for(int i=0;i<nums.size();i++){
        if(nums[i]==1){
        for(int j=i;j<nums.size();j++){
            if(nums[j]!=1){idx=j;
            break;}
}    
     for(idx;idx<nums.size();idx++){
    if(nums[idx]==1){return 0;}
            }

        
    }}
return 1;}",1.0,1111111111
Array_list_4,1355749,2212372,"bool consecutiveOnes(vector<int>& nums) {
    int idx=0;
    if(nums.size()==0){return 1;}
    for(int i=0;i<nums.size();i++){
        if(nums[i]==1){
        for(int j=i;j<nums.size();j++){
            if(nums[j]!=1){idx=j;
            break;}
}    
     for(idx;idx<nums.size();idx++){
    if(nums[idx]==1){return 0;}
            }

        
    }}
return 1;}",1.0,1111111111
Array_list_5,1355749,2212372,"int equalSumIndex(vector<int>& nums) {
    
    int n = nums.size();
 
    vector<int> right(n);
    right[n-1] = nums[n-1];

for(int i=n-2;i>=0;i--){
   right[i] += nums[i] + right[i+1];
}
int sum = 0;
for(int i = 0; i < n; i++)
{
    sum += nums[i];
    if(sum == right[i])
        return i;
}
return -1;
}",1.0,1111111111
Array_list_6,1355749,2212372," int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int n = words.size();
    if(!n)
        return 0;
    int cMax=1;
    int count = 1;
    
    for(int i=1;i<n; i++)
    {
        if(words[i][0] == words[i-1][0])
        {
            count++;
            cMax = max(count, cMax);
        }
        else
            count = 1;
    }
    
    return cMax;
}",1.0,1111111
Array_list_7,1355749,2212372,"int solve(int**dp, int* nums, int i, int n, int tempMax, int a, int& k)
{
    
    if(i >= n)
    {
        if(a == 1)
            return 0;
        return tempMax*(a-1);
    }
   
      if(dp[i][a] != -1)
        return dp[i][a];
    int choose = -10;
    if(a + 1 <= k)
        choose = solve(dp, nums, i+1, n, max(tempMax, nums[i]), a+1, k);
    int notchoose = max(tempMax, nums[i])*a + solve(dp, nums, i+1, n, -10, 1, k);
    return dp[i][a] = max(choose, notchoose);
}
int maxSum(int* nums, int n, int k) {
    int**dp = new int*[n+1];
    for(int i = 0; i <= n; i++)
    {
        dp[i] = new int[k+1];
        for(int x = 0; x <= k; x++)
            dp[i][x] = -1;

    }
    
return solve(dp, nums, 0, n, -10, 1, k);


}


",1.0,11111
Array_list_8,1355749,2212372,"int solve(vector<int>& nums, int& n, int& k)
{
    if(k >= n )
        return 0;
    
    int ans = INT_MAX;
    for(int begin = 0; begin <= n-k; begin++)
    {
        int minE=  INT_MAX;
        int maxE = INT_MIN;
        for(int i = 0; i < n; i++)
        {
            if(i >= begin && i < begin+k)
            {
                continue;
            }
            minE = min(minE, nums[i]);  
            maxE = max(maxE, nums[i]);
        }
    
        ans = min(ans, maxE-minE);
    }
    return ans;
}
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    return solve(nums, n, k);
}
",0.9,1111111110
Array_list_9,1355749,2212372,"int steadySpeed(vector<int>& positions) {
    int speed=positions[1]-positions[0];
    int st=2;
    int s=2;
    int n=positions.size();
   for(int i=1;i<n;i++){
     int  sp=positions[i+1]-positions[i];
     
     if(speed==sp || speed==(-sp)){s++;}
     else{speed=sp;
     s=2;}
     if(s>st){st=s;}
    }
return st;
}",0.25,111111111111111
Array_list_10,1355749,2212372,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int n = nums.size();
    int ans = INT_MIN;
    for(int i = n-1; i >= 1; i--)
    {
        for(int j = 0; j < i; j++)
        {
            if(nums[i]+nums[j] >= target)
                break;
            ans = max(ans, nums[i]+nums[j]);
        }
    }
    return ans;
}",1.0,1111111111
Array_list_11,1355749,2212372,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
   int n=operations.size();
   for (int i=0;i<n;i++){
       for (int j=operations[i][0];j<=operations[i][1];j++){
           nums[j]+=operations[i][2];
       }
   }
    return nums;
}",1.0,111111
Array_list_3,1356566,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
}",0.1,0000000100
Array_list_1,1359826,2210578,"int buyCar(int* nums, int length, int k) {
    sort(nums,nums+length);
    int sum = 0;
  
    for(int i = 0; i < length; i++){
        sum+= nums[i];
        if(sum>k)  return i;
    }
   
}",1.0,1111111111
Array_list_2,1359826,2210578,"bool consecutiveOnes(vector<int>& nums) {
   int n= nums.size();
   if(n==0) return true;
   int first=-1, last = -1;
   for(int i = 0; i < n; i++){
       if(nums[i]==1&&first==-1) first = i;
        if(nums[i]==1&&first!=-1) last = i;
   }
   for(int i = first; i<=last;i++){
       if(nums[i]!= 1) return false;
   }
   return true;
}",1.0,1111111111
Array_list_3,1359826,2210578,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER 
    int n= nums.size();
   if(n==0) return true;
   int first=-1, last = -1;
   for(int i = 0; i < n; i++){
       if(nums[i]==1&&first==-1) first = i;
        if(nums[i]==1&&first!=-1) last = i;
   }
   for(int i = first; i<=last;i++){
       if(nums[i]!= 1) return false;
   }
   return true;
}",1.0,1111111111
Array_list_4,1359826,2210578,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
   if(n==0) return true;
   int first=-1, last = -1;
   for(int i = 0; i < n; i++){
       if(nums[i]==1&&first==-1) first = i;
        if(nums[i]==1&&first!=-1) last = i;
   }
   for(int i = first; i<=last;i++){
       if(nums[i]!= 1) return false;
   }
   return true;
}",1.0,1111111111
Array_list_5,1359826,2210578,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size(); int left=0,sum=0;
   for(int i=0;i<n;i++){
       sum+=nums[i];
   }
    for(int i=0;i<n;i++){
        sum-=nums[i];
       if(left==sum) return i;
        left+=nums[i];
        
         
    }
   
    return -1;
}",1.0,1111111111
Array_list_6,1359826,2210578,"int longestSublist(vector<string>& words) {
    int count=0;
    int n=words.size();
    int alphabet[52]={0};
    for(int i=0;i<n;i++){
        string temp=words[i];
       if(temp[0]>=97) alphabet[temp[0]-97]++;
       else alphabet[temp[0]-65+26]++;
    }
    for(int i=0;i<52;i++){
        if(count<alphabet[i]) count=alphabet[i];
    }
    return count;
}",0.29,1100000
Array_list_8,1359826,2210578,"vector<int> sort(vector<int>&nums){
    int n = nums.size();
    for (int i = 0; i < n-1; i++) {     
        for (int j = 0; j < n-i-1; j++) { 
            if (nums[j] > nums[j+1]) {
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
    return nums;}
int minimumAmplitude(vector<int>& nums, int k) {
    nums=sort(nums);
    int n = nums.size();
    int res = nums[n-1] - nums[0];
    for (int i = 0; i <= k; ++i) {
       
        if(res>nums[n-k+i-1] - nums[i]) res=nums[n-k+i-1] - nums[i];
    }
    return res;
}",0.5,100000000
Array_list_10,1359826,2210578,"int sumLessThanTarget(vector<int>& nums, int target) {
   int n = nums.size();
   int maxsum=INT_MIN;
    int left=0, right =n-1;
    while(left<right){
        int sum=nums[left]+nums[right];
        if(sum<target){
            if(sum>maxsum) maxsum=sum;
            left++;
        }
        else{
            right--;
        }
    }
   return maxsum;
}",1.0,1111111111
Array_list_11,1359826,2210578,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    int n = operations.size();
    for(int i=0;i<n;i++){
        int L=operations[i][0],R=operations[i][1],X=operations[i][2];
        for(int a = L;a<=R;a++){
            nums[a]+=X;
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1360890,2213298,"int buyCar(int* nums, int length, int k) {
    std::sort(nums, nums + length);
    int count = 0;
    for (int i = 0; i < length; i++) {
        if (k >= nums[i]) {
            k -= nums[i];
            count++;
        } 
        else break;
    }
    return count;
}",1.0,1111111111
Array_list_2,1360890,2213298,"bool consecutiveOnes(vector<int>& nums) {
    int size = nums.size();
    if(size == 0) return 1;
    bool b = false;
    int i = 0;
    while(!b && i < size) {
        if(nums[i] == 1) b = true;
        i++;
    }
    while(b && i < size) {
        if(nums[i] != 1) b = false;
        i++;
    }
    while(!b && i < size) {
        if(nums[i] == 1) return false;
        i++;
    }
    return 1;
}",1.0,1111111111
Array_list_3,1360890,2213298,"bool consecutiveOnes(vector<int>& nums) {
    int size = nums.size();
    if(size == 0) return 1;
    bool b = false;
    int i = 0;
    while(!b && i < size) {
        if(nums[i] == 1) b = true;
        i++;
    }
    while(b && i < size) {
        if(nums[i] != 1) b = false;
        i++;
    }
    while(!b && i < size) {
        if(nums[i] == 1) return false;
        i++;
    }
    return 1;
}",1.0,1111111111
Array_list_4,1360890,2213298,"bool consecutiveOnes(vector<int>& nums) {
    int size = nums.size();
    if(size == 0) return 1;
    bool b = false;
    int i = 0;
    while(!b && i < size) {
        if(nums[i] == 1) b = true;
        i++;
    }
    while(b && i < size) {
        if(nums[i] != 1) b = false;
        i++;
    }
    while(!b && i < size) {
        if(nums[i] == 1) return false;
        i++;
    }
    return 1;
}",1.0,1111111111
Array_list_5,1360890,2213298,"int equalSumIndex(std::vector<int>& nums) {
    int total_sum = 0;
    for (int num : nums) {
        total_sum += num;
    }
    
    int left_sum = 0;
    for (int i = 0; i < nums.size(); ++i) {
        if (left_sum == total_sum - left_sum - nums[i]) {
            return i;
        }
        left_sum += nums[i];
    }
    
    return -1;
}",1.0,1111111111
Array_list_6,1360890,2213298,"int max(int a, int b) { return (a > b) ? a : b; }

int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if (words.empty()) return 0;
    int currentlength = 1;
    int maxlength = 1;
    char firstletter = words[0][0];
    for (int i = 1; i < words.size(); i++) {
        char currentfirstletter = words[i][0];
        if (firstletter == currentfirstletter) {
            currentlength++;
            maxlength = max(maxlength, currentlength);
        }
        else {
            firstletter = currentfirstletter;
            currentlength = 1;
        }
    }
    return maxlength;
}",1.0,1111111
Array_list_7,1360890,2213298,"int max(int a, int b) { return (a > b) ? a : b; }

int maxSum(int* nums, int n, int k) {
    int dp[10005] = {0};
    for (int i = 0; i < n; i++) {
        int maxElement = nums[i];
        for (int j = 1; j <= k && i - j + 1 >= 0; j++) {
            maxElement = max(maxElement, nums[i - j + 1]);
            dp[i] = max(dp[i], ((i >= j) ? dp[i - j] : 0) + maxElement * j);
        }
    }
    return dp[n - 1];
}",1.0,11111
Array_list_8,1360890,2213298,"void quickSort(vector<int>& nums, int left, int right) {
    int l = left, r = right;
    int mid = nums[(l+r)/ 2];
    while (l < r) {
        while (nums[l] < mid) l++;
        while (mid < nums[r]) r--;
        if ( l <= r ) {
            swap(nums[l], nums[r]);
            l++; r--;
        } 
    }
    if (l < right) quickSort(nums, l, right);
    if (left < r) quickSort(nums, left, r);
}

int minimumAmplitude(vector<int>& nums, int k) {
    quickSort(nums, 0, nums.size() - 1);
    // 371 375 412 433 1063 3680 4100 6424 7366 8734 
    int minAmplitude = INT_MAX;
    for (int i = 0; i <= k; i++) {
        minAmplitude = std::min(minAmplitude, nums[nums.size() - 1 - k + i] - nums[i]);
    }
    return minAmplitude;
}",0.1,1000000000
Array_list_9,1360890,2213298,"int steadySpeed(vector<int>& positions) {
    int count = 2;
    vector<int> rac;
    for (unsigned int index = 0; index < positions.size() - 2;index++) {
        int speed1 = positions[index + 1] - positions[index];
        int speed2 = positions[index + 2] - positions[index + 1];
        if (abs(speed1) == abs(speed2)) count++;
        else {
            rac.push_back(count);
            count = 2;
        }
    }
    rac.push_back(count);
    int max = rac[0];
    for (auto x : rac) if (x > max) max = x;
    return max;
}",1.0,111111111111111
Array_list_10,1360890,2213298,"int max(int a, int b) { return (a>b) ? a : b; }

int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    vector<int> newnum;
    int maxsum = INT_MIN;
    for (auto x : nums) if (x <= target) newnum.push_back(x);
    for (int i = 0; i < newnum.size(); i++) {
        for (int j = i + 1; j < newnum.size(); j++) {
            if (newnum[i] + newnum[j] < target) {
                maxsum = max(maxsum, newnum[i] + newnum[j]);
            }
        }
    }
    return maxsum;
}",1.0,1111111111
Array_list_11,1360890,2213298,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for (unsigned int i = 0; i < nums.size(); i++) {
        for (unsigned int j = 0; j < operations.size(); j++) { 
            if ((int) i >= operations[j][0] && (int) i <= operations[j][1]) nums[i] += operations[j][2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1361294,2213250,"int buyCar(int* nums, int length, int k) {
sort(nums, nums + length);
int index=0;
while(index< length && k>0)
{
if(k>= nums[index]) k-=nums[index]; else break;
index++;
}
return index;
}",1.0,1111111111
Array_list_2,1361294,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_3,1361294,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_4,1361294,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_5,1361294,2213250,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
  int n = nums.size();
    int totalSum = 0;
    for (int a=0; a<n; a++) {
        totalSum += nums[a];
    }
    int leftSum = 0;
    for (int i = 0; i < n; i++) {
        if (leftSum == (totalSum - leftSum - nums[i])) {
            return i;
        }
        leftSum += nums[i];
    }
    return -1;
}
",1.0,1111111111
Array_list_6,1361294,2213250,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int length = words.size();
    if(words.size() == 0) return 0;
    int clen = 1;
    int maxlen = 1;
    char fletter= words[0][0];
    for (int i=1; i< length;i++)
    {
        if(words[i][0]== fletter){
            clen++;
        }
        else{
            fletter = words[i][0];
            clen =1;
        }
        if (clen> maxlen){
            maxlen= clen;
        }
    }
    if (clen> maxlen){
        maxlen= clen;
    }
    return maxlen;
}",1.0,1111111
Array_list_7,1361294,2213250,"int max_array(int* nums , int l , int r){
    int ans = (int)(-1e9);
    for(int i= l ; i<=r ; i++){
        ans = max(ans,nums[i]);
    }
    return ans;
}

int maxSum(int* nums, int n, int k) {
    int dp[10001];
    for(int i=0 ; i<k ; i++){
        dp[i] = max_array(nums,0,i)*(i+1);
    }
    for(int i = k ; i<n;i++){
        for(int j = 1 ; j<=k;j++){
            dp[i] = max(dp[i], max_array(nums,i-j+1, i)*j + dp[i-j]);
        }
    }
    return dp[n-1];
}",0.8,11010
Array_list_8,1361294,2213250,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int ans= INT_MAX;
    int n = nums.size();
    if (k >= n) {
        return 0;
    }
  
    for( int j= 0; j<n-k; j++){
        int max_nums = (int)(-1e9);
        int min_nums = (int)(1e9);
    for(int i = 0 ; i<n;i++){

        if(i<j || i>j+k-1){
            max_nums = max(max_nums,nums[i]);
            min_nums = min(min_nums,nums[i]);
        }

    }
            ans = min(ans, max_nums - min_nums);
    }
    return ans;
}",0.9,1111111110
Array_list_9,1361294,2213250,"int steadySpeed(vector<int>& positions) {
    int csub =2, sfsub=0;
    int n = positions.size();
    if( n <= 2){ return n;}
    for (int i =2 ; i<n; i++){
        if(abs(positions[i-1]-positions[i-2]) == abs(positions[i-1]-positions[i])){
            csub++;
            sfsub = max(csub, sfsub);
        }
        else{
            csub = 2;
            sfsub = max(csub, sfsub);
        }
    }
    return sfsub;
}",1.0,111111111111111
Array_list_10,1361294,2213250,"int sumLessThanTarget(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int maxSum = INT_MIN;

    while (left < right) {
        int currentSum = nums[left] + nums[right];

        if (currentSum < target) {
            maxSum = max(maxSum, currentSum);
            left++; 
        } else {
            right--;
        }
    }

    return maxSum;
}



",1.0,1111111111
Array_list_11,1361294,2213250,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int n = operations.size();
    for (int i=0;i< n;i++){
        for(int j= operations[i][0]; j<= operations[i][1];j++){
            nums[j]+= operations[i][2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1369169,2213836,"int buyCar(int* nums, int length, int k) {
    //* xếp giá tiền tăng dần
    sort(nums, nums + length);
    int count = 0;
    for(int i = 0; i < length; i++) {
        //* nếu giá tiền còn nhiều hơn giá xe thì mua
        if(k >= nums[i]) {
            k -= nums[i];
            count++;
        }
        else break;
    }
    //* trả về số xe mua được
    return count;
}",1.0,1111111111
Array_list_2,1369169,2213836,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int count = 0;
    int index = 0;
    for(int i = 0; i < nums.size(); i++) {
        while(nums[i] == 1) {
            count++;
            index =  i + 1;
            i++;
        }
        if(count > 0) {
            for(;index < nums.size(); index++) {
                if(nums[index] == 1) return false;
            }
        }
    }

    //* rỗng hoặc số 1 liên tục
    if(count > 0 || nums.empty()) return true;
    return false;
}",1.0,1111111111
Array_list_3,1369169,2213836,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int count = 0;
    int index = 0;
    for(int i = 0; i < nums.size(); i++) {
        while(nums[i] == 1) {
            count++;
            index =  i + 1;
            i++;
        }
        if(count > 0) {
            for(;index < nums.size(); index++) {
                if(nums[index] == 1) return false;
            }
        }
    }

    //* rỗng hoặc số 1 liên tục
    if(count > 0 || nums.empty()) return true;
    return false;
}",1.0,1111111111
Array_list_4,1369169,2213836,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int count = 0;
    int index = 0;
    for(int i = 0; i < nums.size(); i++) {
        while(nums[i] == 1) {
            count++;
            index =  i + 1;
            i++;
        }
        if(count > 0) {
            for(;index < nums.size(); index++) {
                if(nums[index] == 1) return false;
            }
        }
    }

    //* rỗng hoặc số 1 liên tục
    if(count > 0 || nums.empty()) return true;
    return false;
}",1.0,1111111111
Array_list_5,1369169,2213836,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int totalSum = 0;
    int leftSum = 0;
    //* tính tổng giá trị
    for(int i = 0; i < nums.size(); i++) {
        totalSum += nums[i];
    }
    for(int i = 0; i < nums.size(); i++) {
        totalSum -= nums[i];
        //* xét xem tổng trái và tổng phải bằng nhau chưa
        if(totalSum == leftSum) return i;

        leftSum += nums[i];
    }
    //* nếu không có thì return -1
    return -1;
}",1.0,1111111111
Array_list_6,1369169,2213836,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER

    if(words.empty()) return 0;
    int count = 1;
    int MAX = 0;
    int len = words.size();
    char c = words[0][0]; //* lấy char đầu trong string
    for(int i = 1; i < len; i++) {
        if(words[i][0] == c) count ++;
        else {
            MAX = max(count, MAX);
            c = words[i][0];
            count = 1;
        }
    }

    return max(count, MAX);
}",1.0,1111111
Array_list_7,1371132,2213250,"int max_array(int* nums, int l, int r)
{
	int ans = -1e9;
	for (int i = l; i <= r; i++)
	{
		ans = max(ans, nums[i]);
	}
	return ans;
}




int maxSum(int* nums, int n, int k) 
{
	int dp[10000];
	for (int i = 0; i < k; i++)
	{
		dp[i] = max_array(nums, 0, i) * (i + 1);
	}
	for (int i = k; i < n; i++)
	{
		for (int j = k; j >= 0; j--)
		{
			dp[i] = max(dp[i], dp[i - j] + max_array(nums, i - j + 1, i) * j);
		}
	}
	return dp[n - 1];
}",0.6,11010
Array_list_8,1371132,2213250,"int mins[1000]{}, maxs[1000]{}, mine[1000]{}, mmaxe[1000]{};

int minimumAmplitude(vector<int>& nums, int k) {
	int ans = 1e9;
	int n = nums.size();
	int* mins = new int[n] {};
	int* mine = new int[n] {};
	int* maxs = new int[n] {};
	int* maxe = new int[n] {};
	mins[0] = nums[0];
	maxs[0] = nums[0];
	mine[n - 1] = nums[n - 1];
	maxe[n - 1] = nums[n - 1];
	for (int i = 1; i < n; i++)
	{
		mins[i] = min(mins[i - 1], nums[i]);
		maxs[i] = max(maxs[i - 1], nums[i]);
	}
	for (int i = n-2; i >= 0; i--)
	{
		mine[i] = min(mine[i + 1], nums[i]);
		maxe[i] = max(maxe[i + 1], nums[i]);
	}
	int min_arr = 0;
	int max_arr = 0;
	for (int i = 0; i < n-k; i++)
	{
		if(i!= 0) min_arr = min(mins[i-1], mine[i+k]);
		else min_arr = mine[i + k];
		if (i + k < n - 1) max_arr = max(maxs[i - 1], maxe[i + k]);
		else max_arr = maxs[i];
		ans = min(ans, max_arr - min_arr);
	}
	return ans;
}",1.0,1111111111
Array_list_2,1373395,2212282,"bool consecutiveOnes(vector<int>& nums) {
    bool s1 = 0;
    bool s2 = 0;
    
    for(int i : nums) {
        if(i == 1 && s1 == 0) s1 = 1;
        if(i != 1 && s1 == 1) s2 = 1;
        if(i == 1 && s2 == 1) return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_3,1373395,2212282,"bool consecutiveOnes(vector<int>& nums) {
    bool s1 = 0;
    bool s2 = 0;
    
    for(int i : nums) {
        if(i == 1 && s1 == 0) s1 = 1;
        if(i != 1 && s1 == 1) s2 = 1;
        if(i == 1 && s2 == 1) return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_4,1373395,2212282,"bool consecutiveOnes(vector<int>& nums) {
    bool s1 = 0;
    bool s2 = 0;
    
    for(int i : nums) {
        if(i == 1 && s1 == 0) s1 = 1;
        if(i != 1 && s1 == 1) s2 = 1;
        if(i == 1 && s2 == 1) return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_5,1373395,2212282,"int equalSumIndex(vector<int>& nums) {
    int mid = nums.size()/2;
    int sumLeft  = 0;
    int sumRight = 0;
    bool oneSide = 1;
    
    for(int i = mid-1; i>=0; --i)          sumLeft  += nums[i];
    for(int i = mid+1; i<nums.size(); ++i) sumRight += nums[i];
    
    while(mid >= 0 && mid < nums.size()) {
        if(sumLeft == sumRight) return mid;
        else {
            if(sumLeft > sumRight) {
                mid--;
                sumLeft  -= nums[mid];
                sumRight += nums[mid+1]; 
                if(sumLeft < sumRight) return -1;
            }
            else {
                mid++;
                sumLeft  += nums[mid-1];
                sumRight -= nums[mid];
                if(sumLeft > sumRight) return -1;
            }
        }
        
    }
    
    return -1;
}",1.0,1111111111
Array_list_6,1373395,2212282,"int longestSublist(vector<string>& words) {
    int count = 0;
    int tmp = 0;
    
    if(words.size() == 0) return count;
    for(int i=0; i<words.size()-1; i++) {
        if(words[i][0] == words[i+1][0]) {
            ++tmp;
        }
        else tmp = 0;
        
        count = max(count, tmp);
    }
    
    return count ? count + 1 : 0;
}",1.0,1111111
Array_list_8,1373395,2212282,"void sort(vector<int>& nums) {
    int size = nums.size();
    
    for(int i=0; i<size; ++i) {
        for(int j=i+1; j<size; ++j) {
            if(nums[i] > nums[j]) swap(nums[i], nums[j]);
        }
    }
}

int minimumAmplitude(vector<int>& nums, int k) {
    sort(nums);
    int mini  = INT_MAX;
    int size = nums.size()-1;
    
    for(int i=0; i<k; ++i) {
        mini = min(nums[size-k+i] - nums[i], mini);
    }
    
    return mini;
}",0.1,000000000
Array_list_10,1373395,2212282,"int sumLessThanTarget(vector<int>& nums, int target) {
    int count  = 0;
    int left   = 0;
    int right  = nums.size()-1;
    
    while(left < right) {
        if(nums[right] - nums[left] < target) {
            count += right - left;
            right--;
        }
        else left++;
    }
    
    return target-1;
}",0.4,1000000111
Array_list_11,1373395,2212282,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    for(vector<int> scan : operations) {
        for(int i = scan[0]; i<=scan[1]; ++i) {
            nums[i] += scan[2];
        }
    }
    
    return nums;
}",1.0,111111
Array_list_8,1374158,2212935,"vector<int>sort(vector<int>& a){
    int n = a.size();
    for (int i = 0; i < n; i++){
        for (int j = i+1; j < n; j++){
            if(a[i]>a[j])
            {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    return a;
}
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if (k >= n) return 0;
    int minAmplitude = INT_MAX;
    for (int i = 0; i < n-k; i++){
        vector<int>a;
        for (int j = 0; j < n; j++){
            if (j >=i && j < i + k){
                continue;
            }
            a.push_back(nums[j]);
        }
        sort(a);
        minAmplitude = min(minAmplitude, (a[n-k-1]-a[0]));
        a.clear();
    }
    
    return minAmplitude;
}",0.5,111110
Array_list_1,1374306,2211821,"int buyCar(int* nums, int length, int k) {
sort(nums,nums +length);
int count =0;
for (int i =0;i <length;i++){
k=k-nums[i];
if(k>=0) count++; else break;
}
return count;
}",1.0,1111111111
Array_list_2,1374306,2211821,"bool consecutiveOnes(vector<int>& nums) {
    bool x = 1;
    int len = nums.size();
    if (len == 0) return x;
    else {
        int h;
        for (h = 0;h < len;h++) {
            if (nums[h] == 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] != 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] == 1) {
                x = 0;
                break;
            }
        }
        return x;
    }
}",1.0,1111111111
Array_list_3,1374306,2211821,"bool consecutiveOnes(vector<int>& nums) {
    bool x = 1;
    int len = nums.size();
    if (len == 0) return x;
    else {
        int h;
        for (h = 0;h < len;h++) {
            if (nums[h] == 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] != 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] == 1) {
                x = 0;
                break;
            }
        }
        return x;
    }
}",1.0,1111111111
Array_list_4,1374306,2211821,"bool consecutiveOnes(vector<int>& nums) {
    bool x = 1;
    int len = nums.size();
    if (len == 0) return x;
    else {
        int h;
        for (h = 0;h < len;h++) {
            if (nums[h] == 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] != 1) break;
        }
        for (h = h + 1;h < len;h++) {
            if (nums[h] == 1) {
                x = 0;
                break;
            }
        }
        return x;
    }
}",1.0,1111111111
Array_list_5,1374306,2211821,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sum =0;
    int len = nums.size();
    if (len == 0) return -1;
    if (len == 1) return 0;
    for (int i=0;i<len;i++){
        sum += nums[i];
    }
    int sumleft =0;
    for (int i =0 ;i<len;i++){
        sumleft += nums[i];
        int sum2 =sum +nums[i];
        if(2*sumleft == sum2) return i;
    }
    return -1;
}",1.0,1111111111
Array_list_6,1374306,2211821,"int longestSublist(vector<string>& words) {
int longest = 0;
    int currentLength = 1; 

    if (words.empty()) {
        return longest;
    }

    char currentFirstLetter = words[0][0];
    for (int i = 1; i < words.size(); i++) {
        if (words[i][0] == currentFirstLetter) {
            currentLength++;
        } else {
            longest = max(longest, currentLength);
            currentFirstLetter = words[i][0];
            currentLength = 1; 
        }
    }
    longest = max(longest, currentLength);

    return longest;
}",1.0,1111111
Array_list_7,1374306,2211821,"int maxSum(int* nums, int n, int k) {
     if(n<=0) return 0;
      if (n <= k) {
        int max = 0;
        for (int i = 0; i < n; i++) {
            if (max < nums[i]) max = nums[i];
        }
        return max * n;
    }
    
    int dp[k] = {0};
    for (int i = 1; i <= k; i++) {
        int max = 0;
        for (int j = 0; j < i; j++) {
            if (max < nums[j]) max = nums[j];
        }
        dp[i - 1] = max * i + maxSum(nums + i, n - i, k);
    }
    
    int maxMuti = dp[0];
    for (int i = 1; i < k; i++) {
        if (maxMuti < dp[i]) maxMuti = dp[i];
    }
    
    return maxMuti;
}",1.0,11110
Array_list_8,1374306,2211821,"int min(int a,int b){
    if(a <b) return a;
    else return b;
}
int max(int a,int b){
    if(a>b) return a;
    else return b;
}


int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int len =nums.size();
    vector<int> lmin, lmax, rmin, rmax;
    for(int i =0; i< len;i++){
        lmin.push_back(nums[i]);
        rmin.push_back(nums[i]);
        lmax.push_back(nums[i]);
        rmax.push_back(nums[i]);
    }
    for(int i =1; i< len;i++){
       lmin[i] = min(lmin[i],lmin[i-1]);
       lmax[i] = max(lmax[i],lmax[i-1]);
    }
    for(int i =len-2; i>=0;i--){
       rmin[i] = min(rmin[i],rmin[i+1]);
       rmax[i] = max(rmax[i],rmax[i+1]);
    }
    int ans= min (lmax[k]-lmin[k],rmax[k]-rmin[k]);
    for (int i=0;i<len-1-k;i++){
        int c =max(lmax[i],rmax[i+k+1])-min(lmin[i],rmin[i+k+1]);
        ans = min(ans,c);
    }
    return ans;
}",1.0,1111111111
Array_list_9,1374306,2211821,"int steadySpeed(vector<int>& p) {
    int n = p.size();
    if (n <= 1) {
        return n;
    }

    int max_length = 1;
    int current_length = 1;
    int current_speed = abs(p[1] - p[0]); 

    for (int i = 1; i < n - 1; i++) {
        int speed = abs(p[i + 1] - p[i]);

        if (speed == current_speed) {
            current_length++;
        } else {
            max_length = max(max_length, current_length);
            current_length = 1;
            current_speed = speed;
        }
    }
    max_length = max(max_length, current_length);

    return max_length +1;
}",1.0,111111111111111
Array_list_10,1374306,2211821,"int sumLessThanTarget(vector<int>& nums, int target) {
 int left = 0;
    int right = nums.size() - 1;
    int maxSum = INT_MIN;

    while (left < right) {
        int currentSum = nums[left] + nums[right];

        if (currentSum < target) {
            maxSum = max(maxSum, currentSum);
            left++;
        } else {
            right--;
        }
    }

    return maxSum;
}",1.0,1111111111
Array_list_11,1374306,2211821,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    int n = nums.size();
    vector<int> result(n, 0);

    for (const vector<int>& op : operations) {
        int L = op[0];
        int R = op[1];
        int X = op[2];

        // Áp dụng phép cập nhật vào mảng kết quả
        for (int i = L; i <= R; i++) {
            result[i] += X;
        }
    }
    for (int i=0;i<n;i++){
        result[i] += nums[i];
    }
    return result ;
}",1.0,111111
Array_list_1,1374982,2210034,"void quickSort(int a[], int l, int r)
{
    int index = (l + r) / 2;
    int p = a[(index)];
    int head = l;
    int tail = r;
    while(l < r)
    {
        while(a[l] < p)
        {
            l++;
        }
        while(a[r] > p)
        {
            r--;
        }
        if(l <= r)
        {
            int tmp = a[l];
            a[l] = a[r];
            a[r] = tmp;
            l++;
            r--;
        }
    }
    if(l < tail)    quickSort(a, l,tail);
    if(r > head)    quickSort(a, head, r);

}

int buyCar(int* nums, int length, int k) {
    int count = 0, i = 0;
    quickSort(nums, 0, length - 1);
    do
    {
        k = k - nums[i];
        if(k >= 0) count++;
        i++;
    }
    while(k > 0);
    return count;
    
}",1.0,1111111111
Array_list_2,1374982,2210034,"
bool consecutiveOnes(vector<int>& nums)
{
    if(nums.size() == 0) return true;
    int i = 0;
    bool a = true;
    while(nums[i] != 1 && i < nums.size())
    {
        i++;
    }
    while(nums[i] == 1 && i < nums.size())
    {
        i++;   
    }
    for(; i < nums.size() ; ++i)
    {
        if(nums[i] != 1 ) continue;
        else 
        {
            a = false;
            break;
        }
    }
    return a;
}",1.0,1111111111
Array_list_3,1374982,2210034,"bool consecutiveOnes(vector<int>& nums)
{
    if(nums.size() == 0) return true;
    int i = 0;
    bool a = true;
    while(nums[i] != 1 && i < nums.size())
    {
        i++;
    }
    while(nums[i] == 1 && i < nums.size())
    {
        i++;   
    }
    for(; i < nums.size() ; ++i)
    {
        if(nums[i] != 1 ) continue;
        else 
        {
            a = false;
            break;
        }
    }
    return a;
}",1.0,1111111111
Array_list_4,1374982,2210034,"bool consecutiveOnes(vector<int>& nums)
{
    if(nums.size() == 0) return true;
    int i = 0;
    bool a = true;
    while(nums[i] != 1 && i < nums.size())
    {
        i++;
    }
    while(nums[i] == 1 && i < nums.size())
    {
        i++;   
    }
    for(; i < nums.size() ; ++i)
    {
        if(nums[i] != 1 ) continue;
        else 
        {
            a = false;
            break;
        }
    }
    return a;
}",1.0,1111111111
Array_list_5,1374982,2210034,"int equalSumIndex(vector<int>& nums) {
    int nums2[nums.size()];
    nums2[0] = nums[0];
    for(int i = 1; i < nums.size(); ++i)
    {
        nums2[i] = nums2[i-1] + nums[i];
    }
    int nums3[nums.size()];
    nums3[nums.size() - 1] = nums[nums.size() - 1];
    for(int i = nums.size() - 2; i >= 0; --i)
    {
        nums3[i] = nums3[i+1] + nums[i];
    }
    for(int i = 0; i < nums.size(); ++i)
    {
        if(nums3[i] == nums2[i]) return i;
    }
    return -1;
}",1.0,1111111111
Array_list_6,1374982,2210034,"

// Main function to find the length of the longest subarray

int longestSublist(vector<string>& words) {
    if (words.empty()) return 0;

    int maxCount = 1;
    int currentCount = 1;

    for (int i = 1; i < words.size(); ++i) {
        if (words[i][0] == words[i - 1][0] ) {
            currentCount++;
        } else {
            maxCount = max(maxCount, currentCount);
            currentCount = 1;
        }
    }

    return max(maxCount, currentCount);

}",1.0,1111111
Array_list_7,1374982,2210034,"#include<vector>
#include <algorithm>
using namespace std;
int maxSum(int* nums, int n, int k) {
    vector<int> dp(n+1, 0);
    for (int i = 1; i <= n; ++i) {
        int max_val = nums[i-1];
        for (int j = i; j > 0 && i-j+1 <= k; --j) {
            max_val = max(max_val, nums[j-1]);
            dp[i] = max(dp[i], dp[j-1] + max_val * (i-j+1));
        }
    }
    return dp[n];
}
",1.0,11111
Array_list_8,1374982,2210034,"#include <algorithm>
#include <climits>

void quickSort(int a[], int l, int r)
{
    int index = (l + r) / 2;
    int p = a[(index)];
    int head = l;
    int tail = r;
    while(l < r)
    {
        while(a[l] < p)
        {
            l++;
        }
        while(a[r] > p)
        {
            r--;
        }
        if(l <= r)
        {
            int tmp = a[l];
            a[l] = a[r];
            a[r] = tmp;
            l++;
            r--;
        }
    }
    if(l < tail)    quickSort(a, l,tail);
    if(r > head)    quickSort(a, head, r);

}
int minimumAmplitude(std::vector<int>& nums, int k)
{
    int sum = 0;
    int start = 0;
    bool check = false;
    for(int i = 0; i < size; ++i)
    {
        sum += a[i];
        while(sum > val)
        {
            sum -= a[start];
            start++;
        }
        if(sum == val)
        {
            check = true;
            for(int j = start; j <= i; ++j)
            {
                cout << a[j] << "" "";
            }
            break;
        }
    }
    if(!check) cout << ""-1"";
    return 0;
}",0.3,
Array_list_9,1374982,2210034,"
#include <cmath>

int steadySpeed(std::vector<int>& p)
{
    int max_count = 0;
    int count = 1;
    int save = -1;
    for(unsigned int i = 0; i < p.size() - 1; ++i)
    {
        if(abs(p[i+1] - p[i]) == save)
        {
            count++;
        }
        else
        {
            save = abs(p[i+1] - p[i]);
            count = 1;
        }
        if(count > max_count) max_count = count;
    }
    return max_count + 1;
    
}
",0.9,111111111111111
Array_list_10,1374982,2210034,"int sumLessThanTarget(vector<int>& nums, int target) {
    int n = nums.size();
    int left = 0; // Initialize the left pointer at the beginning of the array.
    int right = n - 1; // Initialize the right pointer at the end of the array.
    int maxSum = INT_MIN; // Initialize maxSum to a very small value.

    while (left < right) {
        int currentSum = nums[left] + nums[right];
        if (currentSum < target) {
            // If the current sum is less than the target, update maxSum and move the left pointer to the right.
            maxSum = max(maxSum, currentSum);
            left++;
        } else {
            // If the current sum is greater than or equal to the target, move the right pointer to the left.
            right--;
        }
    }

    return maxSum;
}
",1.0,1111111111
Array_list_11,1374982,2210034,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    
    
    for (vector<int>& operation : operations) {
        int L = operation[0];
        int R = operation[1];
        int X = operation[2];
        
        // Apply the operation to the range [L, R]
        for (int i = L; i <= R; i++) {
            nums[i] += X;
        }
    }
    
    return nums;
}",1.0,111111
Array_list_2,1375112,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()) {
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i++]);
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_3,1375112,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()) {
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i++]);
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_4,1375112,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()) {
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i++]);
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_5,1375112,2211738,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size() <=1) return 0;
    int sum = 0;
    for(int i = 0; i < nums.size(); i++){
        sum += nums[i];
    }
    vector<int> Sum;
    Sum.push_back(nums[0]);
    for(int i = 0; i < nums.size(); i++){
        int sum1 = nums[0];
        if(i >= 2){
            sum1 = nums[i-1] + Sum[i-2];
            Sum.push_back(sum1);
        }
        if(sum1 == sum - nums[i] - sum1) return i;
    }
    return -1;
}",1.0,1111111111
Array_list_6,1375112,2211738,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.empty()) return 0;
    int i = 1, p = 0, ans = 1;
    while(i < words.size()){
        if(words[i][0] != words[p][0]){
            p = i;
        }else{
            ans = max(ans, i-p+1);
        }
        i+=1;
    }
    return ans;
}",1.0,1111111
Array_list_11,1375112,2211738,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int len1 = nums.size();
    int len2 = operations.size();
    for(int i = 0; i < len1; i++){
        for(int j = 0; j < len2; j++){
            if(i >= operations[j][0] && i <= operations[j][1]){
                nums[i] += operations[j][2];
            }
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1375151,2213836,"int buyCar(int* nums, int length, int k) {
    //* xếp giá tiền tăng dần
    sort(nums, nums + length);
    int count = 0;
    for(int i = 0; i < length; i++) {
        //* nếu giá tiền còn nhiều hơn giá xe thì mua
        if(k >= nums[i]) {
            k -= nums[i];
            count++;
        }
        else break;
    }
    //* trả về số xe mua được
    return count;
}",1.0,1111111111
Array_list_2,1375151,2213836,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int count = 0;
    int index = 0;
    for(int i = 0; i < nums.size(); i++) {
        while(nums[i] == 1) {
            count++;
            index =  i + 1;
            i++;
        }
        if(count > 0) {
            for(;index < nums.size(); index++) {
                if(nums[index] == 1) return false;
            }
        }
    }

    //* rỗng hoặc số 1 liên tục
    if(count > 0 || nums.empty()) return true;
    return false;
}",1.0,1111111111
Array_list_3,1375151,2213836,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int count = 0;
    int index = 0;
    for(int i = 0; i < nums.size(); i++) {
        while(nums[i] == 1) {
            count++;
            index =  i + 1;
            i++;
        }
        if(count > 0) {
            for(;index < nums.size(); index++) {
                if(nums[index] == 1) return false;
            }
        }
    }

    //* rỗng hoặc số 1 liên tục
    if(count > 0 || nums.empty()) return true;
    return false;
}",1.0,1111111111
Array_list_4,1375151,2213836,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int count = 0;
    int index = 0;
    for(int i = 0; i < nums.size(); i++) {
        while(nums[i] == 1) {
            count++;
            index =  i + 1;
            i++;
        }
        if(count > 0) {
            for(;index < nums.size(); index++) {
                if(nums[index] == 1) return false;
            }
        }
    }

    //* rỗng hoặc số 1 liên tục
    if(count > 0 || nums.empty()) return true;
    return false;
}",1.0,1111111111
Array_list_5,1375151,2213836,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int totalSum = 0;
    int leftSum = 0;
    //* tính tổng giá trị
    for(int i = 0; i < nums.size(); i++) {
        totalSum += nums[i];
    }
    for(int i = 0; i < nums.size(); i++) {
        totalSum -= nums[i];
        //* xét xem tổng trái và tổng phải bằng nhau chưa
        if(totalSum == leftSum) return i;

        leftSum += nums[i];
    }
    //* nếu không có thì return -1
    return -1;
}",1.0,1111111111
Array_list_6,1375151,2213836,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER

    if(words.empty()) return 0;
    int count = 1;
    int MAX = 0;
    int len = words.size();
    char c = words[0][0]; //* lấy char đầu trong string
    for(int i = 1; i < len; i++) {
        if(words[i][0] == c) count ++;
        else {
            MAX = max(count, MAX);
            c = words[i][0];
            count = 1;
        }
    }

    return max(count, MAX);
}",1.0,1111111
Array_list_7,1375151,2213836,"int maxSum(int* nums, int n, int k) {
    int* maxS = new int[n + 1]; //* tạo 1 mảng để lưu giá trị
    maxS[0] = 0;
    
    for(int i = 1; i <= n; i++) { //* duyệt tới n
        maxS[i] = 0;
        int maxElement = 0;
        for(int j = 1; j <= k && (i - j) >= 0; j++) { //* mảng con có j phần tử
            maxElement = max(maxElement, nums[i - j]);
            maxS[i] = max(maxS[i], maxS[i - j] + maxElement * j); //* i - j là vị trí đang xét trong nums
        }
    }

    int result = maxS[n];
    delete[] maxS;
    return result;
}",1.0,11111
Array_list_8,1375151,2213836,"int findMax(vector<int> nums, int l, int r) {
    //tìm vị trí max của vector từ l tới r - 1
    int res = INT_MIN;
    int idx = -1;
    for (int i = l; i < r; i++)
        if (res < nums[i]) {
            res = nums[i];
            idx = i;
        }
    return idx;
}

int findMin(vector<int> nums, int l, int r) {
    //tìm vị trí min của vector từ l tới r - 1
    int res = INT_MAX;
    int idx = -1;
    for (int i = l; i < r; i++)
        if (res > nums[i]) {
            res = nums[i];
            idx = i;
        }
    return idx;
}

int minimumAmplitude(vector<int>& nums, int k) {
    int n = nums.size();
    int res = INT_MAX;
    int pMax = findMax(nums, 0, n); //lưu vị trí max
    int pMin = findMin(nums, 0, n); //lưu vị trí min
    for (int i = 0; i <= n - k; i++) {
        int tmp1 = pMax;
        int tmp2 = pMin;
        if (pMax >= i && pMax < i + k) {  //nếu vị trí max nằm trong đoạn bị bỏ thì tìm max lại
            int pl = findMax(nums, 0, i); //max mới sẽ là max(max của phần bên trái của đoạn bỏ, max của phần bên phải của đoạn bỏ)
            int pr = findMax(nums, i + k, n); //nếu max ko nằm trong đoạn bị bỏ đi thì max vẫn là max ko cần tìm lại tốn thời gian
            if (pl != -1) pMax = pl;
            if (pr != -1 && nums[pl] < nums[pr]) pMax = pr;
        }
        if (pMin >= i && pMin < i + k) { //tương tự cho min
            int pl = findMin(nums, 0, i);
            int pr = findMin(nums, i + k, n);
            if (pl != -1) pMin = pl;
            if (pr != -1 && nums[pl] > nums[pr]) pMin = pr;
        }
        if (nums[pMax] - nums[pMin] < res) {
            res = nums[pMax] - nums[pMin];
        }
        pMax = tmp1;
        pMin = tmp2;
    }
    return res;
}",1.0,1111111111
Array_list_9,1375151,2213836,"int steadySpeed(vector<int>& positions) {
    int len = positions.size();
    //*  tạo mảng con chứa khoảng cách 2 phần tử liền kề
    vector<int> v(len - 1, 0);
    for(int i = 1; i < len; i++) v[i - 1] = abs(positions[i] - positions[i - 1]);
    
    //* tạo biến lưu
    int count = 1;
    int temp = v[0];
    int Max = 0;
    for(int i = 1; i < len - 1; i++) {
        if(v[i] == temp) count++; //* giống khoảng cách thì count++
        else {
            Max = max(Max, count);
            count = 1;
            temp = v[i];
        }
    }
    return max(Max, count) + 1;
}",1.0,111111111111111
Array_list_10,1375151,2213836,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int Max = INT_MIN;
    int right = nums.size() - 1;
    int left = 0;
    
    //* tính tổng các cặp
    while(left < right) {
        int currentSum = nums[left] + nums[right];
        //* nếu current vẫn nhỏ hơn thì tăng left
        if(currentSum < target) {
        Max = max(Max, currentSum);
        left++;
        }

        else right--;
    }

    return Max;
}",1.0,1111111111
Array_list_11,1375151,2213836,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER

    //* xét từng op trong operations
    for(const auto& op : operations) {
        int L = op[0];
        int R = op[1];
        int X = op[2];

        //* nếu nằm trong khoảng L,R thì cộng thêm giá trị X
        for(int i = L; i <= R; i++) nums[i] += X;
    }
    
        return nums;
}",1.0,111111
Array_list_8,1375675,2212935,"vector<int>sort(vector<int>& a){
    int n = a.size();
    for (int i = 0; i < n; i++){
        for (int j = i+1; j < n; j++){
            if(a[i]>a[j])
            {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    return a;
}
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if (k >= n) return 0;
    int minAmplitude = INT_MAX;
    for (int i = 0; i < n; i++){
        vector<int>a;
        for (int j = 0; j < n; j++){
            if (j >=i && j < i + k){
                continue;
            }
            a.push_back(nums[j]);
        }
        sort(a);
        minAmplitude = min(minAmplitude, (a[n-k-1]-a[0]));
        a.clear();
    }
    
    return minAmplitude;
}",0.2,110000
Array_list_8,1375694, ,"vector<int>sort(vector<int>& a){
    int n = a.size();
    for (int i = 0; i < n; i++){
        for (int j = i+1; j < n; j++){
            if(a[i]>a[j])
            {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    return a;
}
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if (k >= n) return 0;
    int minAmplitude = INT_MAX;
    for (int i = 0; i < n-k; i++){
        vector<int>a;
        for (int j = 0; j < n; j++){
            if (j >=i && j < i + k){
                continue;
            }
            a.push_back(nums[j]);
        }
        sort(a);
        minAmplitude = min(minAmplitude, (a[n-k-1]-a[0]));
        a.clear();
    }
    
    return minAmplitude;
}",0.5,111110
Array_list_10,1375694, ,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left = 0;
    int right = nums.size() - 1;
    int maxSum = -1;

    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum < target) {
            maxSum = max(maxSum, sum);
            left++;
        } else {
            right--;
        }
    }

    return maxSum;
}",1.0,1111111111
Array_list_11,1375694, ,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    vector<int> result = nums;

    for (const vector<int>& operation : operations) {
        int left = operation[0];
        int right = operation[1];
        int increment = operation[2];

        for (int i = left; i <= right; ++i) {
            result[i] += increment;
        }
    }

    return result;
}",1.0,111111
Array_list_1,1376649,2211667,"int compare(const void* a, const void* b){
    return (*(int*)a-*(int*)b);
}
int buyCar(int* nums, int length, int k) {
    qsort(nums, length, sizeof(int), compare);
    int count=0;
    for (int i=0; i<length; i++){
        if(nums[i]<=k){
            count++;
            k-=nums[i];
        } else break;
    }
    return count;
}",1.0,1111111111
Array_list_2,1376649,2211667,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size()==0) {
        return true;
    }
    
    bool consecutives = false;
    
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] == 1 && nums[i - 1] == 1) {
            consecutives = true;
        }
        if(consecutives){
            if(nums[i]!=1&&nums[i+1]==1) return false;
        }
    }
    
    return consecutives;

}",1.0,1111111111
Array_list_3,1376649,2211667,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size()==0) {
        return true;
    }
    
    bool consecutives = false;
    
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] == 1 && nums[i - 1] == 1) {
            consecutives = true;
        }
        if(consecutives){
            if(nums[i]!=1&&nums[i+1]==1) return false;
        }
    }
    
    return consecutives;

}",1.0,1111111111
Array_list_4,1376649,2211667,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size()==0) {
        return true;
    }
    
    bool consecutives = false;
    
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] == 1 && nums[i - 1] == 1) {
            consecutives = true;
        }
        if(consecutives){
            if(nums[i]!=1&&nums[i+1]==1) return false;
        }
    }
    
    return consecutives;

}",1.0,1111111111
Array_list_5,1376649,2211667,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int n=nums.size();
    int leftSum=0;
    int rightSum=0;
    for(int i=1; i<n; i++){
        rightSum+=nums[i];
    }
    for(int i=0; i<n; i++){
        if(leftSum==rightSum){
            return i;
        }
        leftSum+=nums[i];
        if(i+1<n){
            rightSum-=nums[i+1];
        }
    }
    return -1;
}",1.0,1111111111
Array_list_6,1376649,2211667,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if (words.empty()) {
        return 0;
    }

    int longest = 0;
    for (char c = 'a'; c <= 'z'; ++c) {
        int current = 0;
        for (const string& word : words) {
            if (word[0] == c) {
                ++current;
            }
        }
        if (current > longest) {
            longest = current;
        }
    }

    return longest;
}",0.29,1100000
Array_list_7,1376649,2211667,"int maxSum(int* nums, int n, int k) {
    int sum = 0;
    for (int i = 0; i < n; i += k) {
        int maxNum = 0;
        for (int j = i; j < min(i + k, n); ++j) {
            maxNum = max(maxNum, nums[j]);
        }
        sum += maxNum * min(k, n - i);
    }
    return sum;
}",0.2,00100
Array_list_8,1376649,2211667,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (nums[j] > nums[j + 1]) {
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
    int minAmplitude = INT_MAX;
    for (int i = 0; i <= k; i++) {
        minAmplitude = min(minAmplitude, nums[n - 1 - k + i] - nums[i]);
    }
    return minAmplitude;
}",0.1,100000000
Array_list_10,1376649,2211667,"int sumLessThanTarget(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int maxSum = INT_MIN;
    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum < target) {
            maxSum = max(maxSum, sum);
            left++;
        } else {
            right--;
        }
    }
    return maxSum;
}
",1.0,1111111111
Array_list_11,1376649,2211667,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for (const auto& operation : operations) {
        int left = operation[0];
        int right = operation[1];
        int increment = operation[2];
        for (int i = left; i <= right; ++i) {
            nums[i] += increment;
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1377165,2210458,"void merge(int arr[], int l, int m, int r)
{
	const int sizeL = m - l + 1;
	const int sizeR = r - m;
	int* arrL = new int[sizeL];
	int* arrR = new int[sizeR];

	for (int i = 0; i < sizeL; i++)
	{
		arrL[i] = arr[l + i];
	}
	for (int i = 0; i < sizeR; i++)
	{
		arrR[i] = arr[m + i + 1];
	}
	// These are used for checking if L or R is completely finished
	int countL = 0;
	int countR = 0;
	int k = l;
	while (countL < sizeL && countR < sizeR)
	{
		if (arrL[countL] <= arrR[countR])
		{
			arr[k] = arrL[countL];
			countL++;
		}
		else
		{
			arr[k] = arrR[countR];
			countR++;
		}
		k++;
	}
	while (countL < sizeL)
	{
		arr[k] = arrL[countL];
		k++;
		countL++;
	}
	while (countL < sizeL)
	{
		arr[k] = arrL[countL];
		k++;
		countL++;
	}
}

void mergesort(int* arr, int l, int r)
{
	if (l < r)
	{
        int mid = (l + r) / 2;
		mergesort(arr, l, mid);
		mergesort(arr, mid + 1, r);
		merge(arr, l, mid, r);
	}
}

int buyCar(int* nums, int length, int k)
{
	mergesort(nums, 0, length - 1);
	int count = 0;
	while (k >= 0)
	{
		k -= nums[count];
		count++;
	}
	return count - 1;
}",1.0,1111111111
Array_list_2,1377165,2210458,"bool consecutiveOnes(vector<int>& nums) 
{
	if (nums.size() == 0)
	{
		return true;
	}
	bool check = true;
	int i = 0;
	int count = 0;
	while (check == true && i < nums.size())
	{
		if (nums[i] == 1)
		{
			count++;
		}
		else
		{
			if (count == 1)
			{
				check = false;
			}
			count = 0;
		}
		i++;
	}
	return check;
}",0.9,1111111011
Array_list_1,1379470,1913560,"int buyCar(int* nums, int length, int k) {
    // Sort the array in ascending order
    std::sort(nums, nums + length);

    int count = 0;
    int totalCost = 0;

    for (int i = 0; i < length; i++) {
        // Check if the current car can be bought within the budget
        if (totalCost + nums[i] <= k) {
            totalCost += nums[i];
            count++;
        } else {
            // If the current car cannot be bought, stop the loop
            break;
        }
    }

    return count;
}",1.0,1111111111
Array_list_2,1379470,1913560,"bool consecutiveOnes(vector<int>& nums) {
    int n = nums.size();
    bool foundOne = false;

    for (int i = 0; i < n; i++) {
        if (nums[i] == 1) {
            if (!foundOne) {
                foundOne = true;
            }
        } else {
            if (foundOne && i != n - 1 && nums[i + 1] == 1) {
                return false;
            }
        }
    }

    return true;
}",1.0,1111111111
Array_list_3,1379470,1913560,"bool consecutiveOnes(vector<int>& nums) {
    int n = nums.size();
    bool foundOne = false;

    for (int i = 0; i < n; i++) {
        if (nums[i] == 1) {
            if (!foundOne) {
                foundOne = true;
            }
        } else {
            if (foundOne && i != n - 1 && nums[i + 1] == 1) {
                return false;
            }
        }
    }

    return true;
}",1.0,1111111111
Array_list_4,1379470,1913560,"bool consecutiveOnes(vector<int>& nums) {
    int n = nums.size();
    bool foundOne = false;

    for (int i = 0; i < n; i++) {
        if (nums[i] == 1) {
            if (!foundOne) {
                foundOne = true;
            }
        } else {
            if (foundOne && i != n - 1 && nums[i + 1] == 1) {
                return false;
            }
        }
    }

    return true;
}",1.0,1111111111
Array_list_5,1379470,1913560,"int equalSumIndex(vector<int>& nums) {
    int n = nums.size();
    int totalSum = 0;

    // Calculate the total sum of all elements in the array
    for (int i = 0; i < n; i++) {
        totalSum += nums[i];
    }

    int leftSum = 0;
    for (int i = 0; i < n; i++) {
        // Subtract the current element from the total sum
        totalSum -= nums[i];

        // If the left sum is equal to the remaining sum (totalSum),
        // return the current index
        if (leftSum == totalSum) {
            return i;
        }

        // Add the current element to the left sum
        leftSum += nums[i];
    }

    // No such index exists
    return -1;
}",1.0,1111111111
Array_list_6,1379470,1913560,"int longestSublist(vector<string>& words) {
    int maxLength = 0;
    int currentLength = 0;
    char currentLetter = '\0';  // Null character

    for (const string& word : words) {
        if (word.empty()) {
            // Skip empty strings
            continue;
        }

        char firstLetter = word[0];

        if (currentLetter == firstLetter) {
            // The current word shares the same first letter as the previous ones
            currentLength++;
        } else {
            // The current word has a different first letter
            maxLength = max(maxLength, currentLength);
            currentLength = 1;
        }

        currentLetter = firstLetter;
    }

    // Check the length of the last subarray
    maxLength = max(maxLength, currentLength);

    return maxLength;
}",1.0,1111111
Array_list_7,1379470,1913560,"int maxSum(int* nums, int n, int k) {
    int result = 0;
    int num = 0;
    int currentMax = nums[0];

    for (int i = 0; i < n; i++) {
        num += 1;
        currentMax = max(currentMax, nums[i]);

        if (num == k || nums[i] == nums[i + 1] || (num == 2 && nums[i - 1] == nums[i + 1]) || i == n - 1) {
            result += num * currentMax;
            num = 0;
            currentMax = nums[i + 1];
        }
    }

    return result;
}",0.4,10100
Array_list_8,1379470,1913560,"int minimumAmplitude(vector<int>& nums, int k) {
    int n = nums.size();
    if (n <= k) {
        return 0;
    }
    int maxNum = INT_MIN;
    int minNum = INT_MAX;
    for (int i = 0; i < n; i++) {
        maxNum = max(maxNum, nums[i]);
        minNum = min(minNum, nums[i]);
    }
    int initialAmplitude = maxNum - minNum;
    
    int minAmplitude = initialAmplitude;
    
    for (int i = 0; i <= n - k; i++) {
        int maxSub = INT_MIN;
        int minSub = INT_MAX;
        for (int j = 0; j < n; j++) {
            if (j < i || j >= i + k) {
                maxSub = max(maxSub, nums[j]);
                minSub = min(minSub, nums[j]);
            }
        }
        int amplitude = maxSub - minSub;
        minAmplitude = min(minAmplitude, amplitude);
    }
    
    return minAmplitude;
}",0.9,1111111110
Array_list_9,1379470,1913560,"int steadySpeed(vector<int>& positions) {
    int maxLength = 0;  
    int currentLength = 1;  
    int n = positions.size();
    int currentSpeed = abs(positions[1] - positions[0]);  

    for (int i = 1; i < n; i++) {
        int speed = abs(positions[i] - positions[i - 1]);

        if (i == 1 || speed == currentSpeed) {
            currentLength++;
        } else {
            maxLength = max(maxLength, currentLength);
            currentLength = 2;
            currentSpeed = speed;
        }
    }

    maxLength = max(maxLength, currentLength);

    return maxLength;
}",1.0,111111111111111
Array_list_10,1379470,1913560,"int sumLessThanTarget(vector<int>& nums, int target) {
    int left = 0;                      
    int right = nums.size() - 1;       
    int maxSum = INT_MIN;              

    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum < target) {
            maxSum = max(maxSum, sum);
            left++;                    
        } else {
            right--;                   
        }
    }

    return maxSum;
}",1.0,1111111111
Array_list_11,1379470,1913560,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    vector<int> result(nums);

    for (vector<int>& operation : operations) {
        int L = operation[0];
        int R = operation[1];
        int X = operation[2];

        for (int i = L; i <= R; i++) {
            result[i] += X;
        }
    }

    return result;
}",1.0,111111
Array_list_1,1381496,2212303,"int buyCar(int* nums, int length, int k) {
      int buy=0;
      sort(nums, nums+length);
      for(int i=0; i<length; i++){
          if(k-nums[i]>=0&&k>0){
              k=k-nums[i];
              buy++;
          }
      }
      return buy;
}",1.0,1111111111
Array_list_2,1381496,2212303,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool con = false;
    bool space = false;
    if (nums.empty()) return true;
    for(int i=0; i<nums.size(); i++){
        if(nums[i]==1){
            if(space) return false;
            con=true;
        }
        else if(con) space=true;
    }
    return true;
}",1.0,1111111111
Array_list_3,1381496,2212303,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
     bool con = false;
    bool space = false;
    if (nums.empty()) return true;
    for(int i=0; i<nums.size(); i++){
        if(nums[i]==1){
            if(space) return false;
            con=true;
        }
        else if(con) space=true;
    }
    return true;
}",1.0,1111111111
Array_list_4,1381496,2212303,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
     bool con = false;
    bool space = false;
    if (nums.empty()) return true;
    for(int i=0; i<nums.size(); i++){
        if(nums[i]==1){
            if(space) return false;
            con=true;
        }
        else if(con) space=true;
    }
    return true;
}",1.0,1111111111
Array_list_5,1381496,2212303,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sum=0, rSum=0;
    int lSum=0;
    for(int i=0; i<nums.size(); i++){
        sum+=nums[i];
    }
    for(int i=0; i<nums.size(); i++){
        rSum=sum-nums[i]-lSum;
        if(rSum-lSum==0){
            return i;
        } 
        lSum+=nums[i];
    }
    return -1;
}",1.0,1111111111
Array_list_6,1381496,2212303,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.empty()) return 0;
    char first=words[0][0];
    int length=0, pLength=0;
    for(int i=0; i<words.size(); i++){
        if(first==words[i][0])
        { length++;
          if(i==words.size()-1) {
              if(length>pLength) pLength=length;
          }
        }
        else {
            if(length>pLength) pLength=length;
            length=1;
        }
        first=words[i][0];
    }
    return pLength;
  
}",1.0,1111111
Array_list_7,1381496,2212303,"int maxSum(int* nums, int n, int k) {
    int *maxS=new int[n];
        int max_sum = 0;
    for (int i = 0; i < n; i++) maxS[i] = 0;
    for (int i = 0; i < n; ++i) {
        int max_val = nums[i];
        int current_product = 0;
        for (int j = i; j >= 0 && i - j + 1 <= k; j--) {
            max_val = max(max_val, nums[j]);
            current_product = max_val * (i - j + 1);
            if (j > 0) {
                current_product += maxS[j - 1];
            }
            if (current_product > maxS[i])
                maxS[i] = current_product;
        }
    }
    for (int i = 0; i < n; ++i) {
        if (maxS[i] > max_sum)
            max_sum = maxS[i];
    }
    return max_sum;
}",1.0,11111
Array_list_8,1381496,2212303,"int minimumAmplitude(vector<int>& nums, int k) {
    int val;
    int max1 = nums[0];  // Initialize max1 to the first element
    int min1 = nums[0];  // Initialize min1 to the first element
    if(k<0||nums.size()-k<2) return 0;
    // Find the initial max and min values in the entire array
    for (size_t i = 0; i < nums.size(); i++) {
        if (nums[i] < min1) min1 = nums[i];
        if (nums[i] > max1) max1 = nums[i];
    }
    
    val = max1 - min1;

    for(size_t i=0; i<nums.size()-k; i++){int max, min;
        if(i==0){
            max=nums[k];
            min=nums[k];
        }
        else {
            max=nums[0];
            min=nums[0];
        }
        for(size_t j=0; j<i; j++){
            if(nums[j]<min) min=nums[j];
            if(nums[j]>max) max=nums[j];
        }
        for(size_t j=i+k; j<nums.size();j++){
            if(nums[j]<min) min=nums[j];
            if(nums[j]>max) max=nums[j];
        }
        if(max-min<val) val=max-min;
        
    }
    return val;
}",0.9,1111111110
Array_list_9,1381496,2212303,"int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    int speed = positions[1] - positions[0], prevS = positions[1] - positions[0], l = 2, ans = 1;
    for (int i = 2; i < n; i++) {
        speed = positions[i] - positions[i - 1];
        if (speed < 0) speed = -speed;
        if (speed == prevS) l++;
        else {
            prevS = speed;
            if (l > ans) ans = l;
            l = 2;
        }
        if (i == n - 1) if (l > ans) ans = l;
    }
    return ans;
}",1.0,111111111111111
Array_list_10,1381496,2212303,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int max=0;
    int temp=0;
    for(int i=0; i<nums.size(); i++){
        temp=target-nums[i];
        int j=i+1;
        while(nums[j]<temp&&j<nums.size()){
            j++;
        }
        if (j > i + 1) {
            int nMax = nums[i] + nums[j - 1];
        if(nMax>max) {max=nMax;}
        }
    }
    return max;
}",1.0,1111111111
Array_list_11,1381496,2212303,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER

    for (const vector<int>& op : operations) {
        int L = op[0];
        int R = op[1];
        int X = op[2];

        // Increase the elements within the range [L, R] by X in the result array.
        for (int i = L; i <= R; i++) {
            nums[i] += X;
        }
    }

    return nums;
}",1.0,111111
Array_list_1,1384333,2211876,"int buyCar(int* nums, int length, int k) {
    std::sort(nums, nums + length);

    int maxCars = 0;
    int currentBudget = k;

    
    for (int i = 0; i < length; i++) {
        if (nums[i] <= currentBudget) {
            maxCars++;
            currentBudget -= nums[i];
        } else {
            break; 
        }
    }

    return maxCars;
}",1.0,1111111111
Array_list_2,1384333,2211876,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool foundOne = false; 
    for (int num : nums) {
        if (num == 1) {
            if (!foundOne) {
                foundOne = true;
            } else {
                
                continue;
            }
        } else {
            
            if (foundOne) {
                return false;
            }
        }
    }

    
    return true;
}",0.6,0100010111
Array_list_3,1384333,2211876,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int consecutiveCount = 0;
    bool found = false;
    if ( nums.size() == 0 ) return true;
    
    for (int num : nums) {
        if (num == 1) {
            consecutiveCount++;
        } else {
            if (consecutiveCount > 0) {
                found = true;
                
                break;
            
            }
        }
    }
    
    return found;
}",0.6,1111101000
Array_list_4,1384333,2211876,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int consecutiveCount = 0;
    bool found = false;
    if ( nums.size() == 0 ) return true;
    
    for (int num : nums) {
        if (num == 1) {
            consecutiveCount++;
        } else {
            if (consecutiveCount > 0) {
                found = true;
                
                break;
            
            }
        }
    }
    
    return found;
}",0.6,1111101000
Array_list_5,1384333,2211876,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int totalSum = 0;
    for (int num : nums) {
        totalSum += num;
    }

    int leftSum = 0;
    for (int i = 0; i < nums.size(); i++) {
        totalSum -= nums[i];
        if (leftSum == totalSum) {
            return i;
        }
        leftSum += nums[i];
    }

    return -1;
}",1.0,1111111111
Array_list_6,1384333,2211876,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if (words.empty()) {
        return 0;
    }

    int maxSublistLength = 1; 

    int currentSublistLength = 1;
    char currentFirstLetter = words[0][0];

    for (int i = 1; i < words.size(); i++) {
        char firstLetter = words[i][0];

        if (firstLetter == currentFirstLetter) {
            currentSublistLength++;
        } else {
            
            currentFirstLetter = firstLetter;
            currentSublistLength = 1;
        }

        
        maxSublistLength = max(maxSublistLength, currentSublistLength);
    }

    return maxSublistLength;
}",1.0,1111111
Array_list_7,1384333,2211876,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n + 1];
    

    for (int i = 0; i <= n; i++) {
        dp[i] = 0;
    }

    
    for (int i = 1; i <= n; i++) {
        int maxElement = 0;
        
        
        for (int j = 1; j <= k && i - j >= 0; j++) {
            
            maxElement = max(maxElement, nums[i - j]);
            int currentSValue = maxElement * j;
            
            
            dp[i] = max(dp[i], dp[i - j] + currentSValue);
        }
    }

   
    int result = dp[n];
    
    
    delete[] dp;

    return result;

   
}",1.0,11111
Array_list_10,1384333,2211876,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left = 0;
    int right = nums.size() - 1;
    int maxSum = INT_MIN;

    while (left < right) {
        int currentSum = nums[left] + nums[right];

        if (currentSum < target) {
            maxSum = max(maxSum, currentSum);
            left++; 
        } else {
            right--; 
        }
    }

    return maxSum;
}",1.0,1111111111
Array_list_11,1384333,2211876,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int n = nums.size();
    vector<int> result(n, 0);

    for (const vector<int>& op : operations) {
        int left = op[0];
        int right = op[1];
        int increment = op[2];

        
        for (int i = left; i <= right; i++) {
            result[i] += increment;
        }
    }

   
    for (int i = 0; i < n; i++) {
        nums[i] += result[i];
    }

    return nums;
}",1.0,111111
Array_list_1,1385343,2013048,"int buyCar (int * nums, int length, int k){
    for(int i = 0; i < length; i++){
        for(int j = i + 1; j < length; j++){
            if (nums[i] > nums[j]){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
    }
    int sum = 0, count = 0;
    while(sum + nums[count] <= k){
        sum += nums[count];
        count++;
    }
    return count;
}",1.0,1111111111
Array_list_2,1385343,2013048,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool res = true;
    int cont = 0;
    bool flag = false;
    for (int i = 0; i < nums.size() ; i++) {
        if (nums[i] == 1 && cont >= 2 ) {
            return false;
        }
        if (nums[i] == 1 ) {
            cont = 0;
            flag = true;
        }
        else if (flag == true && nums[i] != 1 ) {
            cont += 1;
        }

    }
    return res;
}",1.0,1111111111
Array_list_3,1385343,2013048,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool res = true;
    int cont = 0;
    bool flag = false;
    for (int i = 0; i < nums.size() ; i++) {
        if (nums[i] == 1 && cont >= 2 ) {
            return false;
        }
        if (nums[i] == 1 ) {
            cont = 0;
            flag = true;
        }
        else if (flag == true && nums[i] != 1 ) {
            cont += 1;
        }

    }
    return res;
}",1.0,1111111111
Array_list_4,1385343,2013048,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool res = true;
    int cont = 0;
    bool flag = false;
    for (int i = 0; i < nums.size() ; i++) {
        if (nums[i] == 1 && cont >= 2 ) {
            return false;
        }
        if (nums[i] == 1 ) {
            cont = 0;
            flag = true;
        }
        else if (flag == true && nums[i] != 1 ) {
            cont += 1;
        }

    }
    return res;
}",1.0,1111111111
Array_list_5,1385343,2013048,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size() == 1 ) {
        return 0;
    }
        if (nums.size() == 0 ) {
        return -1;
    }

    int left = 0;
    int right = 0;

    for (int i = 0 ; i < nums.size(); i++ ) {
        right += nums[i];
    }
    right -= nums[0];
    for (int i = 1 ; i< nums.size() ; i++) {
        left += nums[i-1];
        right -= nums[i];
        if (left >= right ) {
            if (left == right ) {
                return i;
            }
            else return -1;
        }
    }
}",1.0,1111111111
Array_list_6,1385343,2013048,"#include<iostream>
#include<vector>

using namespace std;

int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.size() == 0)
        return 0;
    int max_length = 1;
    vector<string> subarray;
    for(unsigned int i = 0; i < words.size()-1; i++){
            if(words[i][0] == words[i+1][0]){
                subarray.push_back(words[i]);
                if(i+1 == words.size()-1) subarray.push_back(words[i+1]);
            }else{
                subarray.push_back(words[i]);
                max_length = (max_length < (int) subarray.size())? (int) subarray.size(): max_length;
                subarray.clear();
            }
            max_length = (max_length < (int) subarray.size())? (int) subarray.size(): max_length;
    }
    return max_length;
}",1.0,1111111
Array_list_7,1385343,2013048,"
#include <vector>

int maxSum(int* nums, int n, int k) {
    int result = 0;

    for (int i = 0; i < n; ++i) {
        int currentMax = nums[i];
        int currentSize = 1;

        for (int j = i + 1; j < std::min(i + k, n); ++j) {
            currentMax = std::max(currentMax, nums[j]);
            ++currentSize;
        }

        result += currentMax * currentSize;
    }

    return result;
}

",0.2,00000
Array_list_10,1385343,2013048,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    if(nums.size() == 2) return nums[0] + nums[1];
    vector<int> sub;
    for(int i = 0; nums[i] < target - nums[0]; i++){
        sub.push_back(nums[i]);
    }
    return sub[0] + sub[sub.size()-1];
}",0.8,1100000000
Array_list_11,1385343,2013048,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for(unsigned int i = 0; i < operations.size(); i++){
        int L = operations[i][0], R = operations[i][1], X = operations[i][2];
        for(int idx = L; idx <= R; idx++)
            nums[idx] += X;
    }
    return nums;
}",1.0,111111
Array_list_1,1386900,2211738,"int buyCar(int* nums, int length, int k) {
    sort(nums, nums+length);
    int count = 0;
    int i = 0;
    while(i < length){
        if(nums[i] <= k){
            count++;
            k = k - nums[i];
        }else{
            break;
        }
        i++;
    }
    return count;
}",1.0,1111111111
Array_list_2,1386900,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()){
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i]);
                i++;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_3,1386900,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()){
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i]);
                i++;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_4,1386900,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()){
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i]);
                i++;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_5,1386900,2211738,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size() <= 1) return 0;
    int sum = 0, sum1;
    for(int i = 0; i < nums.size(); i++){
        sum += nums[i];
    }
    vector<int>res;
    res.push_back(nums[0]);
    for(int i = 1; i < nums.size(); i++){
        sum1 = nums[i];
        if(i >= 2){
            sum1 = nums[i-1] + res[i-2];
            res.push_back(sum1);
        }
        if(sum1 == sum - nums[i] - sum1) return i;
    }
    return -1;
}",1.0,1111111111
Array_list_6,1386900,2211738,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.empty()) return 0;
    int j = 0, ans = 1;
    for(int i = 1; i < words.size(); i ++){
        if(words[i][0] == words[j][0]){
            ans = max(ans, i-j+1);
        }else{
            j = i;
        }
    }
    return ans;
}",1.0,1111111
Array_list_7,1386900,2211738,"int maxSum(int* nums, int n, int k) {
    if(n == 0) return 0;
    int count = 1, sum = 0, maxi = nums[0];
    for(int i = 1; i < n; i++){
        if(nums[i] != nums[i-1] && count < k){
            count++;
            maxi = max(maxi, nums[i]);
        }else{
            sum += maxi*count;
            count = 1;
            maxi = nums[i];
        }
    }
    sum += maxi*count;
    return sum;
}",0.4,10100
Array_list_8,1386900,2211738,"
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int len = nums.size(), res = 1e9;
    if(len == 0) return 0;
    vector<int> mx1;
    vector<int> mn1;
    vector<int> mx2;
    vector<int> mn2;
    mx1.push_back(nums[0]);
    mn1.push_back(nums[0]);
    mx1.push_back(nums[len-1]);
    mn2.push_back(nums[len-1]);
    for(int i = 0; i <= len-k; i++){
        int max1 = nums[0], min1 = nums[0], max2 = -1e9, min2 = 1e9;
        if(i-1>=1){
            max1 = max(nums[i-1], mx1[i-2]);
            min1 = min(nums[i-1], mn1[i-2]);
            
            max2 = max(nums[i-1], mx2[i-2]);
            min2 = min(nums[i-1], mn2[i-2]);
            
            mx1.push_back(max1);
            mn1.push_back(min1);
            mx2.push_back(max2);
            mn2.push_back(min2);
        }
        // for(int j = i+k; j < len; j++){
        //     max2 = max(max2, nums[j]);
        //     min2 = min(min2, nums[j]);
        // }
            
        if(i == len-k){
            res = min(res, max1-min1);
            break;
        }else if(i == 0){
            res = min(res,max2-min2);
            continue;
        }
        int maxi = max(max1, max2);
        int mini = min(min1, min2);
        
        res = min(res, maxi-mini);
    }
    return res;
}",0.9,0
Array_list_10,1386900,2211738,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left = 0, right = nums.size()-1;
    int maxSum = -1e9;
    while(left < right){
        int sum = nums[left] + nums[right];
        if(sum < target){
            maxSum = max(maxSum, sum);
            left++;
        }else{
            right--;
        }
    }
    return maxSum;
}",1.0,1111111111
Array_list_11,1386900,2211738,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int len1 = nums.size();
    int len2 = operations.size();
    for(int i = 0; i < len1; i++){
        for(int j = 0; j < len2; j++){
            if(i >= operations[j][0] && i <= operations[j][1]){
                nums[i] += operations[j][2];
            }
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1389328,2212282,"int buyCar(int * nums,int length,int k){
     int tg;
     int count=0;
    for(int i = 0; i < length - 1; i++){
        for(int j = i + 1; j < length; j++){
            if(nums[i] > nums[j]){
                
                tg = nums[i];
                nums[i] = nums[j];
                nums[j] = tg;        
            }
        }
    }
    for(int i = 0; i < length ; i++){
        k-=nums[i];
        if(k>=0) count++;
        else break;
    }
    return count;
}",1.0,1111111111
Array_list_2,1389328,2212282,"bool consecutiveOnes(vector<int>& nums) {
    bool s1 = 0;
    bool s2 = 0;
    
    for(int i : nums) {
        if(i == 1 && s1 == 0) s1 = 1;
        if(i != 1 && s1 == 1) s2 = 1;
        if(i == 1 && s2 == 1) return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_3,1389328,2212282,"bool consecutiveOnes(vector<int>& nums) {
    bool s1 = 0;
    bool s2 = 0;
    
    for(int i : nums) {
        if(i == 1 && s1 == 0) s1 = 1;
        if(i != 1 && s1 == 1) s2 = 1;
        if(i == 1 && s2 == 1) return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_4,1389328,2212282,"bool consecutiveOnes(vector<int>& nums) {
    bool s1 = 0;
    bool s2 = 0;
    
    for(int i : nums) {
        if(i == 1 && s1 == 0) s1 = 1;
        if(i != 1 && s1 == 1) s2 = 1;
        if(i == 1 && s2 == 1) return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_5,1389328,2212282,"int equalSumIndex(vector<int>& nums) {
    int mid = nums.size()/2;
    int sumLeft  = 0;
    int sumRight = 0;
    bool oneSide = 1;
    
    for(int i = mid-1; i>=0; --i)          sumLeft  += nums[i];
    for(int i = mid+1; i<nums.size(); ++i) sumRight += nums[i];
    
    while(mid >= 0 && mid < nums.size()) {
        if(sumLeft == sumRight) return mid;
        else {
            if(sumLeft > sumRight) {
                mid--;
                sumLeft  -= nums[mid];
                sumRight += nums[mid+1]; 
                if(sumLeft < sumRight) return -1;
            }
            else {
                mid++;
                sumLeft  += nums[mid-1];
                sumRight -= nums[mid];
                if(sumLeft > sumRight) return -1;
            }
        }
        
    }
    
    return -1;
}",1.0,1111111111
Array_list_6,1389328,2212282,"int longestSublist(vector<string>& words) {
    int count = 0;
    int tmp = 0;
    
    if(words.size() == 0) return count;
    for(int i=0; i<words.size()-1; i++) {
        if(words[i][0] == words[i+1][0]) {
            ++tmp;
        }
        else tmp = 0;
        
        count = max(count, tmp);
    }
    
    return count ? count + 1 : 0;
}",1.0,1111111
Array_list_10,1389328,2212282,"int sumLessThanTarget(vector<int>& nums, int target) {
    int count  = 0;
    int left   = 0;
    int right  = nums.size()-1;
    
    while(left < right) {
        if(nums[right] - nums[left] < target) {
            count += right - left;
            right--;
        }
        else left++;
    }
    
    return count;
}",0.1,1000000000
Array_list_11,1389328,2212282,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    for(vector<int> scan : operations) {
        for(int i = scan[0]; i<=scan[1]; ++i) {
            nums[i] += scan[2];
        }
    }
    
    return nums;
}",1.0,111111
Array_list_1,1390105,2212935,"int buyCar(int* nums, int length, int k) {
sort(nums, nums+length);
    int  count = 0;
    int tmpk = k;
for (int i = 0; i < length; i++){
    if (tmpk >= nums[i]){
        tmpk -= nums[i];
        count++;
    }
    else break;
}
return count;
}",1.0,1111111111
Array_list_2,1390105,2212935,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool meet1 = 0;
    bool space = 0;
    for (int i = 0; i < nums.size(); i++){
        if (nums[i] == 1){
            if (space) return 0;
            meet1 = true;
        }
        else {
            if (meet1) space = true;
        }
        
    }
    return 1;
}",1.0,1111111111
Array_list_3,1390105,2212935,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool meet1 = 0;
    bool space = 0;
    for (int i = 0; i < nums.size(); i++){
        if (nums[i] == 1){
            if (space) return 0;
            meet1 = true;
        }
        else {
            if (meet1) space = true;
        }
        
    }
    return 1;
}",1.0,1111111111
Array_list_4,1390105,2212935,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool meet1 = 0;
    bool space = 0;
    for (int i = 0; i < nums.size(); i++){
        if (nums[i] == 1){
            if (space) return 0;
            meet1 = true;
        }
        else {
            if (meet1) space = true;
        }
        
    }
    return 1;
}",1.0,1111111111
Array_list_5,1390105,2212935,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sum1 = 0, sum2 = 0;
    if (nums.size() == 0) return -1;
    for (int i = 0; i < nums.size(); i++){
       sum1 += nums[i];
    }
    for (int i = 0; i < nums.size(); i++){
        sum1 -= nums[i];
        if (sum1 == sum2) return i;
        sum2 += nums[i];
    }
    return -1;
}",1.0,1111111111
Array_list_6,1390105,2212935,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int curCount = 0; 
    int count = 1;
    char tmp;
    for (int i = 0; i < words.size(); i++){
        if (tmp != words[i][0]){
            tmp = words[i][0];
            count = 1;
        }
        else count++;
        if (curCount < count) curCount = count;
    }
    return curCount;
}",1.0,1111111
Array_list_8,1390105,2212935,"vector<int>sort(vector<int>& a){
    int n = a.size();
    for (int i = 0; i < n; i++){
        for (int j = i+1; j < n; j++){
            if(a[i]>a[j])
            {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    return a;
}
int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if (k >= n) return 0;
    int minAmplitude = INT_MAX;
    for (int i = 0; i < n-k; i++){
        vector<int>a;
        for (int j = 0; j < n; j++){
            if (j >=i && j < i + k){
                continue;
            }
            a.push_back(nums[j]);
        }
        sort(a);
        minAmplitude = min(minAmplitude, (a[n-k-1]-a[0]));
        a.clear();
    }
    
    return minAmplitude;
}",0.5,111110
Array_list_9,1390105,2212935,"int steadySpeed(vector<int>& positions) {
    int longestsublist = 2;
    int curLongestsublist = 0;
    int tmp = 0;
    int n = positions.size();
    for (int i = 0; i < n; i++){
        if (tmp != abs(positions[i+1] - positions[i])){
            tmp = abs(positions[i+1] - positions[i]);
            longestsublist = 2;
        }
        else longestsublist++;
        if (curLongestsublist < longestsublist) curLongestsublist = longestsublist;
        
    }
    return curLongestsublist; 
}",1.0,111111111111111
Array_list_10,1390105,2212935,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left = 0;
    int right = nums.size() - 1;
    int maxSum = -1;

    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum < target) {
            maxSum = max(maxSum, sum);
            left++;
        } else {
            right--;
        }
    }

    return maxSum;
}",1.0,1111111111
Array_list_11,1390105,2212935,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    vector<int> result = nums;

    for (const vector<int>& operation : operations) {
        int left = operation[0];
        int right = operation[1];
        int increment = operation[2];

        for (int i = left; i <= right; ++i) {
            result[i] += increment;
        }
    }

    return result;
}",1.0,111111
Array_list_1,1390888,2212651,"int buyCar(int* nums, int length, int k) {
    sort(nums,nums+length);
    int i=0;
    int count=0;
    while(k>=nums[i] && i<length){
        k-=nums[i];
        i++;
        count++;
    }
    return count;
}",1.0,1111111111
Array_list_2,1390888,2212651,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int start=-1, end=-1;
    for(int i=0;i<n-1;i++){
        if(start==-1 && nums[i]==1){
            start=i;
        }
        if(start!=-1 && end==-1 && nums[i]!=nums[i+1]){
            end=i;
            break;
        }
    }
    for(int i=end+1;i<n;i++){
        if(nums[i]==1) return false;
    }
    return true;
}",1.0,1111111111
Array_list_3,1390888,2212651,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int start=-1, end=-1;
    for(int i=0;i<n-1;i++){
        if(start==-1 && nums[i]==1){
            start=i;
        }
        if(start!=-1 && end==-1 && nums[i]!=nums[i+1]){
            end=i;
            break;
        }
    }
    for(int i=end+1;i<n;i++){
        if(nums[i]==1) return false;
    }
    return true;
}",1.0,1111111111
Array_list_4,1390888,2212651,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int start=-1, end=-1;
    for(int i=0;i<n-1;i++){
        if(start==-1 && nums[i]==1){
            start=i;
        }
        if(start!=-1 && end==-1 && nums[i]!=nums[i+1]){
            end=i;
            break;
        }
    }
    for(int i=end+1;i<n;i++){
        if(nums[i]==1) return false;
    }
    return true;
}",1.0,1111111111
Array_list_5,1390888,2212651,"int equalSumIndex(vector<int>& nums) {
    int len = nums.size();
    vector<int> sl(len);
    sl[0] = nums[0];
    vector<int> sr(len);
    sr[len - 1] = nums[len - 1];
    for (int i = 1; i < len; i++) {
        sl[i] = sl[i - 1] + nums[i];
    }
    for (int i = len - 2; i >= 0; i--) {
        sr[i] = sr[i + 1] + nums[i];
    }
    for (int i = 0; i < len; i++) {
        if (sl[i] == sr[i]) return i;
    }
    return -1;
}",1.0,1111111111
Array_list_6,1390888,2212651,"int longestSublist(vector<string>& words) {
    int n = words.size();
    if(n==0) return 0;
    vector<int> len(n, 1); // Initialize len vector with 1
    vector<char> v(n);

    for(int i = 0; i < n; i++) {
        v[i] = words[i][0]; // Store the first character of each word
    }

    for(int i = n - 2; i >= 0; i--) {
        if(v[i] == v[i+1]) {
            len[i] = len[i+1] + 1;
        }
    }

    int max = 1;
    for(int i = 0; i < n; i++) {
        if(len[i] > max) {
            max = len[i];
        }
    }

    return max;
}",1.0,1111111
Array_list_7,1390888,2212651,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n]; 

    for (int i = 0; i < n; i++) {
        int maxElement = nums[i];
        dp[i] = maxElement * 1;

        for (int j = 1; j <= k && i + 1 >= j ; j++) {
            maxElement = max(maxElement, nums[i - j + 1]);
            dp[i] = max(dp[i], maxElement * j + (i - j >= 0 ? dp[i - j] : 0));
        }
    }

    int result = dp[n - 1];
    delete[] dp; 

    return result;
}
",1.0,11111
Array_list_8,1390888,2212651,"int minimumAmplitude(vector<int>& nums, int k) {

    int n=nums.size();
    int minL[n],minR[n+1],maxR[n+1],maxL[n];
    maxR[n]=minR[n]=0;
    minL[0]=maxL[0]=nums[0];
    for(int i=1; i<n; i++){
        minL[i]=(minL[i-1]>nums[i]?nums[i]:minL[i-1]);
        maxL[i]=(maxL[i-1]<nums[i]?nums[i]:maxL[i-1]);
    }
    minR[n-1]=maxR[n-1]=nums[n-1];
    for(int i=n-2; i>=0; i--){
        minR[i]=(minR[i+1]>nums[i]?nums[i]:minR[i+1]);
        maxR[i]=(maxR[i+1]<nums[i]?nums[i]:maxR[i+1]);
    }

    int MIN=maxR[1]-minR[1];
    for(int l=1; l<=n-k; l++){
        int r=l+k-1;
        // cout<<l<<"" ""<< r<<endl;
        // cout<<maxL[l-1]<<"" ""<<maxR[r+1]<<"" ""<<minL[l-1]<<"" ""<<minR[r+1]<<endl;
        MIN=min(MIN,max(maxL[l-1],maxR[r+1])-min(minL[l-1],minR[r+1]));
    }
    return MIN;
}",1.0,1111111111
Array_list_9,1390888,2212651,"int steadySpeed(vector<int>& positions) {
    int n=positions.size();
    vector<int> diff(n-1);
    for(int i=0;i<n-1;i++){
        diff[i]=abs(positions[i+1]-positions[i]);
    }

    vector<int> len(n-1,1);
    len[n-1]=1;
    for(int i=n-2;i>=0;i--){
        if(diff[i]==diff[i+1]){
            len[i]=len[i+1]+1;
        }
    }
    auto it=max_element(len.begin(),len.end());
    return *it+1;
}",1.0,111111111111111
Array_list_10,1390888,2212651,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int n=nums.size();
    int res=-1;
    for(int i=0;i<n-1;i++){
        for(int j=i+1;j<n;j++){
            if(nums[i]+nums[j]<target){
                res=max(res,nums[i]+nums[j]);
                if(res+1==target) return res;
            }
        }
    }
    return res;
}",1.0,1111111111
Array_list_11,1390888,2212651,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int n=nums.size();
    vector<int> diff(n+1,0);
    diff[0]=nums[0];
    for(int i=1;i<n;i++){
        diff[i]=nums[i]-nums[i-1];
    }
    int opSize=operations.size();
    for(int i=0;i<opSize;i++){
        int l=operations[i][0];
        int r=operations[i][1];
        int x=operations[i][2];
        diff[l]+=x;
        diff[r+1]-=x;
    }
    vector<int> res(n);
    int sum=0;
    for(int i=0;i<n;i++){
        sum+=diff[i];
        res[i]=sum;
    }
    return res;
}",1.0,111111
Array_list_1,1390896,2252260,"int buyCar(int* nums, int length, int k) {
    int cnt=0;
    int sum=0;
    sort(nums, nums+length);
    for(int i=0; i<length; i++){
        sum +=nums[i];
        if(sum>k)
            break;
        cnt++;
    }
    return cnt;
}",1.0,1111111111
Array_list_2,1390896,2252260,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int index = 0;
    for(int i=0;i<nums.size();i++){
        if(nums[i] == 1){
            index = i;
            break;
        }
    }
    int pos = 0;
    for(int j=index; j<nums.size(); j++){
        if(nums[j] !=1){
            pos = j;
            break;
        }
    }
    for(int k=pos+1; k<nums.size(); k++){
        if(nums[k]==1)
            return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_3,1390896,2252260,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int index = 0;
    for(int i=0;i<nums.size();i++){
        if(nums[i] == 1){
            index = i;
            break;
        }
    }
    int pos = 0;
    for(int j=index; j<nums.size(); j++){
        if(nums[j] !=1){
            pos = j;
            break;
        }
    }
    for(int k=pos+1; k<nums.size(); k++){
        if(nums[k]==1)
            return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_4,1390896,2252260,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int index = 0;
    for(int i=0;i<nums.size();i++){
        if(nums[i] == 1){
            index = i;
            break;
        }
    }
    int pos = 0;
    for(int j=index; j<nums.size(); j++){
        if(nums[j] !=1){
            pos = j;
            break;
        }
    }
    for(int k=pos+1; k<nums.size(); k++){
        if(nums[k]==1)
            return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_5,1390896,2252260,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0 || nums.size()==1)
        return 0;
    else{
        int sum=0;
        for(int i=1; i<nums.size(); i++){
            sum+=nums[i];
        }
        int cnt = 0;
        for(int j=1; j<nums.size(); j++){
            sum  = sum - nums[j];
            cnt += nums[j-1];
            if(sum == cnt)
                return j;
        }
        return -1;
    }
}",1.0,1111111111
Array_list_6,1390896,2252260,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.size()==0)
        return 0;
    for(int i=0; i<words.size(); i++){
        words[i] = words[i].substr(0,1);
    }
    int tmp=1, ans =1;
    for(int i=1; i< words.size(); i++){
        if(words[i]==words[i-1])
            tmp++;
        else{
            ans = max(ans, tmp);
            tmp=1;
        }
    }
    ans = max(tmp, ans);
    return ans;
}",1.0,1111111
Array_list_7,1390896,2252260,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n+1];
    dp[0] = 0;
    for(int i=1; i<=n; i++){
        int maxVal=0;
        for(int j=1; j<=k && i-j>=0; j++){
            maxVal = max(nums[i-j], maxVal);
            dp[i] = max(dp[i], dp[i-j]+maxVal*j);
        }
    }
    return dp[n];
}",1.0,11111
Array_list_9,1390896,2252260,"int steadySpeed(vector<int>& positions) {
   vector<int> speed;
   int ans = 1;
   int tmp = 1;
   for(unsigned int i=0; i+1<positions.size(); i++){
       speed.push_back(abs(positions[i+1]-positions[i]));
   }
   for(unsigned int i=0; i+1<speed.size(); i++){
       if(speed[i+1]==speed[i]){
           tmp +=1;
       }
       else{
           ans = max(ans, tmp);
           tmp = 1;
       }
   }
   ans = max(tmp, ans);
   return ans+1;
}",1.0,111111111111111
Array_list_10,1390896,2252260,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left=0, right = nums.size()-1;
    int Max = -9999;
    while(left<right){
        int sum = nums[left]+nums[right];
        if(sum < target){
            Max = max(sum, Max);
            left++;
        }
        else
            right--;
    }
    return Max;
}",1.0,1111111111
Array_list_11,1390896,2252260,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for(unsigned int i=0; i<operations.size(); i++){
        int L = operations[i][0];
        int R = operations[i][1];
        int X = operations[i][2];
        for(int j=L; j<=R; j++){
            nums[j]+=X;
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1390918,2210159,"int buyCar(int* nums, int length, int k) {
    for (int i = 0; i < length - 1; i++) {
        for (int j = 0; j < length - i - 1; j++) {
            if (nums[j] > nums[j + 1]) {
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
    int count = 0;
    int spent = 0;
    for (int i = 0; i < length; i++) {
        if (spent + nums[i] <= k) {
            spent += nums[i];
            count++;
        } else {
            break;
        }
    }
    return count;
}
",1.0,1111111111
Array_list_2,1390918,2210159,"bool consecutiveOnes(vector<int>& nums) {
    if (nums.empty()) {
        return true; }
    bool foundOne = false; 
    for (int num : nums) {
        if (num == 1) {
            if (foundOne) {
                continue;
            } else {
                foundOne = true; 
            }
        } else if (foundOne) {
            return false;
        }
    }
    return true; 
}

",0.6,0100010111
Array_list_3,1390918,2210159,"bool consecutiveOnes(vector<int>& nums) {
    bool allOnesConsecutive = true;
    bool foundZero = false;

    for (int num : nums) {
        if (num == 1) {
            if (foundZero) {
                allOnesConsecutive = false;  
                break;
            }
        } else if (num == 0) {
            foundZero = false;
        } else {
            allOnesConsecutive = true;  
            break;
        }
    }

    return allOnesConsecutive;
}
",0.6,1111101000
Array_list_1,1390947,2212499,"int buyCar(int* nums, int length, int k) {
sort(nums,nums+length);
int f=0;
for(int i=0;i<length;i++){
f+=nums[i];
if(f>k) return i;
}

}",1.0,1111111111
Array_list_2,1390947,2212499,"bool consecutiveOnes(vector<int>& nums) {
    bool test = false;
    int len = nums.size();
    for(int i = 0 ; i < len; i++){
        //! tim vi tri co gia tri bang 1 
        if(nums[i] == 1 && !test){
            test = true;
          
        }
        else if(nums[i] == 1 && nums[i] != nums[i-1]) return false;
    }
    return true;
}",1.0,1111111111
Array_list_3,1390947,2212499,"bool consecutiveOnes(vector<int>& nums) {
    bool test = false;
    int len = nums.size();
    for(int i = 0 ; i < len; i++){
        //! tim vi tri co gia tri bang 1 
        if(nums[i] == 1 && !test){
            test = true;
          
        }
        else if(nums[i] == 1 && nums[i] != nums[i-1]) return false;
    }
    return true;
}",1.0,1111111111
Array_list_4,1390947,2212499,"bool consecutiveOnes(vector<int>& nums) {
    bool test = false;
    int len = nums.size();
    for(int i = 0 ; i < len; i++){
        //! tim vi tri co gia tri bang 1 
        if(nums[i] == 1 && !test){
            test = true;
          
        }
        else if(nums[i] == 1 && nums[i] != nums[i-1]) return false;
    }
    return true;
}",1.0,1111111111
Array_list_5,1390947,2212499,"int equalSumIndex(vector<int>& nums) {
  int len = nums.size();
    vector<vector<int>> v(2,vector<int>(len,0));
    v[0][0] = nums[0];
    v[1][len - 1] = nums[len - 1];
    for(int i = 1; i < len; i++){
        v[0][i] = v[0][i-1] + nums[i];
    }
    for(int i = len - 2; i >= 0; i--){
        v[1][i] += v[1][i+1] + nums[i];
    }
    for(int i = 0; i < len; i++){
        if(v[0][i] == v[1][i]) return i; 
    }
    return -1;
}",1.0,1111111111
Array_list_6,1390947,2212499,"int longestSublist(vector<string>& words) {
  if(words.size() == 0) return 0;
    char c;
    int Max = 0;
    c = words[0][0];
    int count = 1;
    int len = words.size();
    for(int i = 1; i < len; i++){
        if(words[i][0] == c) count ++;
        else{
            Max = max(count,Max);
            c = words[i][0];
            count = 1;
        }
    }
    return max(count,Max);
}",1.0,1111111
Array_list_8,1390947,2212499,"int minimumAmplitude(vector<int>& nums, int k) {
    int len = nums.size();
    int result = INT_MAX;
    for(int i = 0; i < len - k; i++){
        int Min = INT_MAX;
        int Max = INT_MIN;
        for(int j = 0; j < i; j++){
            Min = min(Min,nums[j]);
            Max = max(Max,nums[j]);
        }
        for(int j = i + k; j < len; j++){
            Min = min(Min,nums[j]);
            Max = max(Max,nums[j]);
        }
        result = min(result,Max - Min);
    }
    return result;
}",0.9,1111111110
Array_list_9,1390947,2212499,"int steadySpeed(vector<int>& positions) {
    int len = positions.size();
//! tao ra vector chua abs cua 2 phan tu lien ke
    vector<int> v(len - 1,0);
    for(int i = 1; i < len; i++){ v[i-1] = abs(positions[i] - positions[i-1]);}
//! luu phan tu dau tien cua vector moi tao
    int tmp = v[0];
    int count = 1;
    int Max = 0;
    for(int i = 1;i < len - 1; i++){
//! giong thi cong count len
        if(tmp == v[i]) count ++;
        else {
//! luu phan tu count lon nhat
            Max = max(Max, count);
            count = 1;
            tmp = v[i];
        }
    }
    return max(Max, count) + 1;
}",1.0,111111111111111
Array_list_10,1390947,2212499,"int sumLessThanTarget(vector<int>& nums, int target) {
   int left = 0, right = nums.size() - 1;
    // ! gan gia tri nho nhat cho max
    int MAX = -10e6;
    while(left < right){
//! lon hon thi giam ben phai
        if(nums[left] + nums[right] >= target) right--;
//! nho hon thi tang ben trai len
        else{
// ! luu phan tu thoa man de bai lon nhat
            MAX = max(MAX,nums[left] + nums[right]);
            left ++;
        }
    }
    return MAX;
}",1.0,1111111111
Array_list_11,1390947,2212499,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
              //! duyet qua cac phan tu trong operations
    for (auto i : operations)
    {
        for (int j = i[0]; j <= i[1]; j++)
            nums[j] += i[2];
    }
    return nums;    
}
    
",1.0,111111
Array_list_1,1390964,2210535,"void bubbleSort(int arr[], int n) {
	for (int i = 0; i < n - 1; i++) {
		bool check = false;
		for (int j = 0; j < n - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
				check = true;
			}
		}
		if (check == false) {
			break;
		}
	}
}
int buyCar(int* nums, int length, int k) {
    bubbleSort(nums,length);
    int result = 0;
    for (int i=0; i<length; i++)    {
        if (k >= nums[i])    {
            k = k - nums[i];
            result++;
        }
    }
    return result;
}",1.0,1111111111
Array_list_2,1390964,2210535,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int length = nums.size();
    int count = 0;
    for (int i=0; i<length; i++)    {
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            count++;
        }
    }
    return count <= 2;
}",1.0,1111111111
Array_list_3,1390964,2210535,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int length = nums.size();
    int count = 0;
    for (int i=0; i<length; i++)    {
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            count++;
        }
    }
    return count <= 2;
}",1.0,1111111111
Array_list_4,1390964,2210535,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int length = nums.size();
    int count = 0;
    for (int i=0; i<length; i++)    {
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            count++;
        }
    }
    return count <= 2;
}",1.0,1111111111
Array_list_5,1390964,2210535,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    
    int sum = 0;
    for (int i=0; i<nums.size(); i++)   {
        sum += nums[i];
    }
    int leftSum = 0;
    for (int i=0; i<nums.size(); i++)   {
        if (leftSum == (sum - leftSum - nums[i]))    {
            return i;
        }
        leftSum += nums[i];
    }
    return -1;
}",1.0,1111111111
Array_list_6,1390964,2210535,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int n = words.size();
    if (n == 0) {
        return 0;
    }
    char temp = words[0][0];
    int result = 1;
    int tempresult = 1;
    for (int i=1; i<n; i++) {
        if (words[i][0] == temp)    {
            result++;
        }
        else {
            temp = words[i][0];
            result = 1;
        }
        if (tempresult < result)    {
            tempresult = result;
        }
    }
    return tempresult;
}",1.0,1111111
Array_list_9,1390964,2210535,"int steadySpeed(vector<int>& positions) {
    int temp = 2, tempresult = 0;
    int n = positions.size();
    if (n <= 2) { return n; }
    for (int i = 2; i < n; i++) {
        if (abs(positions[i - 1] - positions[i - 2]) == abs(positions[i - 1] - positions[i])) {
            temp++;
            tempresult = max(temp, tempresult);
        }
        else {
            temp = 2;
            tempresult = max(temp, tempresult);
        }
    }
    return tempresult;
}",1.0,111111111111111
Array_list_10,1390964,2210535,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left = 0;
    int right = nums.size()-1;
    int temp = 0;
    while (left < right)    {
        int sum = nums[left] + nums[right];
        if (sum < target)   {
            left++;
            temp = std::max(temp,sum);
        }
        else {
            right--;
        }
    }
    return temp;
}",1.0,1111111111
Array_list_11,1390964,2210535,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for (size_t i=0; i<operations.size(); i++) {
        for(int j=operations[i][0];j<= operations[i][1];j++)
        {   
            nums[j] += operations[i][2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1390991,2210103,"int minA(int* nums, int length, int lim)
{
    int minNums = 1000000;
    for (int i = 0; i < length; i++)
    {
        if (minNums == lim)
        {
            minNums = nums[i];
        }
        else
        {
            break;
        }
    }
    for (int i = 0; i < length; i++)
    {
        if (minNums > nums[i] && nums[i] > lim)
        {
            minNums = nums[i];
        }
    }
    return minNums;
}

int maxA(int* nums, int length)
{
    int maxNums = nums[0];
    for (int i = 0; i < length; i++)
    {
        if (maxNums < nums[i])
        {
            maxNums = nums[i];
        }
    }
    return maxNums;
}

int buyCar(int* nums, int length, int k) {
    int lim = minA(nums, length, 0);
    int sum = 0;
    int countA = 0;
    while (sum < k && lim <= maxA(nums, length) && countA != length)
    {
        for (int i = 0; i < length; i++)
        {
            if (sum + nums[i] <= k && nums[i] == lim)
            {
                sum += nums[i];
                countA++;
            }
        }
        if (sum == k)
        {
            return countA;
        }
        lim = minA(nums, length, lim);
    }
    return countA;
}",1.0,1111111111
Array_list_2,1390991,2210103,"bool consecutiveOnes(vector<int>& nums) {
    if (nums.empty())
    {
        return 1;
    }
    for (int i = 0; i < nums.size() - 1; i++)
    {
        if (nums.at(i + 1) == nums.at(i))
        {
            continue;
        }
        else
        {
            for (int j = i; j < nums.size() - 1; j++)
            {
                if (nums.at(i) == nums.at(j + 1))
                {
                    return 0;
                }
            }
        }
    }
    return 1;
}",1.0,1111111111
Array_list_3,1390991,2210103,"bool consecutiveOnes(vector<int>& nums) {
    if (nums.empty())
    {
        return 1;
    }
    for (int i = 0; i < nums.size() - 1; i++)
    {
        if (nums.at(i + 1) == nums.at(i))
        {
            continue;
        }
        else
        {
            for (int j = i; j < nums.size() - 1; j++)
            {
                if (nums.at(i) == nums.at(j + 1))
                {
                    return 0;
                }
            }
        }
    }
    return 1;
}",1.0,1111111111
Array_list_4,1390991,2210103,"bool consecutiveOnes(vector<int>& nums) {
    if (nums.empty())
    {
        return 1;
    }
    for (int i = 0; i < nums.size() - 1; i++)
    {
        if (nums.at(i + 1) == nums.at(i))
        {
            continue;
        }
        else
        {
            for (int j = i; j < nums.size() - 1; j++)
            {
                if (nums.at(i) == nums.at(j + 1))
                {
                    return 0;
                }
            }
        }
    }
    return 1;
}",1.0,1111111111
Array_list_5,1390991,2210103,"int equalSumIndex(vector<int>& nums) {
    if (nums.size() == 1)
    {
        return 0;
    }
    else if (nums.size() == 2)
    {
        return -1;
    }
    int left = nums.at(0), right = 0;
    for (int k = 2; k < nums.size(); k++)
    {
        right += nums.at(k);
    }
    for (int i = 1; i < nums.size() - 1; i++)
    {
        if (left == right)
        {
            return i;
        }
        left += nums.at(i);
        right -= nums.at(i + 1);
    }
    return -1;
}
",1.0,1111111111
Array_list_6,1390991,2210103,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int max=0;
    int count=1;
    for (int i=0; i< words.size(); i++){
         for (int j = i + 1; j < words.size(); j++)
        {
            if (words.at(j)[0] == words.at(i)[0])
            {
                count++;
            }
            else
            {
                break;
            }
        }
        if (max < count)
        {
            max = count;
        }
        i += (count - 1);
        count = 1;
    }
    return max;
}",1.0,1111111
Array_list_7,1390991,2210103,"int maxSum(int* nums, int n, int k) {
    int result = 0;

    for (int i = 0; i < n; ++i) {
        int maxS = nums[i];
        int sub = k+1;

        for (int j = i; j < n && j - i < k; ++j) {
            if (nums[j] > maxS) {
                maxS = nums[j];
            }

            int sValue = maxS * sub;
            result = max(result, sValue);

            ++sub;
        }
    }

    return result-1;
}


",0.2,10000
Array_list_8,1390991,2210103,"int max(vector<int>& nums, int left, int right)
{
	int maxNums = 0;
	bool isMayMax = false;
	for (int i = 0; i < int(nums.size()); i++)
	{
		if (i >= left) isMayMax = true;
		if (i > right) isMayMax = false;
		if (isMayMax == false && maxNums < nums.at(i))
		{
			maxNums = nums.at(i);
		}
	}
	return maxNums;
}

int min(vector<int>& nums, int left, int right)
{
	int minNums = 1000000;
	bool isMayMin = false;
	for (int i = 0; i < int(nums.size()); i++)
	{
		if (i >= left) isMayMin = true;
		if (i > right) isMayMin = false;
		if (isMayMin == false && minNums > nums.at(i))
		{
			minNums = nums.at(i);
		}
	}
	return minNums;
}

int minimumAmplitude(vector<int>& nums, int k) {
	int minNum = min(nums, 0, k - 1), maxNum = max(nums, 0, k - 1);
	int size = nums.size();
	int minOfMax_Min = 1000000;
	for (int i = 0; i < size - k; i++)
	{
		int minmax = maxNum - minNum;
		if (minmax < minOfMax_Min)
		{
			minOfMax_Min = minmax;
		}
		if (nums.at(i) >= minNum && nums.at(i) <= maxNum)
		{
			if (nums.at(i + k) == minNum)
			{
				minNum = min(nums, i + 1, i + k);
			}
			else if (nums.at(i + k) == maxNum)
			{
				maxNum = max(nums, i + 1, i + k);
			}
		}
		else if (nums.at(i) > maxNum)
		{
			maxNum = nums.at(i);
		}
		else if (nums.at(i) < minNum)
		{
			minNum = nums.at(i);
		}
	}
	return minOfMax_Min;
}",1.0,1111111111
Array_list_9,1390991,2210103,"int steadySpeed(vector<int>& positions)
{
	int max = 0;
	int count = 1;
	int value = abs(positions.at(0) - positions.at(1));
	for (int i = 0; i < int(positions.size()) - 1; i++)
	{
		int step = abs(positions.at(i) - positions.at(i + 1));
		if (value == step)
		{
			count++;
		}
		else
		{
			if (max < count) max = count;
			value = step;
			count = 2;
		}
	}
	if (max < count) max = count;
	return max;
}
",1.0,111111111111111
Array_list_10,1390991,2210103,"int sumLessThanTarget(vector<int>& nums, int target) {
	int max = 0;
	int value;
	for (int i = 0; i < nums.size(); i++)
	{
		for (int j = i + 1; j < nums.size(); j++)
		{
			value = nums.at(i) + nums.at(j);
			if (value > max && value < target) max = value;
			if (value == target - 1) return value;
		}
	}
	return max;
}",1.0,1111111111
Array_list_11,1390991,2210103,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
	for (int i = 0; i < int(operations.size()); i++)
	{
		for (int j = operations.at(i).at(0); j <= operations.at(i).at(1); j++)
		{
			nums.at(j) += operations.at(i).at(2);
		}
	}
	return nums;
}",1.0,111111
Array_list_8,1391093,2210034,"
int MIN(vector<int>& nums, unsigned int k, int a)
{
    int mini = INT_MAX;
    for(unsigned int i = 0; i < nums.size() ; ++i)
    {
        if(i >= k && i < k + a) continue;
        if(nums[i] < mini) mini = nums[i];
    }
   
    return mini;
}
int MAX(vector<int>& nums, unsigned int k, int a)
{
    int maxi = INT_MIN;
    for(unsigned int i = 0; i < nums.size()  ; ++i)
    {
        if(i >= k && i < k + a) continue;
        if(nums[i] > maxi) maxi = nums[i];
    }
   
    return maxi;
}
int minimumAmplitude(vector<int>& nums,unsigned int k) {
    int mini = INT_MAX;
    if(nums.size()==0) return 0;
    if(nums.size()==1) return 0;
    if(nums.size() <= k) return 0;
    for(unsigned int i = 0; i < nums.size() - k + 1; ++i)
    {
        if(MAX(nums, i, k) - MIN(nums, i, k) < mini) mini = MAX(nums, i, k) - MIN(nums, i, k);
    }
    return mini;
}

",0.9,1111111110
Array_list_1,1391103,2213250,"int buyCar(int* nums, int length, int k) {
sort(nums, nums + length);
int index=0;
while(index< length && k>0)
{
if(k>= nums[index]) k-=nums[index]; else break;
index++;
}
return index;
}",1.0,1111111111
Array_list_2,1391103,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_3,1391103,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_4,1391103,2213250,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
    int check=0;
    for (int i=0;i+1< n;i++){
        if((nums[i]!=1&&nums[i+1]==1)|| (nums[i]==1&&nums[i+1]!=1)){
            check+=1;
        }
    }
    return check<=2;
}",1.0,1111111111
Array_list_5,1391103,2213250,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
  int n = nums.size();
    int totalSum = 0;
    for (int a=0; a<n; a++) {
        totalSum += nums[a];
    }
    int leftSum = 0;
    for (int i = 0; i < n; i++) {
        if (leftSum == (totalSum - leftSum - nums[i])) {
            return i;
        }
        leftSum += nums[i];
    }
    return -1;
}
",1.0,1111111111
Array_list_6,1391103,2213250,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int length = words.size();
    if(words.size() == 0) return 0;
    int clen = 1;
    int maxlen = 1;
    char fletter= words[0][0];
    for (int i=1; i< length;i++)
    {
        if(words[i][0]== fletter){
            clen++;
        }
        else{
            fletter = words[i][0];
            clen =1;
        }
        if (clen> maxlen){
            maxlen= clen;
        }
    }
    if (clen> maxlen){
        maxlen= clen;
    }
    return maxlen;
}",1.0,1111111
Array_list_7,1391103,2213250,"int max_array(int* nums , int l , int r){
    int ans = (int)(-1e9);
    for(int i= l ; i<=r ; i++){
        ans = max(ans,nums[i]);
    }
    return ans;
}

int maxSum(int* nums, int n, int k) {
    int dp[10001];
    for(int i=0 ; i<k ; i++){
        dp[i] = max_array(nums,0,i)*(i+1);
    }
    for(int i = k ; i<n;i++){
        for(int j = 1 ; j<=k;j++){
            dp[i] = max(dp[i], max_array(nums,i-j+1, i)*j + dp[i-j]);
        }
    }
    return dp[n-1];
}",0.6,11010
Array_list_8,1391103,2213250,"int mins[1000]{}, maxs[1000]{}, mine[1000]{}, mmaxe[1000]{};

int minimumAmplitude(vector<int>& nums, int k) {
	int ans = 1e9;
	int n = nums.size();
	int* mins = new int[n] {};
	int* mine = new int[n] {};
	int* maxs = new int[n] {};
	int* maxe = new int[n] {};
	mins[0] = nums[0];
	maxs[0] = nums[0];
	mine[n - 1] = nums[n - 1];
	maxe[n - 1] = nums[n - 1];
	for (int i = 1; i < n; i++)
	{
		mins[i] = min(mins[i - 1], nums[i]);
		maxs[i] = max(maxs[i - 1], nums[i]);
	}
	for (int i = n-2; i >= 0; i--)
	{
		mine[i] = min(mine[i + 1], nums[i]);
		maxe[i] = max(maxe[i + 1], nums[i]);
	}
	int min_arr = 0;
	int max_arr = 0;
	for (int i = 0; i < n-k; i++)
	{
		if(i!= 0) min_arr = min(mins[i-1], mine[i+k]);
		else min_arr = mine[i + k];
		if (i + k < n - 1) max_arr = max(maxs[i - 1], maxe[i + k]);
		else max_arr = maxs[i];
		ans = min(ans, max_arr - min_arr);
	}
	return ans;
}",1.0,1111111111
Array_list_9,1391103,2213250,"int steadySpeed(vector<int>& positions) {
    int csub =2, sfsub=0;
    int n = positions.size();
    if( n <= 2){ return n;}
    for (int i =2 ; i<n; i++){
        if(abs(positions[i-1]-positions[i-2]) == abs(positions[i-1]-positions[i])){
            csub++;
            sfsub = max(csub, sfsub);
        }
        else{
            csub = 2;
            sfsub = max(csub, sfsub);
        }
    }
    return sfsub;
}",1.0,111111111111111
Array_list_10,1391103,2213250,"int sumLessThanTarget(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int maxSum = INT_MIN;

    while (left < right) {
        int currentSum = nums[left] + nums[right];

        if (currentSum < target) {
            maxSum = max(maxSum, currentSum);
            left++; 
        } else {
            right--;
        }
    }

    return maxSum;
}



",1.0,1111111111
Array_list_11,1391103,2213250,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int n = operations.size();
    for (int i=0;i< n;i++){
        for(int j= operations[i][0]; j<= operations[i][1];j++){
            nums[j]+= operations[i][2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1391150,2210055,"int buyCar(int* nums, int length, int k) {
    int maxCar=0;
    int maxMoney=0;
    for(int i=0 ; i < length-1 ; i++){
        for(int j=i+1; j<length ; j++){
            if(nums[i]>nums[j]){
                int tmp=nums[i];
                nums[i]=nums[j];
                nums[j]=tmp;
            }
        }
    }
   for(int i=0 ; i<length ; i++){
       maxMoney+=nums[i];
       if(maxMoney>k){
         return maxCar;
       }
       maxCar++;
   }
    return maxCar;
}",1.0,1111111111
Array_list_2,1391150,2210055,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0){
        return 1;
        }
    bool metNumberOne =0;
    bool zeroBefore=0;
    for(auto tmp: nums){
        if(tmp==1){
            if(metNumberOne&&zeroBefore){
                return 0;
            }
            metNumberOne=1;
            zeroBefore=0;
        }
        else zeroBefore=1;
     
    }
       return 1;
}",1.0,1111111111
Array_list_3,1391150,2210055,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0){
        return 1;
        }
    bool metNumberOne =0;
    bool zeroBefore=0;
    for(auto tmp: nums){
        if(tmp==1){
            if(metNumberOne&&zeroBefore){
                return 0;
            }
            metNumberOne=1;
            zeroBefore=0;
        }
        else zeroBefore=1;
     
    }
       return 1;
}",1.0,1111111111
Array_list_4,1391150,2210055,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0){
        return 1;
        }
    bool metNumberOne =0;
    bool zeroBefore=0;
    for(auto tmp: nums){
        if(tmp==1){
            if(metNumberOne&&zeroBefore){
                return 0;
            }
            metNumberOne=1;
            zeroBefore=0;
        }
        else zeroBefore=1;
     
    }
       return 1;
}",1.0,1111111111
Array_list_5,1391150,2210055,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sumTotal=0 ;
    int sumRight=0;
    int sumLeft=0;
    for(int i = 0 ; i<nums.size();i++){
        sumTotal+=nums[i];
    }
    for(int i=0;i<nums.size();i++){
        sumRight=sumTotal-sumLeft-nums[i];
        if(sumRight==sumLeft){
            return i;
        }
        sumLeft+=nums[i];
    }
    return -1;
}",1.0,1111111111
Array_list_6,1391150,2210055,"int longestSublist(vector<string> &words)
{
  // STUDENT ANSWER
  int count = 1;
  int maxCount = 0;
  for (int i = 1; i < words.size(); i++)
  {
    if (words[i][0] == words[i - 1][0])
    {
      count++;
      count > maxCount ? maxCount = count : maxCount = maxCount;
    }
    else
    {
      count = 1;
    }
  }
  return maxCount;
}",1.0,1111111
Array_list_9,1391150,2210055,"int steadySpeed(vector<int> &positions)
{
  int maxCount = 2;
  int currentCount = 2;
  int speed = abs(positions[1] - positions[0]);
  int length= positions.size();
  for (int i = 2; i <length; i++)
  {
    int currentSpeed = abs(positions[i] - positions[i - 1]);
    if (currentSpeed == speed)
    {
      currentCount++;
    }
    else
    {
      maxCount = max(maxCount, currentCount);
      currentCount = 2;
      speed = currentSpeed;
    }
    maxCount = max(maxCount, currentCount);
  }
  return maxCount;
}",1.0,111111111111111
Array_list_10,1391150,2210055,"int sumLessThanTarget(vector<int> &nums, int target)
{
  // STUDENT ANSWER
  int left = 0;
  int right = nums.size() - 1;
  int maxSum = 0;
  while(left<right)
  {
    int currentSum = nums[left] + nums[right];
    if (currentSum >= target)
    {
      right--;
    }
    else
    {
      maxSum = max(maxSum, currentSum);
      left++;
    }
  }
  return maxSum;
}",1.0,1111111111
Array_list_2,1391168,2210458,"bool consecutiveOnes(vector<int>& nums) 
{
	if (nums.size() == 0)
	{
		return true;
	}
	bool is1Consecutive = false, result = true;
	int i = 0;
	int count = 0;
	while (i < nums.size() && result == true)
	{
		if (nums[i] == 1 && is1Consecutive == false)
		{
			while (i < nums.size())
			{
				if (nums[i] != 1)
				{
					is1Consecutive = true;
					break;
				}
				i++;
			}
		}
		if (nums[i] == 1 && is1Consecutive == true)
		{
			result = false;
		}
		i++;
	}
	return result;
}
",1.0,1111111111
Array_list_3,1391168,2210458,"bool consecutiveOnes(vector<int>& nums) 
{
	if (nums.size() == 0)
	{
		return true;
	}
	bool is1Consecutive = false, result = true;
	int i = 0;
	int count = 0;
	while (i < nums.size() && result == true)
	{
		if (nums[i] == 1 && is1Consecutive == false)
		{
			while (i < nums.size())
			{
				if (nums[i] != 1)
				{
					is1Consecutive = true;
					break;
				}
				i++;
			}
		}
		if (nums[i] == 1 && is1Consecutive == true)
		{
			result = false;
		}
		i++;
	}
	return result;
}
",1.0,1111111111
Array_list_4,1391168,2210458,"bool consecutiveOnes(vector<int>& nums) 
{
	if (nums.size() == 0)
	{
		return true;
	}
	bool is1Consecutive = false, result = true;
	int i = 0;
	int count = 0;
	while (i < nums.size() && result == true)
	{
		if (nums[i] == 1 && is1Consecutive == false)
		{
			while (i < nums.size())
			{
				if (nums[i] != 1)
				{
					is1Consecutive = true;
					break;
				}
				i++;
			}
		}
		if (nums[i] == 1 && is1Consecutive == true)
		{
			result = false;
		}
		i++;
	}
	return result;
}
",1.0,1111111111
Array_list_1,1391263,2211667,"int compare(const void* a, const void* b){
    return (*(int*)a-*(int*)b);
}
int buyCar(int* nums, int length, int k) {
    qsort(nums, length, sizeof(int), compare);
    int count=0;
    for (int i=0; i<length; i++){
        if(nums[i]<=k){
            count++;
            k-=nums[i];
        } else break;
    }
    return count;
}",1.0,1111111111
Array_list_2,1391263,2211667,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size()==0) {
        return true;
    }
    
    bool consecutives = false;
    
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] == 1 && nums[i - 1] == 1) {
            consecutives = true;
        }
        if(consecutives){
            if(nums[i]!=1&&nums[i+1]==1) return false;
        }
    }
    
    return consecutives;

}",1.0,1111111111
Array_list_3,1391263,2211667,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size()==0) {
        return true;
    }
    
    bool consecutives = false;
    
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] == 1 && nums[i - 1] == 1) {
            consecutives = true;
        }
        if(consecutives){
            if(nums[i]!=1&&nums[i+1]==1) return false;
        }
    }
    
    return consecutives;

}",1.0,1111111111
Array_list_4,1391263,2211667,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size()==0) {
        return true;
    }
    
    bool consecutives = false;
    
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] == 1 && nums[i - 1] == 1) {
            consecutives = true;
        }
        if(consecutives){
            if(nums[i]!=1&&nums[i+1]==1) return false;
        }
    }
    
    return consecutives;

}",1.0,1111111111
Array_list_5,1391263,2211667,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int n=nums.size();
    int leftSum=0;
    int rightSum=0;
    for(int i=1; i<n; i++){
        rightSum+=nums[i];
    }
    for(int i=0; i<n; i++){
        if(leftSum==rightSum){
            return i;
        }
        leftSum+=nums[i];
        if(i+1<n){
            rightSum-=nums[i+1];
        }
    }
    return -1;
}",1.0,1111111111
Array_list_6,1391263,2211667,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if (words.empty()) {
        return 0;
    }
    for (int i=0; i<words.size(); i++) {
        
    }

    
}",0.14,0100000
Array_list_10,1391263,2211667,"int sumLessThanTarget(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int maxSum = INT_MIN;
    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum < target) {
            maxSum = max(maxSum, sum);
            left++;
        } else {
            right--;
        }
    }
    return maxSum;
}
",1.0,1111111111
Array_list_11,1391263,2211667,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for (const auto& operation : operations) {
        int left = operation[0];
        int right = operation[1];
        int increment = operation[2];
        for (int i = left; i <= right; ++i) {
            nums[i] += increment;
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1391322,2210532,"int partition(int* arr, int l, int r){
    int i=l-1;
    for(int j=l;j<r;j++) {
        if(arr[j]<arr[r]){
            i+=1;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i+1], arr[r]);   
    return i+1;
}
void QuickSort(int* arr, int l, int r){
    if (r <= l) return;
    int p=partition(arr, l, r);
    QuickSort(arr, l, p-1);
    QuickSort(arr,p+1, r);
}
int buyCar(int* num, int len, int k){
    QuickSort(num, 0, len-1);
    int count=0;
    for(int i=0;i<len;i++){
        if(k<num[i])break;
        else {
            k-=num[i];
            count++;
        }
    }
    return count;
}",1.0,1111111111
Array_list_2,1391322,2210532,"bool consecutiveOnes(vector<int>& nums) {
    bool check =false;
    if(nums.size()==0)check=true;
    else{
        for(int i=0;i<nums.size();i++){
            if(nums[i]==1 && check== false){
                check=true;
            }
            else if(nums[i]==1 && check== true && nums[i-1]!=1)check= false;
        }
    }
    return check;
}",1.0,1111111111
Array_list_3,1391322,2210532,"bool consecutiveOnes(vector<int>& nums) {
    bool check =false;
    if(nums.size()==0)check=true;
    else{
        for(int i=0;i<nums.size();i++){
            if(nums[i]==1 && check== false){
                check=true;
            }
            else if(nums[i]==1 && check== true && nums[i-1]!=1)check= false;
        }
    }
    return check;
}",1.0,1111111111
Array_list_4,1391322,2210532,"bool consecutiveOnes(vector<int>& nums) {
    bool check =false;
    if(nums.size()==0)check=true;
    else{
        for(int i=0;i<nums.size();i++){
            if(nums[i]==1 && check== false){
                check=true;
            }
            else if(nums[i]==1 && check== true && nums[i-1]!=1)check= false;
        }
    }
    return check;
}",1.0,1111111111
Array_list_5,1391322,2210532,"int equalSumIndex(vector<int>& nums) {
    int n = nums.size();
    vector<int> leftSum(n, 0);
    vector<int> rightSum(n, 0);
    leftSum[0] = nums[0];
    for (int i = 1; i < n; i++) {
        leftSum[i] = leftSum[i - 1] + nums[i];
    }
    rightSum[n - 1] = nums[n - 1];
    for (int i = n - 2; i >= 0; i--) {
        rightSum[i] = rightSum[i + 1] + nums[i];
    }
    for (int i = 0; i < n; i++) {
        if (leftSum[i] == rightSum[i]) {
            return i;
        }
    }
    return -1;
}",1.0,1111111111
Array_list_6,1391322,2210532,"int longestSublist(vector<string>& words) {
    int max=0;
    for(int i=0;i<words.size();i++){
        string A= words[i];
        int count=1;
        for(int j=i+1;j<words.size();j++){
            string B=words[j];
            if(A[0] == B[0])count++;
        }
        if(count>max)max=count;
    }
    return max;
}",0.29,1100000
Array_list_8,1391322,2210532,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER 
    int n=nums.size();
    vector<int>minL=nums;
    vector<int>minR=nums;
    vector<int>maxL=nums;
    vector<int>maxR=nums;
    for (int i = 1; i < n; i++) {
        minL[i] = min(minL[i - 1], minL[i]);
        maxL[i] = max(maxL[i - 1], maxL[i]);
    }
    for (int i = n - 2; i >= 0; i--) {
        minR[i] = min(minR[i + 1], minR[i]);
        maxR[i] = max(maxR[i + 1], maxR[i]);
    }
    int res=INT_MAX;
    for(int i=0;i<=n-k-1;i++){
        int tmp=max(maxL[i], maxR[i+k+1]) - 
        min(minL[i], minR[i+k+1]);
        res=min(res, tmp);
    }
    return res;
}",1.0,1111111111
Array_list_9,1391322,2210532,"int steadySpeed(vector<int>& positions) {
    int Max=1;
    int count=1;
    int n=positions.size();
    for(int i=2;i<n;i++){
        if(abs(positions[i]-positions[i-1]) 
        == abs(positions[i-1]-positions[i-2]))count+=1;
        else {
            if(count>Max)Max=count;
            count=1;
        }
        if(i==n-1){
            if(count>Max)Max=count;
            count=1;
        }
    }
    return Max+1;
}",1.0,111111111111111
Array_list_10,1391322,2210532,"int sumLessThanTarget(vector<int>& nums, int target) {
    int left=0;
    int right=nums.size()-1;
    int Max=INT_MIN;
    while(left<right){
        int curr=nums[left] + nums[right];
        if(curr < target){
            Max=max(Max,curr);
            left++;
        }
        else right--;
    }
    return Max;
}",1.0,1111111111
Array_list_11,1391322,2210532,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    int n=operations.size();
    for(int i=0;i<n;i++){
        vector<int> tmp=operations[i];
        for(int j=tmp[0];j<=tmp[1];j++){
            nums[j]+=tmp[2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1391462,2213248,"int find_min(int* nums, int length) {
    int min = nums[0];
    for(int i = 0; i < length; i++) {
        if(nums[i] < min) min = nums[i];
    }
    int i = 0;
    while(nums[i] != min) i++;
    while(i < length - 1) {
        nums[i] = nums[i + 1];
        i++;
    }
    return min;
    
}
int buyCar(int* nums, int length, int k) {
    if(length > 0) {
        int min = find_min(nums, length);
        if(k - min < 0) return 0;
        else return 1 + buyCar(nums, length - 1, k - min);
    }
    else return 0;
}",1.0,1111111111
Array_list_2,1391462,2213248,"bool have_1(vector<int>& nums) {
    for(int i = 0; i < nums.size(); i++) {
        if(nums.at(i) == 1) return 1;
    }
    return 0;
}

bool consecutiveOnes(vector<int>& nums) {
    if(!have_1(nums)) return 1;
    int i = 0;
    while(nums.at(i) != 1) i++;
    while(nums.at(i) == 1) i++;
    while(i < nums.size()) {
        if(nums.at(i) == 1) return 0;
        i++;
    }
    return 1;
}
",1.0,1111111111
Array_list_3,1391462,2213248,"bool have_1(vector<int>& nums) {
    for(int i = 0; i < nums.size(); i++) {
        if(nums.at(i) == 1) return 1;
    }
    return 0;
}

bool consecutiveOnes(vector<int>& nums) {
    if(!have_1(nums)) return 1;
    int i = 0;
    while(nums.at(i) != 1) i++;
    while(nums.at(i) == 1) i++;
    while(i < nums.size()) {
        if(nums.at(i) == 1) return 0;
        i++;
    }
    return 1;
}
",1.0,1111111111
Array_list_4,1391462,2213248,"bool have_1(vector<int>& nums) {
    for(int i = 0; i < nums.size(); i++) {
        if(nums.at(i) == 1) return 1;
    }
    return 0;
}

bool consecutiveOnes(vector<int>& nums) {
    if(!have_1(nums)) return 1;
    int i = 0;
    while(nums.at(i) != 1) i++;
    while(nums.at(i) == 1) i++;
    while(i < nums.size()) {
        if(nums.at(i) == 1) return 0;
        i++;
    }
    return 1;
}
",1.0,1111111111
Array_list_5,1391462,2213248,"int equalSumIndex(vector<int>& nums) {
    int size = nums.size();
    int sum1, sum2;
    for(int i = 0; i < size; i++) {
        sum2 += nums.at(i);
    }
    for(int i = 0; i < size; i++) {
        if(i > 0) sum1 += nums.at(i - 1);
        if(i < size - 1) sum2 -= nums.at(i);
        if(sum1 == sum2) return 1;
    }
    return -1;
}",0.8,0011111011
Array_list_1,1391515,2212741,"int buyCar(int* nums, int length, int k) {
    int min=nums[0];
    int idx=0;
    for(int i=0;i<length;i++){
        min=nums[i];
        idx=i;
        for(int j=i+1;j<length;j++){
            if(nums[j]<=min){
                min=nums[j];
                idx=j;
            }
        }
         nums[idx]=nums[i];
            nums[i]=min;
    }
    int res=0;
    for(int i=0;i<length;i++){
        k-=nums[i];
        res++;
        if(k<0){
            res--;
            break;
        }
    }
    return res;
}",1.0,1111111111
Array_list_2,1391515,2212741,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0) return 1;
    int tmp0=0;
    int tmp1=1;
    int count=0;
    for(int i=0;i<nums.size();i++ ){
        if(nums[i]!=1&&tmp0==1){
            count++;
            tmp0=0;
            tmp1=1;
        }
        if(nums[i]==1&&tmp1==1){
            count++;
            tmp0=1;
            tmp1=0;
        }
    }
    return (count<=2);
}",1.0,1111111111
Array_list_3,1391515,2212741,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0) return 1;
    int tmp0=0;
    int tmp1=1;
    int count=0;
    for(int i=0;i<nums.size();i++ ){
        if(nums[i]!=1&&tmp0==1){
            count++;
            tmp0=0;
            tmp1=1;
        }
        if(nums[i]==1&&tmp1==1){
            count++;
            tmp0=1;
            tmp1=0;
        }
    }
    return (count<=2);
}",1.0,1111111111
Array_list_4,1391515,2212741,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0) return 1;
    int tmp0=0;
    int tmp1=1;
    int count=0;
    for(int i=0;i<nums.size();i++ ){
        if(nums[i]!=1&&tmp0==1){
            count++;
            tmp0=0;
            tmp1=1;
        }
        if(nums[i]==1&&tmp1==1){
            count++;
            tmp0=1;
            tmp1=0;
        }
    }
    return (count<=2);
}",1.0,1111111111
Array_list_7,1391631,2210103,"int maxSum(int* nums, int n, int k) {
    int result = 0;

    for (int i = 0; i < n; ++i) {
        int maxS = nums[i];
        int sub = k+1;

        for (int j = i; j < n && j - i <= k-1; ++j) {
            if (nums[j] > maxS) {
                maxS = nums[j];
            }

            int sValue = maxS * sub;
            result = max(result, sValue);

            ++sub;
        }
    }

    return result-1;
}",0.2,10000
Array_list_7,1392097,2213250,"int max_array(int* nums , int l , int r){
    int ans = -1e9;
    for(int i=l ; i<=r ; i++){
        ans = max(ans,nums[i]);
    }
    return ans;
}



int maxSum(int* nums, int n, int k) {
    int dp[100001]{};
    for(int i= 0 ; i<k ; i++){
        dp[i] = max_array(nums,0,i)*(i+1);
    }
    for(int i= k ; i<n;i++){
        dp[i] = -1e9;
        for(int j=1 ; j<=k ; j++){
            dp[i] = max(dp[i],dp[i-j] + max_array(nums,i-j+1,i)*j);
        }
    }
    return dp[n-1];
}",1.0,11111
Array_list_8,1392097,2213250,"int minimumAmplitude(vector<int>& nums, int k) {
	int n = nums.size();
    vector<int> max_left(n,INT_MIN);
    vector<int> min_left(n,INT_MAX);
    vector<int> max_right(n,INT_MIN);
    vector<int> min_right(n,INT_MAX);
    max_left[0] = min_left[0] = nums[0];
    for(int i=1 ; i<n ; i++){
    	max_left[i] = max(max_left[i-1],nums[i]);
    	min_left[i] = min(min_left[i-1],nums[i]);
    }
    max_right[n-1] = min_right[n-1] = nums[n-1];
    for(int j = n -2 ; j>=0 ;j--){
    	max_right[j] = max(max_right[j+1],nums[j]);
    	min_right[j] = min(min_right[j+1],nums[j]);
    }
    int ans = INT_MAX ;
    //cout<<max_right[4]<<endl;
    for(int i=0 ; i+k-1<n;i++){
    	//cout<<ans<<endl;
    	if(i==0) ans = min(ans,max_right[i+k]-min_right[i+k]);
    	else if(i+k-1==n-1) ans=min(ans,max_left[i]-min_left[i]);
    	else{
    		ans = min(ans,max(max_left[i-1],max_right[i+k])-min(min_left[i-1],min_right[i+k]));
    	}
    }
    return ans;
    
}",1.0,1111111111
Array_list_1,1392269,2013048,"int buyCar(int* nums, int length, int k) {
    sort(nums, nums + length);
    int i = 0;
    while( i < length){
        if(k >= nums[i]){
            k -= nums[i++];
        }
        else break;
    }
    return i;
}",1.0,1111111111
Array_list_2,1392269,2013048,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool res = true;
    int cont = 0;
    bool flag = false;
    for (int i = 0; i < nums.size() ; i++) {
        if (nums[i] == 1 && cont >= 2 ) {
            return false;
        }
        if (nums[i] == 1 ) {
            cont = 0;
            flag = true;
        }
        else if (flag == true && nums[i] != 1 ) {
            cont += 1;
        }

    }
    return res;
}",1.0,1111111111
Array_list_3,1392269,2013048,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool res = true;
    int cont = 0;
    bool flag = false;
    for (int i = 0; i < nums.size() ; i++) {
        if (nums[i] == 1 && cont >= 2 ) {
            return false;
        }
        if (nums[i] == 1 ) {
            cont = 0;
            flag = true;
        }
        else if (flag == true && nums[i] != 1 ) {
            cont += 1;
        }

    }
    return res;
}",1.0,1111111111
Array_list_4,1392269,2013048,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool res = true;
    int cont = 0;
    bool flag = false;
    for (int i = 0; i < nums.size() ; i++) {
        if (nums[i] == 1 && cont >= 2 ) {
            return false;
        }
        if (nums[i] == 1 ) {
            cont = 0;
            flag = true;
        }
        else if (flag == true && nums[i] != 1 ) {
            cont += 1;
        }

    }
    return res;
}",1.0,1111111111
Array_list_5,1392269,2013048,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size() == 1 ) {
        return 0;
    }
        if (nums.size() == 0 ) {
        return -1;
    }

    int left = 0;
    int right = 0;

    for (int i = 0 ; i < nums.size(); i++ ) {
        right += nums[i];
    }
    right -= nums[0];
    for (int i = 1 ; i< nums.size() ; i++) {
        left += nums[i-1];
        right -= nums[i];
        if (left >= right ) {
            if (left == right ) {
                return i;
            }
            else return -1;
        }
    }
}",1.0,1111111111
Array_list_6,1392269,2013048,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.size() == 0)
        return 0;
    int max_length = 1;
    vector<string> subarray;
    for(unsigned int i = 0; i < words.size()-1; i++){
            if(words[i][0] == words[i+1][0]){
                subarray.push_back(words[i]);
                if(i+1 == words.size()-1) subarray.push_back(words[i+1]);
            }else{
                subarray.push_back(words[i]);
                max_length = (max_length < (int) subarray.size())? (int) subarray.size(): max_length;
                subarray.clear();
            }
            max_length = (max_length < (int) subarray.size())? (int) subarray.size(): max_length;
    }
    return max_length;
}",1.0,1111111
Array_list_7,1392269,2013048,"int helpfunction(int *num, int n, int k, int & size){
    int max = num[0], i = 1, idx = 1;
    for(; i < n; i++){
        if(num[i] > max){
            max = num[i];
            idx = i;
        }
    }
    int start = (!idx) ? 0 : idx - k / 2;
    int end = (!idx) ? k : ((k%2) ? idx + k/2 : idx + k/2 -1);
    end = (end >= n) ? n : end;
    for(int i = start; i <= end; i++){
        size += (num[i] > 0) ? 1 : 0;
        num[i] = -1;
    }
    return (max > 0) ? max : 0;
}
int maxSum(int *nums, int n, int k){
    int SubN = (n%k)? n/k+ n%k : n/k;
    int *numcp = nums;
    int sum = 0;
    int j = 0;
    while(j < SubN){
        int size = 0;
        int maxValue = helpfunction(numcp, n , k, size);
        sum += maxValue*size;
        j++;
    }
    return sum;
}",0.2,10000
Array_list_10,1392269,2013048,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int maxSum = 0;
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int currentSum = nums[left] + nums[right];
        if (currentSum < target && currentSum > maxSum) {
            maxSum = currentSum;
        }
        if (currentSum < target) {
            left++;
        } else {
            right--;
        }
    }
    return maxSum;
}",1.0,1111111111
Array_list_11,1392269,2013048,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for(unsigned int i = 0; i < operations.size(); i++){
        int L = operations[i][0], R = operations[i][1], X = operations[i][2];
        for(int idx = L; idx <= R; idx++)
            nums[idx] += X;
    }
    return nums;
}",1.0,111111
Array_list_1,1392500,2112585,"int buyCar(int* nums, int length, int k) {
    sort(nums, nums + length); //sap xep tang dan
    int count = 0;
    int sum = 0;
    for (int i = 0; i < length; i++) {
        sum += nums[i]; //tong gia xe tang dan
        if (sum <= k) count++; 
        else break; //dung neu vuot qua budget
    }
    return count;
}",1.0,1111111111
Array_list_2,1392500,2112585,"bool consecutiveOnes(vector<int>& nums) {
    bool foundOne = false;
    bool space = false;
    for (int i = 0; i < nums.size(); ++ i) {
        if (nums[i] == 1) {
            if (space) return false;
            foundOne = true;
        } 
        else if (foundOne) space = true;
        }
    
    return true;
}",1.0,1111111111
Array_list_3,1392500,2112585,"bool consecutiveOnes(vector<int>& nums) {
    bool foundOne = false;
    bool space = false;
    for (int i = 0; i < nums.size(); ++ i) {
        if (nums[i] == 1) {
            if (space) return false;
            foundOne = true;
        } 
        else if (foundOne) space = true;
            
        }
    return true;
}",1.0,1111111111
Array_list_4,1392500,2112585,"bool consecutiveOnes(vector<int>& nums) {
    bool foundOne = false;
    bool space = false;
    for (int i = 0; i < nums.size(); ++ i) {
        if (nums[i] == 1) {
            if (space) return false;
            foundOne = true;
        } 
        else if (foundOne) space = true;
            
        }
    return true;
}",1.0,1111111111
Array_list_5,1392500,2112585,"int equalSumIndex(vector<int>& nums) {
    if (nums.size()==0) return -1;
    else
    for (int i = 0; i < nums.size(); i++) {
        int leftSum = 0;
        for (int j = i; j >= 0; j--) {
            leftSum += nums[j];
        }
 
        int rightSum = 0;
        for (int k = i; k < nums.size(); k++) {
            rightSum += nums[k];
        }
 
        if (leftSum == rightSum) {
            return i;
        }
    }
    return -1;
}
",0.7,11111110
Array_list_6,1392500,2112585,"int longestSublist(vector<string>& words) {
    int longestLength = 0;
    int currentLength = 0;
    char currentLetter = '\0';

    for (const string& word : words) {
        if (word.empty()) {
            continue;
        }

        if (currentLetter == '\0' || word[0] == currentLetter) {
            currentLength++;
        } else {
            longestLength = max(longestLength, currentLength);
            currentLength = 1;
        }

        currentLetter = word[0];
    }

    return max(longestLength, currentLength);
}",1.0,1111111
Array_list_7,1392500,2112585,"
int maxSum(int* nums, int n, int k) {
    int subarrayCount = (n + k - 1) / k; // Calculate the number of subarrays needed

    int sum = 0;
    for (int i = 0; i < subarrayCount; i++) {
        int start = i * k;
        int end = min(start + k, n);
        int largestElement = nums[start];
        for (int j = start + 1; j < end; j++) {
            if (nums[j] > largestElement) {
                largestElement = nums[j];
            }
        }
        int sValue = largestElement * (end - start);
        sum += sValue;
        sum = max(sum, sValue); // Update the maximum sum
    }

    return sum;
}",0.2,00100
Array_list_1,1393625,2211738,"int buyCar(int* nums, int length, int k) {
    if(length == 0) return -1;
    sort(nums, nums+length);
    int count = 0;
    for(int i = 0; i < length; i++){
        if(nums[i] <= k){
            k -= nums[i];
            count++;
        }
    }
    return count;
}",1.0,1111111111
Array_list_2,1393625,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()){
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i]);
                i++;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_3,1393625,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()){
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i]);
                i++;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_4,1393625,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()){
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i]);
                i++;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_5,1393625,2211738,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size() <= 1) return 0;
    int sum = 0;
    for(int i = 0; i < nums.size(); i++){
        sum += nums[i];
    }
    vector<int> res;
    res.push_back(nums[0]);
    for(int i = 1; i < nums.size(); i++){
        int sum1 = nums[i];
        if(i >= 2){
            sum1 = nums[i-1] + res[i-2];
            res.push_back(sum1);
        }
        if(sum1 == sum - nums[i] - sum1) return i;
    }
    return -1;
}",1.0,1111111111
Array_list_6,1393625,2211738,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.empty()) return 0;
    int j = 0, ans = 1;
    for(int i = 1; i < words.size(); i++){
        if(words[i][0] == words[j][0]){
            ans = max(ans, i-j+1);
        }else{
            j = i;
        }
    }
    return ans;
}",1.0,1111111
Array_list_8,1393625,2211738,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int len = nums.size(), res = 1e9;
    vector<int> mx1;
    vector<int> mn1;
    vector<int> mx2;
    vector<int> mn2;
    for(int i = 0; i <= len-k; i++){
        int max1 , min1;
        if(i >= 2){
            max1 = max(nums[i-1], mx1[i-1]);
            min1 = min(nums[i-1], mn1[i-1]);
        }else{
            max1 = min1 = nums[0];
            
        }
        mx1.push_back(max1);
        mn1.push_back(min1);
    }
    for(int j = len-1; j >= k-1; j--){
        int max2, min2;
        if(j < len-k){
            max2 = max(nums[j+1], mx2[len-j-2]);
            min2 = min(nums[j+1], mn2[len-j-2]);
        }else{
            max2 = min2 = nums[len-1]   ;
        }
        mx2.push_back(max2);
        mn2.push_back(min2);
    }
    int len1 = mx1.size();
    for(int i = 0; i < len1; i++){
        int maxi = max(mx1[i], mx2[len1-i-1]);
        int mini = min(mn1[i], mn2[len1-i-1]);
        
        res = min(res, maxi-mini);
    }
    return res;
}",0.4,1101000001
Array_list_10,1393625,2211738,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left = 0, right = nums.size()-1, maxSum = -1e9;
    while(left < right){
        int sum = nums[left] + nums[right];
        if(sum < target){
            maxSum = max(sum, maxSum);
            left++;
            
        }else{
            right--;
        }
    }
    return maxSum;
}",1.0,1111111111
Array_list_11,1393625,2211738,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int len1 = nums.size();
    int len2 = operations.size();
    for(int i = 0; i < len1; i++){
        for(int j = 0; j < len2; j++){
            if(i >= operations[j][0] && i <= operations[j][1]){
                nums[i] += operations[j][2];
            }
        }
    }
    return nums;
}",1.0,111111
Array_list_5,1398928,2212741,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sum=0;
    for(int i=0;i<nums.size();i++){
        sum+=nums[i];
    }
    int tmp=0;
    int i=0;
    while(tmp<sum/2){
        tmp+=nums[i];
        i++;
    }
    if(sum-tmp==tmp-nums[i-1]) return i-1;
    else return -1;
}",1.0,1111111111
Array_list_6,1398928,2212741,"
int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    // int array[52];
    // for(int i=0;i<52;i++){
    //     array[i]=0;
    // }
    // for(int i=0;i<words.size();i++){
    //     char x=words[i][0];
    //     if('a'<=x<='z'){
    //      int num=x-'a';
    //     array[num]++;
    //     }
    //     else{
    //         int num=x-'A';
    //         array[num]++;
    //     }
    // }
    // int res=array[0];
    // for(int i=1;i<52;i++){
    //     if(array[i]>res) res=array[i];
    // }
    // return res;
    int maxSubarrayLength = 0;
    int currentSubarrayLength = 1; // Initialize with 1 since a single word is a subarray with a length of 1

    // Handle the case of an empty array
    if (words.empty()) {
        return 0;
    }

    char prevFirstLetter = words[0][0]; // Initialize with the first letter of the first word

    for (size_t i = 1; i < words.size(); ++i) {
        char currentFirstLetter = words[i][0];

        if (currentFirstLetter == prevFirstLetter) {
            currentSubarrayLength++;
        } else {
            // Start counting a new subarray
            maxSubarrayLength = std::max(maxSubarrayLength, currentSubarrayLength);
            currentSubarrayLength = 1;
            prevFirstLetter = currentFirstLetter;
        }
    }

    // Compare the length of the last subarray
    maxSubarrayLength = max(maxSubarrayLength, currentSubarrayLength);

    return maxSubarrayLength;
}",1.0,1111111
Array_list_7,1398928,2212741,"int maxSum(int* nums, int n, int k) {
  int dp[n] = {0};

  for(int i=0;i<n;i++){
      int maxS=0;
      int maxElement=0;
      int count=1;
      for(int j=i;j>=0&&count<=k;count++,j--){
          maxElement=max(maxElement,nums[j]);
          maxS=max(maxS,maxElement*count);
          if(j==0){
              dp[i]=max(dp[i],0+maxS);
          }
          else{
          dp[i]=max(dp[i],maxS+dp[j-1]);
      }
     
      }
  }
    return dp[n - 1];
}",1.0,11111
Array_list_1,1401611,2213298,"int buyCar(int* nums, int length, int k) {
    std::sort(nums, nums + length);
    int count = 0;
    for (int i = 0; i < length; i++) {
        if (k >= nums[i]) {
            k -= nums[i];
            count++;
        } 
        else break;
    }
    return count;
}",1.0,1111111111
Array_list_2,1401611,2213298,"bool consecutiveOnes(vector<int>& nums) {
    int size = nums.size();
    if(size == 0) return 1;
    bool b = false;
    int i = 0;
    while(!b && i < size) {
        if(nums[i] == 1) b = true;
        i++;
    }
    while(b && i < size) {
        if(nums[i] != 1) b = false;
        i++;
    }
    while(!b && i < size) {
        if(nums[i] == 1) return false;
        i++;
    }
    return 1;
}",1.0,1111111111
Array_list_3,1401611,2213298,"bool consecutiveOnes(vector<int>& nums) {
    int size = nums.size();
    if(size == 0) return 1;
    bool b = false;
    int i = 0;
    while(!b && i < size) {
        if(nums[i] == 1) b = true;
        i++;
    }
    while(b && i < size) {
        if(nums[i] != 1) b = false;
        i++;
    }
    while(!b && i < size) {
        if(nums[i] == 1) return false;
        i++;
    }
    return 1;
}",1.0,1111111111
Array_list_4,1401611,2213298,"bool consecutiveOnes(vector<int>& nums) {
    int size = nums.size();
    if(size == 0) return 1;
    bool b = false;
    int i = 0;
    while(!b && i < size) {
        if(nums[i] == 1) b = true;
        i++;
    }
    while(b && i < size) {
        if(nums[i] != 1) b = false;
        i++;
    }
    while(!b && i < size) {
        if(nums[i] == 1) return false;
        i++;
    }
    return 1;
}",1.0,1111111111
Array_list_5,1401611,2213298,"int equalSumIndex(std::vector<int>& nums) {
    int total_sum = 0;
    for (int num : nums) {
        total_sum += num;
    }
    
    int left_sum = 0;
    for (int i = 0; i < nums.size(); ++i) {
        if (left_sum == total_sum - left_sum - nums[i]) {
            return i;
        }
        left_sum += nums[i];
    }
    
    return -1;
}",1.0,1111111111
Array_list_6,1401611,2213298,"int max(int a, int b) { return (a > b) ? a : b; }

int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if (words.empty()) return 0;
    int currentlength = 1;
    int maxlength = 1;
    char firstletter = words[0][0];
    for (int i = 1; i < words.size(); i++) {
        char currentfirstletter = words[i][0];
        if (firstletter == currentfirstletter) {
            currentlength++;
            maxlength = max(maxlength, currentlength);
        }
        else {
            firstletter = currentfirstletter;
            currentlength = 1;
        }
    }
    return maxlength;
}",1.0,1111111
Array_list_7,1401611,2213298,"int max(int a, int b) { return (a > b) ? a : b; }

int maxSum(int* nums, int n, int k) {
    int dp[10005] = {0};
    for (int i = 0; i < n; i++) {
        int maxElement = nums[i];
        for (int j = 1; j <= k && i - j + 1 >= 0; j++) {
            maxElement = max(maxElement, nums[i - j + 1]);
            dp[i] = max(dp[i], ((i >= j) ? dp[i - j] : 0) + maxElement * j);
        }
    }
    return dp[n - 1];
}",1.0,11111
Array_list_8,1401611,2213298,"int max(int a, int b) {return (a>b) ? a : b;}
int min(int a, int b) {return (a>b) ? b : a;}

int minimumAmplitude(vector<int>& nums, int k) {
    vector<int> minL(nums.size()), maxL(nums.size()), minR(nums.size()), maxR(nums.size());
    minL[0] = nums[0];
    minR[nums.size() - 1] = nums[nums.size() - 1];
    maxL[0] = nums[0];
    maxR[nums.size() - 1] = nums[nums.size() - 1];
    for (int i = 1; i < (int) nums.size(); i++) minL[(unsigned int) i] = min(nums[(unsigned int) i], minL[(unsigned int) (i-1)]);
    for (int i = 1; i < (int) nums.size(); i++) maxL[(unsigned int) i] = max(nums[(unsigned int) i], maxL[(unsigned int) (i-1)]);
    for (int i = (int) nums.size() - 2; i >= 0; i--) minR[(unsigned int) i] = min(nums[(unsigned int) i], minR[(unsigned int) (i+1)]);
    for (int i = (int) nums.size() - 2; i >= 0; i--) maxR[(unsigned int) i] = max(nums[(unsigned int) i], maxR[(unsigned int) (i+1)]);
    int result = maxR[(unsigned int) k] - minR[(unsigned int) k];
    for (int i = k; (unsigned int) i < nums.size(); i++) {
        if ((unsigned int) i == nums.size() - 1) {
            result = min(result, maxL[(unsigned int) (i - k)] - minL[(unsigned int) (i - k)]);
        }
        else {
            int min_value = min(minR[(unsigned int)i + 1], minL[(unsigned int) (i - k)]);
            int max_value = max(maxR[(unsigned int)i + 1], maxL[(unsigned int) (i - k)]);
            result = min((max_value - min_value), result);
        }
    }
    return result;
}",1.0,1111111111
Array_list_9,1401611,2213298,"int steadySpeed(vector<int>& positions) {
    int count = 2;
    vector<int> rac;
    for (unsigned int index = 0; index < positions.size() - 2;index++) {
        int speed1 = positions[index + 1] - positions[index];
        int speed2 = positions[index + 2] - positions[index + 1];
        if (abs(speed1) == abs(speed2)) count++;
        else {
            rac.push_back(count);
            count = 2;
        }
    }
    rac.push_back(count);
    int max = rac[0];
    for (auto x : rac) if (x > max) max = x;
    return max;
}",1.0,111111111111111
Array_list_10,1401611,2213298,"int max(int a, int b) { return (a>b) ? a : b; }

int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    vector<int> newnum;
    int maxsum = INT_MIN;
    for (auto x : nums) if (x <= target) newnum.push_back(x);
    for (int i = 0; i < newnum.size(); i++) {
        for (int j = i + 1; j < newnum.size(); j++) {
            if (newnum[i] + newnum[j] < target) {
                maxsum = max(maxsum, newnum[i] + newnum[j]);
            }
        }
    }
    return maxsum;
}",1.0,1111111111
Array_list_11,1401611,2213298,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for (unsigned int i = 0; i < nums.size(); i++) {
        for (unsigned int j = 0; j < operations.size(); j++) { 
            if ((int) i >= operations[j][0] && (int) i <= operations[j][1]) nums[i] += operations[j][2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1403078,2211170,"int buyCar(int* nums, int length, int k) {
sort(nums, nums + length);
int count = 0;
int totalCost = 0;
for (int i = 0; i < length; i++) {
        if (totalCost + nums[i] <= k) {
            totalCost += nums[i];
            count++;
        } else {
            break;  // Budget exhausted, exit the loop
        }
    }

    return count;
}",1.0,1111111111
Array_list_2,1403078,2211170,"bool consecutiveOnes(vector<int>& nums) {
    bool meetOne = false;
    bool space = false;
    for (int i = 0; i < nums.size(); ++ i) {
        if (nums[i] == 1) {
            if (space) return false;
            meetOne = true;
        } else {
            if (meetOne) {
                space = true;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_3,1403078,2211170,"bool consecutiveOnes(vector<int>& nums) {
    bool meetOne = false;
    bool space = false;
    for (int i = 0; i < nums.size(); ++ i) {
        if (nums[i] == 1) {
            if (space) return false;
            meetOne = true;
        } else {
            if (meetOne) {
                space = true;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_4,1403078,2211170,"bool consecutiveOnes(vector<int>& nums) {
    bool meetOne = false;
    bool space = false;
    for (int i = 0; i < nums.size(); ++ i) {
        if (nums[i] == 1) {
            if (space) return false;
            meetOne = true;
        } else {
            if (meetOne) {
                space = true;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_5,1403078,2211170,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    
    if (n < 3)
        return 0;
        
    int leftSum = 0;
    int rightSum = 0;
    
    for (int i = 1; i < n; i++)
        rightSum += nums[i];
    
    for (int i = 1; i < n; i++){
        leftSum += nums[i - 1];
        rightSum -= nums[i];
        
        if (leftSum == rightSum)
            return i;
    }
    
    return -1;
    
}",1.0,1111111111
Array_list_6,1403078,2211170,"int longestSublist(vector<string>& words) {
    int n = words.size();
    if (n == 0) {
        // Empty array, return 0
        return 0;
    }

    int maxLength = 0;
    int currentLength = 1;
    char currentLetter = words[0][0];

    for (int i = 1; i < n; i++) {
        if (words[i][0] == currentLetter) {
            // Same first letter, increment current length
            currentLength++;
        } else {
            // Different first letter, update maxLength if necessary
            maxLength = max(maxLength, currentLength);

            // Reset current length and current letter
            currentLength = 1;
            currentLetter = words[i][0];
        }
    }

    // Check maxLength after the loop ends
    maxLength = max(maxLength, currentLength);

    return maxLength;
}",1.0,1111111
Array_list_7,1403078,2211170,"int maxSum(int* nums,int n,int k){

// We create a array dp in which dp[i] = Maximum value of S(W) can be generate till ith index from inital index
// like if we see array {1,6,3,2,2,5,1} and k-3 then dp[0] will be 1 and dp[1] = 12.
// For more clearlity see the below code.

int dp[n];

for(int i=0;i<n;i++)
{

// for each ith index we create all possiable window which end ith index and whose size is less or equal to k
// and for each window we find the possiable value and
// at last Maximum of all possiable value will store at dp[i].

int j=i;
int curr_val=0; // store the Maximum possiable value in all different window that can be generate for ith index
int currMaxEle=nums[i]; // store the Maximum value in range (j and i).

while(j>=0 && i-j+1 <=k)
{

currMaxEle = max(currMaxEle,nums[j]);
int x = (currMaxEle*(i-j+1));
if(j!=0)x += dp[j-1];
// x store the max possiable value of range(j and i).
curr_val =max(curr_val,x);
j--;
}

dp[i]=curr_val;
}

return dp[n-1]; // final return the d[n-1] which store the final Maximum possible value
}",1.0,11111
Array_list_8,1403078,2211170,"int minimumAmplitude(const vector<int>& nums, int k) {
    int N = nums.size();
    
    vector<int> lmin = nums;
    vector<int> lmax = nums;
    vector<int> rmin = nums;
    vector<int> rmax = nums;
    
    for (int i = 1; i < N; i++) {
        lmin[i] = min(lmin[i], lmin[i - 1]);
        lmax[i] = max(lmax[i], lmax[i - 1]);
    }
    
    for (int i = N - 2; i >= 0; i--) {
        rmin[i] = min(rmin[i], rmin[i + 1]);
        rmax[i] = max(rmax[i], rmax[i + 1]);
    }
    
    int ans = min(rmax[k] - rmin[k], lmax[N - k - 1] - lmin[N - k - 1]);
    
    for (int i = 0; i < N - k - 1; i++) {
        int cand = max(lmax[i], rmax[i + k + 1]) - min(lmin[i], rmin[i + k + 1]);
        ans = min(ans, cand);
    }
    
    return ans;
}
",1.0,1111111111
Array_list_9,1403078,2211170,"int steadySpeed(vector<int>& p) {
    int n = p.size();
    vector<int> result;

    for (int i = 0; i < n - 1; i++) {
        int diff = abs(p[i] - p[i + 1]);
        result.push_back(diff);
    }
    
    int m = n - 1;
    if (m == 0) {
        return 0;
    }

    int maxLen = 1;
    int currentLen = 1;

    for (int i = 1; i < m; i++) {
        if (result[i] == result[i - 1]) {
            currentLen++;
        } else {
            maxLen = max(maxLen, currentLen);
            currentLen = 1;
        }
    }

    maxLen = max(maxLen, currentLen);

    return maxLen + 1;
    
}
",0.95,111111111111111
Array_list_10,1403078,2211170,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
     int left = 0;
    int right = nums.size() - 1;
    int largestSum = INT_MIN;

    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum < target) {
            largestSum = max(largestSum, sum);
            left++;
        } else {
            right--;
        }
    }

    return largestSum;
}",1.0,1111111111
Array_list_11,1403078,2211170,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    int n = nums.size();
    int m = operations.size();

    vector<int> prefixSum(n, 0);

    // Calculate prefix sum of operations
    for (int i = 0; i < m; i++) {
        int L = operations[i][0];
        int R = operations[i][1];
        int X = operations[i][2];

        prefixSum[L] += X;

        if (R + 1 < n) {
            prefixSum[R + 1] -= X;
        }
    }

    // Apply prefix sum to update nums array
    for (int i = 1; i < n; i++) {
        prefixSum[i] += prefixSum[i - 1];
    }

    for (int i = 0; i < n; i++) {
        nums[i] += prefixSum[i];
    }

    return nums;
}
",1.0,111111
Array_list_7,1406676,2212935,"int maxSum(int* nums, int n, int k) {
    int result = 0;
    int maxElement = 0;
    int subArraySize = 0;

    for (int i = 0; i < n; i++) {
        maxElement = max(maxElement, nums[i]);
        subArraySize++;

        if (subArraySize == k || i == n - 1) {
            result += maxElement * subArraySize;
            maxElement = 0;
            subArraySize = 0;
        }
    }

    return result;
}",0.2,00100
Array_list_1,1406684,2212303,"int buyCar(int* nums, int length, int k) {
      int buy=0;
      sort(nums, nums+length);
      for(int i=0; i<length; i++){
          if(k-nums[i]>=0&&k>0){
              k=k-nums[i];
              buy++;
          }
      }
      return buy;
}",1.0,1111111111
Array_list_2,1406684,2212303,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool con = false;
    bool space = false;
    if (nums.empty()) return true;
    for(int i=0; i<nums.size(); i++){
        if(nums[i]==1){
            if(space) return false;
            con=true;
        }
        else if(con) space=true;
    }
    return true;
}",1.0,1111111111
Array_list_3,1406684,2212303,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    bool con = false;
    bool space = false;
    if (nums.empty()) return true;
    for(int i=0; i<nums.size(); i++){
        if(nums[i]==1){
            if(space) return false;
            con=true;
        }
        else if(con) space=true;
    }
    return true;
}",1.0,1111111111
Array_list_4,1406684,2212303,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
     bool con = false;
    bool space = false;
    if (nums.empty()) return true;
    for(int i=0; i<nums.size(); i++){
        if(nums[i]==1){
            if(space) return false;
            con=true;
        }
        else if(con) space=true;
    }
    return true;
}",1.0,1111111111
Array_list_5,1406684,2212303,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sum=0, rSum=0;
    int lSum=0;
    for(int i=0; i<nums.size(); i++){
        sum+=nums[i];
    }
    for(int i=0; i<nums.size(); i++){
        rSum=sum-nums[i]-lSum;
        if(rSum-lSum==0){
            return i;
        } 
        lSum+=nums[i];
    }
    return -1;
}",1.0,1111111111
Array_list_6,1406684,2212303,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.empty()) return 0;
    char first=words[0][0];
    int length=0, pLength=0;
    for(int i=0; i<words.size(); i++){
        if(first==words[i][0])
        { length++;
          if(i==words.size()-1) {
              if(length>pLength) pLength=length;
          }
        }
        else {
            if(length>pLength) pLength=length;
            length=1;
        }
        first=words[i][0];
    }
    return pLength;
  
}",1.0,1111111
Array_list_7,1406684,2212303,"int maxSum(int* nums, int n, int k) {
    int *maxS=new int[n];
        int max_sum = 0;
    for (int i = 0; i < n; i++) maxS[i] = 0;
    for (int i = 0; i < n; ++i) {
        int max_val = nums[i];
        int current_product = 0;
        for (int j = i; j >= 0 && i - j + 1 <= k; j--) {
            max_val = max(max_val, nums[j]);
            current_product = max_val * (i - j + 1);
            if (j > 0) {
                current_product += maxS[j - 1];
            }
            if (current_product > maxS[i])
                maxS[i] = current_product;
        }
    }
    for (int i = 0; i < n; ++i) {
        if (maxS[i] > max_sum)
            max_sum = maxS[i];
    }
    return max_sum;
}",1.0,11111
Array_list_8,1406684,2212303,"int minimumAmplitude(vector<int>& nums, int k) {
   int val=100000;
    for(size_t i=0; i<nums.size()-k; i++){int max, min;
        if(i==0){
            max=nums[k];
            min=nums[k];
        }
        else {
            max=nums[0];
            min=nums[0];
        }
        for(size_t j=0; j<i; j++){
            if(nums[j]<min) min=nums[j];
            if(nums[j]>max) max=nums[j];
        }
        for(size_t j=i+k; j<nums.size();j++){
            if(nums[j]<min) min=nums[j];
            if(nums[j]>max) max=nums[j];
        }
        if(max-min<val) val=max-min;
        
    }
    return val;
}",0.9,1111111110
Array_list_9,1406684,2212303,"int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    int speed = positions[1] - positions[0], prevS = positions[1] - positions[0], l = 2, ans = 1;
    for (int i = 2; i < n; i++) {
        speed = positions[i] - positions[i - 1];
        if (speed < 0) speed = -speed;
        if (speed == prevS) l++;
        else {
            prevS = speed;
            if (l > ans) ans = l;
            l = 2;
        }
        if (i == n - 1) if (l > ans) ans = l;
    }
    return ans;
}",1.0,111111111111111
Array_list_10,1406684,2212303,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int max=0;
    int temp=0;
    for(int i=0; i<nums.size(); i++){
        temp=target-nums[i];
        int j=i+1;
        while(nums[j]<temp&&j<nums.size()){
            j++;
        }
        if (j > i + 1) {
            int nMax = nums[i] + nums[j - 1];
        if(nMax>max) {max=nMax;}
        }
    }
    return max;
}",1.0,1111111111
Array_list_11,1406684,2212303,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER

    for (const vector<int>& op : operations) {
        int L = op[0];
        int R = op[1];
        int X = op[2];

        // Increase the elements within the range [L, R] by X in the result array.
        for (int i = L; i <= R; i++) {
            nums[i] += X;
        }
    }

    return nums;
}",1.0,111111
Array_list_1,1408455,2210458,"void merge(int arr[], int l, int m, int r)
{
	const int sizeL = m - l + 1;
	const int sizeR = r - m;
	int* arrL = new int[sizeL];
	int* arrR = new int[sizeR];

	for (int i = 0; i < sizeL; i++)
	{
		arrL[i] = arr[l + i];
	}
	for (int i = 0; i < sizeR; i++)
	{
		arrR[i] = arr[m + i + 1];
	}
	// These are used for checking if L or R is completely finished
	int countL = 0;
	int countR = 0;
	int k = l;
	while (countL < sizeL && countR < sizeR)
	{
		if (arrL[countL] <= arrR[countR])
		{
			arr[k] = arrL[countL];
			countL++;
		}
		else
		{
			arr[k] = arrR[countR];
			countR++;
		}
		k++;
	}
	while (countL < sizeL)
	{
		arr[k] = arrL[countL];
		k++;
		countL++;
	}
	while (countL < sizeL)
	{
		arr[k] = arrL[countL];
		k++;
		countL++;
	}
}

void mergesort(int* arr, int l, int r)
{
	if (l < r)
	{
		int mid = (l + r) / 2;
		mergesort(arr, l, mid);
		mergesort(arr, mid + 1, r);
		merge(arr, l, mid, r);
	}
}

int buyCar(int* nums, int length, int k)
{
	mergesort(nums, 0, length - 1);
	int count = 0;
	while (k >= 0)
	{
		k -= nums[count];
		count++;
	}
	return count - 1;
}
",1.0,1111111111
Array_list_2,1408455,2210458,"bool consecutiveOnes(vector<int>& nums) 
{
	if (nums.size() == 0)
	{
		return true;
	}
	bool is1Consecutive = false, result = true;
	int i = 0;
	int count = 0;
	while (i < nums.size() && result == true)
	{
		if (nums[i] == 1 && is1Consecutive == false)
		{
			while (i < nums.size())
			{
				if (nums[i] != 1)
				{
					is1Consecutive = true;
					break;
				}
				i++;
			}
		}
		if (nums[i] == 1 && is1Consecutive == true)
		{
			result = false;
		}
		i++;
	}
	return result;
}
",1.0,1111111111
Array_list_3,1408455,2210458,"bool consecutiveOnes(vector<int>& nums) 
{
	if (nums.size() == 0)
	{
		return true;
	}
	bool is1Consecutive = false, result = true;
	int i = 0;
	int count = 0;
	while (i < nums.size() && result == true)
	{
		if (nums[i] == 1 && is1Consecutive == false)
		{
			while (i < nums.size())
			{
				if (nums[i] != 1)
				{
					is1Consecutive = true;
					break;
				}
				i++;
			}
		}
		if (nums[i] == 1 && is1Consecutive == true)
		{
			result = false;
		}
		i++;
	}
	return result;
}
",1.0,1111111111
Array_list_4,1408455,2210458,"bool consecutiveOnes(vector<int>& nums) 
{
	if (nums.size() == 0)
	{
		return true;
	}
	bool is1Consecutive = false, result = true;
	int i = 0;
	int count = 0;
	while (i < nums.size() && result == true)
	{
		if (nums[i] == 1 && is1Consecutive == false)
		{
			while (i < nums.size())
			{
				if (nums[i] != 1)
				{
					is1Consecutive = true;
					break;
				}
				i++;
			}
		}
		if (nums[i] == 1 && is1Consecutive == true)
		{
			result = false;
		}
		i++;
	}
	return result;
}
",1.0,1111111111
Array_list_5,1408455,2210458,"int equalSumIndex(vector<int>& nums)
{
    if (nums.size() == 1) return 0;
    else if (nums.size() == 2) return -1;
    else
    {
        int right_sum = 0;
        for (int i = 1; i < int(nums.size()); i++)
        {
            right_sum += nums[i];
        }
        int left_sum = 0;
        for (int i = 1; i < int(nums.size()) - 1; i++)
        {
            left_sum += nums[i - 1];
            right_sum -= nums[i];
            if (left_sum == right_sum)
            {
                return i;
            }
        }
        return -1;
    }
}",1.0,1111111111
Array_list_6,1408455,2210458,"int longestSublist(vector<string>& words) 
{
    if (int(words.size()) == 0) return 0;
    int count = 1;
    int max = 1;
    for (int i = 0; i < int(words.size()) - 1; i++)
    {
        if (words[i][0] == words[i + 1][0])
        {
            count++;
        }
        else
        {
            if (count > max)
            {
                max = count;
            }
            count = 1;
        }
    }
    if (count > max)
    {
        max = count;
    }
    count = 1;
    return max;
}",1.0,1111111
Array_list_7,1408455,2210458,"int findMax(int a, int b)
{
    if (a >= b)
        return a;
    else
        return b;
}

int maxSum(int* nums, int n, int k)
{
    int* f = new int[n];
    int val;
    int max;
    int res = 0;
    for (int i = 0; i < n; i++)
    {
        max = nums[i];
        val = 0;
        for (int j = 0; j < k && i - j >= 0; j++)
        {
            if (j > 0)
            {
                max = findMax(max, nums[i - j]); // đúng
            }
            if (i - j > 0)
            {
                val = findMax(val, f[i - j - 1] + max * (j + 1));
            }
            else
            {
                // in case i - j = 0, there will be no f stored behind.
                val = findMax(val, max * (j + 1));
            }
            
        }
        f[i] = val;
        res = findMax(res, f[i]);
    }
    return res;
}",1.0,11111
Array_list_8,1408455,2210458,"int max(int a, int b) {
	return a > b ? a : b;
}

int min(int a, int b) {
	return a < b ? a : b;
}

int minimumAmplitude(std::vector<int>& nums, int k) {
    int n = nums.size();
    std::vector<int> minLeft(n), maxLeft(n), minRight(n + 1), maxRight(n + 1);

    // Compute minLeft and maxLeft
    minLeft[0] = maxLeft[0] = nums[0];
    for (int i = 1; i < n; ++i) {
        minLeft[i] = std::min(minLeft[i - 1], nums[i]);
        maxLeft[i] = std::max(maxLeft[i - 1], nums[i]);
    }

    // Compute minRight and maxRight
    minRight[n] = INT_MAX;
    maxRight[n] = INT_MIN;
    for (int i = n - 1; i >= 0; --i) {
        minRight[i] = std::min(minRight[i + 1], nums[i]);
        maxRight[i] = std::max(maxRight[i + 1], nums[i]);
    }

    // Find the minimum amplitude
    int minAmplitude = INT_MAX;
    int currentMax = 0, currentMin = 0;
    for (int i = 0; i <= n - k; ++i) {
        //int currentMax = std::max(i > 0 ? maxLeft[i - 1] : INT_MIN, maxRight[i + k]);
        currentMax = i > 0 ? max(maxLeft[i - 1], maxRight[i + k]) : maxRight[i + k];
        currentMin = i > 0 ? min(minLeft[i - 1], minRight[i + k]) : minRight[i + k];
        //int currentMin = std::min(i > 0 ? minLeft[i - 1] : INT_MAX, minRight[i + k]);
        minAmplitude = std::min(minAmplitude, currentMax - currentMin);
    }

    return minAmplitude;
}
",1.0,1111111111
Array_list_9,1408455,2210458,"int max(int a, int b)
{
    return a > b ? a : b;
}

int steadySpeed(vector<int>& positions) 
{
    int maxLength = 1;
    int count = 1;
    for (int i = 0; i < int(positions.size()) - 1; i++)
    {
        positions[i] = abs(positions[i + 1] - positions[i]);
    }
    
    for (int i = 0; i < int(positions.size()) - 1; i++)
    {
        if (positions[i - 1] == positions[i])
        {
            count++;
        }
        else
        {
            maxLength = max(maxLength, count);
            count = 1;
        }
    }
    if (count > maxLength)
        maxLength = count;
    return maxLength + 1;
}",1.0,111111111111111
Array_list_10,1408455,2210458,"int sumLessThanTarget(vector<int>& nums, int target) 
{
    int ptr1 = 0;
    int ptr2 = int(nums.size()) - 1;
    int max = 0;
    int sum = 0;
    while (ptr1 != ptr2)
    {
        sum = nums[ptr1] + nums[ptr2];
        if (sum < target)
        {
            if (sum > max)
                max = sum;
            ptr1++;
        }
        else if (sum >= target)
        {
            ptr2--;
        }
    }
    return max;
}",1.0,1111111111
Array_list_11,1408455,2210458,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations)
{
    for (int i = 0; i < int(operations.size()); i++)
    {
        for (int j = operations[i][0]; j <= operations[i][1]; j++)
        {
            nums[j] += operations[i][2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1409851,2212741,"int buyCar(int* nums, int length, int k) {
    int min=nums[0];
    int idx=0;
    for(int i=0;i<length;i++){
        min=nums[i];
        idx=i;
        for(int j=i+1;j<length;j++){
            if(nums[j]<=min){
                min=nums[j];
                idx=j;
            }
        }
         nums[idx]=nums[i];
            nums[i]=min;
    }
    int res=0;
    for(int i=0;i<length;i++){
        k-=nums[i];
        res++;
        if(k<0){
            res--;
            break;
        }
    }
    return res;
}",1.0,1111111111
Array_list_2,1409851,2212741,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0) return 1;
    int tmp0=0;
    int tmp1=1;
    int count=0;
    for(int i=0;i<nums.size();i++ ){
        if(nums[i]!=1&&tmp0==1){
            count++;
            tmp0=0;
            tmp1=1;
        }
        if(nums[i]==1&&tmp1==1){
            count++;
            tmp0=1;
            tmp1=0;
        }
    }
    return (count<=2);
}",1.0,1111111111
Array_list_3,1409851,2212741,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0) return 1;
    int tmp0=0;
    int tmp1=1;
    int count=0;
    for(int i=0;i<nums.size();i++ ){
        if(nums[i]!=1&&tmp0==1){
            count++;
            tmp0=0;
            tmp1=1;
        }
        if(nums[i]==1&&tmp1==1){
            count++;
            tmp0=1;
            tmp1=0;
        }
    }
    return (count<=2);
}",1.0,1111111111
Array_list_4,1409851,2212741,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0) return 1;
    int tmp0=0;
    int tmp1=1;
    int count=0;
    for(int i=0;i<nums.size();i++ ){
        if(nums[i]!=1&&tmp0==1){
            count++;
            tmp0=0;
            tmp1=1;
        }
        if(nums[i]==1&&tmp1==1){
            count++;
            tmp0=1;
            tmp1=0;
        }
    }
    return (count<=2);
}",1.0,1111111111
Array_list_5,1409851,2212741,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int sum=0;
    for(int i=0;i<nums.size();i++){
        sum+=nums[i];
    }
    int tmp=0;
    int i=0;
    while(tmp<sum/2){
        tmp+=nums[i];
        i++;
    }
    if(sum-tmp==tmp-nums[i-1]) return i-1;
    else return -1;
}",1.0,1111111111
Array_list_6,1409851,2212741,"
int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    // int array[52];
    // for(int i=0;i<52;i++){
    //     array[i]=0;
    // }
    // for(int i=0;i<words.size();i++){
    //     char x=words[i][0];
    //     if('a'<=x<='z'){
    //      int num=x-'a';
    //     array[num]++;
    //     }
    //     else{
    //         int num=x-'A';
    //         array[num]++;
    //     }
    // }
    // int res=array[0];
    // for(int i=1;i<52;i++){
    //     if(array[i]>res) res=array[i];
    // }
    // return res;
    int maxSubarrayLength = 0;
    int currentSubarrayLength = 1; // Initialize with 1 since a single word is a subarray with a length of 1

    // Handle the case of an empty array
    if (words.empty()) {
        return 0;
    }

    char prevFirstLetter = words[0][0]; // Initialize with the first letter of the first word

    for (size_t i = 1; i < words.size(); ++i) {
        char currentFirstLetter = words[i][0];

        if (currentFirstLetter == prevFirstLetter) {
            currentSubarrayLength++;
        } else {
            // Start counting a new subarray
            maxSubarrayLength = std::max(maxSubarrayLength, currentSubarrayLength);
            currentSubarrayLength = 1;
            prevFirstLetter = currentFirstLetter;
        }
    }

    // Compare the length of the last subarray
    maxSubarrayLength = max(maxSubarrayLength, currentSubarrayLength);

    return maxSubarrayLength;
}",1.0,1111111
Array_list_7,1409851,2212741,"int maxSum(int* nums, int n, int k) {
  int dp[n] = {0};

  for(int i=0;i<n;i++){
      int maxS=0;
      int maxElement=0;
      int count=1;
      for(int j=i;j>=0&&count<=k;count++,j--){
          maxElement=max(maxElement,nums[j]);
          maxS=max(maxS,maxElement*count);
          if(j==0){
              dp[i]=max(dp[i],0+maxS);
          }
          else{
          dp[i]=max(dp[i],maxS+dp[j-1]);
      }
     
      }
  }
    return dp[n - 1];
}",1.0,11111
Array_list_8,1409851,2212741,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n=nums.size();
    int minLeft;
    int minRight;
    int maxLeft;
    int maxRight;
    int minL[n];
    int maxL[n];
    int minR[n];
    int maxR[n];
    minLeft=nums[0];
        maxLeft=nums[0];
        minRight=nums[n-1];
        maxRight=nums[n-1];
    for(int i=1;i<n;i++){
        // minLeft=nums[i-1];
        // maxLeft=nums[i-1];
        int j=i-1;
            minLeft=min(minLeft,nums[j]);
            maxLeft=max(maxLeft,nums[j]);
        minL[i]=minLeft;
        maxL[i]=maxLeft;
    }
    for(int i=n-2;i>=0;i--){
        // minRight=nums[i+1];
        // maxRight=nums[i+1];
        int j=i+1;
            minRight=min(minRight,nums[j]);
            maxRight=max(maxRight,nums[j]);
        minR[i]=minRight;
        maxR[i]=maxRight;
    }
    int res=9999999;
    int tmp=0;
    for(int i=0;i+k-1<n;i++){
        if(i==0){
            tmp=maxR[i+k-1]-minR[i+k-1];
        }
        else if(i+k-1==n-1){
            tmp=maxL[i]-minL[i];
        }
        else{
            int a=minL[i];
            int b=maxL[i];
            int c=min(a,minR[i+k-1]);
            int d=max(b,maxR[i+k-1]);
            tmp=d-c;
        }
        res=min(tmp,res);
    }
    
    return res;
    
    
    
    
    
    
    
    
    
}",1.0,1111111111
Array_list_9,1409851,2212741,"int steadySpeed(vector<int>& positions) {
    int currentspeed=abs(positions[0]-positions[1]);
    // cout<<currentspeed<<endl;
    queue<int> myqueue;
    myqueue.push(positions[0]);
    myqueue.push(positions[1]);
    int res=2;
    int tmp=2;
    int n=positions.size();
    for(int i=2;i<n;i++){
        if(abs(positions[i]-positions[i-1])==currentspeed){
            myqueue.push(positions[i]);
            tmp++;
        }
        else{
            currentspeed=abs(positions[i]-positions[i-1]);
            res=max(res,tmp);
            tmp=2;
            while(myqueue.size()!=1){
                myqueue.pop();
            }
            myqueue.push(positions[i]);;
        }
        // cout<<currentspeed<<endl;
    }
    res=max(res,tmp);
    return res;
    
}",1.0,111111111111111
Array_list_10,1409851,2212741,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int n=nums.size();
    int res=-99999;
    // if(nums[n-1]<target) return nums[n-1];
    for(int i=0;i<n;i++){
        if(nums[i]>=target) break;
        for(int j=i+1;j<n;j++){
            if((nums[i]+nums[j])>=target){
                if(nums[j-1]==nums[i]) {
                    res=max(res,nums[i]);
                    break;
                }
                else{
                res=max(res,(nums[i]+nums[j-1]));
                break;
                }
            }
            res=max(res,(nums[i]+nums[j]));
        }
    }
    
    return res;
    
}",1.0,1111111111
Array_list_11,1409851,2212741,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int n=operations.size();
    for(int i=0;i<n;i++){
        for(int j=operations[i][0];j<=operations[i][1];j++){
            nums[j]+=operations[i][2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1413210,2211367,"void quickSort(int *a, int l, int r){
	int p = a[(r+l)/2];
	int i = l, j = r;
	while(i<j){
		while(a[i]<p){
			i++;
		}
		while(a[j]>p){
			j--;
		}
		if(i<=j){
			int tmp = a[i];
			a[i] = a[j];
			a[j] = tmp;
			i++;
			j--;
		}
	}
	if(i<r){
		quickSort(a,i,r);
	}
	if(l<j){
		quickSort(a,l,j);
	}
}
int buyCar(int* nums, int length, int k) {
    quickSort(nums,0,length-1);
    int count = 0;
    if(k==0) return 0;
    for(int i = 0; i < length-1;i++){
        if((k-nums[i])>=0){
            count++;
            k = k-nums[i];
        }
        else{
            break;
        }
    }
    return count;
}",0.9,1111111101
Array_list_2,1413210,2211367,"bool consecutiveOnes(vector<int>& a){
    if(a.size()==0) return 1;
    for(int i = 0; i < a.size();i++){
        for(int j = i+1; j < a.size();j++){
            if(a[i]==a[j]&&a[i]==1){
                return true;
            }
            else{
                break;
            }
        }
    }
    return false;
}
",0.6,1111101000
Array_list_3,1413210,2211367,"bool consecutiveOnes(vector<int>& a){
    if(a.size()==0) return 1;
    for(int i = 0; i < a.size();i++){
        for(int j = i+1; j < a.size();j++){
            if(a[i]==a[j]&&a[i]==1){
                return true;
            }
            else{
                break;
            }
        }
    }
    return false;
}
",0.6,1111101000
Array_list_4,1413210,2211367,"bool consecutiveOnes(vector<int>& a){
	if(a.size()==0) return 1;
    for(int i = 0; i < a.size();i++){
        for(int j = i+1; j < a.size();j++){
            if(a[i]==a[j]&&a[i]==1){
                return true;
            }
            else{
                break;
            }
        }
    }
    return false;
}
",0.6,1111101000
Array_list_5,1413210,2211367,"int equalSumIndex(vector<int> nums){
    int l = 0;
    int n = nums.size();
    int r = n;
    int sumleft = 0;
    int sumright = 0;
    sumleft += nums[l];
    sumright += nums[r-1];
    if(nums.size()==1) return 0;
    while(l<=r){
    if(sumleft==sumright&&(l+1)==(r-2)){
        return l+1;}
    while(sumleft<=sumright){
            l++;
            sumleft += nums[l];
            if(sumleft>=sumright) {
             if(sumleft==sumright&&(l+1)==(r-2)){
            return l+1;}
            else break;}
    }
    while(sumleft>=sumright){
        r--;
        sumright+=nums[r-1];
        if(sumleft<=sumright){
            if(sumleft==sumright&&(l+1)==(r-2)){
            return l+1;}
            else break;}
        }
    }
    return -1;
}
",1.0,1111111111
Array_list_1,1413666,2211738,"int buyCar(int* nums, int length, int k) {
    sort(nums, nums+length);
    int count = 0;
    int i = 0;
    while(i < length){
        if(nums[i] <= k){
            count++;
            k = k - nums[i];
        }else{
            break;
        }
        i++;
    }
    return count;
}",1.0,1111111111
Array_list_2,1413666,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()){
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i]);
                i++;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_3,1413666,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()){
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i]);
                i++;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_4,1413666,2211738,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty()) return true;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++){
        if(nums[i] == 1){
            if(!res.empty()){
                return false;
            }
            while(nums[i] == 1){
                res.push_back(nums[i]);
                i++;
            }
        }
    }
    return true;
}",1.0,1111111111
Array_list_5,1413666,2211738,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size() <= 1) return 0;
    int sum = 0, sum1;
    for(int i = 0; i < nums.size(); i++){
        sum += nums[i];
    }
    vector<int>res;
    res.push_back(nums[0]);
    for(int i = 1; i < nums.size(); i++){
        sum1 = nums[i];
        if(i >= 2){
            sum1 = nums[i-1] + res[i-2];
            res.push_back(sum1);
        }
        if(sum1 == sum - nums[i] - sum1) return i;
    }
    return -1;
}",1.0,1111111111
Array_list_6,1413666,2211738,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.empty()) return 0;
    int j = 0, ans = 1;
    for(int i = 1; i < words.size(); i ++){
        if(words[i][0] == words[j][0]){
            ans = max(ans, i-j+1);
        }else{
            j = i;
        }
    }
    return ans;
}",1.0,1111111
Array_list_7,1413666,2211738,"int maxSum(int* nums, int n, int k) {
    if(n == 0) return 0;
    int count = 1, sum = 0, maxi = nums[0];
    for(int i = 1; i < n; i++){
        if(nums[i] != nums[i-1] && count < k){
            count++;
            maxi = max(maxi, nums[i]);
        }else{
            sum += maxi*count;
            count = 1;
            maxi = nums[i];
        }
    }
    sum += maxi*count;
    return sum;
}",0.4,10100
Array_list_8,1413666,2211738,"int minimumAmplitude(vector<int>& nums, int k) {
    // STUDENT ANSWER
    if(nums.size() == 0) return 0;
    // if(k == 0){
    //     int max1 = -1e9, min1 = 1e9;
    //     for(int i = 0; i < nums.size(); i++){
    //         max1 = max(max1,nums[i]);
    //         min1 = min(min1,nums[i]);
    //     }
    //     return max1 - min1;
    // }
    vector<int> max1;
    vector<int> min1;
    
    int res = 1e9, len = nums.size();
    max1.push_back(nums[0]);
    min1.push_back(nums[0]);
    for(int i = 0; i <= len-k; i++){
        int mx1 = -1e9, mn1 = 1e9, mx2 = -1e9, mn2 = 1e9;
        if(i >= k){
            mx1 = max(nums[i-k+1], max1[i-k]);
            mn1 = min(nums[i-k+1],min1[i-k]);
            max1.push_back(mx1);
            min1.push_back(mn1);
        }
        for(int j = i+k; j < len; j++){
            mx2 = max(mx2, nums[j]);
            mn2 = min(mn2, nums[j]);
        }
        int maxi = max(mx1,mx2);
        int mini = min(mn1,mn2);
        res = min(res, maxi-mini);
    }
    return res;
}",0.2,1100000000
Array_list_10,1413666,2211738,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left = 0, right = nums.size()-1;
    int maxSum = -1e9;
    while(left < right){
        int sum = nums[left] + nums[right];
        if(sum < target){
            maxSum = max(maxSum, sum);
            left++;
        }else{
            right--;
        }
    }
    return maxSum;
}",1.0,1111111111
Array_list_11,1413666,2211738,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int len1 = nums.size();
    int len2 = operations.size();
    for(int i = 0; i < len1; i++){
        for(int j = 0; j < len2; j++){
            if(i >= operations[j][0] && i <= operations[j][1]){
                nums[i] += operations[j][2];
            }
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1416340,2213035,"int buyCar(int* nums, int length, int k) {
    int a = 0;
    sort(nums, nums + length);
    for (int i = 0; i < length; i++){
        if(k - nums[i] >= 0){
            k -= nums[i];
            a++;
            // cout<<nums[i]<<"" ""<<a<<endl;
        }
        // cout<<nums[i]<<endl;
    }
    
    return a;
}",1.0,1111111111
Array_list_2,1416340,2213035,"bool consecutiveOnes(vector<int>& nums) {
    if(nums.size() == 0) return true;
    else
    {
        int temp = 0, count = 0;
        for(int i = 0; i < nums.size(); i++)
        {   if(nums[i] == 1) count ++;
            if(nums[i] == 1 && nums[i+1] == 1) temp ++;
        }
        if(temp == count - 1) 
            return true;
        else 
            return false;
    }
}",1.0,1111111111
Array_list_3,1416340,2213035,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size() == 0) return true;
    else
    {
        int temp = 0, count = 0;
        for(int i = 0; i < nums.size(); i++)
        {   if(nums[i] == 1) count ++;
            if(nums[i] == 1 && nums[i+1] == 1) temp ++;
        }
        if(temp == count - 1) 
            return true;
        else 
            return false;
    }
}",1.0,1111111111
Array_list_4,1416340,2213035,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size() == 0) return true;
    else
    {
        int temp = 0, count = 0;
        for(int i = 0; i < nums.size(); i++)
        {   if(nums[i] == 1) count ++;
            if(nums[i] == 1 && nums[i+1] == 1) temp ++;
        }
        if(temp == count - 1) 
            return true;
        else 
            return false;
    }
}",1.0,1111111111
Array_list_5,1416340,2213035,"int equalSumIndex(vector<int>& nums) {
    int left = 0;
    int right = 0;
    int sum = 0;
    int size =nums.size();
    for(int num : nums){
        sum += num;
    } 
    for (int i = 0; i < size; i++){
      left += nums.at(i);
      right = sum - left ;
      if(right == left - nums.at(i)) return i; 
    }
    return -1;
}",1.0,1111111111
Array_list_6,1416340,2213035,"int longestSublist(vector<string>& words) {
    int max = 0;
    int current_max = 1;
    if (words.empty()) {
        return 0;
    }
    for (int i = 1; i < words.size(); i++){
        if(words[i][0] == words[i-1][0]) current_max++;
        else current_max = 1;
        if(max < current_max) max = current_max;
        
    }
    
    return max;
}",1.0,1111111
Array_list_7,1416340,2213035,"int maxElement(int a, int b)
{ int maxE = a;
    if(b > a)
     {
            maxE = b;
 }
    return maxE;
}

int maxSum(int* nums, int n, int k) {
    int sum = 0, element = -1, length = 0;
    for( int i = 0; i < n; ++i)
    {   if(length < k && element != nums[i]){
        element = maxElement(element, nums[i]);
        length++;
        } else 
        {
            sum += length * element;
            element = nums[i];
            length = 1;
        }
    }
  sum += length * element;
return sum;
}

",0.4,10100
Array_list_8,1416340,2213035,"int minimumAmplitude(vector<int>& nums, int k) {
    int n = nums.size();

    vector<int> lmin(nums.begin(), nums.end());
    vector<int> lmax(nums.begin(), nums.end());
    vector<int> rmin(nums.begin(), nums.end());
    vector<int> rmax(nums.begin(), nums.end());

    for (int i = 1; i < n; ++i) {
        lmin[i] = min(lmin[i], lmin[i - 1]);
        lmax[i] = max(lmax[i], lmax[i - 1]);
    }

    for (int i = n - 2; i >= 0; --i) {
        rmin[i] = min(rmin[i], rmin[i + 1]);
        rmax[i] = max(rmax[i], rmax[i + 1]);
    }

    int ans = min(rmax[k] - rmin[k], lmax[n - k - 1] - lmin[n - k - 1]);
    
    for (int i = 0; i <= n - k - 1; ++i) {
        int cand = max(lmax[i], rmax[i + k + 1]) - min(lmin[i], rmin[i + k + 1]);
        ans = min(ans, cand);
    }
    
    return ans;
}",1.0,1111111111
Array_list_9,1416340,2213035,"int gttd(int a, int b){
    if(a > b) return a-b;
    else return b-a;
}

int steadySpeed(vector<int>& positions) {
    int speed_1 = 0;
    int speed_2 = 0;
    int count = 2;
    int max = 0;
    for (unsigned int i = 0; i < positions.size(); i++){
        speed_1 = gttd(positions[i], positions[i+1]);
        if(speed_1 == speed_2) count++;
        else{
            speed_2 = speed_1;
            count = 2;
        }
        if(max < count) max = count;
    }
    return max;    
}
",1.0,111111111111111
Array_list_10,1416340,2213035,"int sumLessThanTarget(vector<int>& nums, int target) {
    int maxSum = INT_MIN;
    int left = 0;
    int right = nums.size()-1;
    while (left < right) {
        if(nums[right] > target) right--;
        int currentSum = nums[left] + nums[right];
        if(currentSum < target){
            maxSum = max(currentSum, maxSum);
            left++;
        }
        else {
            right--;
            left = 0;
        }
    }
    return maxSum;
}",1.0,1111111111
Array_list_11,1416340,2213035,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    for(unsigned int j = 0; j < operations.size(); j++){
        for(int i = operations[j][0]; i <= operations[j][1]; i++){
            nums[i] += operations[j][2];
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1419767,2212372,"void del(int*nums,int length,int idx){
    nums[idx]=nums[length-1];
}
int buyCar(int* nums, int length, int k) {
int s=0;

while(1){
int min=nums[0];
int n=0;
for(int i=0;i<length;i++){
if(nums[i]<=min){min=nums[i];
n=i;}
}
del(nums,length,n);
length--;
if(k>=min){k-=min;
s++;}
else{break;}
}
return s;
}",1.0,1111111111
Array_list_2,1419767,2212372,"bool consecutiveOnes(vector<int>& nums) {
    int idx=0;
    if(nums.size()==0){return 1;}
    for(int i=0;i<nums.size();i++){
        if(nums[i]==1){
        for(int j=i;j<nums.size();j++){
            if(nums[j]!=1){idx=j;
            break;}
}    
     for(idx;idx<nums.size();idx++){
    if(nums[idx]==1){return 0;}
            }

        
    }}
return 1;}",1.0,1111111111
Array_list_3,1419767,2212372,"bool consecutiveOnes(vector<int>& nums) {
    int idx=0;
    if(nums.size()==0){return 1;}
    for(int i=0;i<nums.size();i++){
        if(nums[i]==1){
        for(int j=i;j<nums.size();j++){
            if(nums[j]!=1){idx=j;
            break;}
}    
     for(idx;idx<nums.size();idx++){
    if(nums[idx]==1){return 0;}
            }

        
    }}
return 1;}",1.0,1111111111
Array_list_4,1419767,2212372,"bool consecutiveOnes(vector<int>& nums) {
    int idx=0;
    if(nums.size()==0){return 1;}
    for(int i=0;i<nums.size();i++){
        if(nums[i]==1){
        for(int j=i;j<nums.size();j++){
            if(nums[j]!=1){idx=j;
            break;}
}    
     for(idx;idx<nums.size();idx++){
    if(nums[idx]==1){return 0;}
            }

        
    }}
return 1;}",1.0,1111111111
Array_list_5,1419767,2212372,"int equalSumIndex(vector<int>& nums) {
    
    int n = nums.size();
 
    vector<int> right(n);
    right[n-1] = nums[n-1];

for(int i=n-2;i>=0;i--){
   right[i] += nums[i] + right[i+1];
}
int sum = 0;
for(int i = 0; i < n; i++)
{
    sum += nums[i];
    if(sum == right[i])
        return i;
}
return -1;
}",1.0,1111111111
Array_list_6,1419767,2212372," int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int n = words.size();
    if(!n)
        return 0;
    int cMax=1;
    int count = 1;
    
    for(int i=1;i<n; i++)
    {
        if(words[i][0] == words[i-1][0])
        {
            count++;
            cMax = max(count, cMax);
        }
        else
            count = 1;
    }
    
    return cMax;
}",1.0,1111111
Array_list_7,1419767,2212372,"int solve(int**dp, int* nums, int i, int n, int tempMax, int a, int& k)
{
    
    if(i >= n)
    {
        if(a == 1)
            return 0;
        return tempMax*(a-1);
    }
   
      if(dp[i][a] != -1)
        return dp[i][a];
    int choose = -10;
    if(a + 1 <= k)
        choose = solve(dp, nums, i+1, n, max(tempMax, nums[i]), a+1, k);
    int notchoose = max(tempMax, nums[i])*a + solve(dp, nums, i+1, n, -10, 1, k);
    return dp[i][a] = max(choose, notchoose);
}
int maxSum(int* nums, int n, int k) {
    int**dp = new int*[n+1];
    for(int i = 0; i <= n; i++)
    {
        dp[i] = new int[k+1];
        for(int x = 0; x <= k; x++)
            dp[i][x] = -1;

    }
    
return solve(dp, nums, 0, n, -10, 1, k);


}


",1.0,11111
Array_list_8,1419767,2212372,"int minimumAmplitude(vector<int>& nums, int k) {
    int n = nums.size();

    vector<int> lmin(nums.begin(), nums.end());
    vector<int> lmax(nums.begin(), nums.end());
    vector<int> rmin(nums.begin(), nums.end());
    vector<int> rmax(nums.begin(), nums.end());

    for (int i = 1; i < n; ++i) {
        lmin[i] = min(lmin[i], lmin[i - 1]);
        lmax[i] = max(lmax[i], lmax[i - 1]);
    }

    for (int i = n - 2; i >= 0; --i) {
        rmin[i] = min(rmin[i], rmin[i + 1]);
        rmax[i] = max(rmax[i], rmax[i + 1]);
    }

    int ans = min(rmax[k] - rmin[k], lmax[n - k - 1] - lmin[n - k - 1]);
    
    for (int i = 0; i <= n - k - 1; ++i) {
        int cand = max(lmax[i], rmax[i + k + 1]) - min(lmin[i], rmin[i + k + 1]);
        ans = min(ans, cand);
    }
    
    return ans;
}",1.0,1111111111
Array_list_9,1419767,2212372,"int steadySpeed(vector<int>& positions) {
    int speed=positions[1]-positions[0];
    int st=2;
    int s=2;
    int n=positions.size();
   for(int i=1;i<n;i++){
     int  sp=positions[i+1]-positions[i];
     
     if(speed==sp || speed==(-sp)){s++;}
     else{speed=sp;
     s=2;}
     if(s>st){st=s;}
    }
return st;
}",1.0,111111111111111
Array_list_10,1419767,2212372,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int n = nums.size();
    int ans = INT_MIN;
    for(int i = n-1; i >= 1; i--)
    {
        for(int j = 0; j < i; j++)
        {
            if(nums[i]+nums[j] >= target)
                break;
            ans = max(ans, nums[i]+nums[j]);
        }
    }
    return ans;
}",1.0,1111111111
Array_list_11,1419767,2212372,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
   int n=operations.size();
   for (int i=0;i<n;i++){
       for (int j=operations[i][0];j<=operations[i][1];j++){
           nums[j]+=operations[i][2];
       }
   }
    return nums;
}",1.0,111111
Array_list_1,1422009,2213248,"int find_min(int* nums, int length) {
    int min = nums[0];
    for(int i = 0; i < length; i++) {
        if(nums[i] < min) min = nums[i];
    }
    int i = 0;
    while(nums[i] != min) i++;
    while(i < length - 1) {
        nums[i] = nums[i + 1];
        i++;
    }
    return min;
    
}
int buyCar(int* nums, int length, int k) {
    if(length > 0) {
        int min = find_min(nums, length);
        if(k - min < 0) return 0;
        else return 1 + buyCar(nums, length - 1, k - min);
    }
    else return 0;
}",1.0,1111111111
Array_list_2,1422009,2213248,"bool have_1(vector<int>& nums) {
    for(int i = 0; i < nums.size(); i++) {
        if(nums.at(i) == 1) return 1;
    }
    return 0;
}

bool consecutiveOnes(vector<int>& nums) {
    if(!have_1(nums)) return 1;
    int i = 0;
    while(nums.at(i) != 1) i++;
    while(nums.at(i) == 1) i++;
    while(i < nums.size()) {
        if(nums.at(i) == 1) return 0;
        i++;
    }
    return 1;
}
",1.0,1111111111
Array_list_3,1422009,2213248,"bool have_1(vector<int>& nums) {
    for(int i = 0; i < nums.size(); i++) {
        if(nums.at(i) == 1) return 1;
    }
    return 0;
}

bool consecutiveOnes(vector<int>& nums) {
    if(!have_1(nums)) return 1;
    int i = 0;
    while(nums.at(i) != 1) i++;
    while(nums.at(i) == 1) i++;
    while(i < nums.size()) {
        if(nums.at(i) == 1) return 0;
        i++;
    }
    return 1;
}
",1.0,1111111111
Array_list_4,1422009,2213248,"bool have_1(vector<int>& nums) {
    for(int i = 0; i < nums.size(); i++) {
        if(nums.at(i) == 1) return 1;
    }
    return 0;
}

bool consecutiveOnes(vector<int>& nums) {
    if(!have_1(nums)) return 1;
    int i = 0;
    while(nums.at(i) != 1) i++;
    while(nums.at(i) == 1) i++;
    while(i < nums.size()) {
        if(nums.at(i) == 1) return 0;
        i++;
    }
    return 1;
}
",1.0,1111111111
Array_list_5,1422009,2213248,"int sumOfElement(vector<int>& nums, int begin, int end) {
    int sum = 0;
    for(int i = begin; i < end; i++) {
        sum = sum + nums.at(i);
    }
    return sum;
}

int equalSumIndex(vector<int>& nums) {
    int size = nums.size();
    int sum1 = 0, sum2 = 0;;
    for(int i = 0; i < size; i++) {
        sum2 += nums.at(i);
    }
    for(int i = 0; i < size; i++) {
        if(i > 0) sum1 += nums.at(i - 1);
        sum2 -= nums.at(i);
        if(sum1 == sum2) return i;
    }
    return -1;
}",1.0,1111111111
Array_list_6,1422009,2213248,"int longestSublist(vector<string>& words) {
    int max = 0, temp = 0;
    for(int i = 0; i < words.size(); i++) {
        if(i == 0) temp++;
        else if(words.at(i)[0] == words.at(i - 1)[0]) temp++;
        else {
            if(temp > max) max = temp;
            temp = 1;
        }
    }
    if(temp > max) max = temp;
    return max;
}",1.0,1111111
Array_list_7,1422009,2213248,"int maxSum(int* nums, int n, int k) {
    if(n <= 0) return 0;
    int maxArr = 0;
    for(int i = 1; i <= k && i <= n; i++) {
        int maxNum = 0;
        for(int j = n - i; j < n; j++) {
            if(nums[j] > maxNum) maxNum = nums[j];
        }
        int temp = maxSum(nums, n - i, k) + maxNum*i;
        if(temp > maxArr) maxArr = temp;
    }
    return maxArr;
}",0.8,11110
Array_list_8,1422009,2213248,"int minimumAmplitude(vector<int>& nums, int k) {
    int min = INT_MAX, max = INT_MIN, size = nums.size();
    int arr[4][size]; //minl maxl minr maxr
    for(int i = 0; i < size; i++) {
        if(nums.at(i) < min) min = nums.at(i);
        if(nums.at(i) > max) max = nums.at(i);
        arr[0][i] = min;
        arr[1][i] = max;
    }
    min = INT_MAX, max = INT_MIN;
    for(int i = size - 1; i >= 0; i--) {
        if(nums.at(i) < min) min = nums.at(i);
        if(nums.at(i) > max) max = nums.at(i);
        arr[2][i] = min;
        arr[3][i] = max;
    }
    int result = INT_MAX;
    for(int i = 0; i <= size - k; i++) {
        int minl = INT_MAX, maxl = INT_MIN, minr = INT_MAX, maxr = INT_MIN;
        if(i > 0) {
            minl = arr[0][i - 1];
            maxl = arr[1][i - 1];
        }
        if(i < size - k) {
            minr = arr[2][i + k];
            maxr = arr[3][i + k];
        }
        if(minl < minr) min = minl;
        else min = minr;
        if(maxl > maxr) max = maxl;
        else max = maxr;
        if(max - min < result) result = max - min;
    }
    return result;
}",1.0,1111111111
Array_list_9,1422009,2213248,"int steadySpeed(vector<int>& positions) {
    int speed, times, max = 0, size = positions.size();
    if(size <= 2) return positions.size();
    else {
        speed = positions.at(1) - positions.at(0);
        times = 2;
    }
    for(int i = 2; i < size; i++) {
        if(speed == positions.at(i) - positions.at(i - 1) || speed == positions.at(i - 1) - positions.at(i)) times++;
        else {
            times = 2;
            if(positions.at(i) - positions.at(i - 1) > 0) speed = positions.at(i) - positions.at(i - 1);
            else speed = positions.at(i - 1) - positions.at(i);
        }
        if(max < times) max = times;
    }
    return max;
}
",1.0,111111111111111
Array_list_10,1422009,2213248,"int sumLessThanTarget(vector<int>& nums, int target) {
    long sum = 0;
    for(int i = 0; i < nums.size(); i++) {
        if(sum + nums[i] <= target) sum += nums[i];
        else return sum;
    }
    return sum;
}",0.2,1100000000
Array_list_11,1422009,2213248,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    int size = operations.size();
    for(int i = 0; i < size; i++) {
        int left = operations[i][0], right = operations[i][1], increase = operations[i][2];
        for(int j = left; j <= right; j++) {
            nums[j] = nums[j] + increase;
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1423139,2211367,"void quickSort(int* a, int l, int r) {
    int p = a[(r + l) / 2];
    int i = l, j = r;
    while (i <= j) {  // Change 'i<j' to 'i<=j'
        while (a[i] < p) {
            i++;
        }
        while (a[j] > p) {
            j--;
        }
        if (i <= j) {
            int tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
            i++;
            j--;
        }
    }
    if (i < r) {
        quickSort(a, i, r);
    }
    if (l < j) {
        quickSort(a, l, j);
    }
}

int buyCar(int* nums, int length, int k) {
    quickSort(nums, 0, length - 1);
    int count = 0;
    for (int i = 0; i < length; i++) { // Change 'length-1' to 'length'
        if (k >= nums[i]) {
            count++;
            k -= nums[i];
        } else {
            break;
        }
    }
    return count;
}",1.0,1111111111
Array_list_2,1423139,2211367,"bool consecutiveOnes(std::vector<int>& nums) {
    bool consecutive = true; // Initialize as true
    bool foundOne = false;  // Flag to check if at least one '1' is present

    for (int num : nums) {
        if (num == 1) {
            foundOne = true; // Set the flag to true if '1' is found
            if (!consecutive) {
                return false; // Found '1' after '0', not consecutive
            }
        } else if (foundOne) {
            consecutive = false; // Found '0' after '1', not consecutive
        }
    }

    return true; // All '1's are consecutive or no '1' is present
}",1.0,1111111111
Array_list_3,1423139,2211367,"bool consecutiveOnes(std::vector<int>& nums) {
    bool consecutive = true; // Initialize as true
    bool foundOne = false;  // Flag to check if at least one '1' is present

    for (int num : nums) {
        if (num == 1) {
            foundOne = true; // Set the flag to true if '1' is found
            if (!consecutive) {
                return false; // Found '1' after '0', not consecutive
            }
        } else if (foundOne) {
            consecutive = false; // Found '0' after '1', not consecutive
        }
    }

    return true; // All '1's are consecutive or no '1' is present
}",1.0,1111111111
Array_list_4,1423139,2211367,"bool consecutiveOnes(std::vector<int>& nums) {
    bool consecutive = true; // Initialize as true
    bool foundOne = false;  // Flag to check if at least one '1' is present

    for (int num : nums) {
        if (num == 1) {
            foundOne = true; // Set the flag to true if '1' is found
            if (!consecutive) {
                return false; // Found '1' after '0', not consecutive
            }
        } else if (foundOne) {
            consecutive = false; // Found '0' after '1', not consecutive
        }
    }

    return true; // All '1's are consecutive or no '1' is present
}",1.0,1111111111
Array_list_5,1423139,2211367,"int equalSumIndex(vector<int> nums){
    int l = 0;
    int n = nums.size();
    int r = n;
    int sumleft = 0;
    int sumright = 0;
    sumleft += nums[l];
    sumright += nums[r-1];
    if(nums.size()==1) return 0;
    while(l<=r){
    if(sumleft==sumright&&(l+1)==(r-2)){
        return l+1;}
    while(sumleft<=sumright){
            l++;
            sumleft += nums[l];
            if(sumleft>=sumright) {
             if(sumleft==sumright&&(l+1)==(r-2)){
            return l+1;}
            else break;}
    }
    while(sumleft>=sumright){
        r--;
        sumright+=nums[r-1];
        if(sumleft<=sumright){
            if(sumleft==sumright&&(l+1)==(r-2)){
            return l+1;}
            else break;}
        }
    }
    return -1;
}
",1.0,1111111111
Array_list_6,1423139,2211367,"vector<vector<string>> findConsecutiveSublists(const vector<string>& inputList) {
    int n = inputList.size();
    vector<vector<string>> consecutivesublist;
    for(int len = 1; len < n; len++){
        for(int start = 0; start <= n-len; start++){
                vector<string>sublist;
                for(int i = start; i < len+start; i++){
                    sublist.push_back(inputList[i]);
                }
                consecutivesublist.push_back(sublist);}

    }
    return consecutivesublist;
}
int comparesimilar(vector<string> s){
    if (s.empty())return -1; // error condition, empty string is not a valid date
    int n = s.size();
    int giong = 0;
    int giong2 = 0;
    for(int i = 0; i < n;i++){
        if(i+1==n) break;
        for(int j = i+1;j<i+2;j++){
            string a = s[i];
            string b = s[j];
            if(a[0]==b[0]){
                    giong++;
            }
            else{
                if(giong2>giong){
                    giong = 1;
                }
                else{
                giong2 = giong;
                giong = 1;}
            }
        }
    }
    if(giong2>giong){
        return giong2;
    }
    else{
        return giong;
    }
}

int longestSublist(vector<string> s){
    vector<vector<string>> a = findConsecutiveSublists(s);
    int max = 0;
    int n = a.size();
    for(int i = 0; i<n;i++){
        vector<string> x = a[i];
        int temp = comparesimilar(x);
        if(temp>max){
            max = temp;
        }
    }
    return max;
}",0.57,110110
Array_list_7,1423139,2211367,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n];

    for (int i = 0; i < n; ++i) {
        int maxVal = nums[i];
        dp[i] = maxVal;

        for (int j = 1; j <= k && i - j + 1 >= 0; ++j) {
            maxVal = std::max(maxVal, nums[i - j + 1]);
            dp[i] = std::max(dp[i], dp[i - j] + maxVal * j);
        }
    }

    int result = 0;
    for (int i = 0; i < n; ++i) {
        result = std::max(result, dp[i]);
    }

    delete[] dp;

    return result;
}",1.0,11111
Array_list_8,1423139,2211367,"int minimumAmplitude(std::vector<int>& nums, int k) {
    int n = nums.size();
    if (n <= k) {
        // If the array is smaller than or equal to k, we can remove all elements.
        return 0;
    }

    // Initialize the minimum amplitude with a large value.
    int minAmplitude = INT_MAX;

    // Sort the input vector using a custom sorting function.
    auto customSort = [](std::vector<int>& arr) {
        int n = arr.size();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (arr[i] > arr[j]) {
                    std::swap(arr[i], arr[j]);
                }
            }
        }
    };

    // Iterate through all possible windows of size k.
    for (int i = 0; i <= n - k; ++i) {
        std::vector<int> window(nums.begin() + i, nums.begin() + i + k);
        customSort(window);
        int amplitude = window[k - 1] - window[0];
        minAmplitude = std::min(minAmplitude, amplitude);
    }

    return minAmplitude;
}",0.3,000010
Array_list_9,1423139,2211367,"int steadySpeed(std::vector<int>& positions) {
    int n = positions.size();
    if (n <= 2) {
        // If there are only two positions or fewer, the constant speed sublist length is the same as the number of positions.
        return n;
    }

    int maxSteadySpeed = 2; // At least two positions are required for a constant speed sublist.
    int currentSpeed = positions[1] - positions[0];
    int counter = 2;

    for (int i = 2; i < n; ++i) {
        int speed = positions[i] - positions[i - 1];
        if (speed == currentSpeed) {
            counter++;
        } else {
            currentSpeed = speed;
            counter = 2; // Reset the counter to 2 when the speed changes.
        }
        maxSteadySpeed = std::max(maxSteadySpeed, counter);
    }

    return maxSteadySpeed;
}
",0.07,000000000000001
Array_list_10,1423139,2211367,"#include <iostream>
#include <vector>

int sumLessThanTarget(std::vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int maxSum = INT_MIN;

    while (left < right) {
        int currentSum = nums[left] + nums[right];
        if (currentSum < target) {
            // Update maxSum if the current sum is greater and move the left pointer.
            maxSum = std::max(maxSum, currentSum);
            left++;
        } else {
            // If the current sum is greater or equal to target, move the right pointer.
            right--;
        }
    }

    return maxSum;
}

",1.0,1111111111
Array_list_11,1423139,2211367,"std::vector<int> updateArrayPerRange(std::vector<int>& nums, std::vector<std::vector<int>>& operations) {
    int n = nums.size();
    std::vector<int> result(n, 0);

    for (const std::vector<int>& operation : operations) {
        int L = operation[0];
        int R = operation[1];
        int X = operation[2];

        // Update the result array to reflect the operation.
        result[L] += X;
        if (R + 1 < n) {
            result[R + 1] -= X;
        }
    }

    // Compute the cumulative sum to get the final result.
    int sum = 0;
    for (int i = 0; i < n; ++i) {
        sum += result[i];
        nums[i] += sum;
    }

    return nums;
}",1.0,111111
Array_list_2,1423501,2211876,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.empty()) {
        
        return true;
    }

    int consecutiveCount = 0;

    for (int num : nums) {
        if (num == 1) {
            consecutiveCount++;
        } else {
            if ( consecutiveCount != 0 ) {
                return false;
               
            } 
        }

        
    }

    
    return true;
}",0.5,0100010111
Array_list_9,1423501,2211876,"#include <cmath>
int steadySpeed(vector<int>& positions) {
    vector<int> s;
    int length = positions.size();
    for (int i = 0 ; i < length - 2 ; i++ ) {
        int u = abs(positions[i+1] - positions[i]);
        s.push_back(u);
    }
    int max = 1;
    int current = 1;
    int lengths = s.size();
    for ( int i = 0 ; i < lengths ; i++ ) {
        for (int j = i ; j < lengths ; j++) {
            if ( s[j] == s[j+1]) current++;
            else break;
        }
        if (current > max ) max = current;
        current = 1;
    }
    return max ;
}",0.03,000000000000000
Array_list_6,1424495,2211367,"std::vector<std::vector<std::string>> findConsecutiveSublists(const std::vector<std::string>& inputList) {
    int n = inputList.size();
    std::vector<std::vector<std::string>> consecutiveSublists;
    for (int len = 1; len <= n; len++) { // Include sublists of size 1 as well
        for (int start = 0; start <= n - len; start++) {
            std::vector<std::string> sublist;
            for (int i = start; i < start + len; i++) {
                sublist.push_back(inputList[i]);
            }
            consecutiveSublists.push_back(sublist);
        }
    }
    return consecutiveSublists;
}

int compareSimilar(const std::vector<std::string>& s) {
    if (s.empty()) return -1; // Error condition, empty string is not a valid date
    int n = s.size();
    int maxSimilar = 0;
    int currentSimilar = 1; // Initialize with 1 to count the first element

    for (int i = 1; i < n; i++) {
        if (s[i][0] == s[i - 1][0]) {
            currentSimilar++;
        } else {
            if (currentSimilar > maxSimilar) {
                maxSimilar = currentSimilar;
            }
            currentSimilar = 1; // Reset the count for a new character
        }
    }

    if (currentSimilar > maxSimilar) {
        maxSimilar = currentSimilar;
    }

    return maxSimilar;
}

int longestSublist(const std::vector<std::string>& s) {
    std::vector<std::vector<std::string>> consecutiveSublists = findConsecutiveSublists(s);
    int maxLength = 0;

    for (const auto& sublist : consecutiveSublists) {
        int tempLength = compareSimilar(sublist);
        if (tempLength > maxLength) {
            maxLength = tempLength;
        }
    }

    return maxLength;
}",0.71,111110
Array_list_7,1428189,2212988,"int maxSum(int* nums, int n, int k) {
	int* dp = new int[n + 1];
	for (int i = 0; i <= n; ++i)
		dp[i] = 0;
	for (int i = 0; i < n; ++i) {
		int maxNum = nums[i];
		for (int j = 1; j <= k && i - j + 1 >= 0; ++j) {
			maxNum = maxNum > nums[i - j + 1] ? maxNum : nums[i - j + 1];
			dp[i + 1] = dp[i + 1] > dp[i - j + 1] + maxNum * j ? dp[i + 1] : dp[i - j + 1] + maxNum * j;
		}
	}
	int result = dp[n];
	delete[] dp;
	return result;
}",1.0,11111
Array_list_8,1428189,2212988,"int minimumAmplitude(vector<int>& nums, int k) {
	// STUDENT ANSWER
	int min = INT_MAX, max = INT_MIN;
	int res, resmin = INT_MAX;
	int size = nums.size();
	for (int i = 0; i < size - k + 1; i++) {
		if (i == 0) {
			max = nums[i + k];
			min = nums[i + k];
		}
		else {
			max = nums[0];
			min = nums[0];
		}
		for (int t = 0; t < i; t++) {
			if (max < nums[t]) max = nums[t];
			if (min > nums[t]) min = nums[t];
		}
		for (int t = i + k; t < size; t++) {
			if (max < nums[t]) max = nums[t];
			if (min > nums[t]) min = nums[t];
		}
		res = max - min;
		if (res < resmin) resmin = res;
	}
	return resmin;
}",0.9,1111111110
Array_list_1,1428868,2252260,"int buyCar(int* nums, int length, int k) {
    int cnt=0;
    int sum=0;
    sort(nums, nums+length);
    for(int i=0; i<length; i++){
        sum +=nums[i];
        if(sum>k)
            break;
        cnt++;
    }
    return cnt;
}",1.0,1111111111
Array_list_2,1428868,2252260,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int index = 0;
    for(int i=0;i<nums.size();i++){
        if(nums[i] == 1){
            index = i;
            break;
        }
    }
    int pos = 0;
    for(int j=index; j<nums.size(); j++){
        if(nums[j] !=1){
            pos = j;
            break;
        }
    }
    for(int k=pos+1; k<nums.size(); k++){
        if(nums[k]==1)
            return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_3,1428868,2252260,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int index = 0;
    for(int i=0;i<nums.size();i++){
        if(nums[i] == 1){
            index = i;
            break;
        }
    }
    int pos = 0;
    for(int j=index; j<nums.size(); j++){
        if(nums[j] !=1){
            pos = j;
            break;
        }
    }
    for(int k=pos+1; k<nums.size(); k++){
        if(nums[k]==1)
            return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_4,1428868,2252260,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int index = 0;
    for(int i=0;i<nums.size();i++){
        if(nums[i] == 1){
            index = i;
            break;
        }
    }
    int pos = 0;
    for(int j=index; j<nums.size(); j++){
        if(nums[j] !=1){
            pos = j;
            break;
        }
    }
    for(int k=pos+1; k<nums.size(); k++){
        if(nums[k]==1)
            return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_5,1428868,2252260,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0 || nums.size()==1)
        return 0;
    else{
        int sum=0;
        for(int i=1; i<nums.size(); i++){
            sum+=nums[i];
        }
        int cnt = 0;
        for(int j=1; j<nums.size(); j++){
            sum  = sum - nums[j];
            cnt += nums[j-1];
            if(sum == cnt)
                return j;
        }
        return -1;
    }
}",1.0,1111111111
Array_list_6,1428868,2252260,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if(words.size()==0)
        return 0;
    for(int i=0; i<words.size(); i++){
        words[i] = words[i].substr(0,1);
    }
    int tmp=1, ans =1;
    for(int i=1; i< words.size(); i++){
        if(words[i]==words[i-1])
            tmp++;
        else{
            ans = max(ans, tmp);
            tmp=1;
        }
    }
    ans = max(tmp, ans);
    return ans;
}",1.0,1111111
Array_list_7,1428868,2252260,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n+1];
    dp[0] = 0;
    for(int i=1; i<=n; i++){
        int maxVal=0;
        for(int j=1; j<=k && i-j>=0; j++){
            maxVal = max(nums[i-j], maxVal);
            dp[i] = max(dp[i], dp[i-j]+maxVal*j);
        }
    }
    return dp[n];
}",1.0,11111
Array_list_8,1428868,2252260,"int findSmallest(vector<int> tmp){
    int min = tmp[0];
    int n = tmp.size();
    for(int i=0; i<n; i++){
        if(tmp[i] < min)
            min = tmp[i];
    }
    return min;
}

int findLargest(vector<int> tmp){
    int max = tmp[0];
    int n = tmp.size();
    for(int i=0; i<n; i++){
        if(tmp[i] > max)
            max = tmp[i];
    }
    return max;
}

int minimumAmplitude(vector<int>& nums, int k) {
    int minAmplitude = INT_MAX;
    int n = nums.size();
    
    for (int i = 0; i <= n - k; i++) {
        std::vector<int> temp(nums.begin(), nums.begin() + i);
        temp.insert(temp.end(), nums.begin() + i + k, nums.end());
        int smallest = findSmallest(temp);
        int largest = findLargest(temp);
        minAmplitude = std::min(minAmplitude, largest - smallest);
    }
    
    return minAmplitude;
}",0.9,1111111110
Array_list_9,1428868,2252260,"int steadySpeed(vector<int>& positions) {
   vector<int> speed;
   int ans = 1;
   int tmp = 1;
   for(unsigned int i=0; i+1<positions.size(); i++){
       speed.push_back(abs(positions[i+1]-positions[i]));
   }
   for(unsigned int i=0; i+1<speed.size(); i++){
       if(speed[i+1]==speed[i]){
           tmp +=1;
       }
       else{
           ans = max(ans, tmp);
           tmp = 1;
       }
   }
   ans = max(tmp, ans);
   return ans+1;
}",1.0,111111111111111
Array_list_10,1428868,2252260,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left=0, right = nums.size()-1;
    int Max = -9999;
    while(left<right){
        int sum = nums[left]+nums[right];
        if(sum < target){
            Max = max(sum, Max);
            left++;
        }
        else
            right--;
    }
    return Max;
}",1.0,1111111111
Array_list_11,1428868,2252260,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for(unsigned int i=0; i<operations.size(); i++){
        int L = operations[i][0];
        int R = operations[i][1];
        int X = operations[i][2];
        for(int j=L; j<=R; j++){
            nums[j]+=X;
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1429204,2210578,"int buyCar(int* nums, int length, int k) {
    sort(nums,nums+length);
    int sum = 0;
  
    for(int i = 0; i < length; i++){
        sum+= nums[i];
        if(sum>k)  return i;
    }
   
}",1.0,1111111111
Array_list_2,1429204,2210578,"bool consecutiveOnes(vector<int>& nums) {
   int n= nums.size();
   if(n==0) return true;
   int first=-1, last = -1;
   for(int i = 0; i < n; i++){
       if(nums[i]==1&&first==-1) first = i;
        if(nums[i]==1&&first!=-1) last = i;
   }
   for(int i = first; i<=last;i++){
       if(nums[i]!= 1) return false;
   }
   return true;
}",1.0,1111111111
Array_list_3,1429204,2210578,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER 
    int n= nums.size();
   if(n==0) return true;
   int first=-1, last = -1;
   for(int i = 0; i < n; i++){
       if(nums[i]==1&&first==-1) first = i;
        if(nums[i]==1&&first!=-1) last = i;
   }
   for(int i = first; i<=last;i++){
       if(nums[i]!= 1) return false;
   }
   return true;
}",1.0,1111111111
Array_list_4,1429204,2210578,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size();
   if(n==0) return true;
   int first=-1, last = -1;
   for(int i = 0; i < n; i++){
       if(nums[i]==1&&first==-1) first = i;
        if(nums[i]==1&&first!=-1) last = i;
   }
   for(int i = first; i<=last;i++){
       if(nums[i]!= 1) return false;
   }
   return true;
}",1.0,1111111111
Array_list_5,1429204,2210578,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int n= nums.size(); int left=0,sum=0;
   for(int i=0;i<n;i++){
       sum+=nums[i];
   }
    for(int i=0;i<n;i++){
        sum-=nums[i];
       if(left==sum) return i;
        left+=nums[i];
        
         
    }
   
    return -1;
}",1.0,1111111111
Array_list_6,1429204,2210578,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int length = words.size();
    if(words.size() == 0) return 0;
    int clen = 1;
    int maxlen = 1;
    char fletter= words[0][0];
    for (int i=1; i< length;i++)
    {
        if(words[i][0]== fletter){
            clen++;
        }
        else{
            fletter = words[i][0];
            clen =1;
        }
        if (clen> maxlen){
            maxlen= clen;
        }
    }
    if (clen> maxlen){
        maxlen= clen;
    }
    return maxlen;
}",1.0,1111111
Array_list_8,1429204,2210578,"int minimumAmplitude(vector<int>& nums, int k) {
    int n= nums.size(); ;
    int minleft[n],maxleft[n],minright[n],maxright[n];
    minleft[0]=nums[0];maxleft[0]=nums[0];minright[n-1]=nums[n-1];maxright[n-1]=nums[n-1];
    //cout<<maxleft[0];
    for(int i=1; i<n;i++){
        if(minleft[i-1]>nums[i]) minleft[i]=nums[i];
        else minleft[i]=minleft[i-1];
        if(maxleft[i-1]<nums[i]) maxleft[i]=nums[i];
        else {maxleft[i]=maxleft[i-1];}
       // cout<<i<<"" ""<<minleft[i]<<""-""<<maxleft[i]<<endl;
    }
    for(int i=n-2; i>=0;i--){
        if(minright[i+1]>nums[i]) minright[i]=nums[i];
        else minright[i]=minright[i+1];
        if(maxright[i+1]<nums[i]) maxright[i]=nums[i];
        else maxright[i]=maxright[i+1];
        //cout<<i<<"" ""<<minright[i]<<"" ""<<maxright[i]<<endl;
    }
    int minimum=INT_MAX;
    for(int i=0;i<n-k;i++){
        int result;
        if(i==0) result=maxright[k-1]-minright[k-1];
        else if(i==n-k-1) result=maxleft[n-k-1]-minleft[n-k-1];
        else{
            int min, max;
            if(minleft[i-1]>minright[i+k]) min=minright[i+k];
            else min=minleft[i-1];
            if(maxleft[i-1]<maxright[i+k]) max=maxright[i+k];
            else max=maxleft[i-1];
            result=max-min;
        }
        if(minimum>result) {minimum=result;}
    }
    return minimum;
}",1.0,1111111111
Array_list_9,1429204,2210578,"int steadySpeed(vector<int>& positions) {
     int n = positions.size();
    if (n < 3) return n;
    
    int maxLength = 2;
    int length = 2;
    int diff =abs( positions[1] - positions[0]);
    
    for (int i = 2; i < n; ++i) {
        if (abs(positions[i] - positions[i-1]) == diff) {
            ++length;
        } else {
            diff = abs(positions[i] - positions[i-1]);
            length = 2;
        }
        maxLength = std::max(maxLength, length);
    }
    
    return maxLength;
}",1.0,111111111111111
Array_list_10,1429204,2210578,"int sumLessThanTarget(vector<int>& nums, int target) {
   int n = nums.size();
   int maxsum=INT_MIN;
    int left=0, right =n-1;
    while(left<right){
        int sum=nums[left]+nums[right];
        if(sum<target){
            if(sum>maxsum) maxsum=sum;
            left++;
        }
        else{
            right--;
        }
    }
   return maxsum;
}",1.0,1111111111
Array_list_11,1429204,2210578,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    int n = operations.size();
    for(int i=0;i<n;i++){
        int L=operations[i][0],R=operations[i][1],X=operations[i][2];
        for(int a = L;a<=R;a++){
            nums[a]+=X;
        }
    }
    return nums;
}",1.0,111111
Array_list_1,1429820,2210034,"void quickSort(int a[], int l, int r)
{
    int index = (l + r) / 2;
    int p = a[(index)];
    int head = l;
    int tail = r;
    while(l < r)
    {
        while(a[l] < p)
        {
            l++;
        }
        while(a[r] > p)
        {
            r--;
        }
        if(l <= r)
        {
            int tmp = a[l];
            a[l] = a[r];
            a[r] = tmp;
            l++;
            r--;
        }
    }
    if(l < tail)    quickSort(a, l,tail);
    if(r > head)    quickSort(a, head, r);

}

int buyCar(int* nums, int length, int k) {
    int count = 0, i = 0;
    quickSort(nums, 0, length - 1);
    do
    {
        k = k - nums[i];
        if(k >= 0) count++;
        i++;
    }
    while(k > 0);
    return count;
    
}",1.0,1111111111
Array_list_2,1429820,2210034,"
bool consecutiveOnes(vector<int>& nums)
{
    if(nums.size() == 0) return true;
    int i = 0;
    bool a = true;
    while(nums[i] != 1 && i < nums.size())
    {
        i++;
    }
    while(nums[i] == 1 && i < nums.size())
    {
        i++;   
    }
    for(; i < nums.size() ; ++i)
    {
        if(nums[i] != 1 ) continue;
        else 
        {
            a = false;
            break;
        }
    }
    return a;
}",1.0,1111111111
Array_list_3,1429820,2210034,"bool consecutiveOnes(vector<int>& nums)
{
    if(nums.size() == 0) return true;
    int i = 0;
    bool a = true;
    while(nums[i] != 1 && i < nums.size())
    {
        i++;
    }
    while(nums[i] == 1 && i < nums.size())
    {
        i++;   
    }
    for(; i < nums.size() ; ++i)
    {
        if(nums[i] != 1 ) continue;
        else 
        {
            a = false;
            break;
        }
    }
    return a;
}",1.0,1111111111
Array_list_4,1429820,2210034,"bool consecutiveOnes(vector<int>& nums)
{
    if(nums.size() == 0) return true;
    int i = 0;
    bool a = true;
    while(nums[i] != 1 && i < nums.size())
    {
        i++;
    }
    while(nums[i] == 1 && i < nums.size())
    {
        i++;   
    }
    for(; i < nums.size() ; ++i)
    {
        if(nums[i] != 1 ) continue;
        else 
        {
            a = false;
            break;
        }
    }
    return a;
}",1.0,1111111111
Array_list_5,1429820,2210034,"int equalSumIndex(vector<int>& nums) {
    int nums2[nums.size()];
    nums2[0] = nums[0];
    for(int i = 1; i < nums.size(); ++i)
    {
        nums2[i] = nums2[i-1] + nums[i];
    }
    int nums3[nums.size()];
    nums3[nums.size() - 1] = nums[nums.size() - 1];
    for(int i = nums.size() - 2; i >= 0; --i)
    {
        nums3[i] = nums3[i+1] + nums[i];
    }
    for(int i = 0; i < nums.size(); ++i)
    {
        if(nums3[i] == nums2[i]) return i;
    }
    return -1;
}",1.0,1111111111
Array_list_6,1429820,2210034,"

// Main function to find the length of the longest subarray

int longestSublist(vector<string>& words) {
    if (words.empty()) return 0;

    int maxCount = 1;
    int currentCount = 1;

    for (int i = 1; i < words.size(); ++i) {
        if (words[i][0] == words[i - 1][0] ) {
            currentCount++;
        } else {
            maxCount = max(maxCount, currentCount);
            currentCount = 1;
        }
    }

    return max(maxCount, currentCount);

}",1.0,1111111
Array_list_7,1429820,2210034,"#include<vector>
#include <algorithm>
using namespace std;
int maxSum(int* nums, int n, int k) {
    vector<int> dp(n+1, 0);
    for (int i = 1; i <= n; ++i) {
        int max_val = nums[i-1];
        for (int j = i; j > 0 && i-j+1 <= k; --j) {
            max_val = max(max_val, nums[j-1]);
            dp[i] = max(dp[i], dp[j-1] + max_val * (i-j+1));
        }
    }
    return dp[n];
}",1.0,11111
Array_list_8,1429820,2210034,"int minimumAmplitude(vector<int>& arr, int K)
{
    // Size of array
    int N = arr.size();
 
    // Stores the maximum and minimum
    // in the suffix subarray [i .. N-1]
    int maxSuffix[N + 1], minSuffix[N + 1];
 
    maxSuffix[N] = -1e9;
    minSuffix[N] = 1e9;
    maxSuffix[N - 1] = arr[N - 1];
    minSuffix[N - 1] = arr[N - 1];
 
    // Constructing the maxSuffix and
    // minSuffix arrays
 
    // Traverse the array
    for (int i = N - 2; i >= 0; --i) {
 
        maxSuffix[i] = max(
maxSuffix[i + 1],
 arr[i]);
        minSuffix[i] = min(
minSuffix[i + 1],
 arr[i]);
    }
 
    // Stores the maximum and minimum
    // in the prefix subarray [0 .. i-1]
    int maxPrefix = arr[0];
    int minPrefix = arr[0];
 
    // Store the minimum difference
    int minDiff = maxSuffix[K] - minSuffix[K];
 
    // Traverse the array
    for (int i = 1; i < N; ++i) {
 
        // If the suffix doesn't exceed
        // the end of the array
        if (i + K <= N) {
 
            // Store the maximum element
            // in array after removing
            // subarray of size K
            int maximum = max(maxSuffix[i + K], maxPrefix);
 
            // Stores the maximum element
            // in array after removing
            // subarray of size K
            int minimum = min(minSuffix[i + K], minPrefix);
 
            // Update minimum difference
            minDiff = min(minDiff, maximum - minimum);
        }
 
        // Updating the maxPrefix and
        // minPrefix with current element
        maxPrefix = max(maxPrefix, arr[i]);
        minPrefix = min(minPrefix, arr[i]);
    }
 
    // Print the minimum difference
    return minDiff;
}",1.0,1111111111
Array_list_9,1429820,2210034,"#include <cmath>

int steadySpeed(std::vector<int>& p)
{
    int max_count = 0;
    int count = 1;
    int save = -1;
    for(unsigned int i = 0; i < p.size() - 1; ++i)
    {
        if(abs(p[i+1] - p[i]) == save)
        {
            count++;
        }
        else
        {
            save = abs(p[i+1] - p[i]);
            count = 1;
        }
        if(count > max_count) max_count = count;
    }
    return max_count + 1;
    
}",1.0,111111111111111
Array_list_10,1429820,2210034,"int sumLessThanTarget(vector<int>& nums, int target) {
    int n = nums.size();
    int left = 0; // Initialize the left pointer at the beginning of the array.
    int right = n - 1; // Initialize the right pointer at the end of the array.
    int maxSum = INT_MIN; // Initialize maxSum to a very small value.

    while (left < right) {
        int currentSum = nums[left] + nums[right];
        if (currentSum < target) {
            // If the current sum is less than the target, update maxSum and move the left pointer to the right.
            maxSum = max(maxSum, currentSum);
            left++;
        } else {
            // If the current sum is greater than or equal to the target, move the right pointer to the left.
            right--;
        }
    }

    return maxSum;
}
",1.0,1111111111
Array_list_11,1429820,2210034,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    
    
    for (vector<int>& operation : operations) {
        int L = operation[0];
        int R = operation[1];
        int X = operation[2];
        
        // Apply the operation to the range [L, R]
        for (int i = L; i <= R; i++) {
            nums[i] += X;
        }
    }
    
    return nums;
}",1.0,111111
Array_list_1,1431200,2212282,"int buyCar(int * nums,int length,int k){
     int tg;
     int count=0;
    for(int i = 0; i < length - 1; i++){
        for(int j = i + 1; j < length; j++){
            if(nums[i] > nums[j]){
                
                tg = nums[i];
                nums[i] = nums[j];
                nums[j] = tg;        
            }
        }
    }
    for(int i = 0; i < length ; i++){
        k-=nums[i];
        if(k>=0) count++;
        else break;
    }
    return count;
}",1.0,1111111111
Array_list_2,1431200,2212282,"bool consecutiveOnes(vector<int>& nums) {
    bool s1 = 0;
    bool s2 = 0;
    
    for(int i : nums) {
        if(i == 1 && s1 == 0) s1 = 1;
        if(i != 1 && s1 == 1) s2 = 1;
        if(i == 1 && s2 == 1) return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_3,1431200,2212282,"bool consecutiveOnes(vector<int>& nums) {
    bool s1 = 0;
    bool s2 = 0;
    
    for(int i : nums) {
        if(i == 1 && s1 == 0) s1 = 1;
        if(i != 1 && s1 == 1) s2 = 1;
        if(i == 1 && s2 == 1) return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_4,1431200,2212282,"bool consecutiveOnes(vector<int>& nums) {
    bool s1 = 0;
    bool s2 = 0;
    
    for(int i : nums) {
        if(i == 1 && s1 == 0) s1 = 1;
        if(i != 1 && s1 == 1) s2 = 1;
        if(i == 1 && s2 == 1) return 0;
    }
    return 1;
}",1.0,1111111111
Array_list_5,1431200,2212282,"int equalSumIndex(vector<int>& nums) {
    int mid = nums.size()/2;
    int sumLeft  = 0;
    int sumRight = 0;
    bool oneSide = 1;
    
    for(int i = mid-1; i>=0; --i)          sumLeft  += nums[i];
    for(int i = mid+1; i<nums.size(); ++i) sumRight += nums[i];
    
    while(mid >= 0 && mid < nums.size()) {
        if(sumLeft == sumRight) return mid;
        else {
            if(sumLeft > sumRight) {
                mid--;
                sumLeft  -= nums[mid];
                sumRight += nums[mid+1]; 
                if(sumLeft < sumRight) return -1;
            }
            else {
                mid++;
                sumLeft  += nums[mid-1];
                sumRight -= nums[mid];
                if(sumLeft > sumRight) return -1;
            }
        }
        
    }
    
    return -1;
}",1.0,1111111111
Array_list_6,1431200,2212282,"int longestSublist(vector<string>& words) {
    int count = 0;
    int tmp = 0;
    
    if(words.size() == 0) return count;
    for(int i=0; i<words.size()-1; i++) {
        if(words[i][0] == words[i+1][0]) {
            ++tmp;
        }
        else tmp = 0;
        
        count = max(count, tmp);
    }
    
    return count ? count + 1 : 0;
}",1.0,1111111
Array_list_7,1431200,2212282,"int maxSum(int* nums, int n, int k) {
    int result = 0;
    int i = 0;

    while (i < n) {
        int maxVal = nums[i];
        int maxIndex = i;

        // Find the maximum element within the next k elements
        for (int j = i + 1; j < std::min(i + k, n); ++j) {
            if (nums[j] > maxVal) {
                maxVal = nums[j];
                maxIndex = j;
            }
        }

        // Calculate and add S-value for the sub-array
        result += maxVal * (maxIndex - i + 1);

        // Move to the next non-overlapping sub-array
        i = maxIndex + 1;
    }

    return result;
}",0.2,00000
Array_list_8,1431200,2212282,"int minimumAmplitude(vector<int>& nums, int k) {
    int n = static_cast<int>(nums.size());
    
    if(n == 0) return 0;
    if(n == 1) return nums[0];
    if(n == 2) {
        if(nums[0] >= nums[1]) return nums[0] - nums[1];
        return nums[1] - nums[0];
    }
    
    for(int i=0; i<n; ++i) {
        for(int j=i+1; j<n; ++j) {
            if(nums[i] > nums[j]) swap(nums[i], nums[j]);
        }
    }
    
    int djtmetruongloz = INT_MAX;
    
    for(int i=0; i<n; ++i) {
        for(int j=i+1; j<n; ++j) {
            int max = INT_MAX;
            int min = INT_MIN;
            for(int t = 0; t<n; ++t) {
                if(i == t || t == j) continue;
                if(nums[t] < max) max = nums[t];
                if(nums[t] > min) min = nums[t];
            }
            if(djtmetruongloz > (min-max)) djtmetruongloz = min-max;
        }
    }
    
    return djtmetruongloz;
}",0.4,111100
Array_list_9,1431200,2212282,"int steadySpeed(vector<int>& p) {
    int n = p.size();
    if(n==5) return 3;

    if (n <= 1) {
        return n;  // If there is only one position or none, the length is the same as the input
    }

    int maxSteadySpeed = 1;  // Minimum steady speed is 1

    int currentSteadySpeed = 1;

    // Check the difference between consecutive positions
    for (int i = 1; i < n; ++i) {
        if (p[i] == p[i - 1]) {
            currentSteadySpeed++;
        } else {
            currentSteadySpeed = 1;
        }

        // Update the maximum steady speed
        maxSteadySpeed = max(maxSteadySpeed, currentSteadySpeed);
    }

    return maxSteadySpeed+3;
}",0.33,100001110000000
Array_list_10,1431200,2212282,"int sumLessThanTarget(vector<int>& nums, int target) {
    int count  = 0;
    int left   = 0;
    int right  = nums.size()-1;
    
    while(left < right) {
        if(nums[right] - nums[left] < target) {
            count = max(count, nums[right] - nums[left]);
            right--;
        }
        else left++;
    }
    
    return count;
}",0.1,1000000000
Array_list_11,1431200,2212282,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    for(vector<int> scan : operations) {
        for(int i = scan[0]; i<=scan[1]; ++i) {
            nums[i] += scan[2];
        }
    }
    
    return nums;
}",1.0,111111
Array_list_1,1432012,2211878,"int buyCar(int* nums, int length, int k) {
    sort(nums, nums + length);
    int count = 0;
    for (int i = 0; i < length; i++) {
        if (k >= nums[i]) {
            k -= nums[i];
            count++;
        }
    }
    return count;
}",1.0,1111111111
Array_list_2,1432012,2211878,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n == 0) return true;
    
    int i = 0;
    while (i < n && nums[i] != 1) {
        i++;
    } if(i == n) return false;
    while (i < n && nums[i] == 1) {
        i++;
    }
    if(i == n) return true;
    while(i < n && nums[i] != 1){
        i++;
    }  
    if(i == n) return true;
    return false;
    
}",1.0,1111111111
Array_list_3,1432012,2211878,"bool consecutiveOnes(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) {
        return true;
    }
    
    int i = 0;
    while (i < n && nums[i] != 1) {
        i++;
    } if(i == n) return false;
    while (i < n && nums[i] == 1) {
        i++;
    }
    if(i == n) return true;
    while(i < n && nums[i] != 1){
        i++;
    }  
    if(i == n) return true;
    return false;
}",1.0,1111111111
Array_list_4,1432012,2211878,"bool consecutiveOnes(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n == 0) {
        return true;
    }
    
    int i = 0;
    while (i < n && nums[i] != 1) {
        i++;
    } if(i == n) return false;
    while (i < n && nums[i] == 1) {
        i++;
    }
    if(i == n) return true;
    while(i < n && nums[i] != 1){
        i++;
    }  
    if(i == n) return true;
    return false;
}",1.0,1111111111
Array_list_5,1432012,2211878,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n == 1) return 0;
    vector<int> sumvec;
    for(int i = 0; i < n; i++){
        if(i == 0) {
            sumvec.push_back(nums[i]);
        } else {
            sumvec.push_back(nums[i]+sumvec[i-1]);
        }
    }
    int i = 0;
    while(i < n && (sumvec[n-1] - sumvec[i] != sumvec[i-1] )){
        i++;
    }
    
    sumvec.clear();
    if(i == n) return -1;
    else return i;
}",1.0,1111111111
Array_list_6,1432012,2211878,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    int n = words.size();
    if(n == 0) return 0;
    int max_len = 0;
    int curr_len = 1;
    for (int i = 1; i < n; i++) {
        if (words[i][0] == words[i - 1][0]) {
            curr_len++;
        } else {
            max_len = max(max_len, curr_len);
            curr_len = 1;
        }
    }

    return max(max_len, curr_len);
}",1.0,1111111
Array_list_7,1432012,2211878,"int maxsubarr(int s, int e, int * arr){
    int max = arr[s];
    for(int i = s+1; i <= e; i++){
        if(max < arr[i]) max = arr[i];
    }
    return max;
}

int maxSum(int *nums,int n, int k){
    int * res = new int [n];
    for(int i = 0; i < n;i++){
        if(i >= k){
            res[i] = nums[i] + res[i-1];
            for(int j = 1; j < k; j++){
                res[i] = max(res[i],(j+1)*maxsubarr(i-j,i,nums)+res[i-j-1]);
            }
        } else {
            res[i] = (i+1)*maxsubarr(0,i,nums);
        }
    }
    int temp = res[n-1];
    delete []res;
    return temp;
}
",1.0,11111
Array_list_8,1432012,2211878,"void swap( int& a, int& b){
    a += b;
    b = a - b;
    a -= b;
}

void sort(vector<int> &nums){
    int n = nums.size();
    for(int i = 0; i < n - 1; i++){
        for(int j = i + 1; j < n; j++){
            if (nums[i] > nums[j]) {
                swap(nums[i],nums[j]);
            }
        }
    }
}

int minimumAmplitude(vector<int> &nums, int k){
    sort(nums);
    return nums[nums.size()-1] - nums[k];
}",0.1,1000000000
Array_list_9,1432012,2211878,"int ab(int a){
    if(a < 0) a *= -1;
    return a;
}

int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    if(n <= 1) return n;
    int *a = new int[n];
    for(int i = 0; i < n; i++){
        if(i == 0) {
            a[0] = -1;
        } else {
            a[i] = ab(positions[i] - positions[i-1]); 
        }
    }
    
    int max_count = 0;
    int count = 1;

    for (int i = 1; i < n; i++) {
        if (a[i] == a[i - 1]) {
            count++;
        } else {
            max_count = max(max_count, count);
            count = 1;
        }
    }
    max_count = max(max_count, count);
    delete []a;
    max_count++;
    return max_count;
}",1.0,111111111111111
Array_list_10,1432012,2211878,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int n = nums.size();
    int left = 0;
    int right = n - 1;
    int max_sum = INT_MIN;

    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum < target) {
            max_sum = max(max_sum, sum);
            left++;
        } else {
            right--;
        }
    }

    return max_sum;
}",1.0,1111111111
Array_list_11,1432012,2211878,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    for (const auto& operation : operations) {
        int L = operation[0];
        int R = operation[1];
        int X = operation[2];

        for (int i = L; i <= R; i++) {
            nums[i] += X;
        }
    }

    return nums;
}",1.0,111111
Array_list_1,1432325,2212988,"int buyCar(int* nums, int length, int k) {
	sort(nums, nums+ length);
	int count = 0;
	int totalmoney = 0;
	for (int i = 0; i < length; i++) {
		if (totalmoney + nums[i] <= k) {
			totalmoney += nums[i];
			count++;
		}
		else {
			break;
		}
	}
	return count;
}",1.0,1111111111
Array_list_2,1432325,2212988,"bool consecutiveOnes(vector<int>& nums) {
	// STUDENT ANSWER
	int n = nums.size();
	bool res = true;
	vector<int> nums2 = {};
	int k = 0;
	int s1 = -1;
	int s2 = -1;
	if (n == 0) return true;
	for (int i = 0; i < n; i++) {
		if (nums[i] == 1) {
			s2 = i;
			if (s1 == -1) {
				s1 = i;
			}
		}
	}
	for (int i = s1; i <= s2; i++) {
		nums2.push_back(nums[i]);
	}
	int d = nums2.size();
	for (int i = 0; i < d; i++) {
		if (nums2[i] != 1) {
			res = false;
		}
	}
	return res;
}",1.0,1111111111
Array_list_3,1432325,2212988,"bool consecutiveOnes(vector<int>& nums) {
	// STUDENT ANSWER
	int n = nums.size();
	bool res = true;
	vector<int> nums2 = {};
	int k = 0;
	int s1 = -1;
	int s2 = -1;
	if (n == 0) return true;
	for (int i = 0; i < n; i++) {
		if (nums[i] == 1) {
			s2 = i;
			if (s1 == -1) {
				s1 = i;
			}
		}
	}
	for (int i = s1; i <= s2; i++) {
		nums2.push_back(nums[i]);
	}
	int d = nums2.size();
	for (int i = 0; i < d; i++) {
		if (nums2[i] != 1) {
			res = false;
		}
	}
	return res;
}",1.0,1111111111
Array_list_4,1432325,2212988,"bool consecutiveOnes(vector<int>& nums) {
	// STUDENT ANSWER
	int n = nums.size();
	bool res = true;
	vector<int> nums2 = {};
	int k = 0;
	int s1 = -1;
	int s2 = -1;
	if (n == 0) return true;
	for (int i = 0; i < n; i++) {
		if (nums[i] == 1) {
			s2 = i;
			if (s1 == -1) {
				s1 = i;
			}
		}
	}
	for (int i = s1; i <= s2; i++) {
		nums2.push_back(nums[i]);
	}
	int d = nums2.size();
	for (int i = 0; i < d; i++) {
		if (nums2[i] != 1) {
			res = false;
		}
	}
	return res;
}",1.0,1111111111
Array_list_5,1432325,2212988,"int equalSumIndex(vector<int>& nums) {
	// STUDENT ANSWER
	int totalsum = 0;
	int totalleft = 0;
	int totalright;
	int n = nums.size();
	for (int i = 0; i < n; i++) {
		totalsum += nums[i];
	}
	//cout << totalsum << endl;

	int res = -1;
	for (int i = 0; i < n; i++) {
		//if (i )
		if (i > 0) {
			totalleft += nums[i - 1];
		}
		totalright = totalsum - totalleft - nums[i];
		if (totalleft == totalright) {
			res = i;
			break;
		}
	}
	return res;
}",1.0,1111111111
Array_list_6,1432325,2212988,"int longestSublist(vector<string>& words) {
	// STUDENT ANSWER
	int maxlength = 1;
	int currlength = 1;
	size_t n = words.size();
	//	sort( words.begin(), words.end());
	if (n == 0) return 0;
	for (int i = 1; i < n; i++) {// pay attention
		if (words[i][0] == words[i - 1][0]) {
			currlength++;
		}
		else {
			maxlength = max(maxlength, currlength);
			currlength = 1;
		}
	}
	maxlength = max(maxlength, currlength);
	//cout << 1;
	return maxlength;
}",1.0,1111111
Array_list_7,1432325,2212988,"int maxSum(int* nums, int n, int k) {
	int* dp = new int[n + 1];
	for (int i = 0; i <= n; ++i)
		dp[i] = 0;
	for (int i = 0; i < n; ++i) {
		int maxNum = nums[i];
		for (int j = 1; j <= k && i - j + 1 >= 0; ++j) {
			maxNum = maxNum > nums[i - j + 1] ? maxNum : nums[i - j + 1];
			dp[i + 1] = dp[i + 1] > dp[i - j + 1] + maxNum * j ? dp[i + 1] : dp[i - j + 1] + maxNum * j;
		}
	}
	int result = dp[n];
	delete[] dp;
	return result;
}",1.0,11111
Array_list_8,1432325,2212988,"int minimumAmplitude(vector<int>& nums, int k) {
	// STUDENT ANSWER
	int min = INT_MAX, max = INT_MIN;
	int res, resmin = INT_MAX;
	int size = nums.size();
	for (int i = 0; i < size - k + 1; i++) {
		if (i == 0) {
			max = nums[i + k];
			min = nums[i + k];
		}
		else {
			max = nums[0];
			min = nums[0];
		}
		for (int t = 0; t < i; t++) {
			if (max < nums[t]) max = nums[t];
			if (min > nums[t]) min = nums[t];
		}
		for (int t = i + k; t < size; t++) {
			if (max < nums[t]) max = nums[t];
			if (min > nums[t]) min = nums[t];
		}
		res = max - min;
		if (res < resmin) resmin = res;
	}
	return resmin;
}",0.9,1111111110
Array_list_9,1432325,2212988,"int steadySpeed(vector<int>& positions) {
	size_t n = positions.size();
	if (n < 2) return 0;

	int currspeed = abs(positions[1] - positions[0]);
	int currlength = 2;
	int maxlength = 0;
	for (unsigned int i = 1; i < n; i++) {
		int newspeed = abs(positions[i + 1] - positions[i]);
		if (newspeed == currspeed) {
			currlength++;
			maxlength = max(maxlength, currlength);
		}
		else {
			currspeed = newspeed;
			currlength = 2;

		}
	}
	maxlength = max(maxlength, currlength);
	return maxlength;
}",1.0,111111111111111
Array_list_10,1432325,2212988,"int sumLessThanTarget(vector<int>& nums, int target) {
	size_t n = nums.size();
	
	int left = 0;
	int right = n - 1;
	int largestsum = INT_MIN;
	while (left < right) {
		int sum = nums[left] + nums[right];
		if (sum < target) {
			largestsum = max(sum, largestsum);
			left++;
		}
		else {
			right--;
		}
	}
	return largestsum;
}",1.0,1111111111
Array_list_11,1432325,2212988,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
	// STUDENT ANSWER
	// STUDENT ANSWER
	for (const std::vector<int>& operation : operations) {
		int L = operation[0];
		int R = operation[1];
		int X = operation[2];
		for (int i = L; i <= R; i++) {
			nums[i] += X;
		}
	}
	return nums;
}",1.0,111111
Array_list_1,1432584,2211876,"int buyCar(int* nums, int length, int k) {
    std::sort(nums, nums + length);

    int maxCars = 0;
    int currentBudget = k;

    
    for (int i = 0; i < length; i++) {
        if (nums[i] <= currentBudget) {
            maxCars++;
            currentBudget -= nums[i];
        } else {
            break; 
        }
    }

    return maxCars;
}",1.0,1111111111
Array_list_2,1432584,2211876,"bool consecutiveOnes(vector<int>& nums) {
    int index1start = 0;
    
    if (nums.size() == 0) return true;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 1) {
            index1start++;
        } else {
            break;
        }}
    
    if (index1start == nums.size()) return false;
    
    for (int i =index1start ; i < nums.size() ; i++) {
        if (nums[i] == 1) {
            index1start++;
        } else {
            break;
        }}
    
    if ( index1start == nums.size()) return true;
    
    for (int i =index1start ; i < nums.size() ; i++) {
        if (nums[i] == 1) {
            return false;
        } else {
            return true;
    }}    
        
    
}",0.6,1111101000
Array_list_3,1432584,2211876,"bool consecutiveOnes(vector<int>& nums) {
    int index1start = 0;
    
    if (nums.size() == 0) return true;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 1) {
            index1start++;
        } else {
            break;
        }}
    
    if (index1start == nums.size()) return false;
    
    for (int i =index1start ; i < nums.size() ; i++) {
        if (nums[i] == 1) {
            index1start++;
        } else {
            break;
        }}
    
    if ( index1start == nums.size()) return true;
    
    for (int i =index1start ; i < nums.size() ; i++) {
        if (nums[i] == 1) {
            return false;
        } else {
            return true;
    }}    
        
    
}",0.6,1111101000
Array_list_4,1432584,2211876,"bool consecutiveOnes(vector<int>& nums) {
    int index1start = 0;
    
    if (nums.size() == 0) return true;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 1) {
            index1start++;
        } else {
            break;
        }}
    
    if (index1start == nums.size()) return false;
    
    for (int i =index1start ; i < nums.size() ; i++) {
        if (nums[i] == 1) {
            index1start++;
        } else {
            break;
        }}
    
    if ( index1start == nums.size()) return true;
    
    for (int i =index1start ; i < nums.size() ; i++) {
        if (nums[i] == 1) {
            return false;
        } else {
            return true;
    }}    
        
    
}",0.6,1111101000
Array_list_5,1432584,2211876,"int equalSumIndex(vector<int>& nums) {
    // STUDENT ANSWER
    int totalSum = 0;
    for (int num : nums) {
        totalSum += num;
    }

    int leftSum = 0;
    for (int i = 0; i < nums.size(); i++) {
        totalSum -= nums[i];
        if (leftSum == totalSum) {
            return i;
        }
        leftSum += nums[i];
    }

    return -1;
}",1.0,1111111111
Array_list_6,1432584,2211876,"int longestSublist(vector<string>& words) {
    // STUDENT ANSWER
    if (words.empty()) {
        return 0;
    }

    int maxSublistLength = 1; 

    int currentSublistLength = 1;
    char currentFirstLetter = words[0][0];

    for (int i = 1; i < words.size(); i++) {
        char firstLetter = words[i][0];

        if (firstLetter == currentFirstLetter) {
            currentSublistLength++;
        } else {
            
            currentFirstLetter = firstLetter;
            currentSublistLength = 1;
        }

        
        maxSublistLength = max(maxSublistLength, currentSublistLength);
    }

    return maxSublistLength;
}",1.0,1111111
Array_list_7,1432584,2211876,"int maxSum(int* nums, int n, int k) {
    int* dp = new int[n + 1];
    

    for (int i = 0; i <= n; i++) {
        dp[i] = 0;
    }

    
    for (int i = 1; i <= n; i++) {
        int maxElement = 0;
        
        
        for (int j = 1; j <= k && i - j >= 0; j++) {
            
            maxElement = max(maxElement, nums[i - j]);
            int currentSValue = maxElement * j;
            
            
            dp[i] = max(dp[i], dp[i - j] + currentSValue);
        }
    }

   
    int result = dp[n];
    
    
    delete[] dp;

    return result;

   
}",1.0,11111
Array_list_10,1432584,2211876,"int sumLessThanTarget(vector<int>& nums, int target) {
    // STUDENT ANSWER
    int left = 0;
    int right = nums.size() - 1;
    int maxSum = INT_MIN;

    while (left < right) {
        int currentSum = nums[left] + nums[right];

        if (currentSum < target) {
            maxSum = max(maxSum, currentSum);
            left++; 
        } else {
            right--; 
        }
    }

    return maxSum;
}",1.0,1111111111
Array_list_11,1432584,2211876,"vector<int> updateArrayPerRange(vector<int>& nums, vector<vector<int>>& operations) {
    // STUDENT ANSWER
    int n = nums.size();
    vector<int> result(n, 0);

    for (const vector<int>& op : operations) {
        int left = op[0];
        int right = op[1];
        int increment = op[2];

        
        for (int i = left; i <= right; i++) {
            result[i] += increment;
        }
    }

   
    for (int i = 0; i < n; i++) {
        nums[i] += result[i];
    }

    return nums;
}",1.0,111111
Singly_linked_list_1,1291105,2110501,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    if (l0 == NULL && l1 == NULL)           return NULL;
    else if (l0 == NULL && l1 != NULL)      return l1;
    else if (l0 != NULL && l1 == NULL)      return l0;
    LLNode* head = new LLNode(-1,NULL);
    LLNode* tail = head;
    int S;
    int carry = 0;
    while (true)
    {
        S= l0->val + l1->val + carry;
        if (S >= 10)
        {
            S %= 10;
            carry = 1;
        }
        else carry=0;
        LLNode* pNew = new LLNode(S,NULL);
        if (head->val == -1)    head = tail=pNew;
        else
        {
            tail->next = pNew;
            tail = pNew;
        }
        if(l0->next == NULL && l1->next == NULL)
        {
            if (carry == 1)
            {
                LLNode*pNew = new LLNode(1,NULL);
                tail->next = pNew;
                tail = pNew;
            }
            break;
        }
        
        if (l0->next != NULL)       l0 = l0->next;
        else                        l0->val = 0;
        if (l1->next != NULL)       l1 = l1->next;
        else                        l1->val = 0;
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1291105,2110501,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.exp < 0 || term.coeff == 0);
    else
    {
    SLinkedList<Term>::Iterator cur;
    int count = 0;
    for (cur=this->terms->begin();cur!=this->terms->end();cur++) 
    {
        Term tmp = *cur;
        if(tmp.exp == term.exp)
        {
            tmp.coeff += term.coeff;
            if(tmp.coeff != 0)      cur.set(tmp);
            else                    cur.remove();
            return;
        }
        else 
        {
            if(tmp.exp < term.exp)    break;
        }
        count++;
    }
    this->terms->add(count,term);
}
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    if(exp < 0 ||coeff ==0);
    else
    {
    SLinkedList<Term>::Iterator cur;
    int count = 0;
    for (cur = this->terms->begin(); cur != this->terms->end(); cur++) 
    {
        Term tmp = *cur;
        if(tmp.exp == exp)
        {
            tmp.coeff += coeff;
            if(tmp.coeff != 0.0000000f) cur.set(tmp);
            else                        cur.remove();
            return;
        }
        else 
        {
            if(tmp.exp < exp) break;
        }
        count++;
    }
    Term tmp(coeff,exp);
    this->terms->add(count,tmp);
    }
}",1.0,11111
Singly_linked_list_3,1291105,2110501,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList=pList;
    if(begin==true)
    {
        if(this->pList!=NULL)
        {
            this->index=0;
            this->current=this->pList->head;
        }
        else
        {
            this->index=-1;
            this->current=NULL;
        }
    }
    else
    {
        this->current=NULL;
        if(this->pList!=NULL)   this->index=this->pList->count;
        else                    this->index=0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current=iterator.current;
    this->index=iterator.index;
    this->pList=iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    if (this->index == 0)
     {
         pList->removeAt(0);
         this->current=NULL;
         this->index = -1;
     }
     pList->removeAt(this->index);
     this->index--;
     Node *cur=pList->head;
     for (int i=0;i<this->index;i++) 
     {
         cur=cur->next;
     }
     this->current=cur;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    else                    this->current->data=e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    else                    return this->current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return !((this->current == iterator.current) && (this->index == iterator.index));
    
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(this->current==NULL&&this->index==this->pList->count) throw std::out_of_range(""Segmentation fault!"");
    else if(this->index==-1&&current==NULL)
    {
        this->current=this->pList->head;
        this->index++;
    } 
    else if(current !=NULL)
    {
        this->current=this->current->next;
        this->index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    Iterator tmp=*this;
    ++*this;
    return tmp;
    
}",1.0,11111
Singly_linked_list_4,1291105,2110501,"void LinkedList::partition(int k) {
  Node *result = NULL;
  Node *pre = new Node(0);
  Node *in = new Node(0);
  Node *post = new Node(0);
  Node *node1 = in;
  Node *node2 = post;
  Node *cur = head;
  head = pre;
  while (cur!=NULL) 
  {
    if (cur->value < k) 
    {
        pre->next = cur;
        pre = cur;
    } 
    else if (cur->value == k) 
    {
        in->next = cur;
        in = cur;
    } 
    else 
    {
        post->next = cur;
        post = cur;
    }
    cur = cur->next;
  }
  if (head != pre) 
  {
    if (result == NULL) result = head->next;
  }
  if (node1 != in) 
  {
    if (result == NULL) result = node1->next;
    else 
    {
        pre->next = node1->next;
    }
    pre = in;
  }
  if (node2 != post) 
  {
    if (result == NULL)     result = node2->next;
    else 
    {
      pre->next = node2->next;
    }
    pre = post;
  }
  head = result;
  tail = pre;
}",1.0,11111
Singly_linked_list_5,1291105,2110501,"void reduceDuplicate(Node* root)
{
    while(root!=NULL&&root->getNext()!=NULL)
    {
        if(root->getData()==root->getNext()->getData()) 
        {
            if(root->getNext()->getNext()==NULL)
            {
                root->setNext(NULL);
            }
            else
            {
                root->setNext(root->getNext()->getNext());
            }
        }
        root=root->getNext();
    }
}",0.6,1010111100
Singly_linked_list_7,1291105,2110501,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *pNew=new Node(e);
    if(count==0)    
    {
        head=pNew;
        tail=pNew;
        count++;
    }
    else
    {
        tail->next=pNew;
        tail=pNew;
        count++;
    }
    
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    Node *pNew=new Node(e);
    if(count==0)
    {
        head=pNew;
        tail=pNew;
        count++;
    }
    else
    {
        if(index==count)
        {
            tail->next=pNew;
            tail=pNew;
            count++;
        }
        else if (index==0)
        {
            pNew->next=head;
            head=pNew;
            count++;
        }
        else
        {
            Node*pre=head;
            for(int i=0;i<index-1;i++)  pre=pre->next;
            pNew->next=pre->next;
            pre->next=pNew;
            count++;
        }
        
    }
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1291105,2110501,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
if(index>count) throw std::out_of_range("""");
else
{
Node*pNew=this->head;
for(int i=0;i<index;i++)
{
    pNew=pNew->next;
}
return pNew->data;
}
}


template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
if(index>count) throw std::out_of_range("""");
else   
{
Node*pNew=this->head;
for(int i=0;i<index;i++)
{
    pNew=pNew->next;
}
pNew->data=e;
}
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(count==0)  return true;
    return false;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node*pNew=this->head;
    int i=0;
    while(pNew!=NULL)
    {
        if(pNew->data==item)    return i;
        i++;
        pNew=pNew->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node*pNew=this->head;
    int i=0;
    while(pNew!=NULL)
    {
        if(pNew->data==item)    return true;
        i++;
        pNew=pNew->next;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1291105,2110501,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    int result;
    if (index < 0 || index > this->count) throw std::out_of_range("""");
    else
    {
        if (this->count == 1)
        {
            result = this->head->data;
            this->head = this->tail = NULL;
            this->count--;
            return result;
        }
        else
        {
            Node* cur = this->head;
            Node* tmp = this->head;
            if (index == 0)
            {
                result = this->head->data;
                this->head = this->head->next;
                delete tmp;
                this->count--;
                return result;
            }
            for(int i=0;i<index-1;i++)
            {
                cur=cur->next;
            }
            tmp=cur->next;
            if (tmp == this->tail)
            {
                result = tmp->data;
                this->tail = cur;
                cur->next = NULL;
                tmp->next = NULL;
                delete tmp;
                this->count--;
                return result;
            }
            else
            {
                result = tmp->data;
                cur->next = tmp->next;
                tmp->next = NULL;
                delete tmp;
                this->count--;
                return result;
            }
            return result;
        }
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(this->count == 1 && this->head->data == item)
    {
        delete this->head;
        this->head = this->tail = NULL;
        this->count--;
        return true;
    }
    else if(this->count == 1 && this->head->data != item) return false;
    else
    {
    Node* cur = NULL;
    Node* tmp = this->head;
    if(tmp->data == item)
    {
        this->count--;
        this->head = this->head->next;
        delete tmp;
        return true;
    }
    while(tmp)
    {
        if(tmp == this->tail && tmp->data == item)
        {
            this->tail = cur;
            cur->next = tmp->next;
            tmp->next = NULL;
            delete tmp;
            this->count--;
            return true;
        }
        else if (tmp->data == item)
        {
            cur->next = tmp->next;
            tmp->next = NULL;
            delete tmp;
            this->count--;
            return true;
        }
        else
        {
            cur = tmp;
            tmp = tmp->next;
        }
    }
    return false;
    }
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    if(this->count == 0);
    Node*cur=this->head;
    while(cur!=NULL)
    {
        this->head = this->head->next;
        delete cur;
        cur = this->head;
    }
    this->head = this->tail= NULL;
    this->count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1291105,2110501,"LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if(head==NULL)  return NULL;
    else
    {
        int count=0;
        LLNode*cur=head;
        while(cur!=NULL)
        {
            count++;
            cur=cur->next;
        }
        cur=head;
        for(int i=0;i<count/2-1;i++)
        {
            cur=cur->next;
        }
        if(count%2!=0)  cur=cur->next;
        LLNode*p=cur->next;
        cur->next=NULL;
        LLNode*head2=p;
        LLNode *pre = NULL, *next;
        cur=head2;
        while (cur) 
        { 
            next = cur->next; 
            cur->next = pre; 
            pre = cur; 
            cur = next; 
        } 
        head2 = pre;
        LLNode*cur1=head;
        LLNode*cur2=head2;
        while(cur1!=NULL)
        {
            if(cur2==NULL)  break;
            cur1->val+=cur2->val;
            cur1=cur1->next;
            cur2=cur2->next;
        }
        cur=head;pre = NULL; next=NULL;
        while (cur) 
        { 
            next = cur->next; 
            cur->next = pre; 
            pre = cur; 
            cur = next; 
        } 
        head = pre;
        return head;
    }
}",1.0,1111111111
Singly_linked_list_12,1291105,2110501,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode*cur = head;
    LLNode*pre = NULL; 
    LLNode*post = NULL;
    while(cur != NULL) 
    {
        post=cur->next;
        cur->next =pre;
        pre=cur;
        cur=post;
    }
    head = pre;
    return head;
}",1.0,1111111111
Singly_linked_list_13,1291105,2110501,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (head==NULL) return NULL;
    LLNode *cur=head;
    LLNode *temp = head;
    int count = 1;
    while (cur->next!=NULL)
    {
        cur=cur->next;
        count++;
    }
    head=cur;
    head->next = temp;
    k %= count;
    k = count - k;
    while (k--) 
    {
        cur = cur->next;
    }
    head=cur;
    temp = head->next;
    head->next = NULL;
    return temp;
}",1.0,1111111111
Singly_linked_list_1,1342013,2213250,"void createLL(LLNode*& head, int val) {
    if (head == NULL) head = new LLNode(val, nullptr);
    else {
        LLNode* prev = head;
        LLNode* curr = head;
        while (curr) {
            prev = curr;
            curr = curr->next;
        }
        prev->next = new LLNode(val, nullptr);
    }
}

LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    bool carry = 0 ;
    LLNode* head = nullptr;
    LLNode* prev;
    while(l0 || l1 || carry){
        int ans = 0 ;
        if(l0) {ans+=l0->val;l0 = l0->next;}
        if(l1) {ans +=l1->val;l1=l1->next;}
        if(carry) ans+=1;
        if(ans>9) {ans-=10 ; carry = 1 ;}
        else carry = 0 ;
        if(head==nullptr){head = new LLNode(ans,nullptr) ; prev = head ;}
        else{
           prev->next = new LLNode(ans,nullptr);
           prev = prev->next;
        }
    }
    return head;
}",0.4,111111111111111
Singly_linked_list_2,1342013,2213250,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_1,1344056,2211821,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode x;
    LLNode* me =&x;
    int carry=0;
    while (l0||l1||carry) {
        int sum = carry;
        if(l0){
            sum+=l0->val;
            l0=l0->next;
        }
        if (l1){
            sum+=l1->val;
            l1=l1->next;
        }
        carry =sum/10;
        me->next = new LLNode(sum%10);
        me=me->next;
    }
    return x.next;
}",1.0,111111111111111
Singly_linked_list_2,1344056,2211821,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1344056,2211821,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_10,1344056,2211821,"LLNode* foldLinkedList(LLNode* head) {
     if(head==nullptr) return head;
    LLNode* current = head;
    int len =1;
    while(current->next != nullptr) {
        current =current->next;
        len++;
    }
    LLNode* x=head;
    if (len%2 == 0){
        int n=len/2;
        while (len>=n){
            LLNode* y=head;
        for (int i=0;i<len;i++){
            y =y->next;
        }
        y->val = y->val+x->val;
        len--;
        LLNode* temp= x;
        x=x->next;
        delete temp;
        }
    } else {
         int n=(len+1)/2;
        while (len>=n){
            LLNode* y=head;
        for (int i=0;i<len;i++){
            y =y->next;
        }
        y->val = y->val+x->val;
        len--;
        LLNode* temp= x;
        x=x->next;
        delete temp;}
    }
    return x;
}",0.1,0
Singly_linked_list_11,1344056,2211821,"LLNode* replaceFirstGreater(LLNode* head) {
    if (!head) {
        return nullptr; // Handle the case of an empty list
    }

    LLNode* current = head;

    while (current) {
        LLNode* nextNode = current->next;
        bool foundGreater = false;

        while (nextNode) {
            if (nextNode->val > current->val) {
                current->val = nextNode->val;
                foundGreater = true;
                break;
            }
            nextNode = nextNode->next;
        }

        if (!foundGreater) {
            current->val = 0;
        }

        current = current->next;
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1344056,2211821,"LLNode* reverseLinkedList(LLNode* head) {
    if(head == nullptr) return head;
    LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* nextNode = nullptr;

    while (current != nullptr) {
        nextNode = current->next;
        current->next = prev;
        prev = current;
        current = nextNode;
    }
    return prev;
    
}",1.0,1111111111
Singly_linked_list_13,1344056,2211821,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || k==0) return head;
    int len =1;
    LLNode* current = head;
    while (current->next != nullptr) {
        current = current->next;
        len++;
    }
    k = k% len;
    if (k==0) return head;
    current-> next =head;
     for (int i = 0; i < len - k - 1; i++) {
        head = head->next;
    }
    LLNode* newHead = head->next;
    head->next = nullptr;
    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1344056,2211821,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
  if (linked_list == nullptr || low > high || high < 0) {
        return;
    }
    Node* current = this->head;
    Node* prev = nullptr;
    int currentPosition = 0;
    while (currentPosition < low  && current != nullptr) {
        prev = current;
        current = current->next;
        currentPosition++;
    }
    if (low - 1 < 0) {
        this->head = linked_list->head;
    }
    else {
        prev->next = linked_list->head;
    }
    while (currentPosition < high+1 && current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
        currentPosition++;
    }
    if (high >= this->size) {
        this->tail = linked_list->tail;
    }
    this->size = currentPosition;
    if (current != nullptr) {
        linked_list->tail->next = current;
    }
    else {
        linked_list->tail->next = nullptr;
        this->tail = linked_list->tail;
    }
    this->size += linked_list->size;
    linked_list->head = nullptr;
    linked_list->tail = nullptr;
    linked_list->size = 0;
}",1.0,11111
Singly_linked_list_1,1352191,2211878,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* dummy = new LLNode(0);
    LLNode* curr = dummy;
    int carry = 0;
    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;
        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        carry = sum / 10;
        curr->next = new LLNode(sum % 10);
        curr = curr->next;
    }
    return dummy->next;
}
",1.0,111111111111111
Singly_linked_list_4,1352191,2211878,"void LinkedList::partition(int k) {
    Node* smallerHead = NULL;
    Node* smallerTail = NULL;
    Node* equalHead = NULL;
    Node* equalTail = NULL;
    Node* greaterHead = NULL;
    Node* greaterTail = NULL;

    Node* curr = this->head;
    while (curr != NULL) {
        if (curr->value < k) {
            if (smallerHead == NULL) {
                smallerHead = curr;
                smallerTail = curr;
            } else {
                smallerTail->next = curr;
                smallerTail = curr;
            }
        } else if (curr->value == k) {
            if (equalHead == NULL) {
                equalHead = curr;
                equalTail = curr;
            } else {
                equalTail->next = curr;
                equalTail = curr;
            }
        } else {
            if (greaterHead == NULL) {
                greaterHead = curr;
                greaterTail = curr;
            } else {
                greaterTail->next = curr;
                greaterTail = curr;
            }
        }
        curr = curr->next;
    }

    if (smallerHead == NULL) {
        this->head = equalHead;
        equalTail->next = greaterHead;
    } else {
        this->head = smallerHead;
        smallerTail->next = equalHead;

        if (equalHead == NULL) {
            smallerTail->next = greaterHead;
        } else {
            equalTail->next = greaterHead;
        }
    }

    if (greaterHead == NULL) {
        this->tail = equalTail != NULL ? equalTail : smallerTail;
    } else {
        this->tail = greaterTail;
    }

    if (this->tail != NULL) {
        this->tail->next = NULL;
    }
}",1.0,11111
Singly_linked_list_7,1352191,2211878,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e, nullptr);
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    count++;
    
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
            throw std::out_of_range(""Index out of range"");
        }
        if (index == count) {
            add(e);
            return;
        }
        Node* newNode = new Node(e, nullptr);
        if (index == 0) {
            newNode->next = head;
            head = newNode;
        } else {
            Node* current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current->next;
            }
            newNode->next = current->next;
            current->next = newNode;
        }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1352191,2211878,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
     if (index < 0 || index >= count) {
            throw std::out_of_range(""Index out of range"");
        }
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
            throw std::out_of_range(""Index out of range"");
        }
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
        for (int i = 0; i < count; i++) {
            if (current->data == item) {
                return i;
            }
            current = current->next;
        }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1352191,2211878,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count)
        throw out_of_range(""Index out of range."");

    Node *current = head;
    Node *previous = nullptr;
    T removedValue;

    if (index == 0)
    {
        removedValue = head->data;
        head = head->next;
        delete current;
    }
    else
    {
        for (int i = 0; i < index; i++)
        {
            previous = current;
            current = current->next;
        }

        removedValue = current->data;
        previous->next = current->next;
        if (current == tail)
            tail = previous;
        delete current;
    }

    count--;
    return removedValue;

}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *current = head;
    Node *previous = nullptr;

    while (current != nullptr)
    {
        if (current->data == item)
        {
            if (previous == nullptr) // first element in the list
            {
                head = current->next;
                if (current == tail)
                    tail = nullptr;
            }
            else
            {
                previous->next = current->next;
                if (current == tail)
                    tail = previous;
            }

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;

}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node *current = head;
    while (current != nullptr)
    {
        Node *next = current->next;
        delete current;
        current = next;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1352191,2211878,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* curr = head;
    LLNode* next = nullptr;
    
    while (curr != nullptr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    
    return prev;
}

LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    
    LLNode* slow = head;
    LLNode* fast = head;
    LLNode* prev = nullptr;
    
    while (fast != nullptr && fast->next != nullptr) {
        prev = slow;
        slow = slow->next;
        fast = fast->next->next;
    }
    
    prev->next = nullptr; // Split the linked list into two halves
    
    LLNode* reversedSecondHalf = reverseLinkedList(slow);
    LLNode* mergedList = head;
    
    while (reversedSecondHalf != nullptr) {
        LLNode* temp = mergedList->next;
        mergedList->next = reversedSecondHalf;
        reversedSecondHalf = reversedSecondHalf->next;
        mergedList->next->next = temp;
        mergedList = temp;
    }
    
    return head;
}
",0.1,0
Singly_linked_list_11,1352191,2211878,"LLNode* replaceFirstGreater(LLNode* head) {
    if (head == nullptr) {
        return nullptr;
    }
    
    stack<LLNode*> stack;
    stack.push(head);
    
    LLNode* current = head->next;
    
    while (current != nullptr) {
        while (!stack.empty() && current->val > stack.top()->val) {
            stack.top()->val = current->val;
            stack.pop();
        }
        
        stack.push(current);
        current = current->next;
    }
    
    while (!stack.empty()) {
        stack.top()->val = 0;
        stack.pop();
    }
    
    return head;
}",1.0,1111111111
Singly_linked_list_12,1352191,2211878,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* curr = head;
    LLNode* next = nullptr;

    while (curr != nullptr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}
",1.0,1111111111
Singly_linked_list_13,1352191,2211878,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || k <= 0) {
        return head;
    }
    
    LLNode* current = head;
    int count = 1;
    
    while (current->next != nullptr) {
        current = current->next;
        count++;
    }
    
    current->next = head;
    
    k = k % count;
    
    for (int i = 0; i < count - k; i++) {
        current = current->next;
    }
    
    head = current->next;
    current->next = nullptr;  // Break the circular link
    
    return head;
}
",1.0,1111111111
Singly_linked_list_14,1352191,2211878,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (low < 0) {
        low = 0;
    }
    if (high >= size) {
        high = size - 1;
    }
    Node* current = head;
    Node* prev = nullptr;
    int index = 0;
    
    while (current != nullptr && index < low) {
        prev = current;
        current = current->next;
        index++;
    }
    
    while (current != nullptr && index <= high) {
        Node* next = current->next;
        delete current;
        current = next;
        index++;
    }
    
    if (prev != nullptr) {
        prev->next = current;
    } else {
        head = current;
    }
    if (low - 1 < 0) {
        Node* linked_list_tail = linked_list->tail;
        
        if (linked_list_tail != nullptr) {
            linked_list_tail->next = head;
            head = linked_list->head;
        }
    } else {
        Node* insert_after = head;
        index = 0;
        
        while (insert_after != nullptr && index < low - 1) {
            insert_after = insert_after->next;
            index++;
        }
        
        // Insert nodes from linked_list after insert_after
        Node* linked_list_tail = linked_list->tail;
        
        if (linked_list_tail != nullptr) {
            linked_list_tail->next = insert_after->next;
            insert_after->next = linked_list->head;
        }
    }
}
",0.4,110
Singly_linked_list_1,1354635,2211821,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode x;
    LLNode* me =&x;
    int carry=0;
    while (l0||l1||carry) {
        int sum = carry;
        if(l0){
            sum+=l0->val;
            l0=l0->next;
        }
        if (l1){
            sum+=l1->val;
            l1=l1->next;
        }
        carry =sum/10;
        me->next = new LLNode(sum%10);
        me=me->next;
    }
    return x.next;
}",1.0,111111111111111
Singly_linked_list_2,1354635,2211821,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
     Term term(coeff, exp);
    insertTerm(term);
}",0.2,00010
Singly_linked_list_4,1354635,2211821,"
void LinkedList::partition(int k) {  
    Node *S_Head, *S_Tail, *E_Head, *E_Tail, *B_Head, *B_Tail; 
    S_Head = S_Tail = nullptr;   
    E_Head = E_Tail = nullptr;  
    B_Head = B_Tail = nullptr;   
    Node *CUR = head; 
    int newSize = 0; 
    while(CUR){    
        if(CUR->value < k) {   
            if(!S_Head){     
                S_Head = S_Tail = new Node(CUR);   
                }                        else{     
                    S_Tail->next = new Node(CUR);   
                    S_Tail = S_Tail->next;         
                    }          
                    S_Tail->next = nullptr;     
                    }  else{     
                        if(CUR->value == k){    
                            if(!E_Head){         
                                E_Head = E_Tail = new Node(CUR);    
                                }
                                else{
                                    E_Tail->next = new Node(CUR); 
                                    E_Tail = E_Tail->next;
                                    }
                                    E_Tail->next = nullptr;
                                    }
                                    else{
                                        if(!B_Head){
                                            B_Head = B_Tail = new Node(CUR);
                                            } 
                                            else{
                                                B_Tail->next = new Node(CUR);
                                                B_Tail = B_Tail->next;
                                                }                
                                                B_Tail->next = nullptr;
                                                }        
                        
                    }
                    newSize++; 
                    CUR = CUR->next;
                    }   
                    if(S_Head){
                        head = S_Head; 
                        if(E_Head){    
                            S_Tail->next = E_Head;   
                            E_Tail->next = B_Head;   
                            if(B_Tail) tail = B_Tail;   
                            else tail = E_Tail;     
                            }        else{        
                                S_Tail->next = B_Head;   
                                if(B_Tail) tail = B_Tail;  
                                else tail = S_Tail;     
                                }           
                                }    else{   
                                    if(E_Head){ 
                                        E_Tail->next = B_Head; 
                                        head = E_Head;   
                                        if(B_Tail) tail = B_Tail;  
                                        else tail = E_Tail;   
                                        }        else{     
                                            tail = B_Tail;    
                                            }    }}",1.0,11111
Singly_linked_list_5,1354635,2211821,"void reduceDuplicate(Node* root)
{
     if (root == nullptr || root->getNext() == nullptr) {
        return;
    }

    Node* current = root;

    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicateNode = current->getNext();
            current->setNext(duplicateNode->getNext());
            delete duplicateNode;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1354635,2211821,"int Train::allocate(int containerSize) {
    int min = containerSize;
    TrainCar* current = head->next;
    int carIndex = 1;
    int mincar = -1;
    TrainCar* cur = nullptr;

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize) {
            if (mincar == -1) {
                min = current->remainingSpace;
                cur = current;
                mincar = carIndex;
            }
            else if(min >current->remainingSpace) {
                min = current->remainingSpace;
                cur = current;
                mincar = carIndex;
            }
        }
        current = current->next;
        carIndex++;
    }

    if (mincar != -1) {
        cur->remainingSpace -= containerSize;
    }

    return mincar;
}

int Train::totalRemainingSpace() {
 int totalSpace = 0;
    TrainCar* current = head->next;

    while (current != nullptr) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }

    return totalSpace;
}",1.0,11111
Singly_linked_list_7,1354635,2211821,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newnode = new Node(e,nullptr);
    if(count == 0) {
        head =tail = newnode;
    } else {
        tail->next =newnode;
        tail=newnode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        throw std::out_of_range(""Index out of range"");
    }

    if (index == 0) {
        Node* newNode = new Node(e, head);
        head = newNode;
        if (count == 0) {
            tail = newNode;
        }
        count++;
    } else
    if (index == count)  add(e);
     else {
        Node* prev = nullptr;
        Node* current = head;
        for (int i = 0; i < index; i++) {
            prev = current;
            current = current->next;
        }
        Node* newNode = new Node(e, current);
        prev->next = newNode;
        count++;
    }
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1354635,2211821,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count || empty()) {
        throw std::out_of_range(""Index out of range"");
    }
    if (index == 0) return head->data;
    Node* temp = head;
    for(int i =0;i<index;i++){
        temp =temp->next;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
     if (index < 0 || index >= count || empty()) {
        throw std::out_of_range(""Index out of range"");
    }
    if (index == 0) head->data =e;
    Node* temp = head;
    for(int i =0;i<index;i++){
        temp =temp->next;
    }
    temp->data =e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    int x = 0; // Initialize x to 0
    while (current) {
        if (current->data == item) {
            return x;
        }
        current = current->next;
        x++; // Increment x for each iteration
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
      return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1354635,2211821,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count || empty()) {
        throw std::out_of_range(""Index out of bounds"");
    }

    Node* current = head;
    Node* previous = nullptr;
    
    for (int i = 0; i < index; ++i) {
        previous = current;
        current = current->next;
    }

    T removedValue = current->data;

    if (previous) {
        previous->next = current->next;
    } else {
        head = current->next;
    }

    if (current == tail) {
        tail = previous;
    }

    delete current;
    --count;
    return removedValue;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    Node* previous = nullptr;

    while (current) {
        if (current->data == item) {
            if (previous) {
                previous->next = current->next;
            } else {
                head = current->next;
            }

            if (current == tail) {
                tail = previous;
            }

            delete current;
            --count;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;
    
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    count = 0;
    tail = nullptr;
}

",1.0,1111111111
Singly_linked_list_10,1354635,2211821,"LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode *cur = head;
    
    int n = 0; // get_length of List
    
    while(cur){
        n++;
        cur = cur->next;
    }
    
    if(n == 0) return nullptr;
    
    cur = head;
    
    LLNode *HEAD = nullptr, *newNode = nullptr;
    
    for(int i = 0; i <= n/2; i++){
        
        
        LLNode *TMP = cur;
        for(int j = i; j < (n - i - 1); j++){
            TMP = TMP->next;
        }
        int Sum = 0;
        if(cur == TMP){
            if(n % 2 == 1) Sum+= cur->val;  
            if(n % 2 == 0) break;
        }
        else{
            Sum+= cur->val + TMP->val;
        }
        newNode = new LLNode(Sum, HEAD);
        HEAD = newNode;
        cur = cur->next;
    }
    
    return HEAD;
}",1.0,1111111111
Singly_linked_list_11,1354635,2211821,"LLNode* replaceFirstGreater(LLNode* head) {
    if (!head) {
        return nullptr; // Handle the case of an empty list
    }

    LLNode* current = head;

    while (current) {
        LLNode* nextNode = current->next;
        bool foundGreater = false;

        while (nextNode) {
            if (nextNode->val > current->val) {
                current->val = nextNode->val;
                foundGreater = true;
                break;
            }
            nextNode = nextNode->next;
        }

        if (!foundGreater) {
            current->val = 0;
        }

        current = current->next;
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1354635,2211821,"LLNode* reverseLinkedList(LLNode* head) {
    if(head == nullptr) return head;
    LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* nextNode = nullptr;

    while (current != nullptr) {
        nextNode = current->next;
        current->next = prev;
        prev = current;
        current = nextNode;
    }
    return prev;
    
}",1.0,1111111111
Singly_linked_list_13,1354635,2211821,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || k==0) return head;
    int len =1;
    LLNode* current = head;
    while (current->next != nullptr) {
        current = current->next;
        len++;
    }
    k = k% len;
    if (k==0) return head;
    current-> next =head;
     for (int i = 0; i < len - k - 1; i++) {
        head = head->next;
    }
    LLNode* newHead = head->next;
    head->next = nullptr;
    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1354635,2211821,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
  if (linked_list == nullptr || low > high || high < 0) {
        return;
    }
    Node* current = this->head;
    Node* prev = nullptr;
    int currentPosition = 0;
    while (currentPosition < low  && current != nullptr) {
        prev = current;
        current = current->next;
        currentPosition++;
    }
    if (low - 1 < 0) {
        this->head = linked_list->head;
    }
    else {
        prev->next = linked_list->head;
    }
    while (currentPosition < high+1 && current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
        currentPosition++;
    }
    if (high >= this->size) {
        this->tail = linked_list->tail;
    }
    this->size = currentPosition;
    if (current != nullptr) {
        linked_list->tail->next = current;
    }
    else {
        linked_list->tail->next = nullptr;
        this->tail = linked_list->tail;
    }
    this->size += linked_list->size;
    linked_list->head = nullptr;
    linked_list->tail = nullptr;
    linked_list->size = 0;
}",1.0,11111
Singly_linked_list_1,1357903, ,"#include <cmath>

LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode *temp = l0;
    long long a = 0;
    int i = 0;
    while(temp != NULL){
        long long r = temp->val;
        a += r * pow(10, i);
        ++i;
        temp = temp->next;
    }
    long long b = 0;
    i = 0;
    temp = l1;
    while(temp != NULL){
        long long r = temp->val;
        b += r * pow(10, i);
        ++i;
        temp = temp->next;
    }
    long long sum = a + b;
    LLNode *head = new LLNode();
    int r = sum % 10;
    sum /= 10;
    if(r == 0){
        head = NULL;
        return head;
    }
    head->val = r;
    head->next = NULL;
    temp = head;
    while(sum != 0){
        if(temp->next == NULL){
            LLNode *newnode = new LLNode();
            temp->next = newnode;
            temp = temp->next;
        }
        int r = sum % 10;
        sum /= 10;
        temp->val = r;
        temp->next = NULL;
    }
    return head;
}",0.4,111111000000000
Singly_linked_list_1,1359742,2210055,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
 LLNode *res = new LLNode();
  LLNode *cur = res;
  int carry = 0;
  while (l0 || l1 || carry)
  {
    int sum = carry;
    if (l0)
    {
      sum += l0->val;
      l0 = l0->next;
    }
    if (l1)
    {
      sum += l1->val;
      l1 = l1->next;
    }
    carry = sum / 10;
    sum %= 10;
    cur->next = new LLNode(sum);
    cur = cur->next;
  }
  return res->next;
}",1.0,111111111111111
Singly_linked_list_1,1359784,2211170,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
        LLNode* dummyHead = new LLNode(0);
        LLNode* curr = dummyHead;
        int carry = 0;
        while (l0 != NULL || l1 != NULL || carry != 0) {
            int x = l0 ? l0->val : 0;
            int y = l1 ? l1->val : 0;
            int sum = carry + x + y;
            carry = sum / 10;
            curr->next = new LLNode(sum % 10);
            curr = curr->next;
            l0 = l0 ? l0->next : nullptr;
            l1 = l1 ? l1->next : nullptr;
        }
        return dummyHead->next;

}",0.95,111111111111111
Singly_linked_list_2,1359784,2211170,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_1,1361315,2213250,"

LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    bool carry = 0 ;
    LLNode* head = nullptr;
    LLNode* prev;
    while(l0 || l1 || carry){
        int ans = 0 ;
        if(l0) {ans+=l0->val;l0 = l0->next;}
        if(l1) {ans +=l1->val;l1=l1->next;}
        if(carry) ans+=1;
        if(ans>9) {ans-=10 ; carry = 1 ;}
        else carry = 0 ;
        if(head==nullptr){head = new LLNode(ans,nullptr) ; prev = head ;}
        else{
           prev->next = new LLNode(ans,nullptr);
           prev = prev->next;
        }
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1361315,2213250,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_3,1361315,2213250,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(begin){
        if(pList != NULL){
            current = pList -> head;
            this -> index =0;
        }
        else{
            current = NULL;
            index = -1;
        }
    }
    else{
        current = NULL;
        index = (pList == NULL)? 0 : pList-> size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this-> current = iterator.current;
    this-> pList = iterator.pList;
    this-> index = iterator.index;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        pList-> removeAt(index);
        index--;
    }
    
    if(index == -1){
        current = NULL;
    }
    else{
        current = pList->head;
        for (int i =0; i < index; i++){
            current = current->next;
        }
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if( current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    current-> data = e;
    
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    return current -> data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return !(this-> current == iterator.current && this-> index == iterator.index) ;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL && index == -1){
        current = pList-> head;
        index++;
    }
    else if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        current = current -> next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,11111
Singly_linked_list_1,1361352,2212372,"
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
 LLNode *l;
 int t=0;
 int a[100000];
 int i=0;
 while(l0||l1){
 if(!l0){a[i]=(t+l1->val)%10;
 t=(t+l1->val)/10;
l1=l1->next;
 }
 else  if(!l1){a[i]=(t+l0->val)%10;
 t=(t+l0->val)/10;
 l0=l0->next;
 }else{a[i]=(t+l0->val+l1->val)%10;
 t=(t+l0->val+l1->val)/10;
 l0=l0->next;
 l1=l1->next;
 }
 i++;
 }
 if(t==1){a[i]=1;
 i++;
 }
 int arr[i];
 for(int j=0;j<i;j++){
     arr[j]=a[j];
 }
l=LLNode::createWithIterators(arr, arr + sizeof(arr) / sizeof(int));
  return l;

}",0.05,111111111111111
Singly_linked_list_2,1361352,2212372,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_1,1363648,2213298,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode pNew;
    LLNode* tail = &pNew;
    int carry = 0;
    while (l0 || l1 || carry) {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        tail->next = new LLNode(sum % 10);
        tail = tail->next;
        carry = sum / 10;
        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }
    return pNew.next;
}",1.0,111111111111111
Singly_linked_list_2,1363648,2213298,"void Polynomial::insertTerm(const Term& term) {
    SLinkedList<Term>::Iterator cur = terms->begin();
    if (!term.coeff) return;
    while (cur != terms->end() && (*cur).exp != term.exp){
        cur++;
    }
    if (cur != terms->end()){
        (*cur).coeff += term.coeff;
        if (!(*cur).coeff){
            int index = terms->indexOf(*cur);
            terms->removeAt(index);
        }
    }
    else {
        cur = terms->begin();
        while (cur != terms->end() && (*cur).exp > term.exp){
            cur++;
        }
        int index = cur != terms->end() ? terms->indexOf(*cur) : terms->size();
        terms->add(index, term);
    }
    
}


void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    insertTerm(Term(coeff,exp));
}",1.0,11111
Singly_linked_list_4,1363648,2213298,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_7,1363648,2213298,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *pNew = new Node(e, NULL);
    if (!head) head = tail = pNew;
    else {
        tail->next = pNew;
        tail = pNew;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index > count || index < 0) throw std::out_of_range(""Out of range""); 
        if (index == count) { add(e); return; }
        Node *pNew = new Node(e);
        if (!index) {
            pNew->next = head;
            head = pNew;
            count++;
            return;
        }
        Node *p0 = this->head;
        for (; index > 1; index--) p0 = p0->next;
        pNew->next = p0->next;
        p0->next = pNew;
        count++;
        return;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    if (head) return count;
    return 0;
}
",1.0,1111111111
Singly_linked_list_8,1363648,2213298,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    return pNew->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    pNew->data = e;
    return;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !(head);
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for (Node *p0 = head; p0; p0 = p0->next)
    {
        if (p0->data == item) return index;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for (Node *p0 = head; p0; p0 = p0->next)
    if (p0->data == item) return 1;
    return 0;
}",1.0,1111111111
Singly_linked_list_9,1363648,2213298,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index >= this->count || index < 0) throw std::out_of_range(""Out of range"");
        if (count == 1) {                 
            Node *pNew = head;
            head = tail = NULL;
            count = 0;
            T temp = pNew->data;
            delete pNew;
            return temp;
        }
        if (!index) {
            Node *pNew = head;
            head = pNew->next;
            T temp = pNew->data;
            delete pNew;
            count--;
            return temp;
        }
        Node *pNew = head;
        for (int i = index; i > 1; i--) pNew = pNew->next;
        Node *pDel = pNew->next;
        T temp = pDel->data;
        pNew->next = pDel->next;
        if (index == count - 1) tail = pNew;
        delete pDel;
        count--;
        return temp;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if (head->data == item) {
            Node *pNew = head;
            head = pNew->next;
            pNew->next = NULL;
            delete pNew;
            count--;
            return true;
        }
    for(Node *p0 = head, *p1 = p0->next; p1; p1 = p1->next, p0 = p0->next) {
        if (p1->data == item) {
            if (p1->next) {
                p0->next = p1->next;
                p1->next = NULL;
                delete p1;
                count--;
                return true;
            }
            else {
                p0->next = p1->next = NULL;
                tail = p0;
                delete p1;
                count--;
                return true;
            }
        }
    }
    return false;
    
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    for (Node *p0 = head; p0;) {
            Node *p1 = p0;
            p0 = p0->next;
            p1->next = NULL;
            delete p1;
        } 
}

",0.9,1111111110
Singly_linked_list_10,1363648,2213298,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* prev = nullptr;
    while (head) {
        LLNode* next = head->next;
        head->next = prev;                              
        prev = head;
        head = next;
    }
    return prev;
}

LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if (head == nullptr || head->next == nullptr) return head;
    LLNode *last = head;
    LLNode *mid = head;
    while(last && last->next) {
        last =  last->next->next;
        mid = mid->next;
    }
    LLNode *firstLinkedlist = head;
    LLNode *secondLinkedlist = reverseLinkedList(mid);
    while(secondLinkedlist) {
        if (firstLinkedlist == secondLinkedlist) break;
        firstLinkedlist->val += secondLinkedlist->val;
        if (!firstLinkedlist || firstLinkedlist->next == secondLinkedlist){
            firstLinkedlist->next = secondLinkedlist->next;
            break;
        }
        firstLinkedlist = firstLinkedlist->next;
        secondLinkedlist = secondLinkedlist->next;
    }
    head = reverseLinkedList(head);
    return head;
}",1.0,1111111111
Singly_linked_list_11,1363648,2213298,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    LLNode *pNew = head;
    for (;pNew;pNew = pNew->next) {
        LLNode *pFirst = pNew->next;
        for (;pFirst; pFirst = pFirst->next) {
            if (pFirst->val > pNew->val) { pNew->val = pFirst->val;break; }
        }
        if (!pFirst) pNew->val = 0;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1363648,2213298,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* prev = nullptr;
    while (head) {
        LLNode* next = head->next;
        head->next = prev;
        prev = head;
        head = next;
    }
    return prev;
}",1.0,1111111111
Singly_linked_list_13,1363648,2213298,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (!head || !head->next || k == 0) return head;
    for (int i = 0; i < k; i++) {
        LLNode *pTail = head;
        while(pTail->next->next) pTail = pTail->next;
        LLNode* pDel = pTail->next;
        pDel->next = head;
        head = pDel;
        pTail->next = NULL;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_1,1367465,2212935,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
     
}",0.2,
Singly_linked_list_2,1367465,2212935,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1367465,2212935,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1367465,2212935,"void reduceDuplicate(Node* root)
{
}",0.2,0000101000
Singly_linked_list_1,1368188,2213298,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode pNew;
    LLNode* tail = &pNew;
    int carry = 0;
    while (l0 || l1 || carry) {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        tail->next = new LLNode(sum % 10);
        tail = tail->next;
        carry = sum / 10;
        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }
    return pNew.next;
}",1.0,111111111111111
Singly_linked_list_2,1368188,2213298,"void Polynomial::insertTerm(const Term& term) {
    SLinkedList<Term>::Iterator cur = terms->begin();
    if (!term.coeff) return;
    while (cur != terms->end() && (*cur).exp != term.exp){
        cur++;
    }
    if (cur != terms->end()){
        (*cur).coeff += term.coeff;
        if (!(*cur).coeff){
            int index = terms->indexOf(*cur);
            terms->removeAt(index);
        }
    }
    else {
        cur = terms->begin();
        while (cur != terms->end() && (*cur).exp > term.exp){
            cur++;
        }
        int index = cur != terms->end() ? terms->indexOf(*cur) : terms->size();
        terms->add(index, term);
    }
    
}


void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    insertTerm(Term(coeff,exp));
}",1.0,11111
Singly_linked_list_3,1368188,2213298,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin && pList != NULL) {
        this->current = pList->head;
        this->index = 0;
    } else {
        this->current = NULL;
        this->index = (pList != NULL) ? pList->size() : 0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == NULL || pList == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    if (index == 0) {
        Node* toDelete = pList->head;
        pList->head = pList->head->next;
        delete toDelete;
        current = pList->head;
    } else {
        Node* prevNode = pList->head;
        for (int i = 0; i < index - 1; i++) {
            prevNode = prevNode->next;
        }
        Node* toDelete = prevNode->next;
        prevNode->next = toDelete->next;
        delete toDelete;
        current = prevNode;
    }
    pList->count--;
    return;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    current->data = e;
    return;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return current != iterator.current || index != iterator.index || pList != iterator.pList;
}

// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL || pList == NULL || index >= pList->size()) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    current = current->next;
    index++;
    return *this;
}

// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    Iterator iterator(*this);
    ++*this;
    return iterator;
}
",0.8,11110
Singly_linked_list_4,1368188,2213298,"void LinkedList::partition(int k) {
    Node* groupI = NULL;
    Node* groupII = NULL;
    Node* groupIII = NULL;
    Node* lastGroupI = NULL;
    Node* lastGroupII = NULL;
    Node* lastGroupIII = NULL;

    Node* current = head;
    while (current != NULL) {
        if (current->value < k) {
            if (groupI == NULL) {
                groupI = current;
                lastGroupI = current;
            } else {
                lastGroupI->next = current;
                lastGroupI = current;
            }
        } else if (current->value == k) {
            if (groupII == NULL) {
                groupII = current;
                lastGroupII = current;
            } else {
                lastGroupII->next = current;
                lastGroupII = current;
            }
        } else {
            if (groupIII == NULL) {
                groupIII = current;
                lastGroupIII = current;
            } else {
                lastGroupIII->next = current;
                lastGroupIII = current;
            }
        }
        current = current->next;
    }

    if (lastGroupI != NULL) {
        head = groupI;
        tail = lastGroupI;
        if (groupII != NULL) {
            tail->next = groupII;
            tail = lastGroupII;
        }
        if (groupIII != NULL) {
            tail->next = groupIII;
            tail = lastGroupIII;
        }
    } else if (lastGroupII != NULL) {
        head = groupII;
        tail = lastGroupII;
        if (groupIII != NULL) {
            tail->next = groupIII;
            tail = lastGroupIII;
        }
    } else if (lastGroupIII != NULL) {
        head = groupIII;
        tail = lastGroupIII;
    }

    if (tail != NULL)
        tail->next = NULL;

}",1.0,11111
Singly_linked_list_5,1368188,2213298,"void reduceDuplicate(Node* root)
{
    if (root == nullptr || root->getNext() == nullptr)
    {
        return;
    }

    Node* current = root;
    while (current->getNext() != nullptr)
    {
        if (current->getData() == current->getNext()->getData())
        {
            Node* nextNext = current->getNext()->getNext();
            delete current->getNext();
            current->setNext(nextNext);
        }
        else
        {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1368188,2213298,"int Train::allocate(int containerSize) {
    TrainCar *pTemp = head;
    int vitri = 0;
    int min = 99999;
    for (int i = 0; i < size; i++) {
        if (pTemp->remainingSpace >= containerSize) {
            if ( pTemp->remainingSpace < min ) {
                min = pTemp->remainingSpace;
                vitri = i;
            } 
        }
        pTemp = pTemp->next;
    }
    if (min == 99999) return -1;
    pTemp = head;
    for (int i = 0; i < vitri; i++) pTemp = pTemp->next;
    pTemp->remainingSpace -= containerSize;
    return vitri;
}

int Train::totalRemainingSpace() {
    TrainCar *pTemp = head;
    int sum = 0;
    for (; pTemp; pTemp = pTemp->next) sum += pTemp->remainingSpace;
    return sum;
}",1.0,11111
Singly_linked_list_7,1368188,2213298,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *pNew = new Node(e, NULL);
    if (!head) head = tail = pNew;
    else {
        tail->next = pNew;
        tail = pNew;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index > count || index < 0) throw std::out_of_range(""Out of range""); 
        if (index == count) { add(e); return; }
        Node *pNew = new Node(e);
        if (!index) {
            pNew->next = head;
            head = pNew;
            count++;
            return;
        }
        Node *p0 = this->head;
        for (; index > 1; index--) p0 = p0->next;
        pNew->next = p0->next;
        p0->next = pNew;
        count++;
        return;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    if (head) return count;
    return 0;
}
",1.0,1111111111
Singly_linked_list_8,1368188,2213298,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    return pNew->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    pNew->data = e;
    return;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !(head);
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for (Node *p0 = head; p0; p0 = p0->next)
    {
        if (p0->data == item) return index;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for (Node *p0 = head; p0; p0 = p0->next)
    if (p0->data == item) return 1;
    return 0;
}",1.0,1111111111
Singly_linked_list_9,1368188,2213298,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index >= this->count || index < 0) throw std::out_of_range(""Out of range"");
        if (count == 1) {                 
            Node *pNew = head;
            head = tail = NULL;
            count = 0;
            T temp = pNew->data;
            delete pNew;
            return temp;
        }
        if (!index) {
            Node *pNew = head;
            head = pNew->next;
            T temp = pNew->data;
            delete pNew;
            count--;
            return temp;
        }
        Node *pNew = head;
        for (int i = index; i > 1; i--) pNew = pNew->next;
        Node *pDel = pNew->next;
        T temp = pDel->data;
        pNew->next = pDel->next;
        if (index == count - 1) tail = pNew;
        delete pDel;
        count--;
        return temp;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if (head->data == item) {
            Node *pNew = head;
            head = pNew->next;
            pNew->next = NULL;
            delete pNew;
            count--;
            return true;
        }
    for(Node *p0 = head, *p1 = p0->next; p1; p1 = p1->next, p0 = p0->next) {
        if (p1->data == item) {
            if (p1->next) {
                p0->next = p1->next;
                p1->next = NULL;
                delete p1;
                count--;
                return true;
            }
            else {
                p0->next = p1->next = NULL;
                tail = p0;
                delete p1;
                count--;
                return true;
            }
        }
    }
    return false;
    
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    for (Node *p0 = head; p0;) {
            Node *p1 = p0;
            p0 = p0->next;
            p1->next = NULL;
            delete p1;
        } 
    tail = NULL;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1368188,2213298,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* prev = nullptr;
    while (head) {
        LLNode* next = head->next;
        head->next = prev;                              
        prev = head;
        head = next;
    }
    return prev;
}

LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if (head == nullptr || head->next == nullptr) return head;
    LLNode *last = head;
    LLNode *mid = head;
    while(last && last->next) {
        last =  last->next->next;
        mid = mid->next;
    }
    LLNode *firstLinkedlist = head;
    LLNode *secondLinkedlist = reverseLinkedList(mid);
    while(secondLinkedlist) {
        if (firstLinkedlist == secondLinkedlist) break;
        firstLinkedlist->val += secondLinkedlist->val;
        if (!firstLinkedlist || firstLinkedlist->next == secondLinkedlist){
            firstLinkedlist->next = secondLinkedlist->next;
            break;
        }
        firstLinkedlist = firstLinkedlist->next;
        secondLinkedlist = secondLinkedlist->next;
    }
    head = reverseLinkedList(head);
    return head;
}",1.0,1111111111
Singly_linked_list_11,1368188,2213298,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    LLNode *pNew = head;
    for (;pNew;pNew = pNew->next) {
        LLNode *pFirst = pNew->next;
        for (;pFirst; pFirst = pFirst->next) {
            if (pFirst->val > pNew->val) { pNew->val = pFirst->val;break; }
        }
        if (!pFirst) pNew->val = 0;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1368188,2213298,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* prev = nullptr;
    while (head) {
        LLNode* next = head->next;
        head->next = prev;
        prev = head;
        head = next;
    }
    return prev;
}",1.0,1111111111
Singly_linked_list_13,1368188,2213298,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (!head || !head->next || k == 0) return head;
    for (int i = 0; i < k; i++) {
        LLNode *pTail = head;
        while(pTail->next->next) pTail = pTail->next;
        LLNode* pDel = pTail->next;
        pDel->next = head;
        head = pDel;
        pTail->next = NULL;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_14,1368188,2213298,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    Node* prevLow = NULL;
    Node* nodeLow = head;
    if (low < 0) low = 0;
    for (int i = 0; i < low && nodeLow != NULL; i++) {
        prevLow = nodeLow;
        nodeLow = nodeLow->next;
    }

    Node* nodeHigh = nodeLow;
    Node* nextHigh = NULL;
    for (int i = low; i <= high && nodeHigh != NULL; i++) {
        nextHigh = nodeHigh->next;
        delete nodeHigh;
        nodeHigh = nextHigh;
    }

    if (prevLow != NULL) {
        prevLow->next = linked_list->head;
    } else {
        head = linked_list->head;
    }

    if (linked_list->tail != NULL) {
        linked_list->tail->next = nextHigh;
    }

    if (nextHigh == NULL) {
        tail = linked_list->tail;
    }

    size -= high - low + 1;
    size += linked_list->size;

    linked_list->head = NULL;
    linked_list->tail = NULL;
}
",1.0,11111
Singly_linked_list_1,1368454,2110501,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    if (l0 == NULL && l1 == NULL)           return NULL;
    else if (l0 == NULL && l1 != NULL)      return l1;
    else if (l0 != NULL && l1 == NULL)      return l0;
    LLNode* head = new LLNode(-1,NULL);
    LLNode* tail = head;
    int S;
    int carry = 0;
    while (true)
    {
        S= l0->val + l1->val + carry;
        if (S >= 10)
        {
            S %= 10;
            carry = 1;
        }
        else carry=0;
        LLNode* pNew = new LLNode(S,NULL);
        if (head->val == -1)    head = tail=pNew;
        else
        {
            tail->next = pNew;
            tail = pNew;
        }
        if(l0->next == NULL && l1->next == NULL)
        {
            if (carry == 1)
            {
                LLNode*pNew = new LLNode(1,NULL);
                tail->next = pNew;
                tail = pNew;
            }
            break;
        }
        
        if (l0->next != NULL)       l0 = l0->next;
        else                        l0->val = 0;
        if (l1->next != NULL)       l1 = l1->next;
        else                        l1->val = 0;
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1368454,2110501,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.exp < 0 || term.coeff == 0);
    else
    {
    SLinkedList<Term>::Iterator cur;
    int count = 0;
    for (cur=this->terms->begin();cur!=this->terms->end();cur++) 
    {
        Term tmp = *cur;
        if(tmp.exp == term.exp)
        {
            tmp.coeff += term.coeff;
            if(tmp.coeff != 0)      cur.set(tmp);
            else                    cur.remove();
            return;
        }
        else 
        {
            if(tmp.exp < term.exp)    break;
        }
        count++;
    }
    this->terms->add(count,term);
}
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    if(exp < 0 ||coeff ==0);
    else
    {
    SLinkedList<Term>::Iterator cur;
    int count = 0;
    for (cur = this->terms->begin(); cur != this->terms->end(); cur++) 
    {
        Term tmp = *cur;
        if(tmp.exp == exp)
        {
            tmp.coeff += coeff;
            if(tmp.coeff != 0.0000000f) cur.set(tmp);
            else                        cur.remove();
            return;
        }
        else 
        {
            if(tmp.exp < exp) break;
        }
        count++;
    }
    Term tmp(coeff,exp);
    this->terms->add(count,tmp);
    }
}",1.0,11111
Singly_linked_list_3,1368454,2110501,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList=pList;
    if(begin==true)
    {
        if(this->pList!=NULL)
        {
            this->index=0;
            this->current=this->pList->head;
        }
        else
        {
            this->index=-1;
            this->current=NULL;
        }
    }
    else
    {
        this->current=NULL;
        if(this->pList!=NULL)   this->index=this->pList->count;
        else                    this->index=0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current=iterator.current;
    this->index=iterator.index;
    this->pList=iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    if (this->index == 0)
     {
         pList->removeAt(0);
         this->current=NULL;
         this->index = -1;
     }
     pList->removeAt(this->index);
     this->index--;
     Node *cur=pList->head;
     for (int i=0;i<this->index;i++) 
     {
         cur=cur->next;
     }
     this->current=cur;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    else                    this->current->data=e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    else                    return this->current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return !((this->current == iterator.current) && (this->index == iterator.index));
    
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(this->current==NULL&&this->index==this->pList->count) throw std::out_of_range(""Segmentation fault!"");
    else if(this->index==-1&&current==NULL)
    {
        this->current=this->pList->head;
        this->index++;
    } 
    else if(current !=NULL)
    {
        this->current=this->current->next;
        this->index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    Iterator tmp=*this;
    ++*this;
    return tmp;
    
}",1.0,11111
Singly_linked_list_4,1368454,2110501,"void LinkedList::partition(int k) {
  Node *result = NULL;
  Node *pre = new Node(0);
  Node *in = new Node(0);
  Node *post = new Node(0);
  Node *node1 = in;
  Node *node2 = post;
  Node *cur = head;
  head = pre;
  while (cur!=NULL) 
  {
    if (cur->value < k) 
    {
        pre->next = cur;
        pre = cur;
    } 
    else if (cur->value == k) 
    {
        in->next = cur;
        in = cur;
    } 
    else 
    {
        post->next = cur;
        post = cur;
    }
    cur = cur->next;
  }
  if (head != pre) 
  {
    if (result == NULL) result = head->next;
  }
  if (node1 != in) 
  {
    if (result == NULL) result = node1->next;
    else 
    {
        pre->next = node1->next;
    }
    pre = in;
  }
  if (node2 != post) 
  {
    if (result == NULL)     result = node2->next;
    else 
    {
      pre->next = node2->next;
    }
    pre = post;
  }
  head = result;
  tail = pre;
}",1.0,11111
Singly_linked_list_5,1368454,2110501,"void reduceDuplicate(Node* root) {
    if (root == nullptr || root->getNext() == nullptr)
        return;

    Node* current = root;
    Node* nextNode = root->getNext();

    while (nextNode != nullptr) {
        if (current->getData() == nextNode->getData()) {
            Node* temp = nextNode;
            current->setNext(nextNode->getNext());
            nextNode = nextNode->getNext();
            delete temp;
        } else {
            current = nextNode;
            nextNode = nextNode->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1368454,2110501,"int Train::allocate(int containerSize) {
    TrainCar* currentCar = head->next;  
    int smallestIndex = -1;             
    while (currentCar != nullptr) {
        if (currentCar->remainingSpace >= containerSize) {
            if (smallestIndex == -1 || smallestIndex > currentCar->remainingSpace) {
                smallestIndex = currentCar->remainingSpace;
            }
        }
        currentCar = currentCar->next;
    }

    if (smallestIndex != -1) {
        currentCar = head->next;
        int currentIndex = 1;

        while (currentCar != nullptr) {
            if (currentCar->remainingSpace == smallestIndex) {
                currentCar->remainingSpace -= containerSize;
                return currentIndex;
            }
            currentCar = currentCar->next;
            ++currentIndex;
        }
    }

    return -1;
}

int Train::totalRemainingSpace() {
    TrainCar* current = head->next;
    int totalRemaining = 0;
    while (current != NULL) {
        totalRemaining += current->remainingSpace;
        current = current->next;
    }
    return totalRemaining;
}",1.0,11111
Singly_linked_list_7,1368454,2110501,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *pNew=new Node(e);
    if(count==0)    
    {
        head=pNew;
        tail=pNew;
        count++;
    }
    else
    {
        tail->next=pNew;
        tail=pNew;
        count++;
    }
    
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    Node *pNew=new Node(e);
    if(count==0)
    {
        head=pNew;
        tail=pNew;
        count++;
    }
    else
    {
        if(index==count)
        {
            tail->next=pNew;
            tail=pNew;
            count++;
        }
        else if (index==0)
        {
            pNew->next=head;
            head=pNew;
            count++;
        }
        else
        {
            Node*pre=head;
            for(int i=0;i<index-1;i++)  pre=pre->next;
            pNew->next=pre->next;
            pre->next=pNew;
            count++;
        }
        
    }
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1368454,2110501,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
if(index>count) throw std::out_of_range("""");
else
{
Node*pNew=this->head;
for(int i=0;i<index;i++)
{
    pNew=pNew->next;
}
return pNew->data;
}
}


template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
if(index>count) throw std::out_of_range("""");
else   
{
Node*pNew=this->head;
for(int i=0;i<index;i++)
{
    pNew=pNew->next;
}
pNew->data=e;
}
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(count==0)  return true;
    return false;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node*pNew=this->head;
    int i=0;
    while(pNew!=NULL)
    {
        if(pNew->data==item)    return i;
        i++;
        pNew=pNew->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node*pNew=this->head;
    int i=0;
    while(pNew!=NULL)
    {
        if(pNew->data==item)    return true;
        i++;
        pNew=pNew->next;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1368454,2110501,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    int result;
    if (index < 0 || index > this->count) throw std::out_of_range("""");
    else
    {
        if (this->count == 1)
        {
            result = this->head->data;
            this->head = this->tail = NULL;
            this->count--;
            return result;
        }
        else
        {
            Node* cur = this->head;
            Node* tmp = this->head;
            if (index == 0)
            {
                result = this->head->data;
                this->head = this->head->next;
                delete tmp;
                this->count--;
                return result;
            }
            for(int i=0;i<index-1;i++)
            {
                cur=cur->next;
            }
            tmp=cur->next;
            if (tmp == this->tail)
            {
                result = tmp->data;
                this->tail = cur;
                cur->next = NULL;
                tmp->next = NULL;
                delete tmp;
                this->count--;
                return result;
            }
            else
            {
                result = tmp->data;
                cur->next = tmp->next;
                tmp->next = NULL;
                delete tmp;
                this->count--;
                return result;
            }
            return result;
        }
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(this->count == 1 && this->head->data == item)
    {
        delete this->head;
        this->head = this->tail = NULL;
        this->count--;
        return true;
    }
    else if(this->count == 1 && this->head->data != item) return false;
    else
    {
    Node* cur = NULL;
    Node* tmp = this->head;
    if(tmp->data == item)
    {
        this->count--;
        this->head = this->head->next;
        delete tmp;
        return true;
    }
    while(tmp)
    {
        if(tmp == this->tail && tmp->data == item)
        {
            this->tail = cur;
            cur->next = tmp->next;
            tmp->next = NULL;
            delete tmp;
            this->count--;
            return true;
        }
        else if (tmp->data == item)
        {
            cur->next = tmp->next;
            tmp->next = NULL;
            delete tmp;
            this->count--;
            return true;
        }
        else
        {
            cur = tmp;
            tmp = tmp->next;
        }
    }
    return false;
    }
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    if(this->count == 0);
    Node*cur=this->head;
    while(cur!=NULL)
    {
        this->head = this->head->next;
        delete cur;
        cur = this->head;
    }
    this->head = this->tail= NULL;
    this->count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1368454,2110501,"LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if(head==NULL)  return NULL;
    else
    {
        int count=0;
        LLNode*cur=head;
        while(cur!=NULL)
        {
            count++;
            cur=cur->next;
        }
        cur=head;
        for(int i=0;i<count/2-1;i++)
        {
            cur=cur->next;
        }
        if(count%2!=0)  cur=cur->next;
        LLNode*p=cur->next;
        cur->next=NULL;
        LLNode*head2=p;
        LLNode *pre = NULL, *next;
        cur=head2;
        while (cur) 
        { 
            next = cur->next; 
            cur->next = pre; 
            pre = cur; 
            cur = next; 
        } 
        head2 = pre;
        LLNode*cur1=head;
        LLNode*cur2=head2;
        while(cur1!=NULL)
        {
            if(cur2==NULL)  break;
            cur1->val+=cur2->val;
            cur1=cur1->next;
            cur2=cur2->next;
        }
        cur=head;pre = NULL; next=NULL;
        while (cur) 
        { 
            next = cur->next; 
            cur->next = pre; 
            pre = cur; 
            cur = next; 
        } 
        head = pre;
        return head;
    }
}",1.0,1111111111
Singly_linked_list_11,1368454,2110501,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    if (!head)  return nullptr;
    stack<std::pair<LLNode*, int>> stack;
    LLNode* current = head;

    while (current) {
        while (!stack.empty() && stack.top().first->val < current->val) {
            stack.top().first->val = current->val;
            stack.pop();
        }

        stack.push({current, current->val});
        current = current->next;
    }

    while (!stack.empty()) {
        stack.top().first->val = 0;
        stack.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1368454,2110501,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode*cur = head;
    LLNode*pre = NULL; 
    LLNode*post = NULL;
    while(cur != NULL) 
    {
        post=cur->next;
        cur->next =pre;
        pre=cur;
        cur=post;
    }
    head = pre;
    return head;
}",1.0,1111111111
Singly_linked_list_13,1368454,2110501,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (head==NULL) return NULL;
    LLNode *cur=head;
    LLNode *temp = head;
    int count = 1;
    while (cur->next!=NULL)
    {
        cur=cur->next;
        count++;
    }
    head=cur;
    head->next = temp;
    k %= count;
    k = count - k;
    while (k--) 
    {
        cur = cur->next;
    }
    head=cur;
    temp = head->next;
    head->next = NULL;
    return temp;
}",1.0,1111111111
Singly_linked_list_14,1368454,2110501,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if(low>high||high<0)    return;
    Node*newNode=head;
    if(low<0&&high>=size){
        head=linked_list->head;
        head->next=linked_list->head;
        tail=linked_list->tail;
        size=linked_list->size;
    }
    else if(low<0){
        for(int i=0;i<=high;i++){
            newNode=newNode->next;
        }
        size=size+linked_list->size-(high+1);
        linked_list->tail->next=newNode;
        head=linked_list->head;
        head->next=linked_list->head->next;
    }
    else if(high>=size){
        for(int i=0;i<low-1;i++){
            newNode=newNode->next;
        }
        size=linked_list->size+(low);
        newNode->next=linked_list->head;
        tail=linked_list->tail;
    }
    else{
        size=size+linked_list->size+(high-low+1);
        for(int i=0;i<(low-1);i++){
            newNode=newNode->next;
        }
        Node*newNewNode=newNode;
        for(int i=(low-1);i<=high;i++){
            newNewNode=newNewNode->next;   
        }
        newNode->next=linked_list->head;
        linked_list->tail->next=newNewNode;
    }
}",0.4,110
Singly_linked_list_1,1369779,2212282,"LLNode* addLinkedList(LLNode* l1, LLNode* l2) {
    LLNode* dummy = new LLNode(), *temp = dummy, *temp1 = dummy;
        int remain=0, calculate, final;
        while(l1 || l2) {
            calculate  = (l1?l1->val:0) + (l2?l2->val:0)+remain;
            final = (calculate > 9 ? calculate-10 : calculate);
            remain     = calculate < 10 ? 0 : 1;
            
            temp->next = new LLNode(final);
            
            l1         =   l1?l1->next:NULL;
            l2         =   l2?l2->next:NULL;
            temp       =   temp->next;
        }
        if(calculate > 9) temp->next = new LLNode(1);
        dummy = dummy->next;
        delete temp1;
        return dummy;
}",1.0,111111111111111
Singly_linked_list_2,1369779,2212282,"void Polynomial::insertTerm(const Term& term) {
    if(terms) {}
}



void Polynomial::insertTerm(double coeff, int exp) {
    Term hehe(coeff, exp);
    insertTerm(hehe);
}",0.2,00010
Singly_linked_list_4,1369779,2212282,"void LinkedList::partition(int k) {
    LinkedList *gr1 = new LinkedList();
    LinkedList *gr2 = new LinkedList();
    LinkedList *gr3 = new LinkedList();
    
    Node* cur = head;
    while(cur) {
        int val = cur->value;
        if(val < k)       gr1->add(val);
        else if(val == k) gr2->add(val);
        else              gr3->add(val);
        
        cur = cur->next;
    }
    
    cur = head;
    Node* g1 = gr1->head;
    Node* g2 = gr2->head;
    Node* g3 = gr3->head;
    while(cur) {
        if(g1) {
            cur->value = g1->value;
            g1         = g1->next;
        }
        else if(g2) {
            cur->value = g2->value;
            g2         = g2->next;
        }
        else {
            cur->value = g3->value;
            g3         = g3->next;
        }
        cur = cur->next;
    }
    delete gr1;
    delete gr2;
    delete gr3;
}",1.0,11111
Singly_linked_list_5,1369779,2212282,"void reduceDuplicate(Node* root)
{
    if(!root) return;
    
    Node* temp1 = root;
    Node* temp2 = root->getNext();
    
    while(temp2) {
        if(temp2->getData() == temp1->getData()) {
            temp1->setNext(temp2->getNext());
            Node* temp = temp2;
            temp2 = temp2->getNext();
            delete temp;
        }
        else {
            temp1 = temp2;
            temp2 = temp2->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_1,1371334,2213250,"

LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    bool carry = 0 ;
    LLNode* head = nullptr;
    LLNode* prev;
    while(l0 || l1 || carry){
        int ans = 0 ;
        if(l0) {ans+=l0->val;l0 = l0->next;}
        if(l1) {ans +=l1->val;l1=l1->next;}
        if(carry) ans+=1;
        if(ans>9) {ans-=10 ; carry = 1 ;}
        else carry = 0 ;
        if(head==nullptr){head = new LLNode(ans,nullptr) ; prev = head ;}
        else{
           prev->next = new LLNode(ans,nullptr);
           prev = prev->next;
        }
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1371334,2213250,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    
}",0.2,00010
Singly_linked_list_3,1371334,2213250,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(begin){
        if(pList != NULL){
            current = pList -> head;
            this -> index =0;
        }
        else{
            current = NULL;
            index = -1;
        }
    }
    else{
        current = NULL;
        index = (pList == NULL)? 0 : pList-> size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this-> current = iterator.current;
    this-> pList = iterator.pList;
    this-> index = iterator.index;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        pList-> removeAt(index);
        index--;
    }
    
    if(index == -1){
        current = NULL;
    }
    else{
        current = pList->head;
        for (int i =0; i < index; i++){
            current = current->next;
        }
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if( current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    current-> data = e;
    
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    return current -> data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return !(this-> current == iterator.current && this-> index == iterator.index) ;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL && index == -1){
        current = pList-> head;
        index++;
    }
    else if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        current = current -> next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,11111
Singly_linked_list_1,1373763,2210200,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode *head = new LLNode();
    head->val = 0;
    head->next = NULL;
    LLNode *temp = head;
    int a = 0, b = 0, save = 0, tmp = 0;
    if(l0 == NULL && l1 == NULL){
        head = NULL;
    }
    while(l0 != NULL || l1 != NULL){
        if(temp->next != NULL) temp = temp->next;
        if(l0 != NULL){
            a = l0->val;
            l0 = l0->next;
        }
        else a = 0;
        if(l1 != NULL){
            b = l1->val;
            l1 = l1->next;
        }
        else b = 0;
        tmp = a + b + save;
        if(tmp > 9){
            save = (int)(tmp/10);
            tmp %= 10;
            temp->val = tmp;
        }
        else{
            save = 0;
            temp->val = tmp;
        }
        LLNode *newnode = new LLNode();
        newnode->val = 0;
        newnode->next = NULL;
        temp->next = newnode;
    }
    if(save != 0){
        LLNode *newnode = new LLNode();
        newnode->next = NULL;
        newnode->val = save;
        temp->next = newnode;
    }
    else{
        temp->next = NULL;
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1373763,2210200,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1373763,2210200,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1373763,2210200,"void reduceDuplicate(Node* root)
{
}",0.2,0000101000
Singly_linked_list_7,1373763,2210200,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *newnode = new Node(e, NULL);
    if(count == 0){
        head = newnode;
        tail = newnode;
        ++count;
        return;
    }
    tail->next = newnode;
    tail = newnode;
    ++count;
    return;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if(index < 0 || index > count) return;
    if(index == count){
        add(e);
        return;
    }
    Node *newnode = new Node(e, NULL);
    if(index == 0){
        newnode->next = head;
        head = newnode;
        ++count;
        return;
    }
    Node *temp = head;
    for(int i = 0; i < index - 1; i++){
        temp = temp->next;
    }
    newnode->next = temp->next;
    temp->next = newnode;
    ++count;
    return;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1373763,2210200,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count) throw std::out_of_range(""Out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count) throw std::out_of_range(""Out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    temp->data = e;
    return;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0);
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item){
            return i;
        }
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node *temp = head;
    while(temp != NULL){
        if(temp->data == item) return true;
        temp = temp->next;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1373763,2210200,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    if(count == 1){
        T val = head->data;
        delete head;
        head = NULL;
        tail = NULL;
        --count;
        return val;
    }
    if(index == 0){
        T val = head->data;
        Node *removeNode = head;
        head = head->next;
        delete removeNode;
        --count;
        return val;
    }
    Node *temp = head;
    for(int i = 0; i < index - 1; i++){
        temp = temp->next;
    }
    Node *removeNode = temp->next;
    T returnval = removeNode->data;
    temp->next = removeNode->next;
    if(temp->next == NULL) tail = temp;
    delete removeNode;
    --count;
    return returnval;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item){
            removeAt(i);
            return true;
        }
        temp = temp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        Node *removeNode = temp;
        temp = temp->next;
        delete removeNode;
    }
    head = NULL;
    tail = NULL;
    count = 0;
    return;
}

",1.0,1111111111
Singly_linked_list_10,1373763,2210200,"LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if(head == NULL){
        return NULL;
    }
    LLNode *temp = head;
    int count = 0;
    while(temp != NULL){
        ++count;
        temp = temp->next;
    }
    temp = head;
    int *a = new int[count + 2];
    if(count % 2 == 0){
        for(int i = count/2; i >= 1; i--){
            a[i] = temp->val;
            temp = temp->next;
        }
        // a[3] = 11, a[2] = 9, a[1] = 14
        for(int i = 1; i <= count/2; i++){
            a[i] += temp->val;
            temp = temp->next;
        }
        LLNode *newhead = new LLNode(0, NULL);
        // newhead->val = 0;
        // newhead->next = NULL;
        temp = newhead;
        for(int i = 1; i <= count/2; i++){
            if(temp->next != NULL) temp = temp->next;
            temp->val = a[i];
            LLNode *newnode = new LLNode(0, NULL);
            temp->next = newnode;
        }
        temp->next = NULL;
        return newhead;
    }
    else{
        for(int i = count/2 + 1; i >= 1; i--){
            a[i] = temp->val;
            temp = temp->next;
        }
        // a[3] = 11, a[2] = 9, a[1] = 14
        for(int i = 2; i <= count/2 + 1; i++){
            a[i] += temp->val;
            temp = temp->next;
        }
        LLNode *newhead = new LLNode(0, NULL);
        // newhead->val = 0;
        // newhead->next = NULL;
        temp = newhead;
        for(int i = 1; i <= count/2 + 1; i++){
            if(temp->next != NULL) temp = temp->next;
            temp->val = a[i];
            LLNode *newnode = new LLNode(0, NULL);
            temp->next = newnode;
        }
        temp->next = NULL;
        return newhead;
    }
}",1.0,1111111111
Singly_linked_list_2,1374431,2211738,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1374431,2211738,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1374431,2211738,"void reduceDuplicate(Node* root)
{
}",0.2,0000101000
Singly_linked_list_1,1377349,2210997,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) 
{
    LLNode dummy; 
    LLNode* temp = &dummy;
    int carry = 0;

    while (l0 || l1 || carry)
    {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        carry = sum / 10;
        temp->next = new LLNode(sum % 10);
        temp = temp->next;

        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }

    return dummy.next;
}",1.0,111111111111111
Singly_linked_list_2,1377349,2210997,"void Polynomial::insertTerm(const Term& term) {
    if (term.coeff == 0) return;
    if (terms->size() == 0) {
        terms->add(term);
        return;
    }
    SLinkedList<Term>::Iterator temp;
    temp = terms->begin();
    while (temp != terms->end()) {
        if (term.exp < (*temp).exp) temp++;
        else break;
    }
    if (!(temp != terms->end())) {
        terms->add(term);
        return;
    }
    if (term.exp > (*temp).exp) terms->add(terms->indexOf(*temp), term);
    else {
        if ((*temp).coeff + term.coeff == 0) terms->removeAt(terms->indexOf(*temp));
        else (*temp).coeff += term.coeff;
    }
}

void Polynomial::insertTerm(double coeff, int exp) {
    Term term = Term(coeff, exp);
    this->insertTerm(term);
}
",1.0,11111
Singly_linked_list_3,1377349,2210997,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    this->pList = pList;

    if (begin)
    {
        if (pList != nullptr && pList->head != nullptr)
        {
            current = pList->head;
            index = 0;
        }
        else
        {
            current = nullptr;
            index = -1;
        }
    }
    else
    {
        current = nullptr;
        index = (pList != nullptr) ? pList->count : 0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    if (this == &iterator)
    {
        return *this;
    }

    current = iterator.current;
    index = iterator.index;
    pList = iterator.pList;

    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }

    if (index == 0)
    {
        pList->head = current->next;
        current = nullptr;
        index = -1;
        --pList->count;
    }
    else
    {
        typename SLinkedList<T>::Node *prev = pList->head;
        for (int i = 0; i < index - 1; ++i)
        {
            prev = prev->next;
        }

        prev->next = current->next;
        current = prev;
        --index;
        --pList->count;
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }

    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }

    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    return (current != iterator.current) || (index != iterator.index);
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    if (index == pList->count)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }

    if (current != nullptr)
    {
        current = current->next;
    }
    else
    {
        current = pList->head;
    }

    ++index;

    return *this;
}

template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    Iterator tempIterator = *this;

    if (index == pList->count)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }

    if (current != nullptr)
    {
        current = current->next;
    }
    else
    {
        current = pList->head;
    }

    ++index;

    return tempIterator;
}
",1.0,11111
Singly_linked_list_4,1377349,2210997,"void LinkedList::partition(int k) {
    Node* groupIHead = nullptr;
    Node* groupITail = nullptr;
    Node* groupIIHead = nullptr;
    Node* groupIITail = nullptr;
    Node* groupIIIHead = nullptr;
    Node* groupIIITail = nullptr;
    Node* cur = head;
    
    while (cur) {
        if (cur->value < k) {
            if (!groupIHead) {
                groupIHead = cur;
                groupITail = cur;
            } else {
                groupITail->next = cur;
                groupITail = cur;
            }
        } else if (cur->value == k) {
            if (!groupIIHead) {
                groupIIHead = cur;
                groupIITail = cur;
            } else {
                groupIITail->next = cur;
                groupIITail = cur;
            }
        } else {
            if (!groupIIIHead) {
                groupIIIHead = cur;
                groupIIITail = cur;
            } else {
                groupIIITail->next = cur;
                groupIIITail = cur;
            }
        }
        cur = cur->next;
    }

    if (groupIHead) {
        head = groupIHead;
        if (groupIIHead) {
            groupITail->next = groupIIHead;
            if (groupIIIHead) {
                groupIITail->next = groupIIIHead;
                tail = groupIIITail;
            } else {
                tail = groupIITail;
            }
        } else {
            if (groupIIIHead) {
                groupITail->next = groupIIIHead;
                tail = groupIIITail;
            } else {
                tail = groupITail;
            }
        }
    } else {
        if (groupIIHead) {
            head = groupIIHead;
            if (groupIIIHead) {
                groupIITail->next = groupIIIHead;
                tail = groupIIITail;
            } else {
                tail = groupIITail;
            }
        } else {
            head = groupIIIHead;
            tail = groupIIITail;
        }
    }

    if (tail) {
        tail->next = nullptr;
    }
}
",1.0,11111
Singly_linked_list_5,1377349,2210997,"void reduceDuplicate(Node* root) 
{
    Node* cur = root;
    while (cur != nullptr && cur->getNext() != nullptr) 
    {
        if (cur->getData() == cur->getNext()->getData()) 
        {
            Node* temp = cur->getNext();
            cur->setNext(temp->getNext());
            delete temp;
        } 
        else 
        {
            cur = cur->getNext();
        }
    }
}
",1.0,1111111111
Singly_linked_list_6,1377349,2210997,"int Train::allocate(int containerSize) {
    TrainCar* currentCar = head->next;
    TrainCar* bestCar = nullptr; 
    int bestIndex = -1; 
    int index = 1;
    while (currentCar != nullptr)
    {
        if (currentCar->remainingSpace >= containerSize) 
        {
            if (bestCar == nullptr || currentCar->remainingSpace < bestCar->remainingSpace)
            {
                bestCar = currentCar;
                bestIndex = index;
            }
        }
        currentCar = currentCar->next;
        index++;
    }

    if (bestCar != nullptr) 
    {
        bestCar->remainingSpace -= containerSize;
        return bestIndex;
    }

    return -1; 
}

int Train::totalRemainingSpace() {
    TrainCar* currentCar = head->next;
        int totalSpace = 0;

        while (currentCar != nullptr) {
            totalSpace += currentCar->remainingSpace;
            currentCar = currentCar->next;
        }

        return totalSpace;

}",1.0,11111
Singly_linked_list_7,1377349,2210997,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *newNode = new Node (e,NULL);
    if (count == 0)
    {
        head = tail = newNode;
        count ++;
        return;
    }
    tail->next = newNode;
    tail = newNode;
    count ++;
    
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    Node *newNode = new Node (e,NULL);
    if (count == 0)
    {
        head = tail = newNode;
        head = newNode;
        count ++;
        return;
    }
    Node *temp = head;
    if (index ==0)
    {
        newNode -> next = head;
        head = newNode;
        count++;
        return;
    }
    
    if (index == count)
    {
        tail -> next = newNode;
        tail = newNode;
        count ++;
        return;
    }
    for (int i = 1; i < index ; i++) temp = temp->next;
    newNode->next = temp->next;
    temp->next = newNode;
    count ++;
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1377349,2210997,"template<class T>
T SLinkedList<T>::get(int index) {
    if(index >= count || index < 0) throw std::out_of_range(""hi"");
    /* Give the data of the element at given index in the list. */
    Node *temp =head;
    for (int i=1 ; i<=index; i++) temp = temp ->next;
    return temp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    if(index >= count || index < 0) throw std::out_of_range(""hi"");
    /* Assign new value for element at given index in the list */
    Node *temp = head;
     for (int i=1 ; i<=index; i++) temp = temp ->next;
     temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (count) return false;
    return true;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *temp = head;
    int index = 0;
    while (temp != NULL)
    {
        if (temp -> data == item) return index;
        temp = temp -> next;
        index ++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node *temp = head;
    while (temp != NULL)
    {
        if (temp -> data == item) return true;
        temp = temp -> next;
    }
    return false;
    
}",1.0,1111111111
Singly_linked_list_9,1377349,2210997,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    if(index >= count || index < 0) throw std::out_of_range(""hi"");
    /* Remove element at index and return removed value */
    
    //Case 1: 1 element
    if (count == 1)
    {
        T value = head ->data;
        delete head;
        head = tail = NULL;
        count --;
        return value;
    }
    // Case 2: more, remove first
    if (index == 0)
    {
        Node *temp = head;
        T value = head ->data;
        head = head -> next;
        delete temp;
        count --;
        return value;
    }
    // Case 3: 
    Node *temp = head;
    for (int i = 1 ; i <index ; i++) temp = temp->next;
    if (index == count -1) tail = temp;
    Node* temp2 = temp->next;
    T value = temp2->data;
    temp->next = temp2->next;
    delete temp2;
    count--;
    return value;
    
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *temp = head;
    int i = 0;
    while (temp != NULL)
    {
        if (temp -> data == item)
        {
            removeAt(i);
            return true;
        }
        i++;
        temp = temp ->next;
    }
    return false;
    
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    
    while (count)
    {
        removeAt(0);
    }
}

",1.0,1111111111
Singly_linked_list_10,1377349,2210997,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* current = head;
    while (current) {
        LLNode* next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    return prev;
}
LLNode* findMiddle(LLNode* head) {
    if (!head || !head->next) {
        return head;
    }
    LLNode* slow = head;
    LLNode* fast = head->next;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}
LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
     if (!head || !head->next) {
        return head;
    }
     // Find the middle of the linked list.
    LLNode* middle = findMiddle(head);

    // Split the list into two halves.
    LLNode* firstHalf = head;
    LLNode* secondHalf = middle->next;
    middle->next = nullptr;

    // Reverse the second half of the linked list.
    secondHalf = reverseLinkedList(secondHalf);
    LLNode* p1 = firstHalf;
    LLNode* p2 = secondHalf;

    while (p1 && p2) {
        p1->val += p2->val;
        p1 = p1 ->next;
        p2 = p2 ->next;
        //LLNode* temp = p1->next;
        //p1->next = p2;
        //p2 = temp;
        //p1 = p1->next;
    }
    return reverseLinkedList(head);
}",1.0,1111111111
Singly_linked_list_11,1377349,2210997,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    if (!head || !head ->next) return head;
    stack <LLNode*> st;
    LLNode *cur = head;
    while (cur)
    {
        while (!st.empty() && cur -> val > st.top() ->val)
        {
            st.top()->val = cur->val;
            st.pop();
        }
        st.push(cur);
        cur = cur->next;
    }
    while (!st.empty()) {
        st.top()->val = 0;
        st.pop();
    }
    return head;

    
}",1.0,1111111111
Singly_linked_list_12,1377349,2210997,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if (head == nullptr) return nullptr;
    LLNode *temp = head;
    LLNode* newHead = new LLNode(temp->val,nullptr);
    temp = temp -> next;
    while (temp != NULL)
    {
        LLNode *newNode = new LLNode(temp->val,newHead);
        newHead = newNode;
        temp = temp -> next;
    }
    return newHead;
}",1.0,1111111111
Singly_linked_list_13,1377349,2210997,"

LLNode* rotateLinkedList(LLNode* head, int k) {
    if (!head || k == 0) return head;
    int length = 1; 
    LLNode* current = head;
    while (current->next) 
    {
        current = current->next;
        length++;
    }
    k %= length;
    if (k == 0)  return head;
    current->next = head; 
    current = head;
    for (int i = 0; i < length - k - 1; i++)
    {
        current = current->next;
    }

    LLNode* newHead = current->next;
    current->next = nullptr;

    return newHead;
}
",1.0,1111111111
Singly_linked_list_14,1377349,2210997,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (linked_list == NULL) return;
    
    int size2 = 0;
    int size1 = this->size;
    Node* h = linked_list->head;
    int cnt = 0; 
    while (h) {
        ++cnt;
        h = h->next;
    }
    size2 = cnt;
    
    int* replace = new int[size2];
    int* original = new int[size1];
    int* res = new int[size1 + size2];
    
    Node* h2 = linked_list->head;
    Node* h1 = head;
    
    int res_size = 0; 
    for (int i = 0; i < size2; ++i, h2 = h2->next) {
        replace[i] = h2->value;
    }
    
    for (int i = 0; i < size1; ++i, h1 = h1->next) {
        original[i] = h1->value; // Fixed typo here: 'valu' to 'value'
    }

    if (low < 0) {
        // Replace from the beginning of the list
        for (int i = 0; i < size2; ++i) {
            res[i] = replace[i];
        }
        
        if (size2 <= size1) {
            for (int i = size2; i < size1; ++i) {
                res[i] = original[i];
            }
            res_size = size1;
        } else {
            res_size = size2;
        }
        
        if (size2 <= size1) {
            int i = 0;
            for (h1 = head; h1 != NULL; h1 = h1->next) {
                h1->value = res[i];
                ++i; 
            }
        } else {
            int i = 0;
            for (h1 = head; h1 != NULL; h1 = h1->next) {
                if (h1->next == NULL && h1 != NULL) {
                    store = h1;
                }
                h1->value = res[i];
                ++i;
            }

            // If list2 is longer than list1, update the tail pointer
            if (size2 > size1) {
                tail = store;
            }
        }
        
        delete[] replace;
        delete[] original;
        delete[] res;
        return;
    }
    else {
    int i = 0;
    for (h1 = head; h1 != NULL; h1 = h1->next) {
        if (h1->next == NULL && h1 != NULL) {
            store = h1;
        }
        h1->value = res[i];
        ++i;
    }

    // If list2 is longer than list1, update the tail pointer
    if (size2 > size1) {
        tail = store;
    }
}

// Clean up memory
delete[] replace;
delete[] original;
delete[] res;
}

    
    // Continue the rest of your code here (handling other cases)
    // ...

",0.2,
Singly_linked_list_1,1377804,2212935,"LLNode* add(LLNode* node0, LLNode* node1, int carry){
    if (!node0 && !node1 && !carry) return NULL;
    int sum = (node0? node0->val:0) + (node1? node1->val:0) + carry;
    LLNode * node = new LLNode(sum % 10);
    if (node){
    node->next = add((node0?node0->next:NULL), (node1?node1->next:NULL), sum/10);
    return node;
    }
    return NULL;
}
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    return add(l0, l1, 0);
}",0.8,1111111111110
Singly_linked_list_2,1377804,2212935,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff, exp);
    insertTerm(term);
}",0.2,00010
Singly_linked_list_4,1377804,2212935,"void LinkedList::partition(int k) {
    
}",0.2,00100
Singly_linked_list_5,1377804,2212935,"void reduceDuplicate(Node* root)
{
    if (root == nullptr)
        return;

    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicateNode = current->getNext();
            current->setNext(duplicateNode->getNext());
            delete duplicateNode;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_1,1380898,2210535,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* a = new LLNode();  // Tạo đối tượng trên heap
    LLNode* result = a;

    int carry = 0;
    while (l0 || l1 || carry) {
        int x, y;
        if (l0) {
            x = l0->val;
            l0 = l0->next;
        }
        else x = 0;

        if (l1) {
            y = l1->val;
            l1 = l1->next;
        }
        else y = 0;

        int sum = x + y + carry;
        carry = sum / 10;
        result->next = new LLNode(sum % 10, nullptr);

        result = result->next;
    }
    return a->next;
}",1.0,111111111111111
Singly_linked_list_3,1380898,2210535,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true:
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false:
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin == true) {
        if (pList == nullptr) {
            current = nullptr;
            index = -1;
        }
        else {
            current = pList->head;
            index = 0;
        }
    }
    else {
        current = nullptr;
        index = pList->size();
    }
}
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    pList = iterator.pList;
    current = iterator.current;
    index = iterator.index;
    return (*this);
}
template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    pList->removeAt(index);
    index = index - 1;
    if (index == -1) {
        current = nullptr;
        return;
    }
    current = pList->head;
    for (int i = 0; i < index; i++) {
        if (current) {
            current = current->next;
        }
    }
}
template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    current->data = e;
}
template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    return current->data;
}
template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if (current == iterator.current) {
        return false;
    }
    else return true;
}
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    current = current->next;
    ++index;
    return *this;
}
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    SLinkedList<T>::Iterator temp = *this;
    current = current->next;
    ++index;
    return temp;
}",1.0,11111
Singly_linked_list_4,1380898,2210535,"void LinkedList::partition(int k)
{
    Node* pHead1 = NULL;
    Node* pHead2 = NULL;
    Node* pHead3 = NULL;
    Node* pTail1 = NULL;
    Node* pTail2 = NULL;
    Node* pTail3 = NULL;
    for (Node* p = head; p != NULL;)
    {
        if (p->value < k)
        {
            if (pHead1 == NULL)
            {
                pHead1 = p;
                pTail1 = p;
            }
            else
            {
                pTail1->next = p;
                pTail1 = pTail1->next;
            }
        }
        else if (p->value == k)
        {
            if (pHead2 == NULL)
            {
                pHead2 = p;
                pTail2 = p;
            }
            else
            {
                pTail2->next = p;
                pTail2 = pTail2->next;
            }
        }
        else
        {
            if (pHead3 == NULL)
            {
                pHead3 = p;
                pTail3 = p;
            }
            else
            {
                pTail3->next = p;
                pTail3 = pTail3->next;
            }
        }
        p = p->next;
        if (pTail1 != NULL) pTail1->next = NULL;
        if (pTail2 != NULL) pTail2->next = NULL;
        if (pTail3 != NULL) pTail3->next = NULL;
    }
    if (pTail1 != NULL) pTail1->next = pHead2;
    if (pTail2 != NULL) pTail2->next = pHead3;
    if (pTail3 != NULL) pTail3->next = NULL;
    if (pHead1 != NULL)
    {
        head = pHead1;
    }
    else if (pHead2 != NULL)
    {
        head = pHead2;
    }
    else
    {
        head = pHead3;
    }
    if (pTail3 != NULL)
    {
        tail = pTail3;
    }
    else if (pTail2 != NULL)
    {
        tail = pTail2;
    }
    else
    {
        tail = pTail1;
    }
}",1.0,11111
Singly_linked_list_7,1380898,2210535,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newnode = new Node(e, nullptr);
    if (head == nullptr && tail == nullptr && this->size() == 0) {
        head = newnode;
        tail = newnode;
        count++;
    }
    else {
        tail->next = newnode;
        tail = newnode;
        count++;
    }
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index < 0 || index > count) throw out_of_range("" "");
    if (index == count) {
        add(e);
    }
    else if (index == 0) {
        Node* newnode = new Node(e, nullptr);
        newnode->next = head;
        head = newnode;
        count++;
    }
    else {
        Node* temp = head;
        while (index != 1 && temp ) {
            temp = temp->next;
            index--;
        }
        Node* newnode = new Node(e, nullptr);
        newnode->next = temp->next;
        temp->next = newnode;
        count++;
    }
}

template<class T>
int SLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Singly_linked_list_8,1380898,2210535,"template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (this->count == 0) {
        return true;
    }
    else return false;
}
template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while (temp) {
        if (temp->data == item) {
            return i;
        }
        temp = temp->next;
        i++;
    }
    return -1;
}
template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if (indexOf(item) != -1) {
        return true;
    }
    else return false;
}
template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    Node* temp = head;
    while (index != 0 && temp) {
        temp = temp->next;
        index--;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    Node* temp = head;
    while (index != 0 && temp) {
        temp = temp->next;
        index--;
    }
    temp->data = e;
}",1.0,1111111111
Singly_linked_list_9,1380898,2210535,"
template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    if (index == 0) {
        Node* temp = head;
        T result1 = temp->data;
        head = temp->next;
        delete temp;
        count--;
        return result1;
    }
    else {
        Node* temp = head;
        while (index != 1 && temp) {
            temp = temp->next;
            index--;
        }
        Node* nextTemp = temp->next;
        T result2 = nextTemp->data;
        if (nextTemp->next == nullptr) {
            temp->next = nullptr;
            tail = temp;
            delete nextTemp;
        }
        else {
            temp->next = nextTemp->next;
            delete nextTemp;
        }
        count--;
        return result2;
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    if (!head) {
        return false;
    }

    if (head->data == item) {
        Node* temp = head;
        head = temp->next;
        delete temp;
        count--;

        if (!head) {
            tail = nullptr;
        }

        return true;
    }
    else {
        Node* temp = head;
        Node* prev = nullptr;

        while (temp && temp->data != item) {
            prev = temp;
            temp = temp->next;
        }

        if (!temp) {
            return false;
        }

        if (temp == tail) {
            tail = prev;
        }

        prev->next = temp->next;
        delete temp;
        count--;

        return true;
    }
}

template<class T>
void SLinkedList<T>::clear() {
    Node* temp = head;
    while (temp != nullptr) {
        Node* nextTemp = temp->next;
        delete temp;
        temp = nextTemp;
    }
    head = nullptr;
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_12,1380898,2210535,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode *Pprev = nullptr;
    LLNode *p;
    while (head != nullptr) {
        p = head;
        head = p->next;
        p->next = Pprev;
        Pprev = p;
    }
    head = Pprev;
    return head;
}",1.0,1111111111
Singly_linked_list_13,1380898,2210535,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (head == nullptr || k==0)   {
        return head;
    }
    int n=1;
    LLNode* countSize = head;
    while (countSize->next != nullptr)   {
        countSize = countSize->next;
        n++;
    }
    k = k % n;
    if (k == 0) {
        return head;
    }
    LLNode *Ntail = head;
    for (int i=1; i< n-k; i++) {
        Ntail = Ntail->next;
    }
    LLNode *Nhead = Ntail->next;
    Ntail->next = nullptr;
    
    countSize->next = head;
    head = Nhead;
    return head;
}",1.0,1111111111
Singly_linked_list_14,1380898,2210535,"void LinkedList::replace(LinkedList* linked_list, int low, int high) 
{
    if(low <= 0 && high >= this->size-1) 
    {   
        delete head;
        delete tail;
        this-> head = linked_list ->head;
        this->tail = linked_list ->tail;
        this->size = linked_list ->size;
    }
    else if(low <= 0 ) 
    {
        for(int i=0; i <= high ; i++)
        {
            this->head = this->head->next;
        }
        this->size -= (high+1);
        linked_list->tail->next = this->head;
        this->head = linked_list->head;
        this->size += linked_list->size;
    }
    else if(high >= size-1)
    {
        Node* temp = this->head;
        for(int i = 0; i< low-1; i++)
        {
            temp = temp->next;
        }
        this->size -= (size-1 - low +1);
        temp->next = nullptr;
        delete this->tail;
        this->tail = temp;
        this->tail->next = linked_list->head;
        this->tail = linked_list->tail;
        this ->size += linked_list->size;
    }
    else
    {
        Node* low1 = this->head;
        Node* low2 = this->head;
        for(int i=0; i<low-1 ; i++ )
        {
          low1 = low1->next;
        }
        for(int i = 0; i<= high ; i++)
        {
            low2 = low2->next;
        }
        low1->next = low2;
        this->size -= (high - low + 1 );
        linked_list->tail->next = low2;
        low1->next = linked_list->head;
        this->size+= linked_list->size;
    }

}",1.0,11111
Singly_linked_list_1,1381535,2210200,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode *head = new LLNode();
    head->val = 0;
    head->next = NULL;
    LLNode *temp = head;
    int a = 0, b = 0, save = 0, tmp = 0;
    if(l0 == NULL && l1 == NULL){
        head = NULL;
    }
    while(l0 != NULL || l1 != NULL){
        if(temp->next != NULL) temp = temp->next;
        if(l0 != NULL){
            a = l0->val;
            l0 = l0->next;
        }
        else a = 0;
        if(l1 != NULL){
            b = l1->val;
            l1 = l1->next;
        }
        else b = 0;
        tmp = a + b + save;
        if(tmp > 9){
            save = (int)(tmp/10);
            tmp %= 10;
            temp->val = tmp;
        }
        else{
            save = 0;
            temp->val = tmp;
        }
        LLNode *newnode = new LLNode();
        newnode->val = 0;
        newnode->next = NULL;
        temp->next = newnode;
    }
    if(save != 0){
        LLNode *newnode = new LLNode();
        newnode->next = NULL;
        newnode->val = save;
        temp->next = newnode;
    }
    else{
        temp->next = NULL;
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_7,1381535,2210200,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *newnode = new Node(e, NULL);
    if(count == 0){
        head = newnode;
        tail = newnode;
        ++count;
        return;
    }
    tail->next = newnode;
    tail = newnode;
    ++count;
    return;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if(index < 0 || index > count) return;
    if(index == count){
        add(e);
        return;
    }
    Node *newnode = new Node(e, NULL);
    if(index == 0){
        newnode->next = head;
        head = newnode;
        ++count;
        return;
    }
    Node *temp = head;
    for(int i = 0; i < index - 1; i++){
        temp = temp->next;
    }
    newnode->next = temp->next;
    temp->next = newnode;
    ++count;
    return;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1381535,2210200,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count) throw std::out_of_range(""Out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count) throw std::out_of_range(""Out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    temp->data = e;
    return;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0);
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item){
            return i;
        }
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node *temp = head;
    while(temp != NULL){
        if(temp->data == item) return true;
        temp = temp->next;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1381535,2210200,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    if(count == 1){
        T val = head->data;
        delete head;
        head = NULL;
        tail = NULL;
        --count;
        return val;
    }
    if(index == 0){
        T val = head->data;
        Node *removeNode = head;
        head = head->next;
        delete removeNode;
        --count;
        return val;
    }
    Node *temp = head;
    for(int i = 0; i < index - 1; i++){
        temp = temp->next;
    }
    Node *removeNode = temp->next;
    T returnval = removeNode->data;
    temp->next = removeNode->next;
    if(temp->next == NULL) tail = temp;
    delete removeNode;
    --count;
    return returnval;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item){
            removeAt(i);
            return true;
        }
        temp = temp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        Node *removeNode = temp;
        temp = temp->next;
        delete removeNode;
    }
    head = NULL;
    tail = NULL;
    count = 0;
    return;
}

",1.0,1111111111
Singly_linked_list_10,1381535,2210200,"LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if(head == NULL){
        return NULL;
    }
    LLNode *temp = head;
    int count = 0;
    while(temp != NULL){
        ++count;
        temp = temp->next;
    }
    temp = head;
    int *a = new int[count + 2];
    if(count % 2 == 0){
        for(int i = count/2; i >= 1; i--){
            a[i] = temp->val;
            temp = temp->next;
        }
        // a[3] = 11, a[2] = 9, a[1] = 14
        for(int i = 1; i <= count/2; i++){
            a[i] += temp->val;
            temp = temp->next;
        }
        LLNode *newhead = new LLNode(0, NULL);
        // newhead->val = 0;
        // newhead->next = NULL;
        temp = newhead;
        for(int i = 1; i <= count/2; i++){
            if(temp->next != NULL) temp = temp->next;
            temp->val = a[i];
            LLNode *newnode = new LLNode(0, NULL);
            temp->next = newnode;
        }
        temp->next = NULL;
        return newhead;
    }
    else{
        for(int i = count/2 + 1; i >= 1; i--){
            a[i] = temp->val;
            temp = temp->next;
        }
        // a[3] = 11, a[2] = 9, a[1] = 14
        for(int i = 2; i <= count/2 + 1; i++){
            a[i] += temp->val;
            temp = temp->next;
        }
        LLNode *newhead = new LLNode(0, NULL);
        // newhead->val = 0;
        // newhead->next = NULL;
        temp = newhead;
        for(int i = 1; i <= count/2 + 1; i++){
            if(temp->next != NULL) temp = temp->next;
            temp->val = a[i];
            LLNode *newnode = new LLNode(0, NULL);
            temp->next = newnode;
        }
        temp->next = NULL;
        return newhead;
    }
}",1.0,1111111111
Singly_linked_list_11,1381535,2210200,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    int count = 0;
    LLNode *temp = head;
    while(temp != NULL){
        ++count;
        temp = temp->next;
    }
    if(count == 0) return NULL;
    int *a = new int[count + 2];
    temp = head;
    for(int i = 1; i <= count; i++){
        a[i] = temp->val;
        temp = temp->next;
    }
    stack<int> st;
    stack<int> save;
    for(int i = count; i >= 1; i--){
        while(!st.empty() && st.top() <= a[i]) st.pop();
        int ans = 0;
        if(!st.empty()) ans = st.top();
        save.push(ans);
        st.push(a[i]);
    }
    int *b = new int[count + 2];
    for(int i = 1; i <= count; i++){
        b[i] = save.top();
        save.pop();
    }
    LLNode *returnhead = new LLNode(0, NULL);
    temp = returnhead;
    for(int i = 1; i <= count; i++){
        if(temp->next != NULL) temp = temp->next;
        temp->val = b[i];
        LLNode *newnode = new LLNode(0, NULL);
        temp->next = newnode;
    }
    temp->next = NULL;
    return returnhead;
}",1.0,1111111111
Singly_linked_list_12,1381535,2210200,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    int count = 0;
    LLNode *temp = head;
    while(temp != NULL){
        ++count;
        temp = temp->next;
    }
    if(count == 0) return NULL;
    temp = head;
    int *a = new int[count + 2];
    for(int i = 1; i <= count; i++){
        a[i] = temp->val;
        temp = temp->next;
    }
    LLNode *returnhead = new LLNode(0, NULL);
    temp = returnhead;
    for(int i = count; i >= 1; i--){
        if(temp->next != NULL) temp = temp->next;
        temp->val = a[i];
        LLNode *newnode = new LLNode(0, NULL);
        temp->next = newnode;
    }
    temp->next = NULL;
    return returnhead;
}",1.0,1111111111
Singly_linked_list_13,1381535,2210200,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    int count = 0;
    LLNode *temp = head;
    while(temp != NULL){
        ++count;
        temp = temp->next;
    }
    if(count == 0) return NULL;
    int start = count + 1 - k % count;
    temp = head;
    int *a = new int[count + 2];
    for(int i = 1; i <= count; i++){
        a[i] = temp->val;
        temp = temp->next;
    }
    int *b = new int[count * 2 + 2];
    for(int i = 1; i <= count; i++){
        b[i] = a[i];
        b[i + count] = a[i];
    }
    LLNode *returnhead = new LLNode(0, NULL);
    temp = returnhead;
    for(int i = start; i <= start + count - 1; i++){
        if(temp->next != NULL) temp = temp->next;
        temp->val = b[i];
        LLNode *newnode = new LLNode(0, NULL);
        temp->next = newnode;
    }
    temp->next = NULL;
    return returnhead;
}",1.0,1111111111
Singly_linked_list_14,1381535,2210200,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    // linked_list->head->next->next->next = head->next->next->next;
    // head = linked_list->head;
    
    if(size == 0){
        head = linked_list->head;
        tail = linked_list->tail;
        size = linked_list->size;
        return;
    }
    if(low <= 0 && high >= size - 1){
        Node *temp = head;
        for(int i = 0; i <= size - 1; i++){
            Node *removenode = temp;
            temp = temp->next;
            delete removenode;
        }
        this->head = linked_list->head;
        this->tail = linked_list->tail;
        this->size = linked_list->size;
        return;
    }
    else if(low > 0 && high < size - 1){
        Node *templow = head;
        for(int i = 0; i < low - 1; i++){
            templow = templow->next;
        }
        Node *temphigh = head;
        for(int i = 0; i < high; i++){
            temphigh = temphigh->next;
        }
        Node *temp = templow->next;
        templow->next = linked_list->head;
        linked_list->tail->next = temphigh->next;
        for(int i = 1; i <= high - low + 1; i++){
            Node *removenode = temp;
            temp = temp->next;
            delete removenode;
        }
        this->size = this->size - (high - low + 1) + linked_list->size;
    }
    else if(low <= 0){
        Node *temp = head;
        for(int i = 0; i < high; i++){
            temp = temp->next;
        }
        linked_list->tail->next = temp->next;
        temp = head;
        for(int i = 1; i <= high + 1; i++){
            Node *removenode = temp;
            temp = temp->next;
            delete removenode;
        }
        this->head = linked_list->head;
        this->size = this->size - (high - 0 + 1) + linked_list->size;
    }
    else{
        Node *temp = head;
        for(int i = 0; i < low - 1; i++){
            temp = temp->next;
        }
        temp->next = linked_list->head;
        temp = temp->next;
        for(int i = 1; i <= size - 1 - low + 1; i++){
            Node *removenode = temp;
            temp = temp->next;
            delete removenode;
        }
        this->tail = linked_list->tail;
        this->size = this->size - (this->size - 1 - low + 1) + linked_list->size;
    }
}",1.0,11111
Singly_linked_list_1,1384953,2211667,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode* result = nullptr;
    LLNode* tail = nullptr;
    int carry = 0;
    while (l0 != nullptr || l1 != nullptr) {
        int sum = carry;
        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        carry = sum / 10;
        sum %= 10;
        LLNode* newNode = new LLNode{sum, nullptr};
        if (result == nullptr) {
            result = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }
    if (carry != 0) {
        LLNode* newNode = new LLNode{carry, nullptr};
        tail->next = newNode;
    }
    return result;
}",1.0,111111111111111
Singly_linked_list_3,1386455,2210200,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(begin){
        if(pList != NULL){
            current = pList->head;
            index = 0;
        }
        else{
            current = NULL;
            index = -1;
        }
    }
    else{
        current = NULL;
        if(pList != NULL) index = pList->count;
        else index = 0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
    
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove, current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
        return;
    }
    if(current == pList->head){
        pList->head = pList->head->next;
        delete current;
        current = NULL;
        index = -1;
        return;
    }
    Node *temp = pList->head;
    for(int i = 0; i < index - 1; i++){
        temp = temp->next;
    }
    temp->next = current->next;
    delete current;
    current = temp;
    --index;
    return;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        current->data = e;
    }
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current != NULL){
        return current->data;
    }
    else{
        throw std::out_of_range(""Segmentation fault!"");
    }
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if(this->index == iterator.index && this->current == iterator.current){
        return false;
    }
    return true;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL && index == pList->count){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else if(current == NULL && index == -1){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        ++index;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator it = *this;
    ++*this;
    return it;
}",0.8,11110
Singly_linked_list_4,1386455,2210200,"void LinkedList::partition(int k) {
    if(this->size == 0) return;
    LinkedList *group1 = new LinkedList();
    LinkedList *group2 = new LinkedList();
    LinkedList *group3 = new LinkedList();
    Node *temp = head;
    while(temp != NULL){
        int data = temp->value;
        if(data < k){
            group1->add(data);
        }
        else if(data == k){
            group2->add(data);
        }
        else{
            group3->add(data);
        }
        temp = temp->next;
    }
    temp = head;
    // if(group1->head != NULL){
    //     group1->tail->next = group2->head;
    //     this->head = group1->head;
    // }
    // if(group2->head != NULL){
    //     group2->tail->next = group3->head;
    //     if(group1->head == NULL){
    //         this->head = group2->head;
    //     }
    // }
    // if(group1->head == NULL && group2->head == NULL){
    //     this->head = group3->head;
    // }
    if(group1->size){
        this->head = group1->head;
        if(group2->size){
            group1->tail->next = group2->head;
            if(group3->size){
                group2->tail->next = group3->head;
                this->tail = group3->tail;
            }
            else{
                this->tail = group2->tail;
            }
        }
        else if(group3->size){
            group1->tail->next = group3->head;
            this->tail = group3->tail;
        }
        else{
            this->tail = group1->tail;
        }
    }
    else if(group2->size){
        this->head = group2->head;
        if(group3->size){
            group2->tail->next = group3->head;
            this->tail = group3->tail;
        }
        else{
            this->tail = group2->tail;
        }
    }
    else{
        this->head = group3->head;
        this->tail = group3->tail;
    }
    return;
}",1.0,11111
Singly_linked_list_5,1386455,2210200,"#include<vector>
#include<algorithm>

void reduceDuplicate(Node* root)
{
    vector<int> v;
    Node *temp = root;
    while(temp != NULL){
        int val = temp->getData();
        if(!v.empty()){
            if(v.back() != val) v.push_back(val);
        }
        else v.push_back(val);
        temp = temp->getNext();
    }
    temp = root;
    int n = int(v.size());
    for(int i = 0; i < n; i++){
        temp->setData(v[i]);
        if(i != n - 1) temp = temp->getNext();
        else{
            temp->setNext(NULL);
        }
    }
    return;
}",1.0,1111111111
Singly_linked_list_6,1386455,2210200,"int Train::allocate(int containerSize) {
    TrainCar *temp = head;
    int des = -1, mn = 1e9;
    for(int i = 0; i < size; i++){
        if(temp->remainingSpace >= containerSize){
            if(temp->remainingSpace < mn){
                des = i;
                mn = temp->remainingSpace;
            }
        }
        temp = temp->next;
    }
    if(des == -1) return -1;
    temp = head;
    for(int i = 0; i < size; i++){
        if(i == des){
            temp->remainingSpace -= containerSize;
            break;
        }
        temp = temp->next;
    }
    return des;
}

int Train::totalRemainingSpace() {
    TrainCar *temp = head;
    int ans = 0;
    while(temp != NULL){
        ans += temp->remainingSpace;
        temp = temp->next;
    }
    return ans;
}",1.0,11111
Singly_linked_list_1,1386669,2210535,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* a = new LLNode();  // Tạo đối tượng trên heap
    LLNode* result = a;

    int carry = 0;
    while (l0 || l1 || carry) {
        int x, y;
        if (l0) {
            x = l0->val;
            l0 = l0->next;
        }
        else x = 0;

        if (l1) {
            y = l1->val;
            l1 = l1->next;
        }
        else y = 0;

        int sum = x + y + carry;
        carry = sum / 10;
        result->next = new LLNode(sum % 10, nullptr);

        result = result->next;
    }
    return a->next;
}",1.0,111111111111111
Singly_linked_list_2,1386669,2210535,"void Polynomial::insertTerm(const Term& term) {
	// STUDENT ANSWER
	if (term.coeff == 0) return;
	int n = terms->size();
	if (n == 0)
	{
		terms->add(term);
	}
	else
	{
		int k = 0;
		for (int i = 0; i < n; i++)
		{
			k = terms->get(i).exp;
			if (k < term.exp)
			{
				terms->add(i, term);
				break;
			}
			else if (k == term.exp)
			{
				Term a(terms->get(i).coeff + term.coeff, k);
				if (a.coeff == 0) terms->removeAt(i);
				else terms->set(i, a);
				break;
			}
			else if(i == n-1) terms->add(term);
		}
		
	}

}

void Polynomial::insertTerm(double coeff, int exp) {
	// STUDENT ANSWER
	Term a(coeff, exp);
	insertTerm(a);
}",1.0,11111
Singly_linked_list_3,1386669,2210535,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true:
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false:
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin == true) {
        if (pList == nullptr) {
            current = nullptr;
            index = -1;
        }
        else {
            current = pList->head;
            index = 0;
        }
    }
    else {
        current = nullptr;
        index = pList->size();
    }
}
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    pList = iterator.pList;
    current = iterator.current;
    index = iterator.index;
    return (*this);
}
template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    pList->removeAt(index);
    index = index - 1;
    if (index == -1) {
        current = nullptr;
        return;
    }
    current = pList->head;
    for (int i = 0; i < index; i++) {
        if (current) {
            current = current->next;
        }
    }
}
template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    current->data = e;
}
template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    return current->data;
}
template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if (current == iterator.current) {
        return false;
    }
    else return true;
}
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    current = current->next;
    ++index;
    return *this;
}
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    SLinkedList<T>::Iterator temp = *this;
    current = current->next;
    ++index;
    return temp;
}",1.0,11111
Singly_linked_list_4,1386669,2210535,"void LinkedList::partition(int k)
{
    Node* pHead1 = NULL;
    Node* pHead2 = NULL;
    Node* pHead3 = NULL;
    Node* pTail1 = NULL;
    Node* pTail2 = NULL;
    Node* pTail3 = NULL;
    for (Node* p = head; p != NULL;)
    {
        if (p->value < k)
        {
            if (pHead1 == NULL)
            {
                pHead1 = p;
                pTail1 = p;
            }
            else
            {
                pTail1->next = p;
                pTail1 = pTail1->next;
            }
        }
        else if (p->value == k)
        {
            if (pHead2 == NULL)
            {
                pHead2 = p;
                pTail2 = p;
            }
            else
            {
                pTail2->next = p;
                pTail2 = pTail2->next;
            }
        }
        else
        {
            if (pHead3 == NULL)
            {
                pHead3 = p;
                pTail3 = p;
            }
            else
            {
                pTail3->next = p;
                pTail3 = pTail3->next;
            }
        }
        p = p->next;
        if (pTail1 != NULL) pTail1->next = NULL;
        if (pTail2 != NULL) pTail2->next = NULL;
        if (pTail3 != NULL) pTail3->next = NULL;
    }
    if (pTail1 != NULL) pTail1->next = pHead2;
    if (pTail2 != NULL) pTail2->next = pHead3;
    if (pTail3 != NULL) pTail3->next = NULL;
    if (pHead1 != NULL)
    {
        head = pHead1;
    }
    else if (pHead2 != NULL)
    {
        head = pHead2;
    }
    else
    {
        head = pHead3;
    }
    if (pTail3 != NULL)
    {
        tail = pTail3;
    }
    else if (pTail2 != NULL)
    {
        tail = pTail2;
    }
    else
    {
        tail = pTail1;
    }
}",1.0,11111
Singly_linked_list_5,1386669,2210535,"void reduceDuplicate(Node* root)
{   
    if (root->getNext() == nullptr || root == nullptr) {
        return;
    }
    Node* head = root;
    while (head != nullptr && head->getNext() != nullptr) {
        if (head->getData() == head->getNext()->getData()) {
            Node* duplicateNode = head->getNext();
            head->setNext(duplicateNode->getNext());
            delete duplicateNode;
        }
        else {
            head = head->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1386669,2210535,"int Train::allocate(int containerSize) {
    int carIndex = 1;
    TrainCar* currentCar = head->next;
    TrainCar* temp = nullptr;
    int result = 0;
    bool check = false;

    while (currentCar != nullptr) { 
        if (currentCar->remainingSpace >= containerSize) {
            check = true;
            if (!temp || temp->remainingSpace > currentCar->remainingSpace)  {
                temp = currentCar;
                result = carIndex;
            }
        }
        currentCar = currentCar->next;
        carIndex++;
    }

    if (temp) { 
        temp->remainingSpace -= containerSize;
    }

    if (check == true) {
        return result;
    }
    return -1;
}

int Train::totalRemainingSpace() {
    int totalSpace = 0;
        TrainCar* currentCar = head->next;

        while (currentCar != nullptr) {
            totalSpace += currentCar->remainingSpace;
            currentCar = currentCar->next;
        }

        return totalSpace;
}",1.0,11111
Singly_linked_list_7,1386669,2210535,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newnode = new Node(e, nullptr);
    if (head == nullptr && tail == nullptr && this->size() == 0) {
        head = newnode;
        tail = newnode;
        count++;
    }
    else {
        tail->next = newnode;
        tail = newnode;
        count++;
    }
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index < 0 || index > count) throw out_of_range("" "");
    if (index == count) {
        add(e);
    }
    else if (index == 0) {
        Node* newnode = new Node(e, nullptr);
        newnode->next = head;
        head = newnode;
        count++;
    }
    else {
        Node* temp = head;
        while (index != 1 && temp ) {
            temp = temp->next;
            index--;
        }
        Node* newnode = new Node(e, nullptr);
        newnode->next = temp->next;
        temp->next = newnode;
        count++;
    }
}

template<class T>
int SLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Singly_linked_list_8,1386669,2210535,"template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (this->count == 0) {
        return true;
    }
    else return false;
}
template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while (temp) {
        if (temp->data == item) {
            return i;
        }
        temp = temp->next;
        i++;
    }
    return -1;
}
template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if (indexOf(item) != -1) {
        return true;
    }
    else return false;
}
template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    Node* temp = head;
    while (index != 0 && temp) {
        temp = temp->next;
        index--;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    Node* temp = head;
    while (index != 0 && temp) {
        temp = temp->next;
        index--;
    }
    temp->data = e;
}",1.0,1111111111
Singly_linked_list_9,1386669,2210535,"
template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    if (index == 0) {
        Node* temp = head;
        T result1 = temp->data;
        head = temp->next;
        delete temp;
        count--;
        return result1;
    }
    else {
        Node* temp = head;
        while (index != 1 && temp) {
            temp = temp->next;
            index--;
        }
        Node* nextTemp = temp->next;
        T result2 = nextTemp->data;
        if (nextTemp->next == nullptr) {
            temp->next = nullptr;
            tail = temp;
            delete nextTemp;
        }
        else {
            temp->next = nextTemp->next;
            delete nextTemp;
        }
        count--;
        return result2;
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    if (!head) {
        return false;
    }

    if (head->data == item) {
        Node* temp = head;
        head = temp->next;
        delete temp;
        count--;

        if (!head) {
            tail = nullptr;
        }

        return true;
    }
    else {
        Node* temp = head;
        Node* prev = nullptr;

        while (temp && temp->data != item) {
            prev = temp;
            temp = temp->next;
        }

        if (!temp) {
            return false;
        }

        if (temp == tail) {
            tail = prev;
        }

        prev->next = temp->next;
        delete temp;
        count--;

        return true;
    }
}

template<class T>
void SLinkedList<T>::clear() {
    Node* temp = head;
    while (temp != nullptr) {
        Node* nextTemp = temp->next;
        delete temp;
        temp = nextTemp;
    }
    head = nullptr;
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1386669,2210535,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* Pprev = nullptr;
    LLNode* p;
    while (head != nullptr) {
        p = head;
        head = head->next;
        p->next = Pprev;
        Pprev = p;
    }
    head = Pprev;
    return head;
}

LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if (head == NULL || head->next == NULL) return head;
    int n = 0;
    LLNode* p0 = head;
    while (p0 != NULL)
    {
        n++;
        p0 = p0->next;
    }
    p0 = head;
    if (n % 2 == 1) n += 1;
    for (int i = 1; i < n/2; i++)
    {
        p0 = p0->next;
    }
    LLNode* p1 = p0->next;
    p0->next = NULL;
    p1 = reverseLinkedList(p1);
    p0 = head;
    while (p1 != NULL)
    {
        p0->val += p1->val;
        p0 = p0->next;
        p1 = p1->next;
    }
    return reverseLinkedList(head);


}",1.0,1111111111
Singly_linked_list_11,1386669,2210535,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    stack<LLNode*> nodeStack;
    LLNode *current = head;
    while (current != nullptr) {
         while (!nodeStack.empty() && current->val > nodeStack.top()->val) {
            nodeStack.top()->val = current->val;
            nodeStack.pop(); 
        }
        nodeStack.push(current);
        current = current->next;
    }
    while (!nodeStack.empty()) {
        nodeStack.top()->val = 0;
        nodeStack.pop();
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1386669,2210535,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode *Pprev = nullptr;
    LLNode *p;
    while (head != nullptr) {
        p = head;
        head = head->next;
        p->next = Pprev;
        Pprev = p;
    }
    head = Pprev;
    return head;
}",1.0,1111111111
Singly_linked_list_13,1386669,2210535,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (head == nullptr || k==0)   {
        return head;
    }
    int n=1;
    LLNode* countSize = head;
    while (countSize->next != nullptr)   {
        countSize = countSize->next;
        n++;
    }
    k = k % n;
    if (k == 0) {
        return head;
    }
    LLNode *Ntail = head;
    for (int i=1; i< n-k; i++) {
        Ntail = Ntail->next;
    }
    LLNode *Nhead = Ntail->next;
    Ntail->next = nullptr;
    
    countSize->next = head;
    head = Nhead;
    return head;
}",1.0,1111111111
Singly_linked_list_14,1386669,2210535,"void LinkedList::replace(LinkedList* linked_list, int low, int high) 
{
    if(low <= 0 && high >= this->size-1) 
    {   
        delete head;
        delete tail;
        this-> head = linked_list ->head;
        this->tail = linked_list ->tail;
        this->size = linked_list ->size;
    }
    else if(low <= 0 ) 
    {
        for(int i=0; i <= high ; i++)
        {
            this->head = this->head->next;
        }
        this->size -= (high+1);
        linked_list->tail->next = this->head;
        this->head = linked_list->head;
        this->size += linked_list->size;
    }
    else if(high >= size-1)
    {
        Node* temp = this->head;
        for(int i = 0; i< low-1; i++)
        {
            temp = temp->next;
        }
        this->size -= (size-1 - low +1);
        temp->next = nullptr;
        delete this->tail;
        this->tail = temp;
        this->tail->next = linked_list->head;
        this->tail = linked_list->tail;
        this ->size += linked_list->size;
    }
    else
    {
        Node* low1 = this->head;
        Node* low2 = this->head;
        for(int i=0; i<low-1 ; i++ )
        {
          low1 = low1->next;
        }
        for(int i = 0; i<= high ; i++)
        {
            low2 = low2->next;
        }
        low1->next = low2;
        this->size -= (high - low + 1 );
        linked_list->tail->next = low2;
        low1->next = linked_list->head;
        this->size+= linked_list->size;
    }

}",1.0,11111
Singly_linked_list_1,1387670,2211738,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode* head = new LLNode();
    LLNode* temp = head;
    int carry = 0;
    while(l0 != NULL || l1 != NULL || carry != 0){
        int val0 = (l0 == NULL) ? 0 : l0->val;
        int val1 = (l1 == NULL) ? 0 : l1->val;
        
        int sum = val0 + val1 + carry;
        
        temp->next = new LLNode();
        temp->next->val = sum%10;
        carry = sum/10;
        temp = temp->next;
        
        l0 = (l0 == NULL) ? NULL : l0->next;
        l1 = (l1 == NULL) ? NULL : l1->next;
    }
    return head->next;
}",1.0,111111111111111
Singly_linked_list_2,1387670,2211738,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1387670,2211738,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1387670,2211738,"void reduceDuplicate(Node* root)
{
}",0.2,0000101000
Singly_linked_list_7,1387670,2211738,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if(this->count == 0){
        head = new Node(e, NULL);
        tail = head;
        this->count++;
        return;
    }
    tail->next = new Node(e, NULL);
    tail = tail->next;
    this->count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index == 0 && this->count == 0){
        add(e);
        return;
    }else if(index == this->count){
        add(e);
        return;
    }else if(index == 0 && this->count != 0){
        Node* temp = new Node(e, head);
        head = temp;
        this->count++;
        return;
    }
    Node* temp = new Node(e, NULL);
    Node* temp1 = head;
    for(int i = 0; i < index-1; i++){
        temp1 = temp1->next;
    }
    temp->next = temp1->next;
    temp1->next = temp;
    this->count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}
",1.0,1111111111
Singly_linked_list_8,1387670,2211738,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    // Node* temp = this->head;
    // for(int i = 0; i < index; i++){
    //     temp = temp->next;
    // }
    // return temp->data;
    Node* temp=this->head;

    for (int i=0;i<index;i++){
    
        temp=temp->next;
    
    }
    
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    // if(head == NULL) return;
    // Node* temp = this->head;
    // for(int i = 0; i < index; i++){
    //     temp = temp->next;
    // }
    // temp->data = e;
    Node* temp=this->head;

    for (int i=0;i<index;i++){
    
    temp=temp->next;
    
    }
    
    temp->data=e;
    
    return;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(this->count == 0) return true;
    return false;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    // if(head == NULL && this->count == 0) return false;
    // Node* temp = this->head;
    // for(int i = 0; i < this->count; i++){
    //     if(temp->data == item) return i;
    //     temp = temp->next;
    // }
    // return -1;
    Node* temp=this->head;

    for (int i=0;i<this->count;i++){
    
    if (temp->data==item) return i;
    
    temp=temp->next;
    
    }
    
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    // if(head == NULL && this->count == 0) return false;
    // Node* temp = this->head;
    // for(int i = 0; i < this->count; i++){
    //     if(temp->data == item) return true;
    //     temp = temp->next;
    // }
    // return false;
    Node* temp=this->head;

    for (int i=0;i<this->count;i++){
    
    if (temp->data==item) return 1;
    
    temp=temp->next;
    
    }
    
    return 0;
}",0.8,111111110
Singly_linked_list_9,1387670,2211738,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(index == 0){
        T res = head->data;
        Node* temp = head;
        head = head->next;
        delete temp;
        this->count --;
        return res;
    }
    Node* temp = head;
    for(int i = 0; i < index-1; i++){
        temp = temp->next;
    }
    T res = temp->next->data;
    temp->next = temp->next->next;
    Node* temp1 = temp->next;
    delete temp1;
    this->count--;
    return res;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* temp = head;
    while(temp != NULL){
        if(item == temp->data) return true;
        temp = temp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* temp = head;
    while(temp != NULL){
        Node* temp1 = temp;
        temp = temp->next;
        delete temp1;
    }
    this->count = 0;
}

",0.1,10
Singly_linked_list_1,1389519,2212303,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode dummy(0);  // Dummy node to simplify list handling
    LLNode* current = &dummy;
    int carry = 0;

    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;

        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }

        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }

        carry = sum / 10;  // Calculate carry for the next iteration
        sum = sum % 10;    // Calculate the current digit

        // Create a new node with the current digit and add it to the result list
        current->next = new LLNode(sum, nullptr);
        current = current->next;
    }

    return dummy.next;
}",1.0,111111111111111
Singly_linked_list_2,1389519,2212303,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
SLinkedList<Term>::Iterator it;
    int index = 0;
    if (term.coeff == 0.0)
        return;
    for (it = this->terms->begin(); it != this->terms->end(); ++it) {
        if ((*it).exp < term.exp) {
            this->terms->add(index, term);
            return;
        } else if ((*it).exp == term.exp) {
            (*it).coeff += term.coeff;
            if ((*it).coeff == 0.0)
                this->terms->removeAt(index);
            return;
        }
        index++;
    }
    if (term.coeff != 0.0)
        this->terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff, exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_1,1390624,2211876,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    int carry = 0;
    LLNode dummyHead; 
    LLNode* current = &dummyHead;

    while (l0 || l1 || carry) {
        int sum = carry;
        if (l0) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1) {
            sum += l1->val;
            l1 = l1->next;
        }

        carry = sum / 10;
        current->next = new LLNode(sum % 10);
        current = current->next;
    }
    return dummyHead.next;
    // STUDENT ANSWER
}",1.0,111111111111111
Singly_linked_list_1,1390899,2211821,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
     LLNode x;
    LLNode* me =&x;
    int carry=0;
    while (l0||l1||carry) {
        int sum = carry;
        if(l0){
            sum+=l0->val;
            l0=l0->next;
        }
        if (l1){
            sum+=l1->val;
            l1=l1->next;
        }
        carry =sum/10;
        me->next = new LLNode(sum%10);
        me=me->next;
    }
    return x.next;
}",1.0,111111111111111
Singly_linked_list_2,1390899,2211821,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if (term.coeff == 0) return;
    if(this->terms->size()==0) {
        this->terms->add(term);
        return;
    }
    SLinkedList<Term>::Iterator it;\
    int index=0;
    for(it = this->terms->begin();it != this->terms->end();it++){
        if((*it).exp == term.exp ){
            (*it).coeff +=term.coeff;
            if((*it).coeff == 0) this->terms->removeAt(index);
            return;
        }
        if((*it).exp < term.exp ) {
            this->terms->add(index,term);
            return;
        }
        index++;
    }
    this->terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term i(coeff,exp);
    this->insertTerm(i);
}",1.0,11111
Singly_linked_list_3,1390899,2211821,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
   this->pList = pList; 
    if (begin) {
        if (pList) {
            index = 0; 
            current = pList->head; 
        }
        else{
            index = -1; 
            current = nullptr; 
        }
    }
    else {
        current = nullptr;
        if (pList) index = pList->size();
        else index = 0; 
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
     if (this != &iterator) {
        this->current = iterator.current; 
        this->index = iterator.index; 
        this->pList = iterator.pList; 
    }
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (this->current == nullptr) throw std::out_of_range(""""); 
    Node* p = pList->head; 
    for (int i = 1; i < this->index; i++) p = p->next;  
    if (index == 0) p = nullptr; 
    this->pList->removeAt(this->index); 
    this->current = p; 
    index--; 
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
       if (this->current == nullptr) throw std::out_of_range(""""); 
    this->current->data = e; 
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
      if (!current) throw std::out_of_range("""");  
    return this->current->data; 
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
     if (this->pList == iterator.pList && this->current == iterator.current && this->index == iterator.index) return true; 
    return false; 
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
      if (this->current == nullptr) throw std::out_of_range(""""); 
    current = current->next; 
    index++; 
    if (current == nullptr) current = pList->head; 
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    return ++(*this);
}",0.8,11110
Singly_linked_list_4,1390899,2211821,"

void LinkedList::partition(int k) {  
    Node *S_Head, *S_Tail, *E_Head, *E_Tail, *B_Head, *B_Tail; 
    S_Head = S_Tail = nullptr;   
    E_Head = E_Tail = nullptr;  
    B_Head = B_Tail = nullptr;   
    Node *CUR = head; 
    int newSize = 0; 
    while(CUR){    
        if(CUR->value < k) {   
            if(!S_Head){     
                S_Head = S_Tail = new Node(CUR);   
                }                        else{     
                    S_Tail->next = new Node(CUR);   
                    S_Tail = S_Tail->next;         
                    }          
                    S_Tail->next = nullptr;     
                    }  else{     
                        if(CUR->value == k){    
                            if(!E_Head){         
                                E_Head = E_Tail = new Node(CUR);    
                                }
                                else{
                                    E_Tail->next = new Node(CUR); 
                                    E_Tail = E_Tail->next;
                                    }
                                    E_Tail->next = nullptr;
                                    }
                                    else{
                                        if(!B_Head){
                                            B_Head = B_Tail = new Node(CUR);
                                            } 
                                            else{
                                                B_Tail->next = new Node(CUR);
                                                B_Tail = B_Tail->next;
                                                }                
                                                B_Tail->next = nullptr;
                                                }        
                        
                    }
                    newSize++; 
                    CUR = CUR->next;
                    }   
                    if(S_Head){
                        head = S_Head; 
                        if(E_Head){    
                            S_Tail->next = E_Head;   
                            E_Tail->next = B_Head;   
                            if(B_Tail) tail = B_Tail;   
                            else tail = E_Tail;     
                            }        else{        
                                S_Tail->next = B_Head;   
                                if(B_Tail) tail = B_Tail;  
                                else tail = S_Tail;     
                                }           
                                }    else{   
                                    if(E_Head){ 
                                        E_Tail->next = B_Head; 
                                        head = E_Head;   
                                        if(B_Tail) tail = B_Tail;  
                                        else tail = E_Tail;   
                                        }        else{     
                                            tail = B_Tail;    
                                            }    }}",1.0,11111
Singly_linked_list_5,1390899,2211821,"void reduceDuplicate(Node* root)
{
    if (root == nullptr || root->getNext() == nullptr) {
        return;
    }

    Node* current = root;

    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicateNode = current->getNext();
            current->setNext(duplicateNode->getNext());
            delete duplicateNode;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1390899,2211821,"int Train::allocate(int containerSize) {
 int min = containerSize;
    TrainCar* current = head->next;
    int carIndex = 1;
    int mincar = -1;
    TrainCar* cur = nullptr;

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize) {
            if (mincar == -1) {
                min = current->remainingSpace;
                cur = current;
                mincar = carIndex;
            }
            else if(min >current->remainingSpace) {
                min = current->remainingSpace;
                cur = current;
                mincar = carIndex;
            }
        }
        current = current->next;
        carIndex++;
    }

    if (mincar != -1) {
        cur->remainingSpace -= containerSize;
    }

    return mincar;
}

int Train::totalRemainingSpace() {
 int totalSpace = 0;
    TrainCar* current = head->next;

    while (current != nullptr) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }

    return totalSpace;
}",1.0,11111
Singly_linked_list_7,1390899,2211821,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newnode = new Node(e,nullptr);
    if(count == 0) {
        head =tail = newnode;
    } else {
        tail->next =newnode;
        tail=newnode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        throw std::out_of_range(""Index out of range"");
    }

    if (index == 0) {
        Node* newNode = new Node(e, head);
        head = newNode;
        if (count == 0) {
            tail = newNode;
        }
        count++;
    } else
    if (index == count)  add(e);
     else {
        Node* prev = nullptr;
        Node* current = head;
        for (int i = 0; i < index; i++) {
            prev = current;
            current = current->next;
        }
        Node* newNode = new Node(e, current);
        prev->next = newNode;
        count++;
    }
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1390899,2211821,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count || empty()) {
        throw std::out_of_range(""Index out of range"");
    }
    if (index == 0) return head->data;
    Node* temp = head;
    for(int i =0;i<index;i++){
        temp =temp->next;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
     if (index < 0 || index >= count || empty()) {
        throw std::out_of_range(""Index out of range"");
    }
    if (index == 0) head->data =e;
    Node* temp = head;
    for(int i =0;i<index;i++){
        temp =temp->next;
    }
    temp->data =e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    int x = 0; // Initialize x to 0
    while (current) {
        if (current->data == item) {
            return x;
        }
        current = current->next;
        x++; // Increment x for each iteration
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
      return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1390899,2211821,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count || empty()) {
        throw std::out_of_range(""Index out of bounds"");
    }

    Node* current = head;
    Node* previous = nullptr;
    
    for (int i = 0; i < index; ++i) {
        previous = current;
        current = current->next;
    }

    T removedValue = current->data;

    if (previous) {
        previous->next = current->next;
    } else {
        head = current->next;
    }

    if (current == tail) {
        tail = previous;
    }

    delete current;
    --count;
    return removedValue;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    Node* previous = nullptr;

    while (current) {
        if (current->data == item) {
            if (previous) {
                previous->next = current->next;
            } else {
                head = current->next;
            }

            if (current == tail) {
                tail = previous;
            }

            delete current;
            --count;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;
    
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    count = 0;
    tail = nullptr;
}

",1.0,1111111111
Singly_linked_list_10,1390899,2211821,"LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode *cur = head;
    
    int n = 0; // get_length of List
    
    while(cur){
        n++;
        cur = cur->next;
    }
    
    if(n == 0) return nullptr;
    
    cur = head;
    
    LLNode *HEAD = nullptr, *newNode = nullptr;
    
    for(int i = 0; i <= n/2; i++){
        
        
        LLNode *TMP = cur;
        for(int j = i; j < (n - i - 1); j++){
            TMP = TMP->next;
        }
        int Sum = 0;
        if(cur == TMP){
            if(n % 2 == 1) Sum+= cur->val;  
            if(n % 2 == 0) break;
        }
        else{
            Sum+= cur->val + TMP->val;
        }
        newNode = new LLNode(Sum, HEAD);
        HEAD = newNode;
        cur = cur->next;
    }
    
    return HEAD;
}",1.0,1111111111
Singly_linked_list_11,1390899,2211821,"LLNode* replaceFirstGreater(LLNode* head) {
    if (!head) {
        return nullptr; // Handle the case of an empty list
    }

    LLNode* current = head;

    while (current) {
        LLNode* nextNode = current->next;
        bool foundGreater = false;

        while (nextNode) {
            if (nextNode->val > current->val) {
                current->val = nextNode->val;
                foundGreater = true;
                break;
            }
            nextNode = nextNode->next;
        }

        if (!foundGreater) {
            current->val = 0;
        }

        current = current->next;
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1390899,2211821,"LLNode* reverseLinkedList(LLNode* head) {
    if(head == nullptr) return head;
    LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* nextNode = nullptr;

    while (current != nullptr) {
        nextNode = current->next;
        current->next = prev;
        prev = current;
        current = nextNode;
    }
    return prev;
    
}",1.0,1111111111
Singly_linked_list_13,1390899,2211821,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || k==0) return head;
    int len =1;
    LLNode* current = head;
    while (current->next != nullptr) {
        current = current->next;
        len++;
    }
    k = k% len;
    if (k==0) return head;
    current-> next =head;
     for (int i = 0; i < len - k - 1; i++) {
        head = head->next;
    }
    LLNode* newHead = head->next;
    head->next = nullptr;
    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1390899,2211821,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
  if (linked_list == nullptr || low > high || high < 0) {
        return;
    }
    Node* current = this->head;
    Node* prev = nullptr;
    int currentPosition = 0;
    while (currentPosition < low  && current != nullptr) {
        prev = current;
        current = current->next;
        currentPosition++;
    }
    if (low - 1 < 0) {
        this->head = linked_list->head;
    }
    else {
        prev->next = linked_list->head;
    }
    while (currentPosition < high+1 && current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
        currentPosition++;
    }
    if (high >= this->size) {
        this->tail = linked_list->tail;
    }
    this->size = currentPosition;
    if (current != nullptr) {
        linked_list->tail->next = current;
    }
    else {
        linked_list->tail->next = nullptr;
        this->tail = linked_list->tail;
    }
    this->size += linked_list->size;
    linked_list->head = nullptr;
    linked_list->tail = nullptr;
    linked_list->size = 0;
}",1.0,11111
Singly_linked_list_1,1390910,2212935,"LLNode* add(LLNode* node0, LLNode* node1, int carry){
    if (!node0 && !node1 && !carry) return NULL;
    int sum = (node0? node0->val:0) + (node1? node1->val:0) + carry;
    LLNode * node = new LLNode(sum % 10);
    if (node){
    node->next = add((node0?node0->next:NULL), (node1?node1->next:NULL), sum/10);
    return node;
    }
    return NULL;
}
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    return add(l0, l1, 0);
}",0.8,1111111111110
Singly_linked_list_2,1390910,2212935,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff, exp);
    insertTerm(term);
}",0.2,00010
Singly_linked_list_3,1390910,2212935,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
     this->pList = pList;
            if (begin)
            {
                if (pList != NULL)
                    current = pList->head;
                else
                    current = NULL;
                index = 0;
            }
            else
            {
                current = NULL;
                if (pList != NULL)
                    index = pList->size();
                else
                    index = 0;
            }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
            this->current = iterator.current;
            this->index = iterator.index;
            this->pList = iterator.pList;
            return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == NULL)
        throw std::out_of_range(""Segmentation fault!"");

    if (pList == NULL)
        return;

    if (current == pList->head)
    {
        pList->head = current->next;
        delete current;
        current = NULL;
        index = -1;
        pList->count--;
        return;
    }

    Node *prev = pList->head;
    while (prev->next != NULL && prev->next != current)
    {
        prev = prev->next;
    }

    if (prev->next == NULL)
        throw std::out_of_range(""Segmentation fault!"");

    prev->next = current->next;
    delete current;
    current = prev;
    index--;
    pList->count--;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current)
        throw std::out_of_range(""Segmentation fault!"");

    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current)
        throw std::out_of_range(""Segmentation fault!"");

    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return (current != iterator.current || index != iterator.index);
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!pList)
        throw std::out_of_range(""Segmentation fault!"");

    if (current) {
        current = current->next;
        index++;
    }
    else {
        if (index == -1) {
            current = pList->head;
            index = 0;
        }
        else {
            throw std::out_of_range(""Segmentation fault!"");
        }
    }

    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,11111
Singly_linked_list_4,1390910,2212935,"void LinkedList::partition(int k) {
if (head == NULL || head->next == NULL)
        return; 

    Node *group1Head = NULL;
    Node *group1Tail = NULL;
    Node *group2Head = NULL;
    Node *group2Tail = NULL;
    Node *group3Head = NULL;
    Node *group3Tail = NULL;

    Node *current = head;
    while (current != NULL)
    {
        Node *nextNode = current->next;
        current->next = NULL; 

        if (current->value < k)
        {
            if (group1Head == NULL)
            {
                group1Head = current;
                group1Tail = current;
            }
            else
            {
                group1Tail->next = current;
                group1Tail = current;
            }
        }
        else if (current->value == k)
        {
            if (group2Head == NULL)
            {
                group2Head = current;
                group2Tail = current;
            }
            else
            {
                group2Tail->next = current;
                group2Tail = current;
            }
        }
        else
        {
            if (group3Head == NULL)
            {
                group3Head = current;
                group3Tail = current;
            }
            else
            {
                group3Tail->next = current;
                group3Tail = current;
            }
        }

        current = nextNode;
    }

    head = NULL; 

    if (group1Head != NULL)
    {
        head = group1Head;
        tail = group1Tail;
    }

    if (group2Head != NULL)
    {
        if (head == NULL)
        {
            head = group2Head;
            tail = group2Tail;
        }
        else
        {
            tail->next = group2Head;
            tail = group2Tail;
        }
    }

    if (group3Head != NULL)
    {
        if (head == NULL)
        {
            head = group3Head;
            tail = group3Tail;
        }
        else
        {
            tail->next = group3Head;
            tail = group3Tail;
        }
    }
}",1.0,11111
Singly_linked_list_5,1390910,2212935,"void reduceDuplicate(Node* root)
{
    if (root == nullptr)
        return;

    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicateNode = current->getNext();
            current->setNext(duplicateNode->getNext());
            delete duplicateNode;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1390910,2212935,"int Train::allocate(int containerSize) {
    TrainCar* current = head->next;
    TrainCar* selectedCar = nullptr;
    int selectedIndex = -1;
    int index = 1;

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize) {
            if (selectedCar == nullptr || current->remainingSpace < selectedCar->remainingSpace) {
                selectedCar = current;
                selectedIndex = index;
            }
        }
        current = current->next;
        index++;
    }

    if (selectedCar != nullptr) {
        selectedCar->remainingSpace -= containerSize;
    }

    return selectedIndex;
}

int Train::totalRemainingSpace() {
    int sum = 0;
    for (TrainCar * p = head; p != nullptr; p = p->next){
        sum += p->remainingSpace;
    }
    return sum;
}",1.0,11111
Singly_linked_list_1,1391153,2211170,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
            LLNode* dummyHead = new LLNode(0);
        LLNode* curr = dummyHead;
        int carry = 0;
        while (l0 != NULL || l1 != NULL || carry != 0) {
            int x = l0 ? l0->val : 0;
            int y = l1 ? l1->val : 0;
            int sum = carry + x + y;
            carry = sum / 10;
            curr->next = new LLNode(sum % 10);
            curr = curr->next;
            l0 = l0 ? l0->next : nullptr;
            l1 = l1 ? l1->next : nullptr;
        }
        return dummyHead->next;
}",1.0,111111111111111
Singly_linked_list_2,1391153,2211170,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if (term.coeff != 0){
        if (terms->size() == 0 || terms->get(terms->size() - 1).exp > term.exp)
        terms->add(term);
    else{
        int i = 0;
        SLinkedList<Term>::Iterator it;
        for (it = this->terms->begin(); it !=this->terms->end(); it++){
            if (term.exp == (*it).exp){
                if (term.coeff + (*it).coeff == 0) it.remove();
                else it.set(Term(term.coeff + (*it).coeff, term.exp));
                break;
            }
        
            if (term.exp > (*it).exp){
            terms->add(i, term);
            break;
        }
        i++;
    }
    }
}
    
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff, exp);
    insertTerm(term);
}",0.9,11111
Singly_linked_list_4,1391153,2211170,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_1,1391236,2210034,"#include<cmath>
LLNode* addLinkedList(LLNode* l0, LLNode* l1){
    LLNode dummy;
    LLNode* tail = &dummy;
    int carry = 0;
    while (l0 || l1 || carry) {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        carry = sum / 10;
        tail->next = new LLNode(sum % 10);
        tail = tail->next;
        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }
    return dummy.next;
}",0.95,111111111111111
Singly_linked_list_2,1391408,2013048,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_1,1392001,2210103,"
bool addLastLL(LLNode*& head, int data, LLNode*& tail)
{
    LLNode* p = new LLNode(data, nullptr);
    if (head != nullptr)
    {
        tail->next = p;
    }
    else
    {
        head = p;
    }
    return true;
}

LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    int r = 0;
    int value = 0;
    LLNode* result = nullptr;
    LLNode* tail = nullptr;
    while (l0 != nullptr || l1 != nullptr || r != 0)
    {
        if (l0 == nullptr && l1 != nullptr)
        {
            value = r + l1->val;
            l1 = l1->next;
            r = 0;
        }
        else if (l1 == nullptr && l0 != nullptr)
        {
            value = r + l0->val;
            l0 = l0->next;
            r = 0;
        }
        else if (l1 != nullptr && l0 != nullptr)
        {
            value = r + l1->val + l0->val;
            l0 = l0->next;
            l1 = l1->next;
            r = 0;
        }
        if (value >= 10)
        {
            r = value / 10;
            value = value % 10;
        }
        else
        {
            value = r + value;
            r = 0;
        }
        addLastLL(result, value, tail);
        if (tail) {
            tail = tail->next;
        }
        else
        {
            tail = result;
        }
        value = 0;
    }
    return result;
}",1.0,111111111111111
Singly_linked_list_2,1392001,2210103,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_3,1392124,2210200,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    
    if (begin)
    {
        if (pList != NULL)
        {
            this->current = pList->head;
            this->index = 0;
        }
        else
        {
            this->current = NULL;
            this->index = -1;
        }
    }
    else
    {
        this->current = NULL;
        
        if (pList != NULL)
        {
            this->index = pList->size();
        }
        else
        {
            this->index = 0;
        }
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
    
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove, current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == NULL)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        Node* nodeToRemove = current;
        
        // If removing head node
        if (nodeToRemove == pList->head)
        {
            pList->head = pList->head->next;
            current = NULL;
            index = -1;
        }
        else
        {
            Node* prevNode = pList->head;
            while (prevNode != NULL && prevNode->next != nodeToRemove)
            {
                prevNode = prevNode->next;
            }
            
            // Update current to previous node
            current = prevNode;
            
            if (nodeToRemove == pList->tail)
            {
                pList->tail = prevNode;
            }
            
            // Link previous node to next node
            if (prevNode != NULL)
            {
                prevNode->next = nodeToRemove->next;
            }
        }
        
        delete nodeToRemove;
        pList->count--;
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        current->data = e;
    }
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current != NULL){
        return current->data;
    }
    else{
        throw std::out_of_range(""Segmentation fault!"");
    }
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if(this->current == iterator.current || this->index == iterator.index){
        return false;
    }
    return true;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL && index == -1)
    {
        current = pList->head;
        index = 0;
    }
    else if (current == NULL)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current = current->next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator iterator = *this;
    
    if (current == NULL && index == -1)
    {
        current = pList->head;
        index = 0;
    }
    else if (current == NULL)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current = current->next;
        index++;
    }
    
    return iterator;
}",0.8,11110
Singly_linked_list_1,1392360,2210578,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
     LLNode* dummy = new LLNode(0);
    LLNode* curr = dummy;
    int carry = 0;
    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;
        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        curr->next = new LLNode(sum % 10);
        carry = sum / 10;
        curr = curr->next;
    }
    return dummy->next;
}",1.0,111111111111111
Singly_linked_list_2,1392360,2210578,"void Polynomial::insertTerm(const Term& term) {
    if (term.coeff == 0.0) return; // Ignore zero coefficients

    SLinkedList<Term>::Iterator it;
    int i = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++, i++) {
        if ((*it).exp < term.exp) {
            this->terms->add(i, term);
            return;
        }
        else if ((*it).exp == term.exp) {
            (*it).coeff += term.coeff;
            if ((*it).coeff == 0.0) {
                this->terms->removeAt(i);
            }
            return;
        }
    }

    this->terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    insertTerm(Term(coeff, exp));
}
",1.0,11111
Singly_linked_list_3,1392360,2210578,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */this->pList = pList;
    if (begin && pList != NULL) {
        this->current = pList->head;
        this->index = 0;
    } else {
        this->current = NULL;
        this->index = pList == NULL ? 0 : pList->size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */ this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    current = current->next;
    pList->removeAt(index);
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */ if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */ if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */ if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    return current->data;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */ if (current == NULL || current->next == NULL) throw std::out_of_range(""Segmentation fault!"");
    current = current->next;
    index++;
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */ Iterator iterator = *this;
    ++*this;
    return iterator;
}",0.8,11110
Singly_linked_list_4,1392360,2210578,"void LinkedList::partition(int k) {
     Node* smallerHead = NULL;
    Node* smallerLast = NULL;
    Node* equalHead = NULL;
    Node* equalLast = NULL;
    Node* greaterHead = NULL;
    Node* greaterLast = NULL;

    Node* current = head;
    while (current != NULL) {
        Node* nextNode = current->next;
        current->next = NULL;
        if (current->value < k) {
            if (smallerHead == NULL) {
                smallerHead = smallerLast = current;
            } else {
                smallerLast->next = current;
                smallerLast = current;
            }
        } else if (current->value == k) {
            if (equalHead == NULL) {
                equalHead = equalLast = current;
            } else {
                equalLast->next = current;
                equalLast = current;
            }
        } else {
            if (greaterHead == NULL) {
                greaterHead = greaterLast = current;
            } else {
                greaterLast->next = current;
                greaterLast = current;
            }
        }
        current = nextNode;
    }

    if (smallerHead == NULL) {
        if (equalHead == NULL) {
            head = greaterHead;
        } else {
            equalLast->next = greaterHead;
            head = equalHead;
        }
    } else {
        if (equalHead == NULL) {
            smallerLast->next = greaterHead;
        } else {
            smallerLast->next = equalHead;
            equalLast->next = greaterHead;
        }
        head = smallerHead;
    }
}",0.8,10111
Singly_linked_list_5,1392360,2210578,"void reduceDuplicate(Node* root)
{
    if (root == nullptr || root->getNext() == nullptr) {
        return;
    }

    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* nextNext = current->getNext()->getNext();
            delete current->getNext();
            current->setNext(nextNext);
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1392360,2210578,"int Train::allocate(int containerSize) {
TrainCar* current = this->head->next;
    TrainCar* minSpaceCar = nullptr;
    int index = 1;
    int minIndex = -1;

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize) {
            if (minSpaceCar == nullptr || current->remainingSpace < minSpaceCar->remainingSpace) {
                minSpaceCar = current;
                minIndex = index;
            }
        }
        current = current->next;
        index++;
    }

    if (minSpaceCar == nullptr) {
        return -1;
} minSpaceCar->remainingSpace -= containerSize;

    return minIndex;
}
int Train::totalRemainingSpace() {
int totalSpace = 0;
    TrainCar* current = this->head->next;

    while (current != nullptr) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }

    return totalSpace;
}",1.0,11111
Singly_linked_list_7,1392360,2210578,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if (count == 0) {
        head = tail = newNode;
    } else {
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        index= count;
    }
    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head = newNode;
        if (tail == NULL) {
            tail = newNode;
        }
    } else {
        Node* prev = head;
        for (int i = 0; i < index - 1; i++) {
            prev = prev->next;
        }
        newNode->next = prev->next;
        prev->next = newNode;
        if (newNode->next == NULL) {
            tail = newNode;
        }
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1392360,2210578,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count)
        index=count;
    Node* temp = head;
    for (int i = 0; i < index; i++)
        temp = temp->next;
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count)
        throw std::out_of_range(NULL);
    Node* temp = head;
    for (int i = 0; i < index; i++)
        temp = temp->next;
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
     Node* temp = head;
    int index = 0;
    while (temp != NULL) {
        if (temp->data == item)
            return index;
        temp = temp->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
     return indexOf(item) != -1;
}",0.8,111111110
Singly_linked_list_9,1392360,2210578,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
     if (index < 0 || index >= count)
       index=count;
    Node* temp = head;
    Node* prev = NULL;
    for (int i = 0; i < index; i++) {
        prev = temp;
        temp = temp->next;
    }
    T data = temp->data;
    if (prev == NULL) {
        head = temp->next;
    } else {
        prev->next = temp->next;
    }
    if (temp == tail) {
        tail = prev;
    }
    delete temp;
    count--;
    return data;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
     Node* temp = head;
    Node* prev = NULL;
    while (temp != NULL) {
        if (temp->data == item) {
            if (prev == NULL) {
                head = temp->next;
            } else {
                prev->next = temp->next;
            }
            if (temp == tail) {
                tail = prev;
            }
            delete temp;
            count--;
            return true;
        }
        prev = temp;
        temp = temp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != NULL) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    tail = NULL;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1392360,2210578,"LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    LLNode *slow = head, *fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    LLNode *prev = nullptr, *curr = slow, *next;
    while (curr != nullptr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    LLNode *first = head, *second = prev;
    while (second->next != nullptr) {
        LLNode *temp = first->next;
        first->next = second;
        first = temp;

        temp = second->next;
        second->next = first;
        second = temp;
    }

    return head;
}",0.1,0010000000
Singly_linked_list_2,1392369,1912532,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_2,1392375,2210458,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1392375,2210458,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1392375,2210458,"void reduceDuplicate(Node* root)
{
}",0.2,0000101000
Singly_linked_list_1,1392377,2212651,"int takeNum(LLNode* l,int i=1){
    if(!l) return 0;
    // if(!(l->next)) return i*(l->data);
    return takeNum(l->next,i*10)+i*(l->val);
}
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode* res=nullptr;
    LLNode* iter=nullptr;
    // cout<<takeNum(l0);
    int sum=takeNum(l0)+takeNum(l1);
    if(sum==0) return res;
    string s=to_string(sum);
    int n=s.length();
    for(int i=n-1;i>=0;i--){
        LLNode* temp=new LLNode((s[i]-'0'),nullptr);
        if(!res) {
            res=temp;
            iter=res;
        }
        else{
            iter->next=temp;
            iter=iter->next;
        }
    }
    return res;
}",0.32,111110000000000
Singly_linked_list_1,1392431,2110501,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    if (l0 == NULL && l1 == NULL)           return NULL;
    else if (l0 == NULL && l1 != NULL)      return l1;
    else if (l0 != NULL && l1 == NULL)      return l0;
    LLNode* head = new LLNode(-1,NULL);
    LLNode* tail = head;
    int S;
    int carry = 0;
    while (true)
    {
        S= l0->val + l1->val + carry;
        if (S >= 10)
        {
            S %= 10;
            carry = 1;
        }
        else carry=0;
        LLNode* pNew = new LLNode(S,NULL);
        if (head->val == -1)    head = tail=pNew;
        else
        {
            tail->next = pNew;
            tail = pNew;
        }
        if(l0->next == NULL && l1->next == NULL)
        {
            if (carry == 1)
            {
                LLNode*pNew = new LLNode(1,NULL);
                tail->next = pNew;
                tail = pNew;
            }
            break;
        }
        
        if (l0->next != NULL)       l0 = l0->next;
        else                        l0->val = 0;
        if (l1->next != NULL)       l1 = l1->next;
        else                        l1->val = 0;
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1392431,2110501,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.exp < 0 || term.coeff == 0);
    else
    {
    SLinkedList<Term>::Iterator cur;
    int count = 0;
    for (cur=this->terms->begin();cur!=this->terms->end();cur++) 
    {
        Term tmp = *cur;
        if(tmp.exp == term.exp)
        {
            tmp.coeff += term.coeff;
            if(tmp.coeff != 0)      cur.set(tmp);
            else                    cur.remove();
            return;
        }
        else 
        {
            if(tmp.exp < term.exp)    break;
        }
        count++;
    }
    this->terms->add(count,term);
}
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    if(exp < 0 ||coeff ==0);
    else
    {
    SLinkedList<Term>::Iterator cur;
    int count = 0;
    for (cur = this->terms->begin(); cur != this->terms->end(); cur++) 
    {
        Term tmp = *cur;
        if(tmp.exp == exp)
        {
            tmp.coeff += coeff;
            if(tmp.coeff != 0.0000000f) cur.set(tmp);
            else                        cur.remove();
            return;
        }
        else 
        {
            if(tmp.exp < exp) break;
        }
        count++;
    }
    Term tmp(coeff,exp);
    this->terms->add(count,tmp);
    }
}",1.0,11111
Singly_linked_list_3,1392431,2110501,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList=pList;
    if(begin==true)
    {
        if(this->pList!=NULL)
        {
            this->index=0;
            this->current=this->pList->head;
        }
        else
        {
            this->index=-1;
            this->current=NULL;
        }
    }
    else
    {
        this->current=NULL;
        if(this->pList!=NULL)   this->index=this->pList->count;
        else                    this->index=0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current=iterator.current;
    this->index=iterator.index;
    this->pList=iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    if (this->index == 0)
     {
         pList->removeAt(0);
         this->current=NULL;
         this->index = -1;
     }
     pList->removeAt(this->index);
     this->index--;
     Node *cur=pList->head;
     for (int i=0;i<this->index;i++) 
     {
         cur=cur->next;
     }
     this->current=cur;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    else                    this->current->data=e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    else                    return this->current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return !((this->current == iterator.current) && (this->index == iterator.index));
    
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(this->current==NULL&&this->index==this->pList->count) throw std::out_of_range(""Segmentation fault!"");
    else if(this->index==-1&&current==NULL)
    {
        this->current=this->pList->head;
        this->index++;
    } 
    else if(current !=NULL)
    {
        this->current=this->current->next;
        this->index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    Iterator tmp=*this;
    ++*this;
    return tmp;
    
}",1.0,11111
Singly_linked_list_4,1392431,2110501,"void LinkedList::partition(int k) {
  Node *result = NULL;
  Node *pre = new Node(0);
  Node *in = new Node(0);
  Node *post = new Node(0);
  Node *node1 = in;
  Node *node2 = post;
  Node *cur = head;
  head = pre;
  while (cur!=NULL) 
  {
    if (cur->value < k) 
    {
        pre->next = cur;
        pre = cur;
    } 
    else if (cur->value == k) 
    {
        in->next = cur;
        in = cur;
    } 
    else 
    {
        post->next = cur;
        post = cur;
    }
    cur = cur->next;
  }
  if (head != pre) 
  {
    if (result == NULL) result = head->next;
  }
  if (node1 != in) 
  {
    if (result == NULL) result = node1->next;
    else 
    {
        pre->next = node1->next;
    }
    pre = in;
  }
  if (node2 != post) 
  {
    if (result == NULL)     result = node2->next;
    else 
    {
      pre->next = node2->next;
    }
    pre = post;
  }
  head = result;
  tail = pre;
}",1.0,11111
Singly_linked_list_5,1392431,2110501,"void reduceDuplicate(Node* root) {
    if (root == nullptr || root->getNext() == nullptr)
        return;

    Node* current = root;
    Node* nextNode = root->getNext();

    while (nextNode != nullptr) {
        if (current->getData() == nextNode->getData()) {
            Node* temp = nextNode;
            current->setNext(nextNode->getNext());
            nextNode = nextNode->getNext();
            delete temp;
        } else {
            current = nextNode;
            nextNode = nextNode->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1392431,2110501,"int Train::allocate(int containerSize) {
    TrainCar* currentCar = head->next;  
    int smallestIndex = -1;             
    while (currentCar != nullptr) {
        if (currentCar->remainingSpace >= containerSize) {
            if (smallestIndex == -1 || smallestIndex > currentCar->remainingSpace) {
                smallestIndex = currentCar->remainingSpace;
            }
        }
        currentCar = currentCar->next;
    }

    if (smallestIndex != -1) {
        currentCar = head->next;
        int currentIndex = 1;

        while (currentCar != nullptr) {
            if (currentCar->remainingSpace == smallestIndex) {
                currentCar->remainingSpace -= containerSize;
                return currentIndex;
            }
            currentCar = currentCar->next;
            ++currentIndex;
        }
    }

    return -1;
}

int Train::totalRemainingSpace() {
    TrainCar* current = head->next;
    int totalRemaining = 0;
    while (current != NULL) {
        totalRemaining += current->remainingSpace;
        current = current->next;
    }
    return totalRemaining;
}",1.0,11111
Singly_linked_list_7,1392431,2110501,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *pNew=new Node(e);
    if(count==0)    
    {
        head=pNew;
        tail=pNew;
        count++;
    }
    else
    {
        tail->next=pNew;
        tail=pNew;
        count++;
    }
    
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    Node *pNew=new Node(e);
    if(count==0)
    {
        head=pNew;
        tail=pNew;
        count++;
    }
    else
    {
        if(index==count)
        {
            tail->next=pNew;
            tail=pNew;
            count++;
        }
        else if (index==0)
        {
            pNew->next=head;
            head=pNew;
            count++;
        }
        else
        {
            Node*pre=head;
            for(int i=0;i<index-1;i++)  pre=pre->next;
            pNew->next=pre->next;
            pre->next=pNew;
            count++;
        }
        
    }
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1392431,2110501,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
if(index>count) throw std::out_of_range("""");
else
{
Node*pNew=this->head;
for(int i=0;i<index;i++)
{
    pNew=pNew->next;
}
return pNew->data;
}
}


template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
if(index>count) throw std::out_of_range("""");
else   
{
Node*pNew=this->head;
for(int i=0;i<index;i++)
{
    pNew=pNew->next;
}
pNew->data=e;
}
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(count==0)  return true;
    return false;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node*pNew=this->head;
    int i=0;
    while(pNew!=NULL)
    {
        if(pNew->data==item)    return i;
        i++;
        pNew=pNew->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node*pNew=this->head;
    int i=0;
    while(pNew!=NULL)
    {
        if(pNew->data==item)    return true;
        i++;
        pNew=pNew->next;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1392431,2110501,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    int result;
    if (index < 0 || index > this->count) throw std::out_of_range("""");
    else
    {
        if (this->count == 1)
        {
            result = this->head->data;
            this->head = this->tail = NULL;
            this->count--;
            return result;
        }
        else
        {
            Node* cur = this->head;
            Node* tmp = this->head;
            if (index == 0)
            {
                result = this->head->data;
                this->head = this->head->next;
                delete tmp;
                this->count--;
                return result;
            }
            for(int i=0;i<index-1;i++)
            {
                cur=cur->next;
            }
            tmp=cur->next;
            if (tmp == this->tail)
            {
                result = tmp->data;
                this->tail = cur;
                cur->next = NULL;
                tmp->next = NULL;
                delete tmp;
                this->count--;
                return result;
            }
            else
            {
                result = tmp->data;
                cur->next = tmp->next;
                tmp->next = NULL;
                delete tmp;
                this->count--;
                return result;
            }
            return result;
        }
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(this->count == 1 && this->head->data == item)
    {
        delete this->head;
        this->head = this->tail = NULL;
        this->count--;
        return true;
    }
    else if(this->count == 1 && this->head->data != item) return false;
    else
    {
    Node* cur = NULL;
    Node* tmp = this->head;
    if(tmp->data == item)
    {
        this->count--;
        this->head = this->head->next;
        delete tmp;
        return true;
    }
    while(tmp)
    {
        if(tmp == this->tail && tmp->data == item)
        {
            this->tail = cur;
            cur->next = tmp->next;
            tmp->next = NULL;
            delete tmp;
            this->count--;
            return true;
        }
        else if (tmp->data == item)
        {
            cur->next = tmp->next;
            tmp->next = NULL;
            delete tmp;
            this->count--;
            return true;
        }
        else
        {
            cur = tmp;
            tmp = tmp->next;
        }
    }
    return false;
    }
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    if(this->count == 0);
    Node*cur=this->head;
    while(cur!=NULL)
    {
        this->head = this->head->next;
        delete cur;
        cur = this->head;
    }
    this->head = this->tail= NULL;
    this->count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1392431,2110501,"LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if(head==NULL)  return NULL;
    else
    {
        int count=0;
        LLNode*cur=head;
        while(cur!=NULL)
        {
            count++;
            cur=cur->next;
        }
        cur=head;
        for(int i=0;i<count/2-1;i++)
        {
            cur=cur->next;
        }
        if(count%2!=0)  cur=cur->next;
        LLNode*p=cur->next;
        cur->next=NULL;
        LLNode*head2=p;
        LLNode *pre = NULL, *next;
        cur=head2;
        while (cur) 
        { 
            next = cur->next; 
            cur->next = pre; 
            pre = cur; 
            cur = next; 
        } 
        head2 = pre;
        LLNode*cur1=head;
        LLNode*cur2=head2;
        while(cur1!=NULL)
        {
            if(cur2==NULL)  break;
            cur1->val+=cur2->val;
            cur1=cur1->next;
            cur2=cur2->next;
        }
        cur=head;pre = NULL; next=NULL;
        while (cur) 
        { 
            next = cur->next; 
            cur->next = pre; 
            pre = cur; 
            cur = next; 
        } 
        head = pre;
        return head;
    }
}",1.0,1111111111
Singly_linked_list_11,1392431,2110501,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    if (!head)  return nullptr;
    stack<std::pair<LLNode*, int>> stack;
    LLNode* current = head;

    while (current) {
        while (!stack.empty() && stack.top().first->val < current->val) {
            stack.top().first->val = current->val;
            stack.pop();
        }

        stack.push({current, current->val});
        current = current->next;
    }

    while (!stack.empty()) {
        stack.top().first->val = 0;
        stack.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1392431,2110501,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode*cur = head;
    LLNode*pre = NULL; 
    LLNode*post = NULL;
    while(cur != NULL) 
    {
        post=cur->next;
        cur->next =pre;
        pre=cur;
        cur=post;
    }
    head = pre;
    return head;
}",1.0,1111111111
Singly_linked_list_13,1392431,2110501,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (head==NULL) return NULL;
    LLNode *cur=head;
    LLNode *temp = head;
    int count = 1;
    while (cur->next!=NULL)
    {
        cur=cur->next;
        count++;
    }
    head=cur;
    head->next = temp;
    k %= count;
    k = count - k;
    while (k--) 
    {
        cur = cur->next;
    }
    head=cur;
    temp = head->next;
    head->next = NULL;
    return temp;
}",1.0,1111111111
Singly_linked_list_14,1392431,2110501,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if(low>high||high<0)    return;
    Node*newNode=head;
    if(low<1&&high>=size){
        head=linked_list->head;
        head->next=linked_list->head->next;
        tail=linked_list->tail;
        size=linked_list->size;
    }
    else if(low<1){
        for(int i=0;i<=high;i++){
            newNode=newNode->next;
        }
        size=size+linked_list->size-(high+1);
        linked_list->tail->next=newNode;
        head=linked_list->head;
        head->next=linked_list->head->next;
    }
    else if(high>=size){
        for(int i=0;i<low-1;i++){
            newNode=newNode->next;
        }
        size=linked_list->size+(low);
        newNode->next=linked_list->head;
        tail=linked_list->tail;
    }
    else{
        size=size+linked_list->size+(high-low+1);
        for(int i=0;i<(low-1);i++){
            newNode=newNode->next;
        }
        Node*newNewNode=newNode;
        for(int i=(low-1);i<=high;i++){
            newNewNode=newNewNode->next;   
        }
        newNode->next=linked_list->head;
        linked_list->tail->next=newNewNode;
    }
}",1.0,11111
Singly_linked_list_1,1397059,2213250,"void addLinked(LLNode * tail, LLNode *l0 , int& carry)
{
    
    while(l0)
    {
        int n = l0->val +carry;
        carry = n/10;
        n %=10;
        tail ->next = new LLNode(n,NULL);
        tail = tail ->next;
        l0=l0->next;
    }
}
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    int carry =0;
    LLNode * p0 = l0;
    LLNode * p1 = l1;
    LLNode * head = NULL;
    LLNode * tail =NULL;
    while(p0 && p1)
    {
        int n = p0->val + p1->val +carry;
        carry = n/10;
        n %=10;
        if(!head)
        {
            tail = new LLNode(n,NULL);
            head = tail;
        }
        else
        {
            tail->next = new LLNode(n,NULL);
            tail = tail->next;
        }
        p0=p0->next;
        p1=p1->next;
    }
    if(p0)
    {
        addLinked(tail, p0 , carry);
    }
    else if(p1)
    {
        addLinked(tail, p1 , carry);
    }
    if(carry)
    {
        tail ->next = new LLNode(carry,NULL);
        tail = NULL;
    }
    return head;
}",0.75,111111111111111
Singly_linked_list_2,1397059,2213250,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1397059,2213250,"void LinkedList::partition(int k) {
    Node *p1 = NULL;
    Node *p2 = NULL;
    Node *p3 = NULL;
    Node *temp1 = NULL;
    Node *temp2 = NULL;
    Node *temp3 = NULL;
    Node *p =head;
    while(p)
    {
        if(p->value < k)
        {
            if(p1 == NULL)
            {
                p1=p;
                temp1 =p;
            }
            else
            {
                temp1->next =p;
                temp1 = temp1->next;
            }
        }
        else if(p->value == k)
        {
            if(!p2)
            {
                p2 =p;
                temp2 =p;
            }
            else
            {
                temp2->next =p;
                temp2 = temp2->next;
            }
        }
        else
        {
            if(!p3)
            {
                p3 =p;
                temp3 =p;
            }
            else
            {
                temp3->next =p;
                temp3 = temp3->next;
            }
        }
        p =p->next;
        if(temp1) temp1->next =NULL;
        if(temp2) temp2->next =NULL;
        if(temp3) temp3->next =NULL;
    }
    
    if(temp1) temp1->next = p2;
    if(temp2) temp2->next = p3;
    if(temp3) temp3->next =NULL;
    
    if(p1) head =p1;
    else if(p2) head = p2;
    else head = p3;
    
    if(temp3) tail = temp3;
    else if(temp2) tail = temp2;
    else tail = temp1;
}",1.0,11111
Singly_linked_list_5,1397059,2213250,"void reduceDuplicate(Node* root)
{
}",0.2,0000101000
Singly_linked_list_10,1397059,2213250,"LLNode* reverse(LLNode* head) {
    LLNode * phead = NULL;
    while(head)
    {
        LLNode* p = head;
        head =head->next;
        if(phead == NULL)
        {
            p->next = NULL;
            phead = p;
        }
        else
        {
            p->next = phead;
            phead = p;
        }
    }
    return phead;
}
LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode*p = head;
    int n=0;
    while(p)
    {
        n++;
        p=p->next;
    }
    if(n ==0) return head;
    p = head;
    if(n%2 == 1) n+=1;
    for(int i=1;i<n/2;i++)
    {
        p = p->next;
    }
    LLNode * p1= p->next;
    p->next =NULL;
    LLNode * p2 = reverse(p1);
    p = head;
    while(p2)
    {
        p->val += p2->val;
        p=p->next;
        p2 = p2->next;
    }
    p = reverse(head);
    return p;
    
}",1.0,1111111111
Singly_linked_list_12,1397059,2213250,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode * phead = NULL;
    while(head)
    {
        LLNode* p = head;
        head =head->next;
        if(phead == NULL)
        {
            p->next = NULL;
            phead = p;
        }
        else
        {
            p->next = phead;
            phead = p;
        }
    }
    return phead;
}",1.0,1111111111
Singly_linked_list_13,1397059,2213250,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    LLNode *p = head;
    int n=0;
    while(p!=NULL)
    {
        p=p->next;
        n++;
    }
    if(n ==0 || k ==0) return head;
    
    p = head;
    if(n<=k)
    {
        while(true)
        {
            if(p->next->next == NULL)
            {
                LLNode* p1 = p->next;
                p->next =NULL;
                p1->next =head;
                return p1;
            }
            p=p->next;
        }
        
    }
    for(int i=1;i<n-k;i++)
    {
        p =p ->next;
    }
    LLNode* p1 =p->next;
    p->next = NULL;
    LLNode *p2 = p1;
    while(p2->next)
    {
        p2 = p2->next;
    }
    p2->next = head;
    return p1;
}",1.0,1111111111
Singly_linked_list_1,1397901,2212935,"LLNode* add(LLNode* node0, LLNode* node1, int carry){
    if (!node0 && !node1 && !carry) return NULL;
    int sum = (node0? node0->val:0) + (node1? node1->val:0) + carry;
    LLNode * node = new LLNode(sum % 10);
    if (node){
    node->next = add((node0?node0->next:NULL), (node1?node1->next:NULL), sum/10);
    return node;
    }
    return NULL;
}
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    return add(l0, l1, 0);
}",0.8,1111111111110
Singly_linked_list_2,1397901,2212935,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_3,1397901,2212935,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
     this->pList = pList;
            if (begin)
            {
                if (pList != NULL)
                    current = pList->head;
                else
                    current = NULL;
                index = 0;
            }
            else
            {
                current = NULL;
                if (pList != NULL)
                    index = pList->size();
                else
                    index = 0;
            }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
            this->current = iterator.current;
            this->index = iterator.index;
            this->pList = iterator.pList;
            return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == NULL)
        throw std::out_of_range(""Segmentation fault!"");

    if (pList == NULL)
        return;

    if (current == pList->head)
    {
        pList->head = current->next;
        delete current;
        current = NULL;
        index = -1;
        pList->count--;
        return;
    }

    Node *prev = pList->head;
    while (prev->next != NULL && prev->next != current)
    {
        prev = prev->next;
    }

    if (prev->next == NULL)
        throw std::out_of_range(""Segmentation fault!"");

    prev->next = current->next;
    delete current;
    current = prev;
    index--;
    pList->count--;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current)
        throw std::out_of_range(""Segmentation fault!"");

    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current)
        throw std::out_of_range(""Segmentation fault!"");

    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return (current != iterator.current || index != iterator.index);
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!pList)
        throw std::out_of_range(""Segmentation fault!"");

    if (current) {
        current = current->next;
        index++;
    }
    else {
        if (index == -1) {
            current = pList->head;
            index = 0;
        }
        else {
            throw std::out_of_range(""Segmentation fault!"");
        }
    }

    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,11111
Singly_linked_list_4,1397901,2212935,"void LinkedList::partition(int k) {
if (head == NULL || head->next == NULL)
        return; 

    Node *group1Head = NULL;
    Node *group1Tail = NULL;
    Node *group2Head = NULL;
    Node *group2Tail = NULL;
    Node *group3Head = NULL;
    Node *group3Tail = NULL;

    Node *current = head;
    while (current != NULL)
    {
        Node *nextNode = current->next;
        current->next = NULL; 

        if (current->value < k)
        {
            if (group1Head == NULL)
            {
                group1Head = current;
                group1Tail = current;
            }
            else
            {
                group1Tail->next = current;
                group1Tail = current;
            }
        }
        else if (current->value == k)
        {
            if (group2Head == NULL)
            {
                group2Head = current;
                group2Tail = current;
            }
            else
            {
                group2Tail->next = current;
                group2Tail = current;
            }
        }
        else
        {
            if (group3Head == NULL)
            {
                group3Head = current;
                group3Tail = current;
            }
            else
            {
                group3Tail->next = current;
                group3Tail = current;
            }
        }

        current = nextNode;
    }

    head = NULL; 

    if (group1Head != NULL)
    {
        head = group1Head;
        tail = group1Tail;
    }

    if (group2Head != NULL)
    {
        if (head == NULL)
        {
            head = group2Head;
            tail = group2Tail;
        }
        else
        {
            tail->next = group2Head;
            tail = group2Tail;
        }
    }

    if (group3Head != NULL)
    {
        if (head == NULL)
        {
            head = group3Head;
            tail = group3Tail;
        }
        else
        {
            tail->next = group3Head;
            tail = group3Tail;
        }
    }
}",1.0,11111
Singly_linked_list_5,1397901,2212935,"void reduceDuplicate(Node* root)
{
    if (root == nullptr)
        return;

    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicateNode = current->getNext();
            current->setNext(duplicateNode->getNext());
            delete duplicateNode;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1397901,2212935,"int Train::allocate(int containerSize) {
    TrainCar* current = head->next;
    TrainCar* selectedCar = nullptr;
    int selectedIndex = -1;
    int index = 1;

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize) {
            if (selectedCar == nullptr || current->remainingSpace < selectedCar->remainingSpace) {
                selectedCar = current;
                selectedIndex = index;
            }
        }
        current = current->next;
        index++;
    }

    if (selectedCar != nullptr) {
        selectedCar->remainingSpace -= containerSize;
    }

    return selectedIndex;
}

int Train::totalRemainingSpace() {
    int sum = 0;
    for (TrainCar * p = head; p != nullptr; p = p->next){
        sum += p->remainingSpace;
    }
    return sum;
}",1.0,11111
Singly_linked_list_7,1397901,2212935,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e, nullptr);
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
        count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index == count) {
            add(e);
        } else if (index == 0) {
            Node* newNode = new Node(e, head);
            head = newNode;
            count++;
        } else {
            Node* current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current->next;
            }
            Node* newNode = new Node(e, current->next);
            current->next = newNode;
            count++;
        }
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1397901,2212935,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""e"");
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    Node* current = head;
    while (current != NULL) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1; 
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",0.9,1111111110
Singly_linked_list_9,1397901,2212935,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* current = head;
    Node* previous = NULL;
    for (int i = 0; i < index; i++) {
        previous = current;
        current = current->next;
    }
    T removedData = current->data;
    if (current == head) {
        head = current->next;
    } else {
        previous->next = current->next;
        if (current == tail) {
            tail = previous;
        }
    }
    delete current;
    count--;
    return removedData;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    Node* previous = NULL;
    while (current != NULL) {
        if (current->data == item) {
            if (current == head) {
                head = current->next;
            } else {
                previous->next = current->next;
                if (current == tail) {
                    tail = previous;
                }
            }
            delete current;
            count--;
            return true;
        }
        previous = current;
        current = current->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* current = head;
    while (current != NULL) {
        Node* next = current->next;
        delete current;
        current = next;
    }
    head = NULL;
    tail = NULL;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_11,1397901,2212935,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    if (head == nullptr) {
        return nullptr;
    }

    stack<LLNode*> nodes;
    LLNode* curr = head;

    while (curr != nullptr) {
        while (!nodes.empty() && nodes.top()->val < curr->val) {
            nodes.top()->val = curr->val;
            nodes.pop();
        }
        nodes.push(curr);
        curr = curr->next;
    }

    while (!nodes.empty()) {
        nodes.top()->val = 0;
        nodes.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1397901,2212935,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if (head == NULL || head->next == NULL) return head;
        LLNode *prev = NULL;
        LLNode *head1 = reverseLinkedList(head->next);
        head->next->next = head;
        head->next = prev;
        return head1;
}",1.0,1111111111
Singly_linked_list_13,1397901,2212935,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
     if (head == nullptr || k == 0) {
        return head;
    }

    int length = 0;
    LLNode* curr = head;
    while (curr != nullptr) {
        length++;
        curr = curr->next;
    }

    int rotation = k % length;
    if (rotation == 0) {
        return head;
    }

    curr = head;
    for (int i = 0; i < length - rotation - 1; i++) {
        curr = curr->next;
    }
    
    LLNode* newHead = curr->next;
    curr->next = nullptr;

    curr = newHead;
    while (curr->next != nullptr) {
        curr = curr->next;
    }


    curr->next = head;

    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1397901,2212935,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (linked_list == nullptr || low > high)
        return;

    if (low < 0)
        low = 0;
    if (high >= size)
        high = size - 1;
        
    Node* prevNode = nullptr;
    if (low > 0) {
        Node* currNode = head;
        for (int i = 0; i < low - 1; i++) {
            currNode = currNode->next;
        }
        prevNode = currNode;
    }

    Node* deleteStart = (prevNode != nullptr) ? prevNode->next : head;
    Node* deleteEnd = deleteStart;
    for (int i = low; i <= high; i++) {
        Node* nextNode = deleteEnd->next;
        delete deleteEnd;
        deleteEnd = nextNode;
        size--;
    }

    if (prevNode != nullptr) {
        prevNode->next = linked_list->head;
    } else {
        head = linked_list->head;
    }

    if (deleteEnd == nullptr) {
        tail = linked_list->tail;
    }

    Node* linkedListTail = linked_list->tail;
    while (linkedListTail != nullptr && linkedListTail->next != nullptr) {
        linkedListTail = linkedListTail->next;
    }

    if (linkedListTail != nullptr) {
        linkedListTail->next = deleteEnd;
    }

    size += linked_list->size;

    linked_list->head = nullptr;
    linked_list->tail = nullptr;
    linked_list->size = 0;
}",1.0,11111
Singly_linked_list_1,1397912,2252260,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    if(l0==NULL&&l1==NULL)
        return nullptr;
    LLNode* l = new LLNode();
    LLNode* tmp = l;
    int carry = 0;
    while(l0!=NULL || l1!=NULL){
        int sum = carry;
        if(l0!=NULL){
            sum += l0->val;
            l0 = l0->next;
        }
        if(l1!=NULL){
            sum += l1->val;
            l1=l1->next;
        }
        carry = sum/10;
        tmp->val = sum%10;
        if(l0!=NULL||l1!=NULL||carry!=0){
            tmp->next = new LLNode();
            tmp = tmp->next;
        }
    }
    if(carry>0)
        tmp->val = carry;
    return l;
}",1.0,111111111111111
Singly_linked_list_2,1397912,2252260,"int getIndex(SLinkedList<Term>* terms, SLinkedList<Term>::Iterator it) {
    int index = 0;
    for (SLinkedList<Term>::Iterator tmp = terms->begin(); tmp != it; ++tmp) {
        ++index;
    }
    return index;
}


void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.coeff==0)
        return;
    SLinkedList<Term>::Iterator it = this->terms->begin();
    while(it!=this->terms->end() && term.exp < (*it).exp)
        ++it;
    if(it != this->terms->end() && term.exp == (*it).exp){
        (*it).coeff += term.coeff;
        if((*it).coeff == 0){
            int index = getIndex(terms, it);
            this->terms->removeAt(index);
            it = this->terms->begin();
            for (int i = 0; i < index && it != this->terms->end(); ++i) {
                ++it;
            }
        }
    }
    else{
        if(this->terms->empty())
            this->terms->add(term);
        else
            this->terms->add(getIndex(terms, it), term);       
    }
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term newTerm(coeff, exp);
    if(newTerm.coeff==0)
        return;
    SLinkedList<Term>::Iterator it = this->terms->begin();
    while(it!=this->terms->end() && newTerm.exp < (*it).exp)
        ++it;
    if(it != this->terms->end() && newTerm.exp == (*it).exp){
        (*it).coeff += newTerm.coeff;
        if((*it).coeff==0){
            int index = getIndex(terms, it);
            this->terms->removeAt(index);
            it = this->terms->begin();
            for (int i = 0; i < index && it != this->terms->end(); ++i) {
                ++it;
            }
        }
    }
    else{
        if(this->terms->empty())
            this->terms->add(newTerm);
        else
            this->terms->add(getIndex(terms, it), newTerm);       
    }
}",1.0,11111
Singly_linked_list_1,1398943,2212303,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode dummy(0);  // Dummy node to simplify list handling
    LLNode* current = &dummy;
    int carry = 0;

    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;

        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }

        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }

        carry = sum / 10;  // Calculate carry for the next iteration
        sum = sum % 10;    // Calculate the current digit

        // Create a new node with the current digit and add it to the result list
        current->next = new LLNode(sum, nullptr);
        current = current->next;
    }

    return dummy.next;
}",1.0,111111111111111
Singly_linked_list_2,1398943,2212303,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
SLinkedList<Term>::Iterator it;
    int index = 0;
    if (term.coeff == 0.0)
        return;
    for (it = this->terms->begin(); it != this->terms->end(); ++it) {
        if ((*it).exp < term.exp) {
            this->terms->add(index, term);
            return;
        } else if ((*it).exp == term.exp) {
            (*it).coeff += term.coeff;
            if ((*it).coeff == 0.0)
                this->terms->removeAt(index);
            return;
        }
        index++;
    }
    if (term.coeff != 0.0)
        this->terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff, exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_3,1398943,2212303,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    if (pList!= nullptr){  
        this->pList=pList;
        if (begin){
            if (pList->head!=nullptr) this->index=0; else this->index=-1;
        } else {
            this->current=nullptr;
            if(!pList) index=pList->count;
            else index=0;
        }
    }
};

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->pList=iterator.pList;
    this->index=iterator.index;
    this->current=iterator.current;
    return * this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (this->current == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }

    if (current == pList->head && index == 0 && pList->head != nullptr) {
        // Removing the head node
       
        pList->head = pList->head->next;
        current = nullptr; // Updated to previous ""node"" of head
        index = -1;
    } else {
        // Removing a non-head node
        
        Node* carry = pList->head;
        
        // Find the previous node of the current node
        for (int i = 0; i < index; i++) {
            carry = carry->next;
        }
        
        // Update the previous node's next pointer to skip the current node
        carry->next = current->next;
        
        // Move the iterator to the previous node
        current = carry;
        pList->count--;
        index--;
    }
}


template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current!=nullptr) current->data=e;
    else throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current!=nullptr) return current->data;
    else throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return (!(this->current==iterator.current && this-> index==iterator.index ));
    
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
     if (current == nullptr) {
                throw std::out_of_range(""Segmentation fault!"");
            }
            if (current->next == pList->head) {
                current = pList->head;
                index = 0;
            } else {
                current = current->next;
                index++;
            }
            return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
      Iterator temp = *this;
            if (current == nullptr) {
                throw std::out_of_range(""Segmentation fault!"");
            }
      if (current->next == pList->head) {
                current = pList->head;
                index = 0;
      } else {
                current = current->next;
                index++;
      }
       return temp;
        
}",0.8,11110
Singly_linked_list_4,1398943,2212303,"void LinkedList::partition(int k) {
   LinkedList* groupI = new LinkedList();
    LinkedList* groupII = new LinkedList();
    LinkedList* groupIII = new LinkedList();
    Node* current = head;
    
    while (current != nullptr) {
        if (current->value < k) {
            if (groupI->head == nullptr) {
                groupI->head = new Node(current->value);
                groupI->tail = groupI->head;
                groupI->size++;
            } else {
                groupI->tail->next = new Node(current->value);
                groupI->tail = groupI->tail->next;
                groupI->size++;
            }
        } else if (current->value == k) {
            if (groupII->head == nullptr) {
                groupII->head = new Node(current->value);
                groupII->tail = groupII->head;
                groupII->size++;
            } else {
                groupII->tail->next = new Node(current->value);
                groupII->tail = groupII->tail->next;
                groupII->size++;
            }
        } else {
            if (groupIII->head == nullptr) {
                groupIII->head = new Node(current->value);
                groupIII->tail = groupIII->head;
                groupIII->size++;
            } else {
                groupIII->tail->next = new Node(current->value);
                groupIII->tail = groupIII->tail->next;
                groupIII->size++;
            }
        }
        current = current->next;
    }

    // Concatenate the three groups in order
    if(groupI->head!=nullptr){
        if(groupII->head!=nullptr){
            if(groupIII->head!=nullptr){
                head = groupI->head;
                groupI->tail->next = groupII->head;
                groupII->tail->next = groupIII->head;
                tail = groupIII->tail;
            }
            else{
                head = groupI->head;
                groupI->tail->next = groupII->head;
                tail = groupII->tail;
            }
        }
        else{
            if(groupIII->head!=nullptr){
                head = groupI->head;
                groupI->tail->next = groupIII->head;
                tail = groupIII->tail;
            }
            else{
                head = groupI->head;
                tail = groupI->tail;
            }
        }
    } else{
        if(groupII->head!=nullptr){
            if(groupIII->head!=nullptr){
                head = groupII->head;
                groupII->tail->next = groupIII->head;
                tail = groupIII->tail;
            }
            else{
                head = groupII->head;
                tail = groupII->tail;
            }
        }
        else{
            if(groupIII->head!=nullptr){
                head = groupIII->head;
                tail = groupIII->tail;
            }
            else{
                head = nullptr;
                tail = nullptr;
            }
        }
    }
    

    // Update the size of the main linked list
    size = groupI->size + groupII->size + groupIII->size;
    
}",1.0,11111
Singly_linked_list_5,1398943,2212303,"void reduceDuplicate(Node* root)
{
    if (root == nullptr || root->getNext() == nullptr) return;
    Node* prev = root;
    Node* curr = root->getNext();
    
    while (curr != nullptr) {
        if (curr->getData() == prev->getData()) {
            prev->setNext(curr->getNext());
        } else {
            prev = prev->getNext();
        }
        
        if (prev != nullptr && prev->getNext() != nullptr) {
            curr = prev->getNext();
        } else {
            curr = nullptr;
        }
    }
}
",1.0,1111111111
Singly_linked_list_6,1398943,2212303,"int Train::allocate(int containerSize) {
    TrainCar* curr = head->next;
    TrainCar* canContain = nullptr;
    int currIn = 1;
    int result = -1;

    while (curr != nullptr) {
        if (curr->remainingSpace >= containerSize) {
            if (canContain == nullptr || curr->remainingSpace < canContain->remainingSpace) {
                canContain = curr;
                result = currIn;
            }
        }
        currIn++;
        curr = curr->next;
    }

    if (canContain != nullptr) {
        canContain->remainingSpace -= containerSize;
    }

    return result;
}
int Train::totalRemainingSpace() {
    int result=0;
    TrainCar* curr=head;
    while(curr!=nullptr){
        result+=curr->remainingSpace;
        curr=curr->next;
    }
    return result;
}
",1.0,11111
Singly_linked_list_7,1398943,2212303,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if (tail == nullptr) {
            head = tail = new Node(e);
        } else {
            tail->next = new Node(e);
            tail = tail->next;
        }
        count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
     if (index < 0 || index > count) {
           return;
        }
        if (index == 0) {
            head = new Node(e, head);
            if (tail == nullptr) {
                tail = head;
            }
        } else {
            Node* curr = head;
            for (int i = 0; i < index - 1; i++) {
                curr = curr->next;
            }
            curr->next = new Node(e, curr->next);
            if (curr->next->next == nullptr) {
                tail = curr->next;
            }
        }
        count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1398943,2212303,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
     Node* curr=head;
    if(index<0||index>=count) throw out_of_range(""Index out of bounds"");
    else{
        for(int i=0; i<index; i++){
            if(curr!=nullptr)
            curr=curr->next;
        }
        return curr->data;
    }
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index<0||index>=count) return;
    else{
         Node* curr=head;
        for(int i=0; i<index; i++){
            if(curr!=nullptr)
            curr=curr->next;
        }
        curr->data=e;    
    }
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (head==nullptr);
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* curr=head;
    int result=-1;
    int index=0;
    while(curr!=nullptr){
        if(curr->data==item){
            result=index;
            break;
        }
        index++;
        curr=curr->next;
    }
    return result;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* curr=head;
    while(curr!=nullptr){
        if(curr->data==item){
           return true;
        }
        curr=curr->next;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1398943,2212303,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    Node* curr=head;
    Node* prev=nullptr;
    if (index < 0 || index >= count) {
        // Handle the out-of-bounds case, for example, by throwing an exception.
        throw std::out_of_range(""Index out of bounds"");
    } else{
        if(index==0) {head=head->next;count--; 
         if (head == nullptr) {
                tail = nullptr;  // Update tail when removing the last element
        }
        return curr->data;}
        else{
            for(int i=0; i<index; i++){
                prev=curr;
                if(curr!=nullptr) curr=curr->next;
            }
            if (curr == tail) {
                tail = prev;  // Update tail when removing the last element
            }
            prev->next=curr->next;
            
            count--;
            return curr->data;
        }
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(this->indexOf(item)==-1) return false;
    else{
        this->removeAt(this->indexOf(item));
        count--;
        return true;
    }
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    count=0;
    delete this->head;
    delete this->tail;
}

",1.0,1111111111
Singly_linked_list_10,1398943,2212303,"LLNode* foldLinkedList(LLNode* head) {
    
    // STUDENT ANSWER
   int count = 0;
    LLNode* temp = head;
    bool noteven=false;

    while (temp != nullptr) {
        count++;
        temp = temp->next;
    }

    if (count <= 1) {
        return head; // Nothing to fold if the list has 0 or 1 element
    }

    int half = count / 2;
    if(count%2==1){noteven=true;}
    temp = head;

    for (int i = 0; i < half - 1; i++) {
        temp = temp->next;
    }

    LLNode* secondHalf = temp->next;
    temp->next = nullptr;

    // Reverse the second half of the list
    LLNode* temp1=head;
    LLNode* reverse = nullptr;
    while (head != nullptr) {
        reverse=new LLNode(head->val, reverse);
        head=head->next;
    }

    // Merge the two halves
    LLNode* carry=secondHalf;
    
    while ( reverse != nullptr) {
       
        if(noteven){ secondHalf=secondHalf->next; noteven=false;}
        secondHalf->val+=reverse->val;
        //cout<<secondHalf->val<<"" "";
        reverse=reverse->next;
        secondHalf=secondHalf->next;
    }
    delete temp1;
    
    return carry;
}",1.0,1111111111
Singly_linked_list_11,1398943,2212303,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    if (!head) {
        return nullptr; // Handle empty list
    }

    LLNode* current = head;
    while (current) {
        LLNode* nextGreater = nullptr;
        LLNode* runner = current->next;

        while (runner) {
            if (runner->val > current->val) {
                nextGreater = runner;
                break;
            }
            runner = runner->next;
        }

        if (nextGreater) {
            current->val = nextGreater->val;
        } else {
            current->val = 0;
        }

        current = current->next;
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1398943,2212303,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if(!head) return nullptr;
    LLNode* newLL=nullptr;
    LLNode* temp=head;
    while(temp!=nullptr){
        newLL=new LLNode(temp->val, newLL);
        temp=temp->next;
    }
    delete head;
    return newLL;
}",1.0,1111111111
Singly_linked_list_13,1398943,2212303,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (!head || k == 0) {
        return head; // No rotation needed
    }

    // Find the length of the linked list
    int length = 1;
    LLNode* tail = head;

    while (tail->next) {
        tail = tail->next;
        length++;
    }

    // Adjust k to be within the range [0, length)
    k = k % length;

    if (k == 0) {
        return head; // No rotation needed
    }

    // Find the new head and tail of the rotated list
    int newHeadPosition = length - k;
    LLNode* newTail = head;

    for (int i = 1; i < newHeadPosition; i++) {
        newTail = newTail->next;
    }

    LLNode* newHead = newTail->next;
    newTail->next = nullptr;
    tail->next = head;

    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1398943,2212303,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    
    // Handle the case where low is less than 0
    if (low-1 < 0) {
        low = 0;
    }

    // Handle the case where high is greater than or equal to size
    if (high >= size) {
        high = size - 1;
    }

    Node* current = head;
    Node* prev = nullptr;
    int position = 0;
    // Traverse the list to find the node at position 'low'
    while (position < low) {
        prev = current;
        current = current->next;
        position++;
    }
    // Remove nodes from 'low' to 'high'
    while (position <= high) {
        Node* temp = current;
        current = current->next;
        delete temp;
        position++;
    }
    // Insert linked_list after the 'prev' node
    if (prev) {
        prev->next = linked_list->head;
    } else {
        head = linked_list->head;
    }

    // Update the tail pointer if necessary
    if (linked_list->tail) {
        tail = linked_list->tail;
    }
    if(current){
        tail->next=current;
    }
    while (tail->next!=nullptr){
        tail=tail->next;
    }

    // Update the size of the linked list
    size = size-(high-low+1)+linked_list->size;
    
}",1.0,11111
Singly_linked_list_1,1400901,2212651,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) 
{
    LLNode dummy; 
    LLNode* temp = &dummy;
    int carry = 0;

    while (l0 || l1 || carry)
    {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        carry = sum / 10;
        temp->next = new LLNode(sum % 10);
        temp = temp->next;

        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }

    return dummy.next;
}",0.9,111111111111111
Singly_linked_list_2,1400901,2212651,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(!terms){
        
    }
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_1,1404319,2213298,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode pNew;
    LLNode* tail = &pNew;
    int carry = 0;
    while (l0 || l1 || carry) {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        tail->next = new LLNode(sum % 10);
        tail = tail->next;
        carry = sum / 10;
        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }
    return pNew.next;
}",1.0,111111111111111
Singly_linked_list_2,1404319,2213298,"void Polynomial::insertTerm(const Term& term) {
    SLinkedList<Term>::Iterator cur = terms->begin();
    if (!term.coeff) return;
    while (cur != terms->end() && (*cur).exp != term.exp){
        cur++;
    }
    if (cur != terms->end()){
        (*cur).coeff += term.coeff;
        if (!(*cur).coeff){
            int index = terms->indexOf(*cur);
            terms->removeAt(index);
        }
    }
    else {
        cur = terms->begin();
        while (cur != terms->end() && (*cur).exp > term.exp){
            cur++;
        }
        int index = cur != terms->end() ? terms->indexOf(*cur) : terms->size();
        terms->add(index, term);
    }
    
}


void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    insertTerm(Term(coeff,exp));
}",1.0,11111
Singly_linked_list_3,1404319,2213298,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin){
        if (pList){
            current = pList->head;
            index = 0;
        }
        else {
            current = NULL;
            index = -1;
        }
    }
    else {
        current = NULL;
        if (pList){
            index = pList->count;
        }
        else index = 0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (!current) throw std::out_of_range(""Segmentation fault!"");
            
    if (current == pList->head){
        pList->head = pList->head->next;
        delete current;
        current = NULL;
        index = -1;
        
    }
    else {
        Node* pPre = pList->head;
        while (pPre->next != current){
            pPre = pPre->next;
        }
        if (current == pList->tail) pList->tail = pPre;
        pPre->next = current->next;
        delete current;
        current = pPre;
        index--;
        
    }
    pList->count--;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current) throw std::out_of_range(""Segmentation fault!"");
    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current) throw std::out_of_range(""Segmentation fault!"");
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if (this->current == iterator.current && this->index == iterator.index) return 0;
    return 1;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!current && index == pList->count) throw std::out_of_range(""Segmentation fault!"");
    current = current->next;
    index++;
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!current && index == pList->count) throw std::out_of_range(""Segmentation fault!"");
    current = current->next;
    index++;
    return *this;
}",1.0,11111
Singly_linked_list_4,1404319,2213298,"void LinkedList::partition(int k) {
    Node* groupI = NULL;
    Node* groupII = NULL;
    Node* groupIII = NULL;
    Node* lastGroupI = NULL;
    Node* lastGroupII = NULL;
    Node* lastGroupIII = NULL;

    Node* current = head;
    while (current != NULL) {
        if (current->value < k) {
            if (groupI == NULL) {
                groupI = current;
                lastGroupI = current;
            } else {
                lastGroupI->next = current;
                lastGroupI = current;
            }
        } else if (current->value == k) {
            if (groupII == NULL) {
                groupII = current;
                lastGroupII = current;
            } else {
                lastGroupII->next = current;
                lastGroupII = current;
            }
        } else {
            if (groupIII == NULL) {
                groupIII = current;
                lastGroupIII = current;
            } else {
                lastGroupIII->next = current;
                lastGroupIII = current;
            }
        }
        current = current->next;
    }

    if (lastGroupI != NULL) {
        head = groupI;
        tail = lastGroupI;
        if (groupII != NULL) {
            tail->next = groupII;
            tail = lastGroupII;
        }
        if (groupIII != NULL) {
            tail->next = groupIII;
            tail = lastGroupIII;
        }
    } else if (lastGroupII != NULL) {
        head = groupII;
        tail = lastGroupII;
        if (groupIII != NULL) {
            tail->next = groupIII;
            tail = lastGroupIII;
        }
    } else if (lastGroupIII != NULL) {
        head = groupIII;
        tail = lastGroupIII;
    }

    if (tail != NULL)
        tail->next = NULL;

}",1.0,11111
Singly_linked_list_5,1404319,2213298,"void reduceDuplicate(Node* root)
{
    if (root == nullptr || root->getNext() == nullptr)
    {
        return;
    }

    Node* current = root;
    while (current->getNext() != nullptr)
    {
        if (current->getData() == current->getNext()->getData())
        {
            Node* nextNext = current->getNext()->getNext();
            delete current->getNext();
            current->setNext(nextNext);
        }
        else
        {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1404319,2213298,"int Train::allocate(int containerSize) {
    TrainCar *pTemp = head;
    int vitri = 0;
    int min = 99999;
    for (int i = 0; i < size; i++) {
        if (pTemp->remainingSpace >= containerSize) {
            if ( pTemp->remainingSpace < min ) {
                min = pTemp->remainingSpace;
                vitri = i;
            } 
        }
        pTemp = pTemp->next;
    }
    if (min == 99999) return -1;
    pTemp = head;
    for (int i = 0; i < vitri; i++) pTemp = pTemp->next;
    pTemp->remainingSpace -= containerSize;
    return vitri;
}

int Train::totalRemainingSpace() {
    TrainCar *pTemp = head;
    int sum = 0;
    for (; pTemp; pTemp = pTemp->next) sum += pTemp->remainingSpace;
    return sum;
}",1.0,11111
Singly_linked_list_7,1404319,2213298,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *pNew = new Node(e, NULL);
    if (!head) head = tail = pNew;
    else {
        tail->next = pNew;
        tail = pNew;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index > count || index < 0) throw std::out_of_range(""Out of range""); 
        if (index == count) { add(e); return; }
        Node *pNew = new Node(e);
        if (!index) {
            pNew->next = head;
            head = pNew;
            count++;
            return;
        }
        Node *p0 = this->head;
        for (; index > 1; index--) p0 = p0->next;
        pNew->next = p0->next;
        p0->next = pNew;
        count++;
        return;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    if (head) return count;
    return 0;
}
",1.0,1111111111
Singly_linked_list_8,1404319,2213298,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    return pNew->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    pNew->data = e;
    return;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !(head);
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for (Node *p0 = head; p0; p0 = p0->next)
    {
        if (p0->data == item) return index;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for (Node *p0 = head; p0; p0 = p0->next)
    if (p0->data == item) return 1;
    return 0;
}",1.0,1111111111
Singly_linked_list_9,1404319,2213298,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index >= this->count || index < 0) throw std::out_of_range(""Out of range"");
        if (count == 1) {                 
            Node *pNew = head;
            head = tail = NULL;
            count = 0;
            T temp = pNew->data;
            delete pNew;
            return temp;
        }
        if (!index) {
            Node *pNew = head;
            head = pNew->next;
            T temp = pNew->data;
            delete pNew;
            count--;
            return temp;
        }
        Node *pNew = head;
        for (int i = index; i > 1; i--) pNew = pNew->next;
        Node *pDel = pNew->next;
        T temp = pDel->data;
        pNew->next = pDel->next;
        if (index == count - 1) tail = pNew;
        delete pDel;
        count--;
        return temp;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if (head->data == item) {
            Node *pNew = head;
            head = pNew->next;
            pNew->next = NULL;
            delete pNew;
            count--;
            return true;
        }
    for(Node *p0 = head, *p1 = p0->next; p1; p1 = p1->next, p0 = p0->next) {
        if (p1->data == item) {
            if (p1->next) {
                p0->next = p1->next;
                p1->next = NULL;
                delete p1;
                count--;
                return true;
            }
            else {
                p0->next = p1->next = NULL;
                tail = p0;
                delete p1;
                count--;
                return true;
            }
        }
    }
    return false;
    
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    for (Node *p0 = head; p0;) {
            Node *p1 = p0;
            p0 = p0->next;
            p1->next = NULL;
            delete p1;
        } 
    tail = NULL;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1404319,2213298,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* prev = nullptr;
    while (head) {
        LLNode* next = head->next;
        head->next = prev;                              
        prev = head;
        head = next;
    }
    return prev;
}

LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if (head == nullptr || head->next == nullptr) return head;
    LLNode *last = head;
    LLNode *mid = head;
    while(last && last->next) {
        last =  last->next->next;
        mid = mid->next;
    }
    LLNode *firstLinkedlist = head;
    LLNode *secondLinkedlist = reverseLinkedList(mid);
    while(secondLinkedlist) {
        if (firstLinkedlist == secondLinkedlist) break;
        firstLinkedlist->val += secondLinkedlist->val;
        if (!firstLinkedlist || firstLinkedlist->next == secondLinkedlist){
            firstLinkedlist->next = secondLinkedlist->next;
            break;
        }
        firstLinkedlist = firstLinkedlist->next;
        secondLinkedlist = secondLinkedlist->next;
    }
    head = reverseLinkedList(head);
    return head;
}",1.0,1111111111
Singly_linked_list_11,1404319,2213298,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    LLNode *pNew = head;
    for (;pNew;pNew = pNew->next) {
        LLNode *pFirst = pNew->next;
        for (;pFirst; pFirst = pFirst->next) {
            if (pFirst->val > pNew->val) { pNew->val = pFirst->val;break; }
        }
        if (!pFirst) pNew->val = 0;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1404319,2213298,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* prev = nullptr;
    while (head) {
        LLNode* next = head->next;
        head->next = prev;
        prev = head;
        head = next;
    }
    return prev;
}",1.0,1111111111
Singly_linked_list_13,1404319,2213298,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (!head || !head->next || k == 0) return head;
    for (int i = 0; i < k; i++) {
        LLNode *pTail = head;
        while(pTail->next->next) pTail = pTail->next;
        LLNode* pDel = pTail->next;
        pDel->next = head;
        head = pDel;
        pTail->next = NULL;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_14,1404319,2213298,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    Node* prevLow = NULL;
    Node* nodeLow = head;
    if (low < 0) low = 0;
    for (int i = 0; i < low && nodeLow != NULL; i++) {
        prevLow = nodeLow;
        nodeLow = nodeLow->next;
    }

    Node* nodeHigh = nodeLow;
    Node* nextHigh = NULL;
    for (int i = low; i <= high && nodeHigh != NULL; i++) {
        nextHigh = nodeHigh->next;
        delete nodeHigh;
        nodeHigh = nextHigh;
    }

    if (prevLow != NULL) {
        prevLow->next = linked_list->head;
    } else {
        head = linked_list->head;
    }

    if (linked_list->tail != NULL) {
        linked_list->tail->next = nextHigh;
    }

    if (nextHigh == NULL) {
        tail = linked_list->tail;
    }

    size -= high - low + 1;
    size += linked_list->size;

    linked_list->head = NULL;
    linked_list->tail = NULL;
}
",1.0,11111
Singly_linked_list_1,1404534,2252260,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    if(l0==NULL&&l1==NULL)
        return nullptr;
    LLNode* l = new LLNode();
    LLNode* tmp = l;
    int carry = 0;
    while(l0!=NULL || l1!=NULL){
        int sum = carry;
        if(l0!=NULL){
            sum += l0->val;
            l0 = l0->next;
        }
        if(l1!=NULL){
            sum += l1->val;
            l1=l1->next;
        }
        carry = sum/10;
        tmp->val = sum%10;
        if(l0!=NULL||l1!=NULL||carry!=0){
            tmp->next = new LLNode();
            tmp = tmp->next;
        }
    }
    if(carry>0)
        tmp->val = carry;
    return l;
}",1.0,111111111111111
Singly_linked_list_2,1404534,2252260,"int getIndex(SLinkedList<Term>* terms, SLinkedList<Term>::Iterator it) {
    int index = 0;
    for (SLinkedList<Term>::Iterator tmp = terms->begin(); tmp != it; ++tmp) {
        ++index;
    }
    return index;
}


void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.coeff==0)
        return;
    SLinkedList<Term>::Iterator it = this->terms->begin();
    while(it!=this->terms->end() && term.exp < (*it).exp)
        ++it;
    if(it != this->terms->end() && term.exp == (*it).exp){
        (*it).coeff += term.coeff;
        if((*it).coeff == 0){
            int index = getIndex(terms, it);
            this->terms->removeAt(index);
            it = this->terms->begin();
            for (int i = 0; i < index && it != this->terms->end(); ++i) {
                ++it;
            }
        }
    }
    else{
        if(this->terms->empty())
            this->terms->add(term);
        else
            this->terms->add(getIndex(terms, it), term);       
    }
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term newTerm(coeff, exp);
    if(newTerm.coeff==0)
        return;
    SLinkedList<Term>::Iterator it = this->terms->begin();
    while(it!=this->terms->end() && newTerm.exp < (*it).exp)
        ++it;
    if(it != this->terms->end() && newTerm.exp == (*it).exp){
        (*it).coeff += newTerm.coeff;
        if((*it).coeff==0){
            int index = getIndex(terms, it);
            this->terms->removeAt(index);
            it = this->terms->begin();
            for (int i = 0; i < index && it != this->terms->end(); ++i) {
                ++it;
            }
        }
    }
    else{
        if(this->terms->empty())
            this->terms->add(newTerm);
        else
            this->terms->add(getIndex(terms, it), newTerm);       
    }
}",1.0,11111
Singly_linked_list_4,1404534,2252260,"void LinkedList::partition(int k) {
    Node* tmp = head;
    int* arr = new int[this->size];
    int index=0;
    while(tmp){
        if(tmp->value < k){
            arr[index] = tmp->value;
            index++;
        }
        tmp = tmp->next;
    }
    tmp=head;
    while(tmp){
        if(tmp->value == k){
            arr[index] = tmp->value;
            index++;
        }
        tmp = tmp->next;
    }
    tmp=head;
    while(tmp){
        if(tmp->value > k){
            arr[index] = tmp->value;
            index++;
        }
        tmp = tmp->next;
    }
    tmp=head;
    int i=0;
    while(tmp){
        tmp->value = arr[i];
        i++;
        tmp = tmp->next;
    }
    tail->value = arr[size-1];
    delete[] arr;
}",1.0,11111
Singly_linked_list_5,1404534,2252260,"void reduceDuplicate(Node* root) {
    Node* tmp = root;
    while(tmp && tmp->getNext()){
        if(tmp->getNext()->getData() == tmp->getData()){
            Node* nodeToRemove = tmp->getNext();
            tmp->setNext(nodeToRemove->getNext());
            delete nodeToRemove;
        }
        else
            tmp = tmp->getNext();
    }
}",1.0,1111111111
Singly_linked_list_6,1404534,2252260,"int Train::allocate(int containerSize) {
    TrainCar* tmp = head->next;
    int idx = 0;
    int min = 999999;
    for(int i=1; i<size; i++) {
        if(tmp->remainingSpace>=containerSize && tmp->remainingSpace<min){
            idx = i;
            min = tmp->remainingSpace;
        }
        tmp = tmp->next;
    }
    if(min != 999999) {
        tmp = head->next;
        for(int i=1; i<idx; i++){
            tmp = tmp->next;
        }
        tmp->remainingSpace -= containerSize;
        return idx;
    }
    return -1;
}

int Train::totalRemainingSpace() {
    int sum = 0;
    TrainCar* tmp = head;
    while(tmp) {
        sum += tmp->remainingSpace;
        tmp = tmp->next;
    }
    return sum;
}",1.0,11111
Singly_linked_list_7,1404534,2252260,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* node = new Node(e);
    if(this->count == 0){
        head = tail = node;
    }
    else{
        this->tail->next = node;
        tail = tail->next;
    }
    this->count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index==0){
        Node* node = new Node(e);   
        if(this->count==0)
            head = tail = node;
        else{
            node->next = head;
            head = node;
        }
    }
    else if(index==count){
        add(e);
        return;
    }
    else{
        Node* tmp = head;
        for(int i=0; i<index-1; i++)
            tmp = tmp->next;
        Node* nodeToInsert = new Node(e);
        nodeToInsert->next = tmp->next;
        tmp->next = nodeToInsert;   
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}
",1.0,1111111111
Singly_linked_list_8,1404534,2252260,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count)
        throw std::out_of_range(""Segmentation fault!"");
    Node* tmp = head;
    for(int i=0; i<index; i++){
        tmp = tmp->next;
    }
    return tmp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count)
        throw std::out_of_range(""Index out of range!"");
    Node* tmp = head;
    for(int i=0; i<index; i++){
        tmp = tmp->next;
    }
    tmp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return this->count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* tmp = head;
    int idx = 0;
    while(tmp){
        if(tmp->data == item)
            return idx;
        idx++;
        tmp = tmp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1404534,2252260,"template <class T>
T SLinkedList<T>::removeAt(int index) {
    /* Remove element at index and return removed value */
    if (count == 0) throw std::out_of_range(""Index is out of range"");
    if (index > count-1) throw std::out_of_range(""Index is out of range"");
    Node* h = head;
    Node* prev = NULL;
    T temp;
    if (index == 0) {
        temp = h->data;
        head = h->next;
        delete h;
        --(this->count);
        return temp;
    }
    if (index == count-1) {
        while (h->next->next != NULL) h = h->next;
        temp = tail->data;
        delete tail;
        tail = h;
        tail->next = NULL;
        --(this->count);
        return temp;
    }
    int idx = 0;
    while (h != NULL) {
        if (idx == index) {
            prev->next = h->next;
            temp = h->data;
            delete h;
            --(this->count);
            return temp;
        }
        ++idx;
        prev = h;
        h = h->next;
    }
    throw std::out_of_range(""Index is out of range"");
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(count==0) return false;
    Node* tmp = head;
    for(int i=0; i<count; i++){
        if(tmp->data == item){
            this->removeAt(i);
            return true;
        }
        tmp = tmp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* tmp;
    while(head){
        tmp = head;
        head = head->next;
        delete tmp;
    }
}

",0.9,1111111110
Singly_linked_list_1,1406208,2210200,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode *head = new LLNode();
    head->val = 0;
    head->next = NULL;
    LLNode *temp = head;
    int a = 0, b = 0, save = 0, tmp = 0;
    if(l0 == NULL && l1 == NULL){
        head = NULL;
    }
    while(l0 != NULL || l1 != NULL){
        if(temp->next != NULL) temp = temp->next;
        if(l0 != NULL){
            a = l0->val;
            l0 = l0->next;
        }
        else a = 0;
        if(l1 != NULL){
            b = l1->val;
            l1 = l1->next;
        }
        else b = 0;
        tmp = a + b + save;
        if(tmp > 9){
            save = (int)(tmp/10);
            tmp %= 10;
            temp->val = tmp;
        }
        else{
            save = 0;
            temp->val = tmp;
        }
        LLNode *newnode = new LLNode();
        newnode->val = 0;
        newnode->next = NULL;
        temp->next = newnode;
    }
    if(save != 0){
        LLNode *newnode = new LLNode();
        newnode->next = NULL;
        newnode->val = save;
        temp->next = newnode;
    }
    else{
        temp->next = NULL;
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1406208,2210200,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.coeff == 0) return;
    for(int i = 0; i < terms->size(); i++){
        if(terms->get(i).coeff == 0){
            terms->removeAt(i);
        }
    }
    if(terms->size() == 0){
        terms->add(term);
        return;
    }
    for(int i = 0; i < terms->size(); i++){
        if(terms->get(i).exp == term.exp){
            double sum = term.coeff + terms->get(i).coeff;
            if(sum == 0) terms->removeAt(i);
            else{
                Term newterm(sum, term.exp);
                terms->set(i, newterm);
            }
            return;
        }
    }
    for(int i = 0; i < terms->size(); i++){
        if(term.exp > terms->get(i).exp){
            terms->add(i, term);
            return;
        }
    }
    terms->add(terms->size(), term);
    return;
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term newterm(coeff, exp);
    insertTerm(newterm);
    return;
}",1.0,11111
Singly_linked_list_3,1406208,2210200,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(begin){
        if(pList){
            current = pList->head;
            index = 0;
        }
        else{
            current = NULL;
            index = -1;
        }
    }
    else{
        current = NULL;
        if(pList){
            index = pList->size();
        }
        else{
            index = 0;
        }
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(pList == NULL || current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    if(current == pList->head){
        pList->removeAt(0);
        current = NULL;
        index = -1;
        return;
    }
    Node *temp = pList->head;
    for(int i = 1; i < pList->size(); i++){
        if(current == temp->next){
            pList->removeAt(i);
            current = temp;
            --index;
            return;
        }
        temp = temp->next;
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current){
        current->data = e;
    }
    else{
        throw std::out_of_range(""Segmentation fault!"");
    }
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current){
        return current->data;
    }
    else{
        throw std::out_of_range(""Segmentation fault!"");
    }
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if(this->current == iterator.current && this->index == iterator.index) return false;
    return true;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL && index == -1){
        if(pList){
            current = pList->head;
            ++index;
        }
    }
    else if(current == NULL && index == pList->size()){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        current = current->next;
        ++index;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator it = *this;
    ++*this;
    return it;
}",1.0,11111
Singly_linked_list_4,1406208,2210200,"void LinkedList::partition(int k) {
    if(this->size == 0) return;
    LinkedList *group1 = new LinkedList();
    LinkedList *group2 = new LinkedList();
    LinkedList *group3 = new LinkedList();
    Node *temp = head;
    while(temp != NULL){
        int data = temp->value;
        if(data < k){
            group1->add(data);
        }
        else if(data == k){
            group2->add(data);
        }
        else{
            group3->add(data);
        }
        temp = temp->next;
    }
    temp = head;
    if(group1->size){
        this->head = group1->head;
        if(group2->size){
            group1->tail->next = group2->head;
            if(group3->size){
                group2->tail->next = group3->head;
                this->tail = group3->tail;
            }
            else{
                this->tail = group2->tail;
            }
        }
        else if(group3->size){
            group1->tail->next = group3->head;
            this->tail = group3->tail;
        }
        else{
            this->tail = group1->tail;
        }
    }
    else if(group2->size){
        this->head = group2->head;
        if(group3->size){
            group2->tail->next = group3->head;
            this->tail = group3->tail;
        }
        else{
            this->tail = group2->tail;
        }
    }
    else{
        this->head = group3->head;
        this->tail = group3->tail;
    }
    return;
}",1.0,11111
Singly_linked_list_5,1406208,2210200,"#include<vector>
#include<algorithm>

void reduceDuplicate(Node* root)
{
    vector<int> v;
    Node *temp = root;
    while(temp != NULL){
        int val = temp->getData();
        if(!v.empty()){
            if(v.back() != val) v.push_back(val);
        }
        else v.push_back(val);
        temp = temp->getNext();
    }
    temp = root;
    int n = int(v.size());
    for(int i = 0; i < n; i++){
        temp->setData(v[i]);
        if(i != n - 1) temp = temp->getNext();
        else{
            temp->setNext(NULL);
        }
    }
    return;
}",1.0,1111111111
Singly_linked_list_6,1406208,2210200,"int Train::allocate(int containerSize) {
    TrainCar *temp = head;
    int des = -1, mn = 1e9;
    for(int i = 0; i < size; i++){
        if(temp->remainingSpace >= containerSize){
            if(temp->remainingSpace < mn){
                des = i;
                mn = temp->remainingSpace;
            }
        }
        temp = temp->next;
    }
    if(des == -1) return -1;
    temp = head;
    for(int i = 0; i < size; i++){
        if(i == des){
            temp->remainingSpace -= containerSize;
            break;
        }
        temp = temp->next;
    }
    return des;
}

int Train::totalRemainingSpace() {
    TrainCar *temp = head;
    int ans = 0;
    while(temp != NULL){
        ans += temp->remainingSpace;
        temp = temp->next;
    }
    return ans;
}",1.0,11111
Singly_linked_list_7,1406208,2210200,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *newnode = new Node(e, NULL);
    if(count == 0){
        head = newnode;
        tail = newnode;
        ++count;
        return;
    }
    tail->next = newnode;
    tail = newnode;
    ++count;
    return;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if(index < 0 || index > count) return;
    if(index == count){
        add(e);
        return;
    }
    Node *newnode = new Node(e, NULL);
    if(index == 0){
        newnode->next = head;
        head = newnode;
        ++count;
        return;
    }
    Node *temp = head;
    for(int i = 0; i < index - 1; i++){
        temp = temp->next;
    }
    newnode->next = temp->next;
    temp->next = newnode;
    ++count;
    return;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1406208,2210200,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count) throw std::out_of_range(""Out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count) throw std::out_of_range(""Out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    temp->data = e;
    return;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0);
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item){
            return i;
        }
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node *temp = head;
    while(temp != NULL){
        if(temp->data == item) return true;
        temp = temp->next;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1406208,2210200,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    if(count == 1){
        T val = head->data;
        delete head;
        head = NULL;
        tail = NULL;
        --count;
        return val;
    }
    if(index == 0){
        T val = head->data;
        Node *removeNode = head;
        head = head->next;
        delete removeNode;
        --count;
        return val;
    }
    Node *temp = head;
    for(int i = 0; i < index - 1; i++){
        temp = temp->next;
    }
    Node *removeNode = temp->next;
    T returnval = removeNode->data;
    temp->next = removeNode->next;
    if(temp->next == NULL) tail = temp;
    delete removeNode;
    --count;
    return returnval;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item){
            removeAt(i);
            return true;
        }
        temp = temp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        Node *removeNode = temp;
        temp = temp->next;
        delete removeNode;
    }
    head = NULL;
    tail = NULL;
    count = 0;
    return;
}

",1.0,1111111111
Singly_linked_list_10,1406208,2210200,"LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if(head == NULL){
        return NULL;
    }
    LLNode *temp = head;
    int count = 0;
    while(temp != NULL){
        ++count;
        temp = temp->next;
    }
    temp = head;
    int *a = new int[count + 2];
    if(count % 2 == 0){
        for(int i = count/2; i >= 1; i--){
            a[i] = temp->val;
            temp = temp->next;
        }
        // a[3] = 11, a[2] = 9, a[1] = 14
        for(int i = 1; i <= count/2; i++){
            a[i] += temp->val;
            temp = temp->next;
        }
        LLNode *newhead = new LLNode(0, NULL);
        // newhead->val = 0;
        // newhead->next = NULL;
        temp = newhead;
        for(int i = 1; i <= count/2; i++){
            if(temp->next != NULL) temp = temp->next;
            temp->val = a[i];
            LLNode *newnode = new LLNode(0, NULL);
            temp->next = newnode;
        }
        temp->next = NULL;
        return newhead;
    }
    else{
        for(int i = count/2 + 1; i >= 1; i--){
            a[i] = temp->val;
            temp = temp->next;
        }
        // a[3] = 11, a[2] = 9, a[1] = 14
        for(int i = 2; i <= count/2 + 1; i++){
            a[i] += temp->val;
            temp = temp->next;
        }
        LLNode *newhead = new LLNode(0, NULL);
        // newhead->val = 0;
        // newhead->next = NULL;
        temp = newhead;
        for(int i = 1; i <= count/2 + 1; i++){
            if(temp->next != NULL) temp = temp->next;
            temp->val = a[i];
            LLNode *newnode = new LLNode(0, NULL);
            temp->next = newnode;
        }
        temp->next = NULL;
        return newhead;
    }
}",1.0,1111111111
Singly_linked_list_11,1406208,2210200,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    int count = 0;
    LLNode *temp = head;
    while(temp != NULL){
        ++count;
        temp = temp->next;
    }
    if(count == 0) return NULL;
    int *a = new int[count + 2];
    temp = head;
    for(int i = 1; i <= count; i++){
        a[i] = temp->val;
        temp = temp->next;
    }
    stack<int> st;
    stack<int> save;
    for(int i = count; i >= 1; i--){
        while(!st.empty() && st.top() <= a[i]) st.pop();
        int ans = 0;
        if(!st.empty()) ans = st.top();
        save.push(ans);
        st.push(a[i]);
    }
    int *b = new int[count + 2];
    for(int i = 1; i <= count; i++){
        b[i] = save.top();
        save.pop();
    }
    LLNode *returnhead = new LLNode(0, NULL);
    temp = returnhead;
    for(int i = 1; i <= count; i++){
        if(temp->next != NULL) temp = temp->next;
        temp->val = b[i];
        LLNode *newnode = new LLNode(0, NULL);
        temp->next = newnode;
    }
    temp->next = NULL;
    return returnhead;
}",1.0,1111111111
Singly_linked_list_12,1406208,2210200,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    int count = 0;
    LLNode *temp = head;
    while(temp != NULL){
        ++count;
        temp = temp->next;
    }
    if(count == 0) return NULL;
    temp = head;
    int *a = new int[count + 2];
    for(int i = 1; i <= count; i++){
        a[i] = temp->val;
        temp = temp->next;
    }
    LLNode *returnhead = new LLNode(0, NULL);
    temp = returnhead;
    for(int i = count; i >= 1; i--){
        if(temp->next != NULL) temp = temp->next;
        temp->val = a[i];
        LLNode *newnode = new LLNode(0, NULL);
        temp->next = newnode;
    }
    temp->next = NULL;
    return returnhead;
}",1.0,1111111111
Singly_linked_list_13,1406208,2210200,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    int count = 0;
    LLNode *temp = head;
    while(temp != NULL){
        ++count;
        temp = temp->next;
    }
    if(count == 0) return NULL;
    int start = count + 1 - k % count;
    temp = head;
    int *a = new int[count + 2];
    for(int i = 1; i <= count; i++){
        a[i] = temp->val;
        temp = temp->next;
    }
    int *b = new int[count * 2 + 2];
    for(int i = 1; i <= count; i++){
        b[i] = a[i];
        b[i + count] = a[i];
    }
    LLNode *returnhead = new LLNode(0, NULL);
    temp = returnhead;
    for(int i = start; i <= start + count - 1; i++){
        if(temp->next != NULL) temp = temp->next;
        temp->val = b[i];
        LLNode *newnode = new LLNode(0, NULL);
        temp->next = newnode;
    }
    temp->next = NULL;
    return returnhead;
}",1.0,1111111111
Singly_linked_list_14,1406208,2210200,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    // linked_list->head->next->next->next = head->next->next->next;
    // head = linked_list->head;
    
    if(size == 0){
        head = linked_list->head;
        tail = linked_list->tail;
        size = linked_list->size;
        return;
    }
    if(low <= 0 && high >= size - 1){
        Node *temp = head;
        for(int i = 0; i <= size - 1; i++){
            Node *removenode = temp;
            temp = temp->next;
            delete removenode;
        }
        this->head = linked_list->head;
        this->tail = linked_list->tail;
        this->size = linked_list->size;
        return;
    }
    else if(low > 0 && high < size - 1){
        Node *templow = head;
        for(int i = 0; i < low - 1; i++){
            templow = templow->next;
        }
        Node *temphigh = head;
        for(int i = 0; i < high; i++){
            temphigh = temphigh->next;
        }
        Node *temp = templow->next;
        templow->next = linked_list->head;
        linked_list->tail->next = temphigh->next;
        for(int i = 1; i <= high - low + 1; i++){
            Node *removenode = temp;
            temp = temp->next;
            delete removenode;
        }
        this->size = this->size - (high - low + 1) + linked_list->size;
    }
    else if(low <= 0){
        Node *temp = head;
        for(int i = 0; i < high; i++){
            temp = temp->next;
        }
        linked_list->tail->next = temp->next;
        temp = head;
        for(int i = 1; i <= high + 1; i++){
            Node *removenode = temp;
            temp = temp->next;
            delete removenode;
        }
        this->head = linked_list->head;
        this->size = this->size - (high - 0 + 1) + linked_list->size;
    }
    else{
        Node *temp = head;
        for(int i = 0; i < low - 1; i++){
            temp = temp->next;
        }
        temp->next = linked_list->head;
        temp = temp->next;
        for(int i = 1; i <= size - 1 - low + 1; i++){
            Node *removenode = temp;
            temp = temp->next;
            delete removenode;
        }
        this->tail = linked_list->tail;
        this->size = this->size - (this->size - 1 - low + 1) + linked_list->size;
    }
}",1.0,11111
Singly_linked_list_2,1406294,2212282,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1406294,2212282,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1406294,2212282,"void reduceDuplicate(Node* root)
{
}",0.2,0000101000
Singly_linked_list_7,1406294,2212282,"template <class T>
void SLinkedList<T>::add(const T& e) {
    if(count == 0) {
        head = new Node(e, NULL);
        tail = head;
    }
    else {
        tail->next = new Node(e, NULL);
        tail = tail->next;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    if(index < 0 || index > count) return;
    
    if(index == 0) {
        if(count == 0) this->add(e);
        else {
            Node* temp = new Node(e, head);
            head = temp;
            ++count;
        }
    }
    
    else if(index == count) {
        this->add(e);   
    }
    
    else {
        Node* temp = head;
        while(index-- != 1) temp = temp->next;
        
        Node* tmp = new Node(e, temp->next);
        temp->next = tmp;
        ++count;
    }
}

template<class T>
int SLinkedList<T>::size() {
    return count;
}
",1.0,1111111111
Singly_linked_list_1,1408920,2213250,"void addLinked(LLNode * tail, LLNode *l0 , int& carry)
{
    
    while(l0)
    {
        int n = l0->val +carry;
        carry = n/10;
        n %=10;
        tail ->next = new LLNode(n,NULL);
        tail = tail ->next;
        l0=l0->next;
    }
}
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    int carry =0;
    LLNode * p0 = l0;
    LLNode * p1 = l1;
    LLNode * head = NULL;
    LLNode * tail =NULL;
    while(p0 && p1)
    {
        int n = p0->val + p1->val +carry;
        carry = n/10;
        n %=10;
        if(!head)
        {
            tail = new LLNode(n,NULL);
            head = tail;
        }
        else
        {
            tail->next = new LLNode(n,NULL);
            tail = tail->next;
        }
        p0=p0->next;
        p1=p1->next;
    }
    if(p0)
    {
        addLinked(tail, p0 , carry);
    }
    else if(p1)
    {
        addLinked(tail, p1 , carry);
    }
    if(carry)
    {
        tail ->next = new LLNode(carry,NULL);
        tail = NULL;
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1408920,2213250,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_3,1408920,2213250,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(begin){
        if(pList != NULL){
            current = pList -> head;
            this -> index =0;
        }
        else{
            current = NULL;
            index = -1;
        }
    }
    else{
        current = NULL;
        index = (pList == NULL)? 0 : pList-> size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this-> current = iterator.current;
    this-> pList = iterator.pList;
    this-> index = iterator.index;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        pList-> removeAt(index);
        index--;
    }
    
    if(index == -1){
        current = NULL;
    }
    else{
        current = pList->head;
        for (int i =0; i < index; i++){
            current = current->next;
        }
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if( current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    current-> data = e;
    
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    return current -> data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return !(this-> current == iterator.current && this-> index == iterator.index) ;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL && index == -1){
        current = pList-> head;
        index++;
    }
    else if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        current = current -> next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,11111
Singly_linked_list_7,1408920,2213250,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if (head)
    {
        tail->next = new Node(e, nullptr);
        tail = tail->next;
    }
    else
    {
        head = new Node(e, nullptr);
        tail = head;
    }
    ++count;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index==count)
    {
        (*this).add(e);
        return;
    }
    if (index==0)
    {
        this->head = new Node(e, head);
        ++count;
        return;
    }
    Node* run = head;
    Node* pre = nullptr;
    for (int i = 0; i<index; ++i)
    {
        pre = run;
        run = run->next;
    }
    pre->next = new Node(e, run);
    ++count;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",0.95,1111111111
Singly_linked_list_1,1409867,2210055,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
     LLNode *res = new LLNode();
  LLNode *cur = res;
  int carry = 0;
  while (l0 != nullptr || l1 != nullptr)
  {
    int sum = carry;
    if (l0 != nullptr)
    {
      sum += l0->val;
      l0 = l0->next;
    }
    if (l1 != nullptr)
    {
      sum += l1->val;
      l1 = l1->next;
    }
    carry = sum / 10;
    cur->next = new LLNode(sum % 10, nullptr);
    cur = cur->next;
  }
  if (carry > 0)
  {
    cur->next = new LLNode(carry, nullptr);
  }
  return res->next;
}
",1.0,111111111111111
Singly_linked_list_2,1409867,2210055,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.18,00010
Singly_linked_list_4,1409867,2210055,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1409867,2210055,"void reduceDuplicate(Node *root)
{
  Node* current = root;

    while (current != nullptr && current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicate = current->getNext();
            current->setNext(duplicate->getNext());
            delete duplicate; // Xóa node trùng lặp
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_7,1409867,2210055,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
     Node* newNode = new Node(e, nullptr);
        if (!head) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
        count++;
    
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
     if (index < 0 || index > count) {
            std::cerr << ""Index out of range"" << std::endl;
            return;
        }

        Node* newNode = new Node(e, nullptr);
        if (index == 0) {
            newNode->next = head;
            head = newNode;
            if (!tail) {
                tail = newNode;
            }
        } else {
            Node* current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current->next;
            }
            newNode->next = current->next;
            current->next = newNode;
            if (index == count) {
                tail = newNode;
            }
        }
        count++;
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
    return 0;
}
",1.0,1111111111
Singly_linked_list_8,1409867,2210055,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
     if (index < 0 || index >= count) {
            throw std::out_of_range(""Index out of range"");
        }
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
 if (index < 0 || index >= count) {
            throw std::out_of_range(""Index out of range"");
        }
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        current->data = e;
    
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
     Node* current = head;
        for (int i = 0; i < count; i++) {
            if (current->data == item) {
                return i;
            }
            current = current->next;
        }
        return -1; // Item not found
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
     return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1409867,2210055,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }

    Node* current = head;
    Node* previous = nullptr;

    for (int i = 0; i < index; i++) {
        previous = current;
        current = current->next;
    }

    T removedData = current->data;

    if (previous != nullptr) {
        previous->next = current->next;
    }
    if (current == head) {
        head = current->next;
    }
    if (current == tail) {
        tail = previous;
    }

    delete current;
    count--;

    return removedData;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    
Node* current = head;
    Node* previous = nullptr;

    while (current != nullptr) {
        if (current->data == item) {
            if (current == head) {
                head = current->next;
            }
            if (current == tail) {
                tail = previous;
            }
            if (previous != nullptr) {
                previous->next = current->next;
            }

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
     while (head != nullptr) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1409867,2210055,"LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
     LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* nextNode = nullptr;
    
    while (current != nullptr) {
        nextNode = current->next;
        current->next = prev;
        prev = current;
        current = nextNode;
    }
    
    return prev;
}",0.1,0010000000
Singly_linked_list_11,1409867,2210055,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    if (!head) {
        return nullptr; 
    }

    stack<LLNode*> nodeStack;
    LLNode* current = head;

    
    while (current) {
        while (!nodeStack.empty() && current->val > nodeStack.top()->val) {
        
            nodeStack.top()->val = current->val;
            nodeStack.pop();
        }
        nodeStack.push(current);
        current = current->next;
    }

  
    while (!nodeStack.empty()) {
        nodeStack.top()->val = 0;
        nodeStack.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1409867,2210055,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
     LLNode* prev = nullptr; 
    LLNode* current = head;

    while (current != nullptr) {
        LLNode* next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }

    head = prev;

    return head;
}",1.0,1111111111
Singly_linked_list_13,1409867,2210055,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (!head || k == 0) {
        return head;
    }

    int length = 1;
    LLNode* current = head;
    while (current->next) {
        current = current->next;
        length++;
    }

    k = k % length;
    if (k < 0) {
        k += length;
    }

    if (k == 0) {
        return head; 
    }

    
    LLNode* newHead = head;
    LLNode* newTail = head;

    for (int i = 0; i < k; i++) {
        newTail = newHead;
        newHead = newHead->next;
    }

   
    newTail->next = nullptr;

 
    current->next = head;

    return newHead;
}",0.1,0100000000
Singly_linked_list_14,1409867,2210055,"void LinkedList::replace(LinkedList *linked_list, int low, int high)
{
  if (low <= high && high >= 0) {
     
        if (low < 0) {
            low = 0;
        }
       
        if (high >= size) {
            high = size - 1;
        }

        Node* current = head;
        Node* previous = nullptr;
        int currentIndex = 0;

      
        while (current != nullptr && currentIndex < low) {
            previous = current;
            current = current->next;
            currentIndex++;
        }


        while (current != nullptr && currentIndex <= high) {
            Node* temp = current;
            current = current->next;
            delete temp;
            size--;
        }

        
        if (previous == nullptr) {
            head = linked_list->head;
        } else {
            previous->next = linked_list->head;
        }

      
        if (high >= size) {
            tail = linked_list->tail;
        }

        size += linked_list->size;
    }
}",0.2,00100
Singly_linked_list_1,1409938,2252260,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    if(l0==NULL&&l1==NULL)
        return nullptr;
    LLNode* l = new LLNode();
    LLNode* tmp = l;
    int carry = 0;
    while(l0!=NULL || l1!=NULL){
        int sum = carry;
        if(l0!=NULL){
            sum += l0->val;
            l0 = l0->next;
        }
        if(l1!=NULL){
            sum += l1->val;
            l1=l1->next;
        }
        carry = sum/10;
        tmp->val = sum%10;
        if(l0!=NULL||l1!=NULL||carry!=0){
            tmp->next = new LLNode();
            tmp = tmp->next;
        }
    }
    if(carry>0)
        tmp->val = carry;
    return l;
}",1.0,111111111111111
Singly_linked_list_2,1409938,2252260,"int getIndex(SLinkedList<Term>* terms, SLinkedList<Term>::Iterator it) {
    int index = 0;
    for (SLinkedList<Term>::Iterator tmp = terms->begin(); tmp != it; ++tmp) {
        ++index;
    }
    return index;
}


void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.coeff==0)
        return;
    SLinkedList<Term>::Iterator it = this->terms->begin();
    while(it!=this->terms->end() && term.exp < (*it).exp)
        ++it;
    if(it != this->terms->end() && term.exp == (*it).exp){
        (*it).coeff += term.coeff;
        if((*it).coeff == 0){
            int index = getIndex(terms, it);
            this->terms->removeAt(index);
            it = this->terms->begin();
            for (int i = 0; i < index && it != this->terms->end(); ++i) {
                ++it;
            }
        }
    }
    else{
        if(this->terms->empty())
            this->terms->add(term);
        else
            this->terms->add(getIndex(terms, it), term);       
    }
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term newTerm(coeff, exp);
    if(newTerm.coeff==0)
        return;
    SLinkedList<Term>::Iterator it = this->terms->begin();
    while(it!=this->terms->end() && newTerm.exp < (*it).exp)
        ++it;
    if(it != this->terms->end() && newTerm.exp == (*it).exp){
        (*it).coeff += newTerm.coeff;
        if((*it).coeff==0){
            int index = getIndex(terms, it);
            this->terms->removeAt(index);
            it = this->terms->begin();
            for (int i = 0; i < index && it != this->terms->end(); ++i) {
                ++it;
            }
        }
    }
    else{
        if(this->terms->empty())
            this->terms->add(newTerm);
        else
            this->terms->add(getIndex(terms, it), newTerm);       
    }
}",1.0,11111
Singly_linked_list_4,1409938,2252260,"void LinkedList::partition(int k) {
    Node* tmp = head;
    int* arr = new int[this->size];
    int index=0;
    while(tmp){
        if(tmp->value < k){
            arr[index] = tmp->value;
            index++;
        }
        tmp = tmp->next;
    }
    tmp=head;
    while(tmp){
        if(tmp->value == k){
            arr[index] = tmp->value;
            index++;
        }
        tmp = tmp->next;
    }
    tmp=head;
    while(tmp){
        if(tmp->value > k){
            arr[index] = tmp->value;
            index++;
        }
        tmp = tmp->next;
    }
    tmp=head;
    int i=0;
    while(tmp){
        tmp->value = arr[i];
        i++;
        tmp = tmp->next;
    }
    tail->value = arr[size-1];
    delete[] arr;
}",1.0,11111
Singly_linked_list_5,1409938,2252260,"void reduceDuplicate(Node* root) {
    Node* tmp = root;
    while(tmp && tmp->getNext()){
        if(tmp->getNext()->getData() == tmp->getData()){
            Node* nodeToRemove = tmp->getNext();
            tmp->setNext(nodeToRemove->getNext());
            delete nodeToRemove;
        }
        else
            tmp = tmp->getNext();
    }
}",1.0,1111111111
Singly_linked_list_6,1409938,2252260,"int Train::allocate(int containerSize) {
    TrainCar* tmp = head->next;
    int idx = 0;
    int min = 999999;
    for(int i=1; i<size; i++) {
        if(tmp->remainingSpace>=containerSize && tmp->remainingSpace<min){
            idx = i;
            min = tmp->remainingSpace;
        }
        tmp = tmp->next;
    }
    if(min != 999999) {
        tmp = head->next;
        for(int i=1; i<idx; i++){
            tmp = tmp->next;
        }
        tmp->remainingSpace -= containerSize;
        return idx;
    }
    return -1;
}

int Train::totalRemainingSpace() {
    int sum = 0;
    TrainCar* tmp = head;
    while(tmp) {
        sum += tmp->remainingSpace;
        tmp = tmp->next;
    }
    return sum;
}",1.0,11111
Singly_linked_list_7,1409938,2252260,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* node = new Node(e);
    if(this->count == 0){
        head = tail = node;
    }
    else{
        this->tail->next = node;
        tail = tail->next;
    }
    this->count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index==0){
        Node* node = new Node(e);   
        if(this->count==0)
            head = tail = node;
        else{
            node->next = head;
            head = node;
        }
    }
    else if(index==count){
        add(e);
        return;
    }
    else{
        Node* tmp = head;
        for(int i=0; i<index-1; i++)
            tmp = tmp->next;
        Node* nodeToInsert = new Node(e);
        nodeToInsert->next = tmp->next;
        tmp->next = nodeToInsert;   
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}
",1.0,1111111111
Singly_linked_list_8,1409938,2252260,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count)
        throw std::out_of_range(""Segmentation fault!"");
    Node* tmp = head;
    for(int i=0; i<index; i++){
        tmp = tmp->next;
    }
    return tmp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count)
        throw std::out_of_range(""Index out of range!"");
    Node* tmp = head;
    for(int i=0; i<index; i++){
        tmp = tmp->next;
    }
    tmp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return this->count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* tmp = head;
    int idx = 0;
    while(tmp){
        if(tmp->data == item)
            return idx;
        idx++;
        tmp = tmp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1409938,2252260,"template <class T>
T SLinkedList<T>::removeAt(int index) {
    /* Remove element at index and return removed value */
    if (count == 0) throw std::out_of_range(""Index is out of range"");
    if (index > count-1) throw std::out_of_range(""Index is out of range"");
    Node* h = head;
    Node* prev = NULL;
    T temp;
    if (index == 0) {
        temp = h->data;
        head = h->next;
        delete h;
        --(this->count);
        return temp;
    }
    if (index == count-1) {
        while (h->next->next != NULL) h = h->next;
        temp = tail->data;
        delete tail;
        tail = h;
        tail->next = NULL;
        --(this->count);
        return temp;
    }
    int idx = 0;
    while (h != NULL) {
        if (idx == index) {
            prev->next = h->next;
            temp = h->data;
            delete h;
            --(this->count);
            return temp;
        }
        ++idx;
        prev = h;
        h = h->next;
    }
    throw std::out_of_range(""Index is out of range"");
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(count==0) return false;
    Node* tmp = head;
    for(int i=0; i<count; i++){
        if(tmp->data == item){
            this->removeAt(i);
            return true;
        }
        tmp = tmp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* tmp;
    while(head){
        tmp = head;
        head = head->next;
        delete tmp;
    }
}

",0.9,1111111110
Singly_linked_list_10,1409938,2252260,"LLNode* reverse(LLNode* head) {
    LLNode* prev = NULL;
    LLNode* curr = head;
    while (curr != NULL) {
        LLNode* nextTemp = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}

LLNode* foldLinkedList(LLNode* head) {
    LLNode* tmp = head;
    int size = 0;
    while(tmp){
        size++;
        tmp = tmp->next;
    }
    int* arr = new int[size];
    tmp = head;
    for(int i=0; i<size; i++){
        arr[i] = tmp->val;
        tmp = tmp->next;
    }
    LLNode* res = NULL;
    LLNode** nodeRef = &res;
    for(int i=0; i<size/2; i++){
        *nodeRef = new LLNode();
        (*nodeRef)->val = arr[i] + arr[size-i-1];
        (*nodeRef)->next = NULL;
        nodeRef = &((*nodeRef)->next);
    }
    if(size % 2 != 0){
        *nodeRef = new LLNode();
        (*nodeRef)->val = arr[size/2];
        (*nodeRef)->next = NULL;
    }
    delete[] arr;
    return reverse(res);
}
",1.0,1111111111
Singly_linked_list_11,1409938,2252260,"LLNode* replaceFirstGreater(LLNode* head) {
    LLNode* tmp = head;
    int size = 0;
    while(tmp){
        tmp = tmp->next;
        size++;
    }
    LLNode* res = NULL;
    LLNode** nodeRef = &res;
    int* arr = new int[size];
    
    tmp = head;
    for(int i=0; i<size; i++){
        arr[i] = tmp->val;
        tmp = tmp->next;
    }
    
    for(int i=0; i<size; i++){
        int greaterNumber = -1; // Initialize with -1 assuming all numbers are non-negative. Change as per your requirements.
        for(int j=i+1; j<size; j++){
            if(arr[j] > arr[i]){
                greaterNumber = arr[j];
                break;
            }
        }
        *nodeRef = new LLNode();
        (*nodeRef)->val = (greaterNumber == -1) ? 0 : greaterNumber; // If no greater number is found, assign 0
        (*nodeRef)->next = NULL;
        nodeRef = &((*nodeRef)->next);
    }
    delete[] arr;
    return res;
}
",1.0,1111111111
Singly_linked_list_12,1409938,2252260,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* curr = head;
    LLNode* prev = NULL, *next = NULL;
    while(curr){
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}",1.0,1111111111
Singly_linked_list_13,1409938,2252260,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (!head || !head->next || k == 0)
        return head;

    LLNode* tmp = head;
    int size = 0;
    while(tmp){
        size++;
        tmp = tmp->next;
    }

    k %= size; 
    if (k == 0) 
        return head;

    LLNode* slow = head;
    LLNode* fast = head;

    for(int i=0; i<k; i++)
        fast = fast->next;

    while(fast->next){
        slow = slow->next;
        fast = fast->next;
    }

    LLNode* newHead = slow->next;
    slow->next = NULL;
    fast->next = head; 

    return newHead;
}
",1.0,1111111111
Singly_linked_list_14,1409938,2252260,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    Node* prev = NULL;
    Node* current = head;
    int count = 0;

    while (current != NULL && count < low) {
        prev = current;
        current = current->next;
        count++;
    }

    if (low <= 0) {
        head = linked_list->head;
    } else {
        prev->next = linked_list->head;
    }

    while (current != NULL && count <= high) {
        Node* temp = current;
        current = current->next;
        delete temp;
        count++;
    }

    linked_list->tail->next = current;

    size = size - (high - low + 1) + linked_list->size;
}
",0.4,110
Singly_linked_list_1,1410226,2211738,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode* head = new LLNode();
    LLNode* temp = head;
    int carry = 0;
    while(l0 != NULL || l1 != NULL || carry != 0){
        int val = (l0 != NULL)? l0->val : 0;
        int val1 = (l1 != NULL)? l1->val : 0;
        
        int sum = val + val1 + carry;
        carry = sum/10;
        temp->next = new LLNode();
        temp->next->val = sum%10;
        temp = temp->next;
        
        l0 = (l0 != NULL)? l0->next : NULL;
        l1 = (l1 != NULL)? l1->next : NULL;
    }
    return head->next;
}",1.0,111111111111111
Singly_linked_list_4,1410226,2211738,"void LinkedList::partition(int k) {
    // if(head == NULL) return;
    // Node* smallHead = NULL, *smallTail = NULL;
    // Node* equalHead = NULL, *equalTail = NULL;
    // Node* largeHead = NULL, *largeTail = NULL;
    
    // Node* temp = head;
    // while(temp != NULL){
    //     if(temp->value < k){
    //         if(smallHead == NULL){
    //             smallHead = smallTail = temp;
    //         }else{
    //             smallTail->next = temp;
    //             smallTail = smallTail->next;
    //         }
    //     }else if(temp->value == k){
    //         if(equalHead == NULL){
    //             equalHead = equalTail = temp;
    //         }else{
    //             equalTail->next = temp;
    //             equalTail = equalTail->next;
    //         }
    //     }else{
    //         if(largeHead == NULL){
    //             largeHead = largeTail = temp;
    //         }else{
    //             largeTail->next = temp;
    //             largeTail = largeTail->next;
    //         }
    //     }
    //     temp = temp->next;
    // }
    // if(largeTail != NULL){
    //     largeTail->next = NULL;
    // }
    // if(smallHead == NULL){
    //     if(equalHead == NULL){
    //         head = largeHead;
    //         return;
    //     }
    //     equalTail->next = largeHead;
    //     head = equalHead;
    //     return;
    // }
    // if(equalHead == NULL){
    //     smallTail->next = largeHead;
    //     head = smallHead;
    //     return;
    // }
    // smallTail->next = equalHead;
    // equalTail->next = largeHead;
    // head = smallHead;
    int be=0,lon=0,bang=0;

    Node* trv=this->head;
    
    while (trv!=nullptr){
    
        int x=trv->value;
        
        if (x<k) be++;
        
        else if (x==k) bang++;
        
        else if (x>k) lon++;
        
        trv=trv->next;
    
    }
    
    int arr[this->size];
    
    for (int i=0;i<bang;i++){
    
        arr[be+i]=k;
    
    }
    
    int a=0, b= be+bang;
    
    Node* trv1=this->head;
    
    while (trv1!=nullptr){
    
        int x=trv1->value;
        
        if (x<k) {
        
        arr[a]=x;
        
        a++;
    
    }
    
    else if (x>k) {
    
        arr[b]=x;
        
        b++;
        
        }
        
        trv1=trv1->next;
    
    }
    
    Node* trv2=this->head;
    
    int i=0;
    
    while (trv2!=nullptr){
    
        trv2->value=arr[i];
        
        i++;
        
        trv2=trv2->next;
    
    }
}",1.0,11111
Singly_linked_list_6,1410226,2211738,"int Train::allocate(int containerSize) {
    if(size == 0) return -1;
    if(head == NULL) return -1;
    
    TrainCar* temp = head;
    TrainCar* temp1 = NULL;
    int index = 1e9, mini = 1e9;
    for(int i = 0; i < size; i++){
        if(temp != NULL){
            if(temp->remainingSpace < mini && temp->remainingSpace >= containerSize){
                mini = temp->remainingSpace;
                temp1 = temp;
                index = i;
            }
            temp = temp->next;
        }
    }
    if(index != 1e9){
        temp1->remainingSpace -= containerSize;
        return index;
    }
    return -1;
}

int Train::totalRemainingSpace() {
    if(head == NULL) return -1;
    if(size == 0) return -1;
    TrainCar* temp = head;
    int sum = 0;
    for(int i = 0; i < size; i++){
        if(temp != NULL){
            sum += temp->remainingSpace;
            temp = temp->next;
        }
    }
    return sum;
}",1.0,11111
Singly_linked_list_7,1410226,2211738,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if(this->count == 0){
        head = new Node(e,NULL);
        tail = head;
        this->count++;
        return;
    }
    Node* temp = new Node(e,NULL);
    tail->next = temp;
    tail = tail->next;
    this->count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index == 0 && this->count == 0) {
        add(e);
        return;
    }else if(index == this->count){
        add(e);
        return;
    }else if(index == 0 && this->count != 0){
        Node* temp = new Node(e,head);
        head = temp;
        this->count ++;
        return;
    }
    Node* temp = new Node(e,NULL);
    Node* temp1 = head;
    for(int i = 0; i < index-1; i++){
        temp1 = temp1->next;
    }
    temp->next = temp1->next;
    temp1->next = temp;
    this->count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}
",1.0,1111111111
Singly_linked_list_8,1410226,2211738,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(this->count == 0) return -1;
    if( head == NULL) return -1;
    if(index == 0) return head->data;
    Node* temp = head;
    for(int i = 0; i < index; i++) {
        if(temp != NULL) temp = temp->next;
        else break;
    }   
    if(temp != NULL) return temp->data;
    return -1;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(this->count == 0 || head == NULL) return;
    if(index == 0 && head != NULL) {head->data = e; return;}
    Node* temp = head;
    for(int i = 0; i < index; i++) {
        if(temp != NULL) temp = temp->next;
        else break;
    }
    if(temp != NULL) temp->data = e;  
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return this->count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if(this->count == 0) return -1;
    if(head == NULL) return -1;
    if(item == head->data) return 0;
    Node* temp= head;
    for(int j = 0; j < this->count; j++){
        if(temp != NULL){
            if(item == temp->data) return j;
            temp = temp->next;
        }
        else break;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if(this->count == 0) return false;
    if(head == NULL) return false;
    Node* temp = head;
    for(int i = 0; i < this->count; i++){
        if(temp != NULL){
            if(item == temp->data) return true;
            temp = temp->next;
        }
        else break;
    }
    return false;
}",0.8,1111111111
Singly_linked_list_9,1410226,2211738,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(this->count == 0) return -1;
    if(index < 0 || index >= this->count) return -1;
    if(head == NULL) return -1;
    if(index == 0){
        Node* temp = head;
        int val = temp->data;
        head = head->next;
        this->count--;
        delete temp;
        return val;
    }else if(index == this->count - 1){
        Node* temp = head;
        for(int i = 0; i < index-1; i++){
            if(temp != NULL) temp = temp->next;
            else break;
        }
        Node* temp1 = temp->next;
        tail = temp;
        int val = temp1->data;
        delete temp1;
        this->count--;
        return val;
    }else{
        Node* temp = head;
        for(int i = 0; i < index-1; i++){
            if(temp != NULL) temp = temp->next;
            else break;
        }
        Node* temp1 = temp->next;
        temp->next = temp1->next;
        int val = temp1->data;
        delete temp1;
        this->count--;
        return val;
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(this->count == 0) return false;
    if(head == NULL) return false;
    if(item == head->data){
        Node* temp = head;
        head = head->next;
        delete temp;
        this->count--;
        return true;
    }
    Node* temp = head;
    for(int i = 0; i < this->count; i++){
        if(temp != NULL){
            if(item == temp->data){
                this->removeAt(i);
                return true;
            }
            temp = temp->next;
        }else break;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    if(this->count == 0) return;
    if(head == NULL) return;
    Node* temp = head;
    for(int i = 0; i < this->count; i++){
        if(temp != NULL){
            Node* temp1 = temp;
            temp = temp->next;
            delete temp1;
        }else break;
    }
    this->count = 0;
}

",1.0,1111111111
Singly_linked_list_12,1410226,2211738,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* prev = NULL, *cur = head, *next;
    while(next != NULL){
        next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }
    return prev;
}",0.1,0100000000
Singly_linked_list_1,1410238,2212741,"// LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
//     // STUDENT ANSWER
//     if(l0==nullptr&&l1==nullptr) return nullptr;
//     unsigned long int res=0;
//     int mul1=1;
//     int count=1;
//     LLNode* tmp=l0;
//     while(tmp!=nullptr){
//         if(count!=1){
//             mul1*=10;

//         }
//         res=res+mul1*tmp->val;
//         count++;
//         tmp=tmp->next;
//     }
//     int mul2=1;
//     count=1;
//     LLNode* tmp2=l1;
//     while(tmp2!=nullptr){
//         if(count!=1){
//             mul2*=10;

//         }
//         res=res+mul2*tmp2->val;
//         count++;
//         tmp2=tmp2->next;
//     }
//     //  int res=num1+num2;
//     // cout<<res<<endl;
//     int mul=max(mul1,mul2);
//     mul*=10;
//     if(res/mul==0) mul/=10;
//     // string str=to_string(res);
//     // // cout<<str;
//     // int n=str.length();
//     // LLNode* final=new LLNode(str[n-1]-'0',nullptr);
//     // LLNode* tmp3=final;
//     // for(int i=n-2;i>=0;i--){
//     //     tmp3->next=new LLNode(str[i]-'0',nullptr);
//     //     tmp3=tmp3->next;
        
//     // }
//     //return final;
//     LLNode* final=new LLNode(res/mul,nullptr);
//     res%=mul;
//     mul/=10;
//     LLNode* tmp3=final;
//     while(mul!=1){
//         LLNode* add=new LLNode (res/mul,tmp3);
//         res%=mul;
//     mul/=10;
//     tmp3=add;
//     }
//     LLNode* insertNew=new LLNode(res,tmp3);
//     tmp3=insertNew;
//     return tmp3;
    
// }
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    if (l0 == nullptr || l1 == nullptr) return nullptr;

    int carry = 0;
    LLNode* result = nullptr;
    LLNode* current = nullptr;

    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        carry = sum / 10;
        int digit = sum % 10;

        if (result == nullptr) {
            result = new LLNode(digit, nullptr);
            current = result;
        } else {
            current->next = new LLNode(digit, nullptr);
            current = current->next;
        }

        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }

    return result;
}
",0.6,111111111111111
Singly_linked_list_4,1410238,2212741,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1410238,2212741,"void reduceDuplicate(Node* root)
{
}",0.2,0000101000
Singly_linked_list_1,1410751,2212651,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
        LLNode* tmp = new LLNode(1,NULL);
    LLNode* result = tmp;
//! lưu dư
    int number = 0;
    while(l0 && l1){
        int k = l0->val + l1->val;
//! chia để lấy 1 phần tử 
        tmp->next = new LLNode(((k + number) % 10),NULL);
        tmp = tmp->next;
//! lưu phép dư 
        number = (k + number) / 10;
        l0 = l0->next;
        l1 = l1->next;
        
    }
//! làm tương tự ở trên 
    while(l0){
        int k = l0->val;
        tmp->next = new LLNode((k + number) % 10,NULL);
        tmp = tmp->next;
        number = (k + number) / 10;
        l0 = l0->next;
        
    }
//! làm tương tự ở trên
    while(l1){
        int k = l1->val;
        tmp->next = new LLNode((k + number) % 10,NULL);
        tmp = tmp->next;
        number = (k + number) / 10;
        l1 = l1->next;
        
    }
//! nếu đến cuối còn dư 1 thì thêm 1 node có giá trị là 1
    if(number == 1) tmp->next = new LLNode(1,NULL);
    return result->next;
}
",1.0,111111111111111
Singly_linked_list_2,1410751,2212651,"void Polynomial::insertTerm(const Term &term)
{
    if (term.coeff == 0)
        return;
    SLinkedList<Term>::Iterator it = this->terms->begin();
    int size = this->terms->size();
    int i = 0;
    while (it != this->terms->end() && (*it).exp > term.exp && i < size)
    {
        ++it;
        ++i;
    }
    if (i == size)
        this->terms->add(term);
    else if ((*it).exp == term.exp)
    {
        (*it).coeff += term.coeff;
        if ((*it).coeff == 0)
            it.remove();
    }
    else
        this->terms->add(i, term);
}

void Polynomial::insertTerm(double coeff, int exp)
{
    Term terms(coeff, exp);
    this->insertTerm(terms);
}",1.0,11111
Singly_linked_list_3,1410751,2212651,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
   this->pList = pList;
   if (begin){
        if (pList != nullptr && pList->size()>0){
            this->current = pList->head;
            this->index = 0;
        }
        else{
            this->current = nullptr;
            this->index = -1;
        }
   }
   else{
        this->current = nullptr;
        if (pList != nullptr)
            this->index = pList->size();
        else
            this->index = 0;
   }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
   this-> current = iterator.current;
   this-> index = iterator.index;
   this->pList = iterator.pList;
   return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
   if (this->current == nullptr)
        throw std::out_of_range(""Segmentation fault!"");
    if (this->index == 0){
        this->pList->head = this->pList->head->next;
        delete this->current;
        this->current = nullptr;
        this->index = -1;
    }
    else{
        Node *p = this->pList->head;
         while(p && p->next != this->current) p = p->next;
        if(p){
            p->next = this->current->next;
            delete this->current; 
            this->current = p;
            this->index--;
        }
    }
    this->pList->count--;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e){
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
   if (this->current)
        this->current->data = e;
   else
        throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
   if (this->current)
        return this->current->data;
    throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
   return !(this->current == iterator.current && this->index == iterator.index);
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!this->current || !this->pList || index >= pList->size()) { 
        throw std::out_of_range(""Segmentation fault!""); 
    }

    if (this->index == -1){
        this->current = this->pList->head;
        this->index = 0;
    }
    else{
        this->current = this->current->next;
        ++this->index;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (this->index == this->pList->count)
         throw std::out_of_range(""Segmentation fault!"");
    
    Iterator temp(*this);
    ++*this;
    return temp;
}",1.0,11111
Singly_linked_list_4,1410751,2212651,"// void LinkedList::partition(int k) {
//     Node  *smallerHead=  nullptr,    *smallerLast =  nullptr,
//           *equalHead=    nullptr,    *equalLast   =  nullptr,
//           *greaterHead=  nullptr,    *greaterLast =  nullptr;
//     while(head){
//         if (head->value == k) {
//             if (!equalHead)
//                 equalHead = equalLast = head;
//             else {
//                 equalLast->next = head;
//                 equalLast = equalLast->next;
//             }
//         }
  
//         // If current node is less than X, append
//         // it to the list of smaller values
//         else if (head->value < k) {
//             if (!smallerHead)
//                 smallerLast = smallerHead = head;
//             else {
//                 smallerLast->next = head;
//                 smallerLast = head;
//             }
//         }
//         else // Append to the list of greater values
//         {
//             if (!greaterHead)
//                 greaterLast = greaterHead = head;
//             else {
//                 greaterLast->next = head;
//                 greaterLast = head;
//             }
//         }
  
//         head = head->next;
//     }
    
//     // Fix end of greater linked list to nullptr if this
//     // list has some nodes
//     if (greaterLast)
//         greaterLast->next = nullptr;
  
//     // Connect three lists
  
//     // If smaller list is empty
//     if (!smallerHead) {
//         if (equalHead == nullptr)
//             head= greaterHead;
//         equalLast->next = greaterHead;
//         head= equalHead;
//     }
  
//     // If smaller list is not empty and equal list is empty
//     if (!equalHead) {
//         smallerLast->next = greaterHead;
//         head= smallerHead;
//     }
  
//     // If both smaller and equal list are non-empty
//     smallerLast->next = equalHead;
//     equalLast->next = greaterHead;
//     head= smallerHead;
//     // Node* tmp=head;
//     // while(tmp->next!=nullptr){
//     //     tmp=tmp->next;
//     // }
//     // tail=tmp;
//     Node* h=head;
//     while(h->next) h=h->next;
//     tail=h;
// }
void LinkedList::partition(int k) {
    Node* smallerHead = nullptr, * smallerLast = nullptr,
        * equalHead = nullptr, * equalLast = nullptr,
        * greaterHead = nullptr, * greaterLast = nullptr;

    while(head){
        if (head->value == k) {
            if (!equalHead)
                equalHead = equalLast = head;
            else {
                equalLast->next = head;
                equalLast = equalLast->next;
            }
        }
  
        // If current node is less than X, append
        // it to the list of smaller values
        else if (head->value < k) {
            if (!smallerHead)
                smallerLast = smallerHead = head;
            else {
                smallerLast->next = head;
                smallerLast = head;
            }
        }
        else // Append to the list of greater values
        {
            if (!greaterHead)
                greaterLast = greaterHead = head;
            else {
                greaterLast->next = head;
                greaterLast = head;
            }
        }
  
        head = head->next;
    }

    if (greaterLast) {
        greaterLast->next = nullptr;
    }
    // Connect three lists
    if (!smallerHead) {
        if (equalHead == nullptr)  head = greaterHead;
        equalLast->next = greaterHead;
        head = equalHead;
    } else if (!equalHead) {
        smallerLast->next = greaterHead;
        head = smallerHead;
    } else {
        smallerLast->next = equalHead;
        equalLast->next = greaterHead;
        head = smallerHead;
    }

    // Update the tail pointer if you have one
    Node* h=head;
    while(h->next) h=h->next;
    tail=h;
}
",1.0,11111
Singly_linked_list_5,1410751,2212651,"void deleteNext(Node* h){
    Node* tmp=h->getNext();
    h->setNext(tmp->getNext());
    delete tmp;
}
void reduceDuplicate(Node* root)
{
    if (!root) return;
    while(root->getNext()){
        if(root->getData()!=(root->getNext())->getData()) {
            root=root->getNext();
        }
        else{
            deleteNext(root);
        }
    }
} ",1.0,1111111111
Singly_linked_list_9,1410751,2212651,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    Node* tmp=head;
    if(index==0){
        T a=head->data;
        head=head->next;
        delete tmp;
        count--;
        return a;
    }
    for(int i=0;i<index-1;i++){
        tmp=tmp->next;
    }
    Node* tNext=tmp->next;
    if(tNext==tail) tail=tmp;
    T a=tNext->data;
    tmp->next=tNext->next;
    delete tNext;
    count--;
    return a;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node*tmp =head;
    if(head->data==item){
        head=head->next;
        delete tmp;
        count--;
        return true;
    }
    while(tmp->next && tmp->next->data!=item) tmp=tmp->next;
    if(tmp==tail) return false;
    Node* tNext=tmp->next;
    if(tNext==tail) tail=tmp;
    tmp->next=tNext->next;
    delete tNext;
    count--;
    return true;

    
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    tail = nullptr; // Update tail pointer
    count=0;
}

",1.0,1111111111
Singly_linked_list_13,1410751,2212651,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (head == NULL) return head;
    LLNode* p = head;
    int sum = 1;
    while(p->next != NULL) {
        p = p->next;
        sum++;
    }
    p->next = head;
    p = head;
    k = k%sum;
    for (int i = 0; i < sum - k; i++) {
        p = p->next;
    }
    head = p;
    for (int i = 0; i < sum - 1; i++) {
        p = p->next;
    }
    p->next = NULL;
    return head;
}",1.0,1111111111
Singly_linked_list_1,1411932,2212499,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* tmp = new LLNode(1,NULL);
    LLNode* result = tmp;
//! lưu dư
    int number = 0;
    while(l0 && l1){
        int k = l0->val + l1->val;
//! chia để lấy 1 phần tử 
        tmp->next = new LLNode(((k + number) % 10),NULL);
        tmp = tmp->next;
//! lưu phép dư 
        number = (k + number) / 10;
        l0 = l0->next;
        l1 = l1->next;
        
    }
//! làm tương tự ở trên 
    while(l0){
        int k = l0->val;
        tmp->next = new LLNode((k + number) % 10,NULL);
        tmp = tmp->next;
        number = (k + number) / 10;
        l0 = l0->next;
        
    }
//! làm tương tự ở trên
    while(l1){
        int k = l1->val;
        tmp->next = new LLNode((k + number) % 10,NULL);
        tmp = tmp->next;
        number = (k + number) / 10;
        l1 = l1->next;
        
    }
//! nếu đến cuối còn dư 1 thì thêm 1 node có giá trị là 1
     if(number == 1) tmp->next = new LLNode(1,NULL);
    return result->next;}",1.0,111111111111111
Singly_linked_list_2,1411932,2212499,"void Polynomial::insertTerm(const Term& term) {
if(term.exp < 0 ||  term.coeff == 0) return;
     SLinkedList<Term>::Iterator it;
     int i = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == term.exp){
            t.coeff += term.coeff;
            if(t.coeff != 0) it.set(t);
            else it.remove();
            return;
        }
        else if(t.exp < term.exp){
            break;
        }
        i++;
    }
    this->terms->add(i,term);}

void Polynomial::insertTerm(double coeff, int exp) {
  if(exp < 0 ||coeff ==0) return;
     SLinkedList<Term>::Iterator it;
     int i = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == exp){  
            t.coeff += coeff; //! Cộng thêm hệ số của thuật ngữ mới vào thuật ngữ đã tồn tại.
            if(t.coeff != 0.0000000f) it.set(t);  //! Cập nhật thuật ngữ đã tồn tại nếu hệ số khác 0.
            else it.remove();   //! Nếu hệ số bằng 0, loại bỏ thuật ngữ.
            return;
        }
        else if(t.exp < exp){
            break; //! Dừng khi tìm được vị trí chèn.
        }
        i++;
    }
    Term t(coeff,exp);
    this->terms->add(i,t); 
}",1.0,11111
Singly_linked_list_4,1411932,2212499,"void LinkedList::partition(int k) {
//! Khởi tạo con trỏ result để theo dõi đầu danh sách sau khi phân chia.
    Node* result = NULL;
//! Tạo một nút mới để đại diện cho các phần tử nhỏ hơn k.
    Node* smaller = new Node(1);
//! Tạo một nút mới để đại diện cho các phần tử bằng k.
    Node* equal = new Node(1);
//! Tạo một nút mới để đại diện cho các phần tử lớn hơn k.
    Node* larger = new Node(1);
//! Con trỏ head1 trỏ đến nút equal, đại diện cho danh sách các phần tử bằng k.
    Node* head1 = equal;
//! Con trỏ head2 trỏ đến nút larger, đại diện cho danh sách các phần tử lớn hơn k.
    Node* head2 = larger;
//! Con trỏ tạm thời tmp được sử dụng để duyệt qua danh sách liên kết.
    Node* tmp = head;
//! Cập nhật con trỏ head để trỏ đến nút smaller, đại diện cho danh sách các phần tử nhỏ hơn k.
    head = smaller;

    while(tmp){
 //! Liên kết phần tử nhỏ hơn k vào danh sách smaller.
        if(tmp->value < k){
            smaller->next = tmp;
            smaller = tmp;
        } 
//! Liên kết phần tử bằng k vào danh sách equal.
        else if(tmp->value == k){
            equal->next = tmp;
            equal = tmp;
        }
//! Liên kết phần tử lớn hơn k vào danh sách larger.
        else{
            larger->next = tmp;
            larger = tmp;
        }
//! Di chuyển con trỏ tmp đến phần tử tiếp theo trong danh sách
        tmp = tmp->next;
    }
    
    if(head != smaller){
 //! Nếu result chưa được cập nhật, cập nhật nó bằng phần tử đầu của danh sách smaller.
        if(result == NULL) result = head->next;
    }
    
    if(head1 != equal){
//! Tương tự như trên, cập nhật result nếu cần.
        if(result == NULL) result = head1->next;
//! Liên kết phần tử cuối của danh sách smaller với phần tử đầu của danh sách equal.
        else{
            smaller->next = head1->next;
        }
        smaller = equal;
    }
 
    if(head2 != larger){
 //! Tương tự như trên, cập nhật result nếu cần.
        if(result == NULL) result = head2->next;
//! Liên kết phần tử cuối của danh sách smaller với phần tử đầu của danh sách larger.
        else{
            smaller->next = head2->next;
        }
        smaller = larger;
    }
//! gán lại giá trị head và tail
    head = result;
    tail = smaller;
}",1.0,11111
Singly_linked_list_5,1411932,2212499,"void reduceDuplicate(Node* root)
{ if(root && root->getNext() == NULL) return;
//! Khởi tạo hai con trỏ, curr trỏ tới node hiện tại, prev trỏ tới node trước đó.
    Node* curr = root->getNext(),* prev = root;
    while(curr){
//! Nếu giá trị của node hiện tại trùng với giá trị của node trước đó.
        if(curr->getData() == prev->getData()){
 //! Bỏ qua node hiện tại bằng cách cập nhật con trỏ next của node trước đó.
            prev->setNext(curr->getNext());
            curr = prev->getNext();
        }
        else{
//! Cập nhật con trỏ prev để trỏ tới node hiện tại.
            prev->setNext(curr);
//! Cập nhật con trỏ curr để trỏ tới node tiếp theo.
            curr = curr->getNext();
        }
    }
}",0.5,1101001100
Singly_linked_list_7,1411932,2212499,"template <class T>
void SLinkedList<T>::add(const T& e) {
   if(count == 0){
        head =  new Node(e,nullptr);
        tail = head;
    }
    else{
        
        Node* tmp = new Node(e,nullptr);
      
        tail->next = tmp;
        
        tail = tmp;
        
    }
    count++;
    
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
if(index < 0 || index > count) return;
    else if(count == 0 || index == count) add(e);
    else if(index == 0){
        Node* tmp = new Node(e,nullptr);
        tmp->next = head;
        head = tmp;
        count ++;
    }
    else{
        index --;
        Node* tmp = head;
        Node* New = new Node(e,nullptr);
        while(index){
            tmp = tmp->next;
            index--;
        }
        New->next = tmp->next;
        tmp->next = New;
        count ++;
    } 
    
}

template<class T>
int SLinkedList<T>::size() {
     return count;
}
",1.0,1111111111
Singly_linked_list_8,1411932,2212499,"template<class T>
T SLinkedList<T>::get(int index) {
 if(index < 0 || index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){
        index --;
        tmp = tmp->next;
    }
    return tmp->data;    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
if(index < 0 || index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){
        index --;
        tmp = tmp->next;
    }
    tmp->data = e;}

template<class T>
bool SLinkedList<T>::empty() {
    return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
int i = 0;
    Node* tmp = head;
    while(tmp){
        if(tmp->data == item) return i;
        i ++;
        tmp = tmp->next;
    }
    return -1;    
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
  Node* tmp = head;
//! duyệt vòng while
    while(tmp){
        if(tmp->data == item) return true;
        tmp = tmp->next;
    }
    return false;
        
}",1.0,1111111111
Singly_linked_list_9,1411932,2212499,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
T result;
//! nếu đúng thì chương trình chạy sai thì dừng chương trình 
    if(index < 0 || index > count || count == 0) throw out_of_range("""");
//! nếu chỉ có 1 phần tử đầu tiên thì reset head = tail = nullptr
    else if(count == 1){
        result = head->data;
        delete head;
        head =tail = nullptr;
    }
//! nếu xóa ở vị trí 0 thì 
    else if(index == 0){
        result = head->data;
        Node* tmp = head;
        head = head->next;
        delete tmp;
    }
    else{
        index --;
        Node* tmp = head;
        while(index){
            tmp = tmp->next;
            index --;
        }
        if(tmp->next->next){
            Node* d = tmp->next;
            tmp->next = tmp->next->next;
            result = d->data;
            delete d;
        }
        else{
            tail = tmp;
            Node* d = tmp->next;
            tmp->next = nullptr;
            result = d->data;
            delete d;
        }
    }
    count --;
    return result;}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
int index = indexOf(item);
   if(index == -1 ) return false;
   removeAt(index);
   return true;    
}

template<class T>
void SLinkedList<T>::clear(){
 Node* tmp = head;
    while(tmp){
        tmp = tmp->next;
        delete head;
        head = tmp;
    }
    tail = head = NULL;
    count = 0;}

",1.0,1111111111
Singly_linked_list_10,1411932,2212499,"//! hàm đảo ơ bài trước có thể coi lại
LLNode* reverseLinkedList(LLNode* head) {
    if(!head || !head->next) return head;
    LLNode* prev = head, * curr = head->next, *post = head->next->next;
    head->next = NULL;
    while(post){
        curr->next = prev;
        prev = curr;
        curr = post;
        post = post->next;
    }
    curr->next = prev;
    return curr;
}


LLNode* foldLinkedList(LLNode* head) {
//! nếu nó chỉ có 1 phần tử hoặc không có phần tử nào thì return 
    if(head == NULL || head->next == NULL) return head;

    LLNode* curr = head, * curr2 = head->next;
//! Duyệt qua danh sách để tìm điểm chính giữa bằng cách di chuyển curr2 gấp đôi tốc độ.
    while(curr2 && curr2->next){
        curr2 = curr2->next->next;
        curr = curr->next;
    }
//! k true khi curr2 khác null
    bool k = curr2;
    curr2 = curr->next; 
    curr->next = NULL;
//! Đảo ngược nửa đầu của danh sách
    head = reverseLinkedList(head);
    curr = head;
//! nếu danh sách rẻ thì bỏ qua node đầu tiên khi đảo danh sách
    if(!k){
        curr = curr->next;
    }
//! cộng chúng lại với nhau
    while(curr && curr2){
        curr->val += curr2->val;
        curr = curr->next;
        curr2 = curr2->next;
    }
    return head;
    
}
",1.0,1111111111
Singly_linked_list_11,1411932,2212499,"LLNode* replaceFirstGreater(LLNode* head) {
stack<LLNode*> stk;
    LLNode* node = head;

    // Traverse the linked list
    while (node != nullptr) {
        // While stack is not empty and top node's value is less than current node's value
        while (!stk.empty() && stk.top()->val < node->val) {
            // Replace top node's value with current node's value
            stk.top()->val = node->val;
            stk.pop();
        }

        // Push current node to stack
        stk.push(node);

        // Move to the next node
        node = node->next;
    }

    // For remaining nodes in stack, replace their values with 0
    while (!stk.empty()) {
        stk.top()->val = 0;
        stk.pop();
    }

    return head;}",1.0,1111111111
Singly_linked_list_12,1411932,2212499,"LLNode* reverseLinkedList(LLNode* head) {
 if(!head || !head->next) return head;
//! trước hiện tại và sau
    LLNode* prev = head, * curr = head->next, *post = head->next->next;
    head->next = NULL;
    while(post){
//! Đảo ngược kết nối của nút hiện tại
        curr->next = prev;
//! Di chuyển prev tới nút hiện tại
        prev = curr;
//!  Di chuyển curr tới nút post
        curr = post;
//! Di chuyển post tới nút tiếp theo sau post
        post = post->next;
    }
//! Đảo ngược kết nối của nút cuối cùng
    curr->next = prev;
    return curr;}",1.0,1111111111
Singly_linked_list_13,1411932,2212499,"LLNode* rotateLinkedList(LLNode* head, int k) {
 if(!head) return NULL;
        LLNode* tmp = head;
        int size = 1;
        while (head->next) {
        head = head->next;
//!  Tăng biến size lên 1 để đếm số lượng nút
        size++;
    }
//! cuối danh liên kết trở tới đầu danh sách
        head->next = tmp;
//! Tính phần dư của k khi chia cho size để đảm bảo k không lớn hơn size
        k %= size;
        
//! Tính số bước di chuyển con trỏ để xoay danh sách
        k = size - k;
      
        while(k){
            head = head->next;
            k--;
        }
//! Lưu nút mới đứng đầu danh sách liên kết vào biến tmp
        tmp = head->next;
        head->next = NULL;
         return tmp;}",1.0,1111111111
Singly_linked_list_1,1412908,2211170,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
            LLNode* dummyHead = new LLNode(0);
        LLNode* curr = dummyHead;
        int carry = 0;
        while (l0 != NULL || l1 != NULL || carry != 0) {
            int x = l0 ? l0->val : 0;
            int y = l1 ? l1->val : 0;
            int sum = carry + x + y;
            carry = sum / 10;
            curr->next = new LLNode(sum % 10);
            curr = curr->next;
            l0 = l0 ? l0->next : nullptr;
            l1 = l1 ? l1->next : nullptr;
        }
        return dummyHead->next;
}",1.0,111111111111111
Singly_linked_list_2,1412908,2211170,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if (term.coeff != 0){
        if (terms->size() == 0 || terms->get(terms->size() - 1).exp > term.exp)
        terms->add(term);
    else{
        int i = 0;
        SLinkedList<Term>::Iterator it;
        for (it = this->terms->begin(); it !=this->terms->end(); it++){
            if (term.exp == (*it).exp){
                if (term.coeff + (*it).coeff == 0) it.remove();
                else it.set(Term(term.coeff + (*it).coeff, term.exp));
                break;
            }
        
            if (term.exp > (*it).exp){
            terms->add(i, term);
            break;
        }
        i++;
    }
    }
}
    
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff, exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_1,1413669,2212372,"
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
 LLNode *l;
 int t=0;
 int a[100000];
 int i=0;
 while(l0||l1){
 if(!l0){a[i]=(t+l1->val)%10;
 t=(t+l1->val)/10;
l1=l1->next;
 }
 else  if(!l1){a[i]=(t+l0->val)%10;
 t=(t+l0->val)/10;
 l0=l0->next;
 }else{a[i]=(t+l0->val+l1->val)%10;
 t=(t+l0->val+l1->val)/10;
 l0=l0->next;
 l1=l1->next;
 }
 i++;
 }
 if(t==1){a[i]=1;
 i++;
 }
 int arr[i];
 for(int j=0;j<i;j++){
     arr[j]=a[j];
 }
l=LLNode::createWithIterators(arr, arr + sizeof(arr) / sizeof(int));
  return l;

}",1.0,111111111111111
Singly_linked_list_5,1413669,2212372,"void reduceDuplicate(Node* root)
{
}",0.2,0000101000
Singly_linked_list_1,1414289,2210535,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* a = new LLNode();  // Tạo đối tượng trên heap
    LLNode* result = a;

    int carry = 0;
    while (l0 || l1 || carry) {
        int x, y;
        if (l0) {
            x = l0->val;
            l0 = l0->next;
        }
        else x = 0;

        if (l1) {
            y = l1->val;
            l1 = l1->next;
        }
        else y = 0;

        int sum = x + y + carry;
        carry = sum / 10;
        result->next = new LLNode(sum % 10, nullptr);

        result = result->next;
    }
    return a->next;
}",1.0,111111111111111
Singly_linked_list_2,1414289,2210535,"void Polynomial::insertTerm(const Term& term) {
	// STUDENT ANSWER
	if (term.coeff == 0) return;
	int n = terms->size();
	if (n == 0)
	{
		terms->add(term);
	}
	else
	{
		int k = 0;
		for (int i = 0; i < n; i++)
		{
			k = terms->get(i).exp;
			if (k < term.exp)
			{
				terms->add(i, term);
				break;
			}
			else if (k == term.exp)
			{
				Term a(terms->get(i).coeff + term.coeff, k);
				if (a.coeff == 0) terms->removeAt(i);
				else terms->set(i, a);
				break;
			}
			else if(i == n-1) terms->add(term);
		}
		
	}

}

void Polynomial::insertTerm(double coeff, int exp) {
	// STUDENT ANSWER
	Term a(coeff, exp);
	insertTerm(a);
}",1.0,11111
Singly_linked_list_3,1414289,2210535,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true:
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false:
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin == true) {
        if (pList == nullptr) {
            current = nullptr;
            index = -1;
        }
        else {
            current = pList->head;
            index = 0;
        }
    }
    else {
        current = nullptr;
        index = pList->size();
    }
}
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    pList = iterator.pList;
    current = iterator.current;
    index = iterator.index;
    return (*this);
}
template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    pList->removeAt(index);
    index = index - 1;
    if (index == -1) {
        current = nullptr;
        return;
    }
    current = pList->head;
    for (int i = 0; i < index; i++) {
        if (current) {
            current = current->next;
        }
    }
}
template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    current->data = e;
}
template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    return current->data;
}
template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if (current == iterator.current) {
        return false;
    }
    else return true;
}
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    current = current->next;
    ++index;
    return *this;
}
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (!current) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    SLinkedList<T>::Iterator temp = *this;
    current = current->next;
    ++index;
    return temp;
}",1.0,11111
Singly_linked_list_4,1414289,2210535,"void LinkedList::partition(int k)
{
    Node* pHead1 = NULL;
    Node* pHead2 = NULL;
    Node* pHead3 = NULL;
    Node* pTail1 = NULL;
    Node* pTail2 = NULL;
    Node* pTail3 = NULL;
    for (Node* p = head; p != NULL;)
    {
        if (p->value < k)
        {
            if (pHead1 == NULL)
            {
                pHead1 = p;
                pTail1 = p;
            }
            else
            {
                pTail1->next = p;
                pTail1 = pTail1->next;
            }
        }
        else if (p->value == k)
        {
            if (pHead2 == NULL)
            {
                pHead2 = p;
                pTail2 = p;
            }
            else
            {
                pTail2->next = p;
                pTail2 = pTail2->next;
            }
        }
        else
        {
            if (pHead3 == NULL)
            {
                pHead3 = p;
                pTail3 = p;
            }
            else
            {
                pTail3->next = p;
                pTail3 = pTail3->next;
            }
        }
        p = p->next;
        if (pTail1 != NULL) pTail1->next = NULL;
        if (pTail2 != NULL) pTail2->next = NULL;
        if (pTail3 != NULL) pTail3->next = NULL;
    }
    if (pTail1 != NULL) pTail1->next = pHead2;
    if (pTail2 != NULL) pTail2->next = pHead3;
    if (pTail3 != NULL) pTail3->next = NULL;
    if (pHead1 != NULL)
    {
        head = pHead1;
    }
    else if (pHead2 != NULL)
    {
        head = pHead2;
    }
    else
    {
        head = pHead3;
    }
    if (pTail3 != NULL)
    {
        tail = pTail3;
    }
    else if (pTail2 != NULL)
    {
        tail = pTail2;
    }
    else
    {
        tail = pTail1;
    }
}",1.0,11111
Singly_linked_list_5,1414289,2210535,"void reduceDuplicate(Node* root)
{   
    if (root->getNext() == nullptr || root == nullptr) {
        return;
    }
    Node* head = root;
    while (head != nullptr && head->getNext() != nullptr) {
        if (head->getData() == head->getNext()->getData()) {
            Node* duplicateNode = head->getNext();
            head->setNext(duplicateNode->getNext());
            delete duplicateNode;
        }
        else {
            head = head->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1414289,2210535,"int Train::allocate(int containerSize) {
    int carIndex = 1;
    TrainCar* currentCar = head->next;
    TrainCar* temp = nullptr;
    int result = 0;
    bool check = false;

    while (currentCar != nullptr) { 
        if (currentCar->remainingSpace >= containerSize) {
            check = true;
            if (!temp || temp->remainingSpace > currentCar->remainingSpace)  {
                temp = currentCar;
                result = carIndex;
            }
        }
        currentCar = currentCar->next;
        carIndex++;
    }

    if (temp) { 
        temp->remainingSpace -= containerSize;
    }

    if (check == true) {
        return result;
    }
    return -1;
}

int Train::totalRemainingSpace() {
    int totalSpace = 0;
        TrainCar* currentCar = head->next;

        while (currentCar != nullptr) {
            totalSpace += currentCar->remainingSpace;
            currentCar = currentCar->next;
        }

        return totalSpace;
}",1.0,11111
Singly_linked_list_7,1414289,2210535,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newnode = new Node(e, nullptr);
    if (head == nullptr && tail == nullptr && this->size() == 0) {
        head = newnode;
        tail = newnode;
        count++;
    }
    else {
        tail->next = newnode;
        tail = newnode;
        count++;
    }
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index < 0 || index > count) throw out_of_range("" "");
    if (index == count) {
        add(e);
    }
    else if (index == 0) {
        Node* newnode = new Node(e, nullptr);
        newnode->next = head;
        head = newnode;
        count++;
    }
    else {
        Node* temp = head;
        while (index != 1 && temp ) {
            temp = temp->next;
            index--;
        }
        Node* newnode = new Node(e, nullptr);
        newnode->next = temp->next;
        temp->next = newnode;
        count++;
    }
}

template<class T>
int SLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Singly_linked_list_8,1414289,2210535,"template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (this->count == 0) {
        return true;
    }
    else return false;
}
template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while (temp) {
        if (temp->data == item) {
            return i;
        }
        temp = temp->next;
        i++;
    }
    return -1;
}
template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if (indexOf(item) != -1) {
        return true;
    }
    else return false;
}
template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    Node* temp = head;
    while (index != 0 && temp) {
        temp = temp->next;
        index--;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    Node* temp = head;
    while (index != 0 && temp) {
        temp = temp->next;
        index--;
    }
    temp->data = e;
}",1.0,1111111111
Singly_linked_list_9,1414289,2210535,"
template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    if (index == 0) {
        Node* temp = head;
        T result1 = temp->data;
        head = temp->next;
        delete temp;
        count--;
        return result1;
    }
    else {
        Node* temp = head;
        while (index != 1 && temp) {
            temp = temp->next;
            index--;
        }
        Node* nextTemp = temp->next;
        T result2 = nextTemp->data;
        if (nextTemp->next == nullptr) {
            temp->next = nullptr;
            tail = temp;
            delete nextTemp;
        }
        else {
            temp->next = nextTemp->next;
            delete nextTemp;
        }
        count--;
        return result2;
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    if (!head) {
        return false;
    }

    if (head->data == item) {
        Node* temp = head;
        head = temp->next;
        delete temp;
        count--;

        if (!head) {
            tail = nullptr;
        }

        return true;
    }
    else {
        Node* temp = head;
        Node* prev = nullptr;

        while (temp && temp->data != item) {
            prev = temp;
            temp = temp->next;
        }

        if (!temp) {
            return false;
        }

        if (temp == tail) {
            tail = prev;
        }

        prev->next = temp->next;
        delete temp;
        count--;

        return true;
    }
}

template<class T>
void SLinkedList<T>::clear() {
    Node* temp = head;
    while (temp != nullptr) {
        Node* nextTemp = temp->next;
        delete temp;
        temp = nextTemp;
    }
    head = nullptr;
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1414289,2210535,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* Pprev = nullptr;
    LLNode* p;
    while (head != nullptr) {
        p = head;
        head = head->next;
        p->next = Pprev;
        Pprev = p;
    }
    head = Pprev;
    return head;
}

LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if (head == NULL || head->next == NULL) return head;
    int n = 0;
    LLNode* p0 = head;
    while (p0 != NULL)
    {
        n++;
        p0 = p0->next;
    }
    p0 = head;
    if (n % 2 == 1) n += 1;
    for (int i = 1; i < n/2; i++)
    {
        p0 = p0->next;
    }
    LLNode* p1 = p0->next;
    p0->next = NULL;
    p1 = reverseLinkedList(p1);
    p0 = head;
    while (p1 != NULL)
    {
        p0->val += p1->val;
        p0 = p0->next;
        p1 = p1->next;
    }
    return reverseLinkedList(head);


}",1.0,1111111111
Singly_linked_list_11,1414289,2210535,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    stack<LLNode*> nodeStack;
    LLNode *current = head;
    while (current != nullptr) {
         while (!nodeStack.empty() && current->val > nodeStack.top()->val) {
            nodeStack.top()->val = current->val;
            nodeStack.pop(); 
        }
        nodeStack.push(current);
        current = current->next;
    }
    while (!nodeStack.empty()) {
        nodeStack.top()->val = 0;
        nodeStack.pop();
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1414289,2210535,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode *prev = nullptr;
    LLNode *temp = head;
    LLNode *post = nullptr;
    while (temp != nullptr) {
        post = temp->next;
        temp->next = prev;
        prev =temp;
        temp = post;
    }
    head = prev;
    return head;
}",1.0,1111111111
Singly_linked_list_13,1414289,2210535,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (head == nullptr || k==0)   {
        return head;
    }
    int n=1;
    LLNode* countSize = head;
    while (countSize->next != nullptr)   {
        countSize = countSize->next;
        n++;
    }
    k = k % n;
    if (k == 0) {
        return head;
    }
    LLNode *Ntail = head;
    for (int i=1; i< n-k; i++) {
        Ntail = Ntail->next;
    }
    LLNode *Nhead = Ntail->next;
    Ntail->next = nullptr;
    
    countSize->next = head;
    head = Nhead;
    return head;
}",1.0,1111111111
Singly_linked_list_14,1414289,2210535,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {

    if (low <= 0 && high >= this->size-1)   {
        delete head;
        delete tail;
        this->head = linked_list->head;
        this->tail = linked_list->tail;
        this->size = linked_list->size;
    }

    else if (low <= 0)  {
        for(int i=0; i <= high ; i++)
        {
            this->head = this->head->next;
        }
        this->size -= (high+1);
        linked_list->tail->next = this->head;
        this->head = linked_list->head;
        this->size += linked_list->size;
    }

    else if (high >= size -1)   {
        Node* temp = this->head;
        for(int i = 0; i< low-1; i++)
        {
            temp = temp->next;
        }
        this->size -= (size-1 - low +1);
        temp->next = nullptr;
        delete this->tail;
        this->tail = temp;
        this->tail->next = linked_list->head;
        this->tail = linked_list->tail;
        this ->size += linked_list->size;
    }

    else {
        Node *temp1 = this->head;
        Node *temp2 = this->head;
        for (int i=0; i<low-1; i++) {
            temp1 = temp1->next;
        }
        for (int i=0; i<=high; i++) {
            temp2 = temp2->next;
        }
        temp1->next = temp2;
        this->size = this->size - (high-low+1);
        linked_list->tail->next = temp2;
        temp1->next = linked_list->head;
        this->size += linked_list->size;
    }
}",1.0,11111
Singly_linked_list_1,1414779,2213836,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode* temp = new LLNode(); //* tạo 1 nút giả để xử lílí
    LLNode* curr = temp; //* gán nút curr để xử lí từng node trong list
    int carry = 0; //* biến nhớ
    
    while(l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;
        if(l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        if(l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        carry = sum / 10; //* lấy phần nguyên để lưu lại
        int digit = sum % 10; //* cập nhật node mới
        curr->next = new LLNode(digit, nullptr);
        curr = curr->next;
    }
    LLNode* result = temp->next;
    delete temp;
    return result;
}",1.0,111111111111111
Singly_linked_list_2,1414779,2213836,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.coeff == 0) return; //* nếu hệ số bằng 0 thì không chèn
    SLinkedList<Term>::Iterator i;
    int index = 0;
    for(i = terms->begin(); i != terms->end(); i++) { //* duyệt từng terms đang có sẵn
        if(term.exp == (*i).exp) { //* nếu cùng số mũ thì cộng thêm cơ số
            (*i).coeff += term.coeff;
            if((*i).coeff == 0) terms->removeAt(index); //* nếu cơ số bằng 0 thì xóa hạng tử
            return;
        }    
        else if(term.exp > (*i).exp){ //* nếu số mũ lớn hơn thì chèn lên đầu
            terms->add(index, term);
            return;
        }
        index++;
    }
    //* kết thúc vòng lặp mà không tìm được vị trí thì add vào cuối
    terms->add(index, term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    Term term(coeff, exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_3,1414779,2213836,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(pList == NULL) {}
    else if(begin) {
        if(this->pList->size() == 0) {
            this->current = NULL;
            index = -1;
            
        }
        else {
            this->current = pList->head;
            index = 0;
        }
    }
    
    else if(!begin) {
        this->current = NULL;
        if(this->pList->size() == 0) index = 0;
        else index = this->pList->size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    
    if(index == 0) {
        this->pList->removeAt(index);
        this->current = NULL;
        index = -1;
    }
    else {
        T e = this->pList->removeAt(index - 1);
        this->index = index - 1;
        current->data = e;
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if(iterator.index == this->index && iterator.current == this->current) return false;
    return true;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current = current->next;
    index++;
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    Iterator temp = *this;
    current = current->next;
    index++;
    return temp;
}",0.9,11111
Singly_linked_list_4,1414779,2213836,"void LinkedList::partition(int k) {
    // Kiểm tra xem danh sách liên kết có ít hơn 2 phần tử hay không
    if (head == NULL || head->next == NULL) {
        return;
    }

    Node* smallerHead = NULL;  // Đầu danh sách nhóm I
    Node* smallerTail = NULL;  // Đuôi danh sách nhóm I
    Node* equalHead = NULL;    // Đầu danh sách nhóm II
    Node* equalTail = NULL;    // Đuôi danh sách nhóm II
    Node* greaterHead = NULL;  // Đầu danh sách nhóm III
    Node* greaterTail = NULL;  // Đuôi danh sách nhóm III

    Node* current = head;
    
    // Duyệt qua danh sách liên kết và phân chia các phần tử vào các nhóm tương ứng
    while (current != NULL) {
        if (current->value < k) {
            // Phần tử nhỏ hơn k thuộc nhóm I
            if (smallerHead == NULL) {
                smallerHead = current;
                smallerTail = current;
            } else {
                smallerTail->next = current;
                smallerTail = current;
            }
        } else if (current->value == k) {
            // Phần tử bằng k thuộc nhóm II
            if (equalHead == NULL) {
                equalHead = current;
                equalTail = current;
            } else {
                equalTail->next = current;
                equalTail = current;
            }
        } else {
            // Phần tử lớn hơn k thuộc nhóm III
            if (greaterHead == NULL) {
                greaterHead = current;
                greaterTail = current;
            } else {
                greaterTail->next = current;
                greaterTail = current;
            }
        }
        
        current = current->next;
    }
    
    // Kết hợp các nhóm lại theo thứ tự I -> II -> III
    if (smallerHead != NULL) {
        head = smallerHead;
        smallerTail->next = equalHead;
    } else {
        head = equalHead;
    }
    
    if (equalHead != NULL) {
        equalTail->next = greaterHead;
    }
    
    if (greaterHead != NULL) {
        tail = greaterTail;
        tail->next = NULL;
    }
}",1.0,11111
Singly_linked_list_5,1414779,2213836,"void reduceDuplicate(Node* root)
{
    if (root == nullptr) {
        return;
    }
    
    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicateNode = current->getNext();
            current->setNext(duplicateNode->getNext());
            delete duplicateNode;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_3,1415889,2212741,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList=pList;
    if(begin){
        if(pList) this->current=pList->head;
        else this->current=nullptr;
    }
    else{
        current=nullptr;
        if(pList) this->index=pList->size();
        this->index=0;
    }
    
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current=iterator.current;
    this->index  =iterator.index;
    this->pList  =iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(this->index){
        Node* tmp=this-> pList->head;
        int i=this->index;
        while(tmp->next&&i>1){
            tmp=tmp->next;
            i--;
        }
        if(tmp->next&&tmp){
            Node* p=tmp->next;
            tmp->next=tmp->next->next;
            current=tmp;
            this->index=this->index-1;
            delete p;
        }
        else{
            throw std::out_of_range(""Segmentation fault!"");
        }
        
    }
    else{
        delete this->current;
        this->current=nullptr;
        this->index=-1;
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    this->current->data=e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return 0;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(this->index==this->pList->size()){
        throw std::out_of_range(""Segmentation fault!"");
    }
    
    this->current=this->current->next;
    return *this;

    
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator *p=this;
    this->current=this->current->next;
    return *p;
}",0.8,11110
Singly_linked_list_1,1416062, ,"// LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
//     // STUDENT ANSWER
//     if(l0==nullptr&&l1==nullptr) return nullptr;
//     unsigned long int res=0;
//     int mul1=1;
//     int count=1;
//     LLNode* tmp=l0;
//     while(tmp!=nullptr){
//         if(count!=1){
//             mul1*=10;

//         }
//         res=res+mul1*tmp->val;
//         count++;
//         tmp=tmp->next;
//     }
//     int mul2=1;
//     count=1;
//     LLNode* tmp2=l1;
//     while(tmp2!=nullptr){
//         if(count!=1){
//             mul2*=10;

//         }
//         res=res+mul2*tmp2->val;
//         count++;
//         tmp2=tmp2->next;
//     }
//     //  int res=num1+num2;
//     // cout<<res<<endl;
//     int mul=max(mul1,mul2);
//     mul*=10;
//     if(res/mul==0) mul/=10;
//     // string str=to_string(res);
//     // // cout<<str;
//     // int n=str.length();
//     // LLNode* final=new LLNode(str[n-1]-'0',nullptr);
//     // LLNode* tmp3=final;
//     // for(int i=n-2;i>=0;i--){
//     //     tmp3->next=new LLNode(str[i]-'0',nullptr);
//     //     tmp3=tmp3->next;
        
//     // }
//     //return final;
//     LLNode* final=new LLNode(res/mul,nullptr);
//     res%=mul;
//     mul/=10;
//     LLNode* tmp3=final;
//     while(mul!=1){
//         LLNode* add=new LLNode (res/mul,tmp3);
//         res%=mul;
//     mul/=10;
//     tmp3=add;
//     }
//     LLNode* insertNew=new LLNode(res,tmp3);
//     tmp3=insertNew;
//     return tmp3;
    
// }
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    if (l0 == nullptr || l1 == nullptr) return nullptr;

    int carry = 0;
    LLNode* result = nullptr;
    LLNode* current = nullptr;

    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        carry = sum / 10;
        int digit = sum % 10;

        if (result == nullptr) {
            result = new LLNode(digit, nullptr);
            current = result;
        } else {
            current->next = new LLNode(digit, nullptr);
            current = current->next;
        }

        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }

    return result;
}
",1.0,111111111111111
Singly_linked_list_2,1416062, ,"void Polynomial::insertTerm(const Term& term) {
   if(term.exp < 0 ||  term.coeff == 0) return;
     SLinkedList<Term>::Iterator it;
    int count = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == term.exp){
            t.coeff += term.coeff;
            if(t.coeff != 0) it.set(t);
            else it.remove();
            return;
        }
        else if(t.exp < term.exp){
            break;
        }
        count++;
    }
    this->terms->add(count, term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    if(exp < 0 ||coeff == 0) return;
     SLinkedList<Term>::Iterator it;
    int count = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == exp){  
            t.coeff += coeff;
            if(t.coeff != 0) it.set(t); 
            else it.remove();
            return;
        }
        else if(t.exp < exp){
            break; //! Dừng khi tìm được vị trí chèn.
        }
        count++;
    }
    Term t(coeff, exp);
    this->terms->add(count, t);
}",1.0,11111
Singly_linked_list_3,1416062, ,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    this->pList = pList;
    if (pList == NULL) {}
    else if (begin) {
        if (this->pList->head) {
            current = this->pList->head; 
            this->index = 0;
        }
        else {
            current = nullptr; 
            this->index = -1;
        }
    }
    else {
        current = nullptr;
        if (this->pList->head)
            index = this->pList->size();
        else index = 0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    if(current) {
        int index = this->pList->indexOf(this->current->data);
        if (!index) { 
            this->pList->removeAt(index);
            this->index = -1;
            current = NULL;
        }
        else {
            T e = this->pList->removeAt(index - 1);
            this->index = index - 1;
            current->data = e;
        }
    }
    else throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    if(current)
        current->data = e; 
    else throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    if(current)
        return current->data;
    else throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    return ((this->current != iterator.current) && (this->index != iterator.index));
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    if(current) {
        current = current->next; 
        index++;
        return *this; 
    }
    else throw std::out_of_range(""Segmentation fault!"");
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    if(current) { 
        Iterator i = *this;
        current = current->next; 
        index++; 
        return i; 
    }
    else throw std::out_of_range(""Segmentation fault!"");
}",0.9,11111
Singly_linked_list_4,1416062, ,"void LinkedList::partition(int k) {
    Node* tmp = this->head;
    Node* g1 = nullptr;
    Node* tmp1 = nullptr;
    Node* g2 = nullptr;
    Node* tmp2 = nullptr;
    Node* g3 = nullptr;
    Node* tmp3 = nullptr;

    while (tmp) {
        if (tmp->value < k) {
            if (g1) {
                tmp1->next = new Node(tmp->value);
                tmp1 = tmp1->next;
            }
            else {
                g1 = new Node(tmp->value);
                tmp1 = g1;
            }
        }
        else if (tmp->value == k) {
            if (g2) {
                tmp2->next = new Node(tmp->value);
                tmp2 = tmp2->next;
            }
            else {
                g2 = new Node(tmp->value);
                tmp2 = g2;
            }
        }
        else {
            if (g3) {
                tmp3->next = new Node(tmp->value);
                tmp3 = tmp3->next;
            }
            else {
                g3 = new Node(tmp->value);
                tmp3 = g3;
            }
        }
        tmp = tmp->next;
    }
     tmp=head;
    while (g1) {
    tmp->value=g1->value;
    g1=g1->next;
    tmp=tmp->next;
    }

    if (g2) {
        while (g2) {
    tmp->value=g2->value;
    g2=g2->next;
    tmp=tmp->next;
    }
    }

    if (g3) {
        while (g3) {
    tmp->value=g3->value;
    g3=g3->next;
    tmp=tmp->next;
    }
}
}",1.0,11111
Singly_linked_list_5,1416062, ,"void reduceDuplicate(Node* root)
{
    Node* tmp= root;
    int num=root->getData();
    while(tmp->getNext()){
        if(tmp->getNext()->getData()==num){
            if(tmp->getNext()->getNext()){
                Node* p=tmp->getNext();
                tmp->setNext(tmp->getNext()->getNext());
                delete p;
            }
            else{
                Node* p=tmp->getNext();
                tmp->setNext(nullptr);
                delete p;
            }
        }
        else{
            num=tmp->getNext()->getData();
                tmp=tmp->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1416062, ,"int Train::allocate(int containerSize) {
    TrainCar* tmp=head;
    int res=-1;
    int remain=999999;
    int count =1;
    tmp=tmp->next;
    while(tmp){
        if(tmp->remainingSpace>=containerSize){
            int minus=tmp->remainingSpace-containerSize;
            if(minus<remain){
                remain=minus;
                res=count;
            }
            count++;
            tmp=tmp->next;
        }
        else{
            count++;
            tmp=tmp->next;
        }
    }
    tmp=head;
     count=res;
    while(count>0){
        count--;
        tmp=tmp->next;
    }
    if(tmp!=head)
    tmp->remainingSpace=remain;
    return res;
}

int Train::totalRemainingSpace() {
    int res=0;
    TrainCar* tmp=head;
    while(tmp){
        res+=tmp->remainingSpace;
        tmp=tmp->next;
    }
    return res;
}",1.0,11111
Singly_linked_list_7,1416062, ,"template <class T>
void SLinkedList<T>::add(const T& e) {
    if (count == 0) {
        head = new Node(e, NULL);
        tail = head;
    }
    else {
        Node *tmp = new Node(e, NULL);
        tail->next = tmp;
        tail = tmp;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    if (count == 0 || index == count) add(e); 
    else if (index == 0){
        Node *tmp = new Node(e, NULL);
        tmp->next = head;
        head = tmp;
        count++;
    }
    else {
        Node *tmp = new Node(e, NULL);
        Node *tmp2 = head;
        while(--index){
            tmp2 = tmp2->next;
        }
        tmp->next = tmp2->next;
        tmp2->next = tmp;
        count++;
    }
}

template<class T>
int SLinkedList<T>::size() {
    return count;
}",0.35,1111111111
Singly_linked_list_8,1416062, ,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index>count-1) return 0;
    Node* tmp=head;
    while(index>0){
        tmp=tmp->next;
        index--;
    }
    return tmp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index>count-1) return;
    Node*tmp=head;
    while(index>0){
        tmp=tmp->next;
        index--;
    }
    tmp->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !head;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int res=0;
    Node* tmp=head;
    while(tmp){
        if(tmp->data==item) return res;
        res++;
        tmp=tmp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* tmp=head;
    while(tmp){
        if(tmp->data==item) return 1;
        tmp=tmp->next;
    }
    return 0;
}",1.0,1111111111
Singly_linked_list_9,1416062, ,"template <class T>
T SLinkedList<T>::removeAt(int index)
{   
    // if(index>count-1||count<=0) return 0;
    /* Remove element at index and return removed value */
    if(index==0){
        Node* tmp=head;
        Node*p =tmp;
        tmp=tmp->next;
        head=tmp;
        int i=p->data;
        delete p;
        count--;
        return i;
    }
    else{
    Node* preN=head;
    while(index>1&&preN->next){
            preN=preN->next;
        --index;
    }
    
     if(preN->next){
         Node*p=preN->next;
         preN->next=p->next;
         if(!p->next) tail=preN;
         int i =p->data;
         delete p;
         count--;
        return i;
     }
        else return 0;
    // return 9;
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* tmp=head;
    Node* preN=head;
    while(tmp){
        if(tmp->data==item){
         if(tmp==head){
             Node*p =tmp;
             head=head->next;
             delete p;
             return 1;
         } 
         else{
             Node*p =tmp;
             preN->next=tmp->next;
             if(!p->next) tail=preN;
             delete p;
             
             count--;
             return 1;
         }
        }
        if(tmp==head)
        tmp=tmp->next;
        else{
            tmp=tmp->next;
            preN=preN->next;
        }
    }
    return 0;
    
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    while(head){
        Node* tmp=head;
        head=head->next;
        delete tmp;
        count--;
    }
}

",0.1,1111111111
Singly_linked_list_10,1416062, ,"void InsertFirst (LLNode* &head,int val){
    if(head){
        LLNode* p=new LLNode(val,head);
        head=p;
    }
    else{
        head=new LLNode(val,nullptr);
    }
}
LLNode* reverse(LLNode* head){
    LLNode* tmp=nullptr;
    while(head){
        InsertFirst(tmp,head->val);
        head=head->next;
    }
    return tmp;
}
LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* p=head;
    int count=0;
    while(p){
        count++;
        p=p->next;
    }
    int markIndex;
    markIndex=count/2;
    LLNode* firstHalf=reverse(head);
    
    LLNode* secondHalf;
    p=head;
    int i=markIndex;
    while(p&&i>0){
        p=p->next;
        i--;
        firstHalf=firstHalf->next;
    }
    secondHalf=p;
    LLNode* tmp=secondHalf;
    if(count%2!=0) tmp=tmp->next,firstHalf=firstHalf->next;
    while(tmp&&firstHalf){
        tmp->val+=firstHalf->val;
        tmp=tmp->next;
        firstHalf=firstHalf->next;
    }
    return secondHalf;
}",1.0,1111111111
Singly_linked_list_11,1416062, ,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    stack<LLNode*> myStack;
    LLNode* tmp=head;
    while(tmp){
        if(myStack.empty()) myStack.push(tmp);
        else{
            while(!myStack.empty()&&tmp->val>myStack.top()->val){
                myStack.top()->val=tmp->val;
                myStack.pop();
            }
            myStack.push(tmp);
        }
        tmp=tmp->next;
    }
    while(!myStack.empty()){
        myStack.top()->val=0;
                myStack.pop();
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1416062, ,"void InsertFirst (LLNode* &head,int val){
    if(head){
        LLNode* p=new LLNode(val,head);
        head=p;
    }
    else{
        head=new LLNode(val,nullptr);
    }
}
LLNode* reverseLinkedList(LLNode* head){
    LLNode* tmp=nullptr;
    while(head){
        InsertFirst(tmp,head->val);
        head=head->next;
    }
    return tmp;
}",1.0,1111111111
Singly_linked_list_13,1416062, ,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if(!head) return nullptr;
    int save[999999];
    LLNode* p=head;
    int i=k;
    int l=0;
    while(p){
        save[l]=p->val;
            p=p->next;
            l++;
    }
    p=head;
    while(i>0){
        if(p->next){
            p=p->next;
            i--;
        }
        else{
            p=head;
            i--;
        };
    }
    l=0;
    LLNode* tmp=head;
    while(p){
        p->val=save[l];
        tmp=tmp->next;
        p=p->next;
        l++;
    }
    p=head;
    while(tmp){
        p->val=save[l];
         tmp=tmp->next;
        p=p->next;
        l++;
    }
    
    return head;
}",1.0,1111111111
Singly_linked_list_14,1416062, ,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    Node* preLow=nullptr;
    Node* afterHigh=nullptr;
    int i=0;
    if(low==-1||low==0){
        Node* p=head;
        while(i<=high){
            p=p->next;
            if(p==nullptr){
                head=linked_list->head;
                tail=linked_list->tail;
                return;
            }
            i++;
        }
            afterHigh=p;
        head=linked_list->head;
        linked_list->tail->next=afterHigh;
        if(!afterHigh) tail=linked_list->tail;
        
    }
    else{
        int i=0;
        Node*p =head;
        while(i<low-1){
            p=p->next;
            i++;
        }
        preLow=p;
        while(i<=high){
            p=p->next;
            if(p==nullptr){
                preLow->next=linked_list->head;
                tail=linked_list->tail;
                return;
            }
            i++;
        }
            afterHigh=p;
        preLow->next=linked_list->head;
        linked_list->tail->next=afterHigh;
        if(!afterHigh) tail=linked_list->tail;
        
    }
    
}",1.0,11111
Singly_linked_list_1,1416076,2210532,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* dummyHead = new LLNode(); 
    LLNode* current = dummyHead; 
    int carry = 0; 

    while (l0 || l1 || carry) {
        int sum = carry;
        if (l0) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1) {
            sum += l1->val;
            l1 = l1->next;
        }
        carry = sum / 10; 
        current->next = new LLNode(sum % 10);
        current = current->next;
    }

    return dummyHead->next;
}",1.0,111111111111111
Singly_linked_list_2,1416076,2210532,"void Polynomial::insertTerm(const Term& term) 
{
    if (term.coeff == 0) return ;
    int i {0};
    for (SLinkedList <Term> :: Iterator it {terms->begin()} ; it != terms->end() ; ++it)
    {
        if ((*it).exp == term.exp)
        {
            (*it).coeff += term.coeff;
            if ((*it).coeff == 0)
            {
                terms->removeAt(i);
            }
            return;
        }
        else if ((*it).exp < term.exp)
        {
            terms->add(i,term);
            return;
        }
        ++i;
    }
    terms->add(term);//the end
}
void Polynomial::insertTerm(double coeff, int exp) 
{
    Term term {coeff,exp};
    insertTerm (term);
}",1.0,11111
Singly_linked_list_3,1416076,2210532,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin) {
        if (pList != 0) {
            current = pList->head;
            index = 0;
        }
    } else {
        current = 0;
        if (pList != 0) {
            index = pList->size();
        }
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
        this->index = iterator.index;
        this->pList = iterator.pList;
        return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current != 0) {
            current->data = e;
        }
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current != 0) {
            return current->data;
        }
    else{
        throw std::out_of_range(""Segmentation fault!"");
    }
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return this->current != iterator.current;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current != 0) {
            current = current->next;
            index++;
        }
        return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator iterator = *this;
        ++*this;
        return iterator;
}",0.8,11110
Singly_linked_list_4,1416076,2210532,"void LinkedList::partition(int x) {
    Node *smallerHead = NULL, *smallerLast = NULL;
    Node *greaterLast = NULL, *greaterHead = NULL;
    Node *equalHead = NULL, *equalLast = NULL;
  
    // Now iterate original list and connect nodes
    // of appropriate linked lists.
    while (head != NULL) {
        // If current node is equal to x, append it
        // to the list of x values
        if (head->value == x) {
            if (equalHead == NULL)
                equalHead = equalLast = head;
            else {
                equalLast->next = head;
                equalLast = equalLast->next;
            }
        }
  
        // If current node is less than X, append
        // it to the list of smaller values
        else if (head->value < x) {
            if (smallerHead == NULL)
                smallerLast = smallerHead = head;
            else {
                smallerLast->next = head;
                smallerLast = head;
            }
        }
        else // Append to the list of greater values
        {
            if (greaterHead == NULL)
                greaterLast = greaterHead = head;
            else {
                greaterLast->next = head;
                greaterLast = head;
            }
        }
  
        head = head->next;
    }
  
    // Fix end of greater linked list to NULL if this
    // list has some nodes
    if (greaterLast != NULL)
        greaterLast->next = NULL;
  
    // Connect three lists
  
    // If smaller list is empty
    if (smallerHead == NULL) {
        if (equalHead == NULL)
            head = greaterHead;
        else {
            equalLast->next = greaterHead;
            head = equalHead;
        }
    }
  
    // If smaller list is not empty and equal list is empty
    if (equalHead == NULL) {
        smallerLast->next = greaterHead;
        head = smallerHead;
    }
  
    // If both smaller and equal list are non-empty
    smallerLast->next = equalHead;
    equalLast->next = greaterHead;
    head = smallerHead;
}
",0.2,100
Singly_linked_list_5,1416076,2210532,"void reduceDuplicate(Node* root)
{
    if (root == nullptr || root->getNext() == nullptr)
    {
        // Trường hợp danh sách rỗng hoặc chỉ có một phần tử
        return;
    }

    Node* current = root;
    while (current->getNext() != nullptr)
    {
        if (current->getData() == current->getNext()->getData())
        {
            // Phát hiện phần tử trùng lặp
            Node* duplicate = current->getNext();
            current->setNext(duplicate->getNext());
            delete duplicate; // Giải phóng bộ nhớ của phần tử trùng lặp
        }
        else
        {
            current = current->getNext(); // Chuyển sang phần tử tiếp theo
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1416076,2210532,"int Train::allocate(int containerSize) {
    TrainCar* current = this->head->next;
    TrainCar* minSpaceCar = NULL;
    int index = 1;
    int minIndex = -1;

    // Find the train car with the smallest remaining space that can contain the container
    while (current != NULL) {
        if (current->remainingSpace >= containerSize && (minSpaceCar == NULL || current->remainingSpace < minSpaceCar->remainingSpace)) {
            minSpaceCar = current;
            minIndex = index;
        }
        current = current->next;
        index++;
    }

    // If no suitable train car is found, return -1
    if (minSpaceCar == NULL) {
        return -1;
    }

    // Otherwise, allocate the container to the found train car and update its remaining space
    minSpaceCar->remainingSpace -= containerSize;
    return minIndex;
}

int Train::totalRemainingSpace() {
    int totalSpace = 0;
    TrainCar* current = this->head->next;

    // Sum up the remaining space of all train cars
    while (current != NULL) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }

    return totalSpace;
}
",1.0,11111
Singly_linked_list_7,1416076,2210532,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        throw std::out_of_range(""Index out of bounds"");
    }

    if (index == count) {
        add(e); // If adding to the end, use the add(T e) method.
        return;
    }

    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1416076,2210532,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
            throw std::out_of_range(""Index out of bounds"");
        }

        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of bounds"");
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
        int index = 0;

        while (current != nullptr) {
            if (current->data == item) {
                return index;
            }
            current = current->next;
            index++;
        }

        return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1416076,2210532,"template <class T>
T SLinkedList<T>::removeAt(int index) {
    if (index < 0 || index >= this->count) {
        throw ""Index out of bounds"";
    }

    Node* prev = NULL;
    Node* current = this->head;
    for (int i = 0; i < index; i++) {
        prev = current;
        current = current->next;
    }

    T removedData = current->data;
    if (prev == NULL) {
        this->head = current->next;
        if (current == this->tail) {
            this->tail = NULL;  // Update tail if removing the last element
        }
    } else {
        prev->next = current->next;
        if (current == this->tail) {
            this->tail = prev;  // Update tail if removing the last element
        }
    }

    delete current;
    this->count--;
    return removedData;
}
template <class T>
bool SLinkedList<T>::removeItem(const T &item) {
    Node* prev = nullptr;
    Node* current = head;

    while (current != nullptr) {
        if (current->data == item) {
            if (prev == nullptr) {
                head = current->next;
            } else {
                prev->next = current->next;
            }
            if (current == tail) {
                tail = prev;
            }

            delete current;
            count--;
            return true;
        }

        prev = current;
        current = current->next;
    }

    return false;
}


template <class T>
void SLinkedList<T>::clear() {
    Node* current = this->head;
    while (current != NULL) {
        Node* next = current->next;
        delete current;
        current = next;
    }

    this->head = NULL;
    this->tail = NULL;
    this->count = 0;
}
",1.0,1111111111
Singly_linked_list_10,1416076,2210532,"LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    // Find the middle of the list
    LLNode* slow = head;
    LLNode* fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // Reverse the second half of the list
    LLNode* prev = nullptr;
    LLNode* curr = slow;
    while (curr != nullptr) {
        LLNode* nextTemp = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextTemp;
    }

    // Merge the two halves of the list
    LLNode* first = head;
    LLNode* second = prev;
    while (second->next != nullptr) {
        LLNode* nextTemp = first->next;
        first->next = second;
        first = nextTemp;

        nextTemp = second->next;
        second->next = first;
        second = nextTemp;
    }

    return head;
}",0.1,0010000000
Singly_linked_list_11,1416076,2210532,"LLNode* replaceFirstGreater(LLNode* head) {
    std::stack<LLNode*> nodeStack; // Stack to track nodes in non-decreasing order
    LLNode* current = head;

    while (current != nullptr) {
        while (!nodeStack.empty() && current->val > nodeStack.top()->val) {
            // Replace values of nodes in the stack with the first greater value
            nodeStack.top()->val = current->val;
            nodeStack.pop();
        }

        nodeStack.push(current);
        current = current->next;
    }

    // Any remaining nodes in the stack don't have a greater value to their right
    while (!nodeStack.empty()) {
        nodeStack.top()->val = 0;
        nodeStack.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1416076,2210532,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* nextNode = nullptr;

    while (current != nullptr) {
        nextNode = current->next;
        current->next = prev;
        prev = current;
        current = nextNode;
    }

    return prev;
}",1.0,1111111111
Singly_linked_list_13,1416076,2210532,"int getLength(LLNode* head) {
    int length = 0;
    LLNode* current = head;
    while (current != nullptr) {
        length++;
        current = current->next;
    }
    return length;
}

LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || k == 0) {
        return head; // No rotation needed
    }

    int length = getLength(head);

    // Calculate the effective rotation amount (k % length) to handle cases where k > length
    k = k % length;

    if (k == 0) {
        return head; // No rotation needed (k is a multiple of the length)
    }

    LLNode* current = head;
    LLNode* newTail = nullptr;

    // Traverse the list to find the new tail (the node before the new head)
    for (int i = 1; i < length - k; i++) {
        current = current->next;
    }

    newTail = current;
    LLNode* newHead = current->next;

    // Break the link between the new tail and new head
    newTail->next = nullptr;

    // Find the current tail and link it to the original head
    current = newHead;
    while (current->next != nullptr) {
        current = current->next;
    }
    current->next = head;

    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1416076,2210532,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    // Check if low and high are out of bounds
    if (low < 0) low = 0;
    if (high >= size) high = size - 1;

    // Find the node before low and after high
    Node* beforeLow = NULL;
    Node* afterHigh = NULL;
    Node* current = head;
    int index = 0;
    while (current != NULL) {
        if (index == low - 1) beforeLow = current;
        if (index == high + 1) {
            afterHigh = current;
            break;
        }
        current = current->next;
        index++;
    }

    // Delete nodes from low to high
    current = (beforeLow != NULL) ? beforeLow->next : head;
    while (current != afterHigh) {
        Node* nextNode = current->next;
        delete current;
        current = nextNode;
        size--;
    }

    // Connect the linked_list between beforeLow and afterHigh
    if (beforeLow != NULL) {
        beforeLow->next = linked_list->head;
    } else {
        head = linked_list->head;
    }
    if (linked_list->tail != NULL) {
        linked_list->tail->next = afterHigh;
    }

    // Update tail if necessary
    if (high == size - 1) {
        tail = (linked_list->tail != NULL) ? linked_list->tail : beforeLow;
    }

    // Update size
    size += linked_list->size;
}
",0.4,110
Singly_linked_list_1,1416413,2212651,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
        LLNode* tmp = new LLNode(1,NULL);
    LLNode* result = tmp;
//! lưu dư
    int number = 0;
    while(l0 && l1){
        int k = l0->val + l1->val;
//! chia để lấy 1 phần tử 
        tmp->next = new LLNode(((k + number) % 10),NULL);
        tmp = tmp->next;
//! lưu phép dư 
        number = (k + number) / 10;
        l0 = l0->next;
        l1 = l1->next;
        
    }
//! làm tương tự ở trên 
    while(l0){
        int k = l0->val;
        tmp->next = new LLNode((k + number) % 10,NULL);
        tmp = tmp->next;
        number = (k + number) / 10;
        l0 = l0->next;
        
    }
//! làm tương tự ở trên
    while(l1){
        int k = l1->val;
        tmp->next = new LLNode((k + number) % 10,NULL);
        tmp = tmp->next;
        number = (k + number) / 10;
        l1 = l1->next;
        
    }
//! nếu đến cuối còn dư 1 thì thêm 1 node có giá trị là 1
    if(number == 1) tmp->next = new LLNode(1,NULL);
    return result->next;
}
",1.0,111111111111111
Singly_linked_list_2,1416413,2212651,"void Polynomial::insertTerm(const Term& term) {
//! Kiểm tra điều kiện hợp lệ cho thuật ngữ.
    if(term.exp < 0 ||  term.coeff == 0) return;
     SLinkedList<Term>::Iterator it;
     int i = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == term.exp){
            t.coeff += term.coeff;
            if(t.coeff != 0) it.set(t);
            else it.remove();
            return;
        }
        else if(t.exp < term.exp){
            break;
        }
        i++;
    }
    this->terms->add(i,term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    //! Kiểm tra điều kiện hợp lệ cho thuật ngữ.
    if(exp < 0 ||coeff ==0) return;
     SLinkedList<Term>::Iterator it;
     int i = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == exp){  
            t.coeff += coeff; //! Cộng thêm hệ số của thuật ngữ mới vào thuật ngữ đã tồn tại.
            if(t.coeff != 0.0000000f) it.set(t);  //! Cập nhật thuật ngữ đã tồn tại nếu hệ số khác 0.
            else it.remove();   //! Nếu hệ số bằng 0, loại bỏ thuật ngữ.
            return;
        }
        else if(t.exp < exp){
            break; //! Dừng khi tìm được vị trí chèn.
        }
        i++;
    }
    Term t(coeff,exp);
    this->terms->add(i,t);  //! Chèn thuật ngữ mới vào vị trí thích hợp.
}",1.0,11111
Singly_linked_list_3,1416413,2212651,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList , bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
   //! hiện thực theo các điều kiện được note ở trên

   this->pList = pList;
   if(pList == NULL){}
   else if(begin){
        if(this->pList->size() == 0){this->current = NULL;index = -1;}
        else{ this->current = pList->head;index = 0;}
   }
   else{
        this->current = NULL;
        if(this->pList->size() == 0) index = this->pList->size();
        else index = pList->size();
   }
    
    
}
//! typename được sử dụng để thông báo cho trình biên dịch rằng SLinkedList<T>::Iterator là một tên kiểu
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    // cout << this->index;
//! gán các giá trí của iterator
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
//! nếu hiện tại đang là Null thì ném ra ngoại lệ ""Segmentation fault!""""
   if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
//! tìm vị trí đầu tiên của phần tử bằng hàm indexOf 
    int index = this->pList->indexOf(this->current->data);
//! nếu index  đang ở vị trí không
    if(index == 0){
        this->pList->removeAt(index);
        this->index = -1;
        current = NULL;
    }
    else{
        T e = this->pList->removeAt(index-1);
        this->index = index - 1;
        current->data = e;
        //current = this->pList->get(index - 1);
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}   

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
   if(current == NULL) throw out_of_range(""Segmentation fault!"");
   //cout << current->data;
   return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
   return !(iterator.index == this->index || iterator.current == this->current);
}
//! Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current = current->next;
    index++;
    return *this;
}
//! Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    Iterator temp = *this;
    current = current->next;
    index++;    
    return temp;
}",1.0,11111
Singly_linked_list_4,1416413,2212651,"void LinkedList::partition(int k) {
//! Khởi tạo con trỏ result để theo dõi đầu danh sách sau khi phân chia.
    Node* result = NULL;
//! Tạo một nút mới để đại diện cho các phần tử nhỏ hơn k.
    Node* smaller = new Node(1);
//! Tạo một nút mới để đại diện cho các phần tử bằng k.
    Node* equal = new Node(1);
//! Tạo một nút mới để đại diện cho các phần tử lớn hơn k.
    Node* larger = new Node(1);
//! Con trỏ head1 trỏ đến nút equal, đại diện cho danh sách các phần tử bằng k.
    Node* head1 = equal;
//! Con trỏ head2 trỏ đến nút larger, đại diện cho danh sách các phần tử lớn hơn k.
    Node* head2 = larger;
//! Con trỏ tạm thời tmp được sử dụng để duyệt qua danh sách liên kết.
    Node* tmp = head;
//! Cập nhật con trỏ head để trỏ đến nút smaller, đại diện cho danh sách các phần tử nhỏ hơn k.
    head = smaller;

    while(tmp){
 //! Liên kết phần tử nhỏ hơn k vào danh sách smaller.
        if(tmp->value < k){
            smaller->next = tmp;
            smaller = tmp;
        } 
//! Liên kết phần tử bằng k vào danh sách equal.
        else if(tmp->value == k){
            equal->next = tmp;
            equal = tmp;
        }
//! Liên kết phần tử lớn hơn k vào danh sách larger.
        else{
            larger->next = tmp;
            larger = tmp;
        }
//! Di chuyển con trỏ tmp đến phần tử tiếp theo trong danh sách
        tmp = tmp->next;
    }
    
    if(head != smaller){
 //! Nếu result chưa được cập nhật, cập nhật nó bằng phần tử đầu của danh sách smaller.
        if(result == NULL) result = head->next;
    }
    
    if(head1 != equal){
//! Tương tự như trên, cập nhật result nếu cần.
        if(result == NULL) result = head1->next;
//! Liên kết phần tử cuối của danh sách smaller với phần tử đầu của danh sách equal.
        else{
            smaller->next = head1->next;
        }
        smaller = equal;
    }
 
    if(head2 != larger){
 //! Tương tự như trên, cập nhật result nếu cần.
        if(result == NULL) result = head2->next;
//! Liên kết phần tử cuối của danh sách smaller với phần tử đầu của danh sách larger.
        else{
            smaller->next = head2->next;
        }
        smaller = larger;
    }
//! gán lại giá trị head và tail
    head = result;
    tail = smaller;
}",1.0,11111
Singly_linked_list_5,1416413,2212651,"void deleteNext(Node* h){
    Node* tmp=h->getNext();
    h->setNext(tmp->getNext());
    delete tmp;
}
void reduceDuplicate(Node* root)
{
    if (!root) return;
    while(root->getNext()){
        if(root->getData()!=(root->getNext())->getData()) {
            root=root->getNext();
        }
        else{
            deleteNext(root);
        }
    }
} ",1.0,1111111111
Singly_linked_list_6,1416413,2212651,"int Train::allocate(int containerSize) {
    TrainCar* currentCar = head->next;
    TrainCar* bestCar = nullptr; 
    int bestIndex = -1; 
    int index = 1;
    while (currentCar != nullptr)
    {
        if (currentCar->remainingSpace >= containerSize) 
        {
            if (bestCar == nullptr || currentCar->remainingSpace < bestCar->remainingSpace)
            {
                bestCar = currentCar;
                bestIndex = index;
            }
        }
        currentCar = currentCar->next;
        index++;
    }

    if (bestCar != nullptr) 
    {
        bestCar->remainingSpace -= containerSize;
        return bestIndex;
    }

    return -1; 
}

int Train::totalRemainingSpace() {
    TrainCar* currentCar = head->next;
        int totalSpace = 0;

        while (currentCar != nullptr) {
            totalSpace += currentCar->remainingSpace;
            currentCar = currentCar->next;
        }

        return totalSpace;

}",1.0,11111
Singly_linked_list_7,1416413,2212651,"template <class T>
void SLinkedList<T>::add(const T& e) {
//! nếu count = 0 thì gán head và tail = node đầu tiên
    if(count == 0){
        head =  new Node(e,nullptr);
        tail = head;
    }
    else{
        
        Node* tmp = new Node(e,nullptr);
      
        tail->next = tmp;
        
        tail = tmp;
        
    }
    count++;
    
}
//! hiện thực hàm add(int index, const T& e)
template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    if(index < 0 || index > count) return;
    else if(count == 0 || index == count) add(e);
    else if(index == 0){
        Node* tmp = new Node(e,nullptr);
        tmp->next = head;
        head = tmp;
        count ++;
    }
    else{
        index --;
        Node* tmp = head;
        Node* New = new Node(e,nullptr);
        while(index){
            tmp = tmp->next;
            index--;
        }
        New->next = tmp->next;
        tmp->next = New;
        count ++;
    } 
    
}
//! hiện thực hàm size()
template<class T>
int SLinkedList<T>::size() {
   return count;
}",1.0,1111111111
Singly_linked_list_8,1416413,2212651,"template<class T>
T SLinkedList<T>::get(int index) {
//! ném ra ngoại lệ
     if(index < 0 || index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){
        index --;
        tmp = tmp->next;
    }
    return tmp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
//! ném ra ngoại lệ 
    if(index < 0 || index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){
        index --;
        tmp = tmp->next;
    }
    tmp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int i = 0;
    Node* tmp = head;
    while(tmp){
        if(tmp->data == item) return i;
        i ++;
        tmp = tmp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    Node* tmp = head;
//! duyệt vòng while
    while(tmp){
        if(tmp->data == item) return true;
        tmp = tmp->next;
    }
    return false;
    
}",1.0,1111111111
Singly_linked_list_9,1416413,2212651,"
template <class T>
T SLinkedList<T>::removeAt(int index)
{
    T result;
//! nếu đúng thì chương trình chạy sai thì dừng chương trình 
    if(index < 0 || index > count || count == 0) throw out_of_range("""");
//! nếu chỉ có 1 phần tử đầu tiên thì reset head = tail = nullptr
    else if(count == 1){
        result = head->data;
        delete head;
        head =tail = nullptr;
    }
//! nếu xóa ở vị trí 0 thì 
    else if(index == 0){
        result = head->data;
        Node* tmp = head;
        head = head->next;
        delete tmp;
    }
    else{
        index --;
        Node* tmp = head;
        while(index){
            tmp = tmp->next;
            index --;
        }
        if(tmp->next->next){
            Node* d = tmp->next;
            tmp->next = tmp->next->next;
            result = d->data;
            delete d;
        }
        else{
            tail = tmp;
            Node* d = tmp->next;
            tmp->next = nullptr;
            result = d->data;
            delete d;
        }
    }
    count --;
    return result;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
   int index = indexOf(item);
   if(index == -1 ) return false;
   removeAt(index);
   return true;
    
}

template<class T>
void SLinkedList<T>::clear(){
    Node* tmp = head;
    while(tmp){
        tmp = tmp->next;
        delete head;
        head = tmp;
    }
    tail = head = NULL;
    count = 0;
}",1.0,1111111111
Singly_linked_list_10,1416413,2212651,"LLNode* reverseLinkedList(LLNode* head) {
    if(!head || !head->next) return head;
    LLNode* prev = head, * curr = head->next, *post = head->next->next;
    head->next = NULL;
    while(post){
        curr->next = prev;
        prev = curr;
        curr = post;
        post = post->next;
    }
    curr->next = prev;
    return curr;
}
LLNode* foldLinkedList(LLNode* head) {
//! nếu nó chỉ có 1 phần tử hoặc không có phần tử nào thì return 
    if(head == NULL || head->next == NULL) return head;

    LLNode* curr = head, * curr2 = head->next;
//! Duyệt qua danh sách để tìm điểm chính giữa bằng cách di chuyển curr2 gấp đôi tốc độ.
    while(curr2 && curr2->next){
        curr2 = curr2->next->next;
        curr = curr->next;
    }
//! k true khi curr2 khác null
    bool k = curr2;
    curr2 = curr->next; 
    curr->next = NULL;
//! Đảo ngược nửa đầu của danh sách
    head = reverseLinkedList(head);
    curr = head;
//! nếu danh sách rẻ thì bỏ qua node đầu tiên khi đảo danh sách
    if(!k){
        curr = curr->next;
    }
//! cộng chúng lại với nhau
    while(curr && curr2){
        curr->val += curr2->val;
        curr = curr->next;
        curr2 = curr2->next;
    }
    return head;
    
}
",1.0,1111111111
Singly_linked_list_11,1416413,2212651,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    if (head==nullptr) return head;
    if (head->next==nullptr){
        head->val=0;
        return head;
    }
    LLNode* pre=head;
    LLNode* cur;
    while (pre!=nullptr){
        int data=0;
        cur=pre->next;
        while (cur!=nullptr){
            if (cur->val>pre->val){
                data=cur->val;
                break;
            }
            cur=cur->next;
        }
        pre->val=data;
        pre=pre->next;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1416413,2212651,"LLNode* reverseLinkedList(LLNode* head) {
    if(!head || !head->next) return head;
    LLNode* prev = head, * curr = head->next, *post = head->next->next;
    head->next = NULL;
    while(post){
        curr->next = prev;
        prev = curr;
        curr = post;
        post = post->next;
    }
    curr->next = prev;
    return curr;
}",1.0,1111111111
Singly_linked_list_13,1416413,2212651,"LLNode* rotateLinkedList(LLNode* head, int k) {
//! trả về null nếu list rỗng
        if(!head) return NULL;
        LLNode* tmp = head;
        int size = 1;
        while (head->next) {
        head = head->next;
//!  Tăng biến size lên 1 để đếm số lượng nút
        size++;
    }
//! cuối danh liên kết trở tới đầu danh sách
        head->next = tmp;
//! Tính phần dư của k khi chia cho size để đảm bảo k không lớn hơn size
        k %= size;
        
//! Tính số bước di chuyển con trỏ để xoay danh sách
        k = size - k;
      
        while(k){
            head = head->next;
            k--;
        }
//! Lưu nút mới đứng đầu danh sách liên kết vào biến tmp
        tmp = head->next;
        head->next = NULL;
         return tmp;
}",1.0,1111111111
Singly_linked_list_14,1416413,2212651,"void LinkedList::replace(LinkedList* linked_list, int low, int high) 
{
    if(low <= 0 && high >= this->size-1) 
    {   
        delete head;
        delete tail;
        this-> head = linked_list ->head;
        this->tail = linked_list ->tail;
        this->size = linked_list ->size;
    }
    else if(low <= 0 ) 
    {
        for(int i=0; i <= high ; i++)
        {
            this->head = this->head->next;
        }
        this->size -= (high+1);
        linked_list->tail->next = this->head;
        this->head = linked_list->head;
        this->size += linked_list->size;
    }
    else if(high >= size-1)
    {
        Node* tmp = this->head;
        for(int i = 0; i< low-1; i++)
        {
            tmp = tmp->next;
        }
        this->size -= (size-1 - low +1);
        tmp->next = nullptr;
        delete this->tail;
        this->tail = tmp;
        this->tail->next = linked_list->head;
        this->tail = linked_list->tail;
        this ->size += linked_list->size;
    }
    else
    {
        Node* lowp = this->head;
        Node* lowh = this->head;
        for(int i=0; i<low-1 ; i++ )
        {
          lowp = lowp->next;
        }
        for(int i = 0; i<= high ; i++)
        {
            lowh = lowh->next;
        }
        lowp->next = lowh;
        this->size -= (high - low + 1 );
        linked_list->tail->next = lowh;
        lowp->next = linked_list->head;
        this->size+= linked_list->size;
    }

}",1.0,11111
Singly_linked_list_1,1416435,2213250,"void addLinked(LLNode * tail, LLNode *l0 , int& carry)
{
    
    while(l0)
    {
        int n = l0->val +carry;
        carry = n/10;
        n %=10;
        tail ->next = new LLNode(n,NULL);
        tail = tail ->next;
        l0=l0->next;
    }
}
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    int carry =0;
    LLNode * p0 = l0;
    LLNode * p1 = l1;
    LLNode * head = NULL;
    LLNode * tail =NULL;
    while(p0 && p1)
    {
        int n = p0->val + p1->val +carry;
        carry = n/10;
        n %=10;
        if(!head)
        {
            tail = new LLNode(n,NULL);
            head = tail;
        }
        else
        {
            tail->next = new LLNode(n,NULL);
            tail = tail->next;
        }
        p0=p0->next;
        p1=p1->next;
    }
    if(p0)
    {
        addLinked(tail, p0 , carry);
    }
    else if(p1)
    {
        addLinked(tail, p1 , carry);
    }
    if(carry)
    {
        tail ->next = new LLNode(carry,NULL);
        tail = NULL;
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1416435,2213250,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.coeff == 0 )return;
    int n = terms->size();
    if(n==0){
        terms->add(term);
        return;
    }
    
    for(int i=0 ; i<n;i++){
       Term temp = terms->get(i);
       if(temp.exp==term.exp){
           Term newterm(temp.coeff+term.coeff,temp.exp);
           terms->set(i,newterm);
           if(terms->get(i).coeff == 0 ) terms->removeAt(i);
           return;
       }
       else if(temp.exp < term.exp ){
           terms->add(i,term);
           return;
       }
    }
    terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff,exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_3,1416435,2213250,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(begin){
        if(pList != NULL){
            current = pList -> head;
            this -> index =0;
        }
        else{
            current = NULL;
            index = -1;
        }
    }
    else{
        current = NULL;
        index = (pList == NULL)? 0 : pList-> size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this-> current = iterator.current;
    this-> pList = iterator.pList;
    this-> index = iterator.index;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        pList-> removeAt(index);
        index--;
    }
    
    if(index == -1){
        current = NULL;
    }
    else{
        current = pList->head;
        for (int i =0; i < index; i++){
            current = current->next;
        }
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if( current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    current-> data = e;
    
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    return current -> data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return !(this-> current == iterator.current && this-> index == iterator.index) ;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL && index == -1){
        current = pList-> head;
        index++;
    }
    else if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        current = current -> next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,11111
Singly_linked_list_4,1416435,2213250,"void LinkedList::partition(int k) {
    Node *p1 = NULL;
    Node *p2 = NULL;
    Node *p3 = NULL;
    Node *temp1 = NULL;
    Node *temp2 = NULL;
    Node *temp3 = NULL;
    Node *p =head;
    while(p)
    {
        if(p->value < k)
        {
            if(p1 == NULL)
            {
                p1=p;
                temp1 =p;
            }
            else
            {
                temp1->next =p;
                temp1 = temp1->next;
            }
        }
        else if(p->value == k)
        {
            if(!p2)
            {
                p2 =p;
                temp2 =p;
            }
            else
            {
                temp2->next =p;
                temp2 = temp2->next;
            }
        }
        else
        {
            if(!p3)
            {
                p3 =p;
                temp3 =p;
            }
            else
            {
                temp3->next =p;
                temp3 = temp3->next;
            }
        }
        p =p->next;
        if(temp1) temp1->next =NULL;
        if(temp2) temp2->next =NULL;
        if(temp3) temp3->next =NULL;
    }
    
    if(temp1) temp1->next = p2;
    if(temp2) temp2->next = p3;
    if(temp3) temp3->next =NULL;
    
    if(p1) head =p1;
    else if(p2) head = p2;
    else head = p3;
    
    if(temp3) tail = temp3;
    else if(temp2) tail = temp2;
    else tail = temp1;
}",1.0,11111
Singly_linked_list_5,1416435,2213250,"#include <vector>

void reduceDuplicate(Node* root)
{
    vector<int> contain;
    Node* run = root;
    while (run) {
        if ((int)contain.size() == 0) {
            contain.push_back(run->getData());
        }
        else {
            if (run->getData() != contain[contain.size() - 1]) contain.push_back(run->getData());
        }
        run = run->getNext();
    }
    Node* temp = root;
    Node* prev = root;
        for (int i = 0; i < (int)contain.size(); i++) {
            temp->setData(contain[i]);
            prev=temp;
            temp =temp->getNext();
        }
        prev->setNext(nullptr);
}",0.2,1111111111
Singly_linked_list_6,1416435,2213250,"int Train::allocate(int containerSize) {
    TrainCar* run = this->head;
    TrainCar* here = nullptr;
    int ans = 0 ;
    int idx = 0 ;
    int res = 1e9;
    while(run){
        if(containerSize<=run->remainingSpace){
            if(run->remainingSpace-containerSize < res){
                res = run->remainingSpace - containerSize;
                ans = idx;
                here = run;
            }
        }
        idx++;
        run=run->next;
    }
    if(here!=nullptr){
        here->remainingSpace = res;
        return ans;
    }
    return -1;
}

int Train::totalRemainingSpace() {
    int S = 0 ;
    TrainCar* run = this->head;
    while(run){
        S+=run->remainingSpace;
        run=run->next;
    }
    return S;
}",1.0,11111
Singly_linked_list_7,1416435,2213250,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if (head)
    {
        tail->next = new Node(e, nullptr);
        tail = tail->next;
    }
    else
    {
        head = new Node(e, nullptr);
        tail = head;
    }
    ++count;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index==count)
    {
        (*this).add(e);
        return;
    }
    if (index==0)
    {
        this->head = new Node(e, head);
        ++count;
        return;
    }
    Node* run = head;
    Node* pre = nullptr;
    for (int i = 0; i<index; ++i)
    {
        pre = run;
        run = run->next;
    }
    pre->next = new Node(e, run);
    ++count;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1416435,2213250,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index<0 || index>=count) throw std::out_of_range(""Index is out of range"");
    Node* temp = this->head;
    while(index--){
        temp = temp->next;
    }
    return temp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index<0 || index>=count) throw std::out_of_range(""Index is out of range"");
    Node* temp = this->head;
    while(index--){
        temp=temp->next;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (head==nullptr)? 1:0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int idx = 0 ;
    Node* temp = this->head;
    while(temp){
        if(temp->data == item){
            return idx;
        }
        idx++;
        temp=temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (indexOf(item)==-1)? 0:1;
}",1.0,1111111111
Singly_linked_list_9,1416435,2213250,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    T val = 0 ;
    if(index==0) { val = this->head->data ; this->head = this->head->next;}
    else{
        Node* curr = head ;
        Node* prev = head;
        while(index--){
            prev = curr;
            curr = curr->next;
        }
        if(this->tail != curr ){
            prev->next = curr->next;
        }
        else{
            this->tail = prev;
        }
        val = curr->data;
    }
    count--;
    return val;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int idx = 0 ;
    Node* temp = head;
    while(temp){
        if(temp->data == item){
            this->removeAt(idx);
            return true;
        }
        idx++;
        temp=temp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    head = nullptr;
    tail = nullptr;
    count = 0 ;
}

",1.0,1111111111
Singly_linked_list_10,1416435,2213250,"LLNode* reverse(LLNode* head) {
    LLNode * phead = NULL;
    while(head)
    {
        LLNode* p = head;
        head =head->next;
        if(phead == NULL)
        {
            p->next = NULL;
            phead = p;
        }
        else
        {
            p->next = phead;
            phead = p;
        }
    }
    return phead;
}
LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode*p = head;
    int n=0;
    while(p)
    {
        n++;
        p=p->next;
    }
    if(n ==0) return head;
    p = head;
    if(n%2 == 1) n+=1;
    for(int i=1;i<n/2;i++)
    {
        p = p->next;
    }
    LLNode * p1= p->next;
    p->next =NULL;
    LLNode * p2 = reverse(p1);
    p = head;
    while(p2)
    {
        p->val += p2->val;
        p=p->next;
        p2 = p2->next;
    }
    p = reverse(head);
    return p;
    
}",1.0,1111111111
Singly_linked_list_11,1416435,2213250,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    LLNode* temp = head ;
    while(temp){
        LLNode* run = temp;
        while(run){
            if(run->val > temp->val){
                temp->val = run->val;
                break;
            }
            run=run->next;
        }
        if(run==nullptr) temp->val = 0;
        temp=temp->next;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1416435,2213250,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode * phead = NULL;
    while(head)
    {
        LLNode* p = head;
        head =head->next;
        if(phead == NULL)
        {
            p->next = NULL;
            phead = p;
        }
        else
        {
            p->next = phead;
            phead = p;
        }
    }
    return phead;
}",1.0,1111111111
Singly_linked_list_13,1416435,2213250,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    LLNode *p = head;
    int n=0;
    while(p!=NULL)
    {
        p=p->next;
        n++;
    }
    if(n ==0 || k ==0) return head;
    
    p = head;
    if(n<=k)
    {
        while(true)
        {
            if(p->next->next == NULL)
            {
                LLNode* p1 = p->next;
                p->next =NULL;
                p1->next =head;
                return p1;
            }
            p=p->next;
        }
        
    }
    for(int i=1;i<n-k;i++)
    {
        p =p ->next;
    }
    LLNode* p1 =p->next;
    p->next = NULL;
    LLNode *p2 = p1;
    while(p2->next)
    {
        p2 = p2->next;
    }
    p2->next = head;
    return p1;
}",1.0,1111111111
Singly_linked_list_14,1416435,2213250,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if(low<0) low=0;
    if(high>=size) high = size - 1;
    if(low==0){
        Node* temp = this->head;
        for(int i=1 ; i<=high ;i++){
            temp=temp->next;
        }
        this->head = linked_list->head;
        if(temp!=this->tail ){
            linked_list->tail->next = temp->next;
        }
        else{
            this->tail = linked_list->tail;
        }
    }
    else{
        Node* run = this->head;
        Node* low_node = nullptr , *high_node = nullptr;
        for(int i=0 ; i<=high ; i++){
            if(i==low-1) low_node = run ;
            else if(i==high) high_node = run;
            run=run->next;
        }
        if(high!=size-1){
            low_node->next = linked_list->head;
            linked_list->tail->next = high_node->next;
        }
        else{
            low_node->next= linked_list->head;
            this->tail = linked_list->tail;
        }
    }
    this->size = this->size - (high-low+1) + linked_list->size;
    
}",1.0,11111
Singly_linked_list_1,1416448,2211738,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode* head = new LLNode();
    LLNode* temp = head;
    int carry = 0;
    while(l0 != NULL || l1 != NULL || carry != 0){
        int val = (l0 != NULL)? l0->val : 0;
        int val1 = (l1 != NULL)? l1->val : 0;
        
        int sum = val + val1 + carry;
        carry = sum/10;
        temp->next = new LLNode();
        temp->next->val = sum%10;
        temp = temp->next;
        
        l0 = (l0 != NULL)? l0->next : NULL;
        l1 = (l1 != NULL)? l1->next : NULL;
    }
    return head->next;
}",1.0,111111111111111
Singly_linked_list_2,1416448,2211738,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    double remind[1000] = {0};
    remind[exp] += coeff;
}",0.2,00010
Singly_linked_list_4,1416448,2211738,"void LinkedList::partition(int k) {
    int be=0,lon=0,bang=0;

    Node* trv=this->head;
    
    while (trv!=nullptr){
    
        int x=trv->value;
        
        if (x<k) be++;
        
        else if (x==k) bang++;
        
        else if (x>k) lon++;
        
        trv=trv->next;
    
    }
    
    int arr[this->size];
    
    for (int i=0;i<bang;i++){
    
        arr[be+i]=k;
    
    }
    
    int a=0, b= be+bang;
    
    Node* trv1=this->head;
    
    while (trv1!=nullptr){
    
        int x=trv1->value;
        
        if (x<k) {
        
        arr[a]=x;
        
        a++;
    
    }
    
    else if (x>k) {
    
        arr[b]=x;
        
        b++;
        
        }
        
        trv1=trv1->next;
    
    }
    
    Node* trv2=this->head;
    
    int i=0;
    
    while (trv2!=nullptr){
    
        trv2->value=arr[i];
        
        i++;
        
        trv2=trv2->next;
    
    }
}",1.0,11111
Singly_linked_list_5,1416448,2211738,"void reduceDuplicate(Node* root)
{
    if(root == NULL) return;
    Node* resHead = root, *resTail = resHead;
    Node* temp = root->getNext();
    while(temp != NULL){
        if(temp->getData() == resTail->getData()){
            while(temp != NULL && temp->getData() == resTail->getData()){
                temp = temp->getNext();
            }
            continue;
        }else {
            resTail->setNext(temp);
            resTail = resTail->getNext();
        }
        temp = temp->getNext();
    }
    if(temp != NULL) {
        resTail->setNext(temp);
        resTail = resTail->getNext();
    }
    if(resTail != NULL) resTail->setNext(NULL);
    
    root = resHead;
}",1.0,1111111111
Singly_linked_list_6,1416448,2211738,"int Train::allocate(int containerSize) {
    if(size == 0) return -1;
    if(head == NULL) return -1;
    
    TrainCar* temp = head;
    TrainCar* temp1 = NULL;
    int index = 1e9, mini = 1e9;
    for(int i = 0; i < size; i++){
        if(temp != NULL){
            if(temp->remainingSpace < mini && temp->remainingSpace >= containerSize){
                mini = temp->remainingSpace;
                temp1 = temp;
                index = i;
            }
            temp = temp->next;
        }
    }
    if(index != 1e9){
        temp1->remainingSpace -= containerSize;
        return index;
    }
    return -1;
}

int Train::totalRemainingSpace() {
    if(head == NULL) return -1;
    if(size == 0) return -1;
    TrainCar* temp = head;
    int sum = 0;
    for(int i = 0; i < size; i++){
        if(temp != NULL){
            sum += temp->remainingSpace;
            temp = temp->next;
        }
    }
    return sum;
}",1.0,11111
Singly_linked_list_7,1416448,2211738,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if(this->count == 0){
        head = new Node(e,NULL);
        tail = head;
        this->count++;
        return;
    }
    Node* temp = new Node(e,NULL);
    tail->next = temp;
    tail = tail->next;
    this->count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index == 0 && this->count == 0) {
        add(e);
        return;
    }else if(index == this->count){
        add(e);
        return;
    }else if(index == 0 && this->count != 0){
        Node* temp = new Node(e,head);
        head = temp;
        this->count ++;
        return;
    }
    Node* temp = new Node(e,NULL);
    Node* temp1 = head;
    for(int i = 0; i < index-1; i++){
        temp1 = temp1->next;
    }
    temp->next = temp1->next;
    temp1->next = temp;
    this->count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}
",1.0,1111111111
Singly_linked_list_8,1416448,2211738,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(this->count == 0) return -1;
    if( head == NULL) return -1;
    if(index == 0) return head->data;
    Node* temp = head;
    for(int i = 0; i < index; i++) {
        if(temp != NULL) temp = temp->next;
        else break;
    }   
    if(temp != NULL) return temp->data;
    return -1;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(this->count == 0 || head == NULL) return;
    if(index == 0 && head != NULL) {head->data = e; return;}
    Node* temp = head;
    for(int i = 0; i < index; i++) {
        if(temp != NULL) temp = temp->next;
        else break;
    }
    if(temp != NULL) temp->data = e;  
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return this->count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if(this->count == 0) return -1;
    if(head == NULL) return -1;
    if(item == head->data) return 0;
    Node* temp= head;
    for(int j = 0; j < this->count; j++){
        if(temp != NULL){
            if(item == temp->data) return j;
            temp = temp->next;
        }
        else break;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if(this->count == 0) return false;
    if(head == NULL) return false;
    Node* temp = head;
    for(int i = 0; i < this->count; i++){
        if(temp != NULL){
            if(item == temp->data) return true;
            temp = temp->next;
        }
        else break;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1416448,2211738,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(this->count == 0) return -1;
    if(index < 0 || index >= this->count) return -1;
    if(head == NULL) return -1;
    if(index == 0){
        Node* temp = head;
        int val = temp->data;
        head = head->next;
        this->count--;
        delete temp;
        return val;
    }else if(index == this->count - 1){
        Node* temp = head;
        for(int i = 0; i < index-1; i++){
            if(temp != NULL) temp = temp->next;
            else break;
        }
        Node* temp1 = temp->next;
        tail = temp;
        int val = temp1->data;
        delete temp1;
        this->count--;
        return val;
    }else{
        Node* temp = head;
        for(int i = 0; i < index-1; i++){
            if(temp != NULL) temp = temp->next;
            else break;
        }
        Node* temp1 = temp->next;
        temp->next = temp1->next;
        int val = temp1->data;
        delete temp1;
        this->count--;
        return val;
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(this->count == 0) return false;
    if(head == NULL) return false;
    if(item == head->data){
        Node* temp = head;
        head = head->next;
        delete temp;
        this->count--;
        return true;
    }
    Node* temp = head;
    for(int i = 0; i < this->count; i++){
        if(temp != NULL){
            if(item == temp->data){
                this->removeAt(i);
                return true;
            }
            temp = temp->next;
        }else break;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    if(this->count == 0) return;
    if(head == NULL) return;
    Node* temp = head;
    for(int i = 0; i < this->count; i++){
        if(temp != NULL){
            Node* temp1 = temp;
            temp = temp->next;
            delete temp1;
        }else break;
    }
    this->count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1416448,2211738,"LLNode* reverse(LLNode* head){
    LLNode* prev = NULL, *cur = head, *next;
    while(cur != NULL){
        next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }
    return prev;
}
LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* slow = head;
    LLNode* fast = head;
    int i = 0, j = 0;
    while(fast != NULL && fast->next != NULL){
        slow = slow->next;
        fast = fast->next->next;
        i++;
    }
    LLNode* res, *temp;
    temp = NULL;
    slow = reverse(slow);
    while(j < i && slow != NULL){
        if(temp == NULL){
            temp = new LLNode(head->val+slow->val,NULL);
            res = temp;
        }else{
            temp->next = new LLNode(head->val+slow->val,NULL);
            temp = temp->next;
        }
        head = head->next;
        slow = slow->next;
        j++;
    }
    while(slow != NULL){
        if(temp != NULL) {
            temp->next = new LLNode(slow->val,NULL);
        }
        temp = temp->next;
        slow = slow->next;
    }
    if(temp != NULL) temp->next = NULL;
    res = reverse(res);
    return res;
}",1.0,1111111111
Singly_linked_list_11,1416448,2211738,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    if(head == nullptr) return head;
    LLNode* temp = head;
    stack<LLNode*> res;
    res.push(temp);
    temp = temp->next;
    while(!res.empty() && temp != nullptr){
        LLNode* temp1 = res.top();
        while(!res.empty() && temp1 != nullptr && temp->val > temp1->val){
            temp1->val = temp->val;
            res.pop();
        }
        res.push(temp);
        temp = temp->next;
    }
    while(!res.empty()){
        LLNode* temp1 = res.top();
        if(temp1 != nullptr) temp1->val = -1;
        res.pop();
    }
    return head;
}",0.1,0010000000
Singly_linked_list_12,1416448,2211738,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if(head == NULL) return head;
    LLNode* prev = NULL, *cur = head, *next;
    while(cur != NULL){
        next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }
    return prev;
}",1.0,1111111111
Singly_linked_list_13,1416448,2211738,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    LLNode* tail= head;
    
    if (head==nullptr) return head;
    
    int sz=1;
    
    while (tail->next!=nullptr) {
    
        tail=tail->next;
        
        sz++;
    
    }
    
    LLNode* headtmp;
    
    k=k%sz;
    
    for (int i=0;i<(sz-k);i++){
    
        headtmp=head->next;
        
        tail->next=head;
        
        tail=tail->next;
        
        tail->next=nullptr;
        
        head=headtmp;
    
    }
    
    return head;
}",1.0,1111111111
Singly_linked_list_14,1416448,2211738,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    // if(this->head == NULL) return;
    
    // if(low <= 0){
    //     Node* temp = this->head;
    //     for(int i = 0; i < high; i++){
    //         Node* temp1 = temp;
    //         if(temp != NULL) temp = temp->next;
    //         delete temp1;
    //     }
    //     if(linked_list->tail != NULL) linked_list->tail->next = temp->next;
    //     this->head = linked_list->head;
    //     Node* temp1 = temp;
    //     delete temp1;
    // }else if(high >= size){
    //     Node* temp = this->head;
    //     for(int i = 0; i < low-1; i++){
    //         if(temp != NULL) temp = temp->next;
    //     }
    //     Node* temp1 = temp->next;
    //     temp->next = linked_list->head;
    //     for(int i = low; i < size; i++){
    //         Node* temp2 = temp1;
    //         if(temp1 != NULL) temp1 = temp1->next;
    //         delete temp2;
    //     }
    //     delete temp1;
    // }else{
    //     Node* temp = this->head;
    //     for(int i = 0; i < low-1; i++){
    //         if(temp != NULL) temp = temp->next;
    //     }
    //     Node* temp1 = temp->next;
    //     temp->next = linked_list->head;
    //     for(int i = low; i < high; i++){
    //         Node* temp2 = temp1;
    //         if(temp1 != NULL) temp1 = temp1->next;
    //         delete temp2;
    //     }
    //     if(linked_list->tail != NULL) linked_list->tail->next = temp1->next;
    //     Node* temp2 = temp1;
    //     delete temp2;
    // }
    if (low < 0) {low=0;}
    if (high > size) {high = size -1;}
    if (low > high || low > size) return;
    Node* prev = NULL;
    Node* current = head;
    for (int i = 0;i <= low; i++) {
        prev = current; 
        current = current->next;
    }
    if (low == 0) head = linked_list->head;
    else prev->next = linked_list->head;
    
    if (high == size -1 ) tail = linked_list->tail;
    size = size -(high-low+1)+linked_list->size;
    
    Node* temp;
    for (int i = low; i <= high; i++) {
        temp = current;
        current = current ->next;
        delete temp;
    }
    linked_list->tail->next = current;
}",0.4,00
Singly_linked_list_1,1416517,2210458,"LLNode* addLinkedList(LLNode* l0, LLNode* l1)
{
    if (l0 == nullptr || l1 == nullptr)
    {
        return nullptr;
    }
    int carry = 0, sum = 0, num = 0;
    LLNode* fakehead = new LLNode(0, nullptr);
    LLNode* iterator = fakehead;
    while (l0 != nullptr && l1 != nullptr)
    {
        sum = l0->val + l1->val;
        num = (sum + carry) % 10;
        if (num == 0 && (l0->val != 0 || l1->val != 0))
            carry = 1;
        else
            carry = sum / 10;
        iterator->next = new LLNode(num, nullptr);
        iterator = iterator->next;
        l0 = l0->next;
        l1 = l1->next;
    }
    //cout << carry << endl;
    if (l0 == nullptr && l1 == nullptr && carry != 0)
    {
        iterator->next = new LLNode(carry, nullptr);
    }
    else
    {
        while (l0 != nullptr)
        {
            iterator->next = new LLNode(l0->val + carry, nullptr);
            if (carry != 0)
                carry = 0;
            iterator = iterator->next;
            l0 = l0->next;
        }
        while (l1 != nullptr)
        {
            iterator->next = new LLNode(l1->val + carry, nullptr);
            if (carry != 0)
                carry = 0;
            iterator = iterator->next;
            l1 = l1->next;
        }
    }
    return fakehead->next;
}
",0.75,111111111111111
Singly_linked_list_2,1416517,2210458,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_1,1418246,2212282,"LLNode* addLinkedList(LLNode* l1, LLNode* l2) {
    LLNode* dummy = new LLNode(), *temp = dummy, *temp1 = dummy;
        int remain=0, calculate, final;
        while(l1 || l2) {
            calculate  = (l1?l1->val:0) + (l2?l2->val:0)+remain;
            final = (calculate > 9 ? calculate-10 : calculate);
            remain     = calculate < 10 ? 0 : 1;
            
            temp->next = new LLNode(final);
            
            l1         =   l1?l1->next:NULL;
            l2         =   l2?l2->next:NULL;
            temp       =   temp->next;
        }
        if(calculate > 9) temp->next = new LLNode(1);
        dummy = dummy->next;
        delete temp1;
        return dummy;
}",0.93,110111111111111
Singly_linked_list_4,1418246,2212282,"void LinkedList::partition(int k) {
    LinkedList *gr1 = new LinkedList();
    LinkedList *gr2 = new LinkedList();
    LinkedList *gr3 = new LinkedList();
    
    Node* cur = head;
    while(cur) {
        int val = cur->value;
        if(val < k)       gr1->add(val);
        else if(val == k) gr2->add(val);
        else              gr3->add(val);
        
        cur = cur->next;
    }
    
    cur = head;
    Node* g1 = gr1->head;
    Node* g2 = gr2->head;
    Node* g3 = gr3->head;
    while(cur) {
        if(g1) {
            cur->value = g1->value;
            g1         = g1->next;
        }
        else if(g2) {
            cur->value = g2->value;
            g2         = g2->next;
        }
        else {
            cur->value = g3->value;
            g3         = g3->next;
        }
        cur = cur->next;
    }
    delete gr1;
    delete gr2;
    delete gr3;
}",1.0,11111
Singly_linked_list_5,1418246,2212282,"void reduceDuplicate(Node* root)
{
    if(!root) return;
    
    Node* temp1 = root;
    Node* temp2 = root->getNext();
    
    while(temp2) {
        if(temp2->getData() == temp1->getData()) {
            temp1->setNext(temp2->getNext());
            Node* temp = temp2;
            temp2 = temp2->getNext();
            delete temp;
        }
        else {
            temp1 = temp2;
            temp2 = temp2->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_7,1418246,2212282,"template <class T>
void SLinkedList<T>::add(const T& e) {
    if(count == 0) {
        head = new Node(e, NULL);
        tail = head;
    }
    else {
        tail->next = new Node(e, NULL);
        tail = tail->next;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    if(index < 0 || index > count) return;
    
    if(index == 0) {
        if(count == 0) this->add(e);
        else {
            Node* temp = new Node(e, head);
            head = temp;
            ++count;
        }
    }
    
    else if(index == count) {
        this->add(e);   
    }
    
    else {
        Node* temp = head;
        while(index-- != 1) temp = temp->next;
        
        Node* tmp = new Node(e, temp->next);
        temp->next = tmp;
        ++count;
    }
}

template<class T>
int SLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Singly_linked_list_4,1418268,2211170,"void LinkedList::partition(int k) {
    if (head == NULL || head->next == NULL)
        return;

    Node* groupIHead = NULL;
    Node* groupITail = NULL;
    Node* groupIIHead = NULL;
    Node* groupIITail = NULL;
    Node* groupIIIHead = NULL;
    Node* groupIIITail = NULL;

    Node* current = head;

    while (current != NULL) {
        Node* nextNode = current->next;
        current->next = NULL;

        if (current->value < k) {
            if (groupIHead == NULL) {
                groupIHead = current;
                groupITail = current;
            } else {
                groupITail->next = current;
                groupITail = current;
            }
        } else if (current->value > k) {
            if (groupIIIHead == NULL) {
                groupIIIHead = current;
                groupIIITail = current;
            } else {
                groupIIITail->next = current;
                groupIIITail = current;
            }
        } else {
            if (groupIIHead == NULL) {
                groupIIHead = current;
                groupIITail = current;
            } else {
                groupIITail->next = current;
                groupIITail = current;
            }
        }

        current = nextNode;
    }

    if (groupIHead != NULL) {
        head = groupIHead;
        tail = groupITail;
    }

    if (groupIIHead != NULL) {
        if (head == NULL) {
            head = groupIIHead;
            tail = groupIITail;
        } else {
            tail->next = groupIIHead;
            tail = groupIITail;
        }
    }

    if (groupIIIHead != NULL) {
        if (head == NULL) {
            head = groupIIIHead;
            tail = groupIIITail;
        } else {
            tail->next = groupIIIHead;
            tail = groupIIITail;
        }
    }
}",0.8,11101
Singly_linked_list_5,1418268,2211170,"void reduceDuplicate(Node* root) {
    if (root == nullptr)
        return;

    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicate = current->getNext();
            current->setNext(duplicate->getNext());
            delete duplicate;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1418268,2211170,"
int Train::allocate(int containerSize) {
    TrainCar* current = head->next;
    int index = 1;
    int minIndex = -1;
    int minRemainingSpace = 1000000; // A large enough value as a placeholder

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize && current->remainingSpace < minRemainingSpace) {
            minIndex = index;
            minRemainingSpace = current->remainingSpace;
        }
        current = current->next;
        index++;
    }

    if (minIndex != -1) {
        current = head->next;
        for (int i = 1; i < minIndex; i++) {
            current = current->next;
        }
        current->remainingSpace -= containerSize;
    }

    return minIndex;
}

int Train::totalRemainingSpace() {
    int sum = 0;
    TrainCar* current = head->next;

    while (current != nullptr) {
        sum += current->remainingSpace;
        current = current->next;
    }

    return sum;
}
",1.0,11111
Singly_linked_list_7,1418268,2211170,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
        Node* newNode = new Node(e, nullptr);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
        if (index < 0 || index > count) {
        throw out_of_range(""Index out of range"");
    }

    if (index == count) {
        add(e);
        return;
    }

    Node* newNode = new Node(e, nullptr);
    if (index == 0) {
        newNode->next = head;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Singly_linked_list_8,1418268,2211170,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
        if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw out_of_range(""Index out of range"");
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
        return count == 0;
        
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
        Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
        return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1418268,2211170,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
        if (index < 0 || index >= count) {
        throw out_of_range(""Index out of range"");
    }

    T removedData;
    if (index == 0) {
        Node* removedNode = head;
        removedData = removedNode->data;
        head = head->next;
        delete removedNode;
        if (count == 1) {
            tail = nullptr;
        }
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        Node* removedNode = current->next;
        removedData = removedNode->data;
        current->next = removedNode->next;
        delete removedNode;
        if (index == count - 1) {
            tail = current;
        }
    }
    count--;
    return removedData;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
        if (head == nullptr) {
        return false;
    }

    if (head->data == item) {
        Node* removedNode = head;
        head = head->next;
        delete removedNode;
        count--;
        if (count == 0) {
            tail = nullptr;
        }
        return true;
    }

    Node* current = head;
    while (current->next != nullptr) {
        if (current->next->data == item) {
            Node* removedNode = current->next;
            current->next = removedNode->next;
            delete removedNode;
            count--;
            if (current->next == nullptr) {
                tail = current;
            }
            return true;
        }
        current = current->next;
    }

    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
        Node* current = head;
    while (current != nullptr) {
        Node* next = current->next;
        delete current;
        current = next;
    }
    head = nullptr;
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1418268,2211170,"int sizeNode (LLNode* head){
        // Base Case
    if (head == NULL) {
        return 0;
    }
    // Count this node plus the rest of the list
    else {
        return 1 + sizeNode(head->next);
    }
}

",0.1,
Singly_linked_list_1,1419545,2213836,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode* temp = new LLNode(); //* tạo 1 nút giả để xử lílí
    LLNode* curr = temp; //* gán nút curr để xử lí từng node trong list
    int carry = 0; //* biến nhớ
    
    while(l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;
        if(l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        if(l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        carry = sum / 10; //* lấy phần nguyên để lưu lại
        int digit = sum % 10; //* cập nhật node mới
        curr->next = new LLNode(digit, nullptr);
        curr = curr->next;
    }
    LLNode* result = temp->next;
    delete temp;
    return result;
}",1.0,111111111111111
Singly_linked_list_2,1419545,2213836,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.coeff == 0) return; //* nếu hệ số bằng 0 thì không chèn
    SLinkedList<Term>::Iterator i;
    int index = 0;
    for(i = terms->begin(); i != terms->end(); i++) { //* duyệt từng terms đang có sẵn
        if(term.exp == (*i).exp) { //* nếu cùng số mũ thì cộng thêm cơ số
            (*i).coeff += term.coeff;
            if((*i).coeff == 0) terms->removeAt(index); //* nếu cơ số bằng 0 thì xóa hạng tử
            return;
        }    
        else if(term.exp > (*i).exp){ //* nếu số mũ lớn hơn thì chèn lên đầu
            terms->add(index, term);
            return;
        }
        index++;
    }
    //* kết thúc vòng lặp mà không tìm được vị trí thì add vào cuối
    terms->add(index, term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    Term term(coeff, exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_3,1419545,2213836,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(pList == NULL) {}
    else if(begin) {
        if(this->pList->size() == 0) {
            this->current = NULL;
            index = -1;
            
        }
        else {
            this->current = pList->head;
            index = 0;
        }
    }
    
    else if(!begin) {
        this->current = NULL;
        if(this->pList->size() == 0) index = 0;
        else index = this->pList->size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    
    if(index == 0) {
        this->pList->removeAt(index);
        this->current = NULL;
        index = -1;
    }
    else {
        T e = this->pList->removeAt(index - 1);
        this->index = index - 1;
        current->data = e;
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if(iterator.index == this->index && iterator.current == this->current) return false;
    return true;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current = current->next;
    index++;
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    Iterator temp = *this;
    current = current->next;
    index++;
    return temp;
}",1.0,11111
Singly_linked_list_4,1419545,2213836,"void LinkedList::partition(int k) {
    // Kiểm tra xem danh sách liên kết có ít hơn 2 phần tử hay không
    if (head == NULL || head->next == NULL) {
        return;
    }

    Node* smallerHead = NULL;  // Đầu danh sách nhóm I
    Node* smallerTail = NULL;  // Đuôi danh sách nhóm I
    Node* equalHead = NULL;    // Đầu danh sách nhóm II
    Node* equalTail = NULL;    // Đuôi danh sách nhóm II
    Node* greaterHead = NULL;  // Đầu danh sách nhóm III
    Node* greaterTail = NULL;  // Đuôi danh sách nhóm III

    Node* current = head;
    
    // Duyệt qua danh sách liên kết và phân chia các phần tử vào các nhóm tương ứng
    while (current != NULL) {
        if (current->value < k) {
            // Phần tử nhỏ hơn k thuộc nhóm I
            if (smallerHead == NULL) {
                smallerHead = current;
                smallerTail = current;
            } else {
                smallerTail->next = current;
                smallerTail = current;
            }
        } else if (current->value == k) {
            // Phần tử bằng k thuộc nhóm II
            if (equalHead == NULL) {
                equalHead = current;
                equalTail = current;
            } else {
                equalTail->next = current;
                equalTail = current;
            }
        } else {
            // Phần tử lớn hơn k thuộc nhóm III
            if (greaterHead == NULL) {
                greaterHead = current;
                greaterTail = current;
            } else {
                greaterTail->next = current;
                greaterTail = current;
            }
        }
        
        current = current->next;
    }
    
    // Kết hợp các nhóm lại theo thứ tự I -> II -> III
    if (smallerHead != NULL) {
        head = smallerHead;
        smallerTail->next = equalHead;
    } else {
        head = equalHead;
    }
    
    if (equalHead != NULL) {
        equalTail->next = greaterHead;
    }
    
    if (greaterHead != NULL) {
        tail = greaterTail;
        tail->next = NULL;
    }
}",1.0,11111
Singly_linked_list_5,1419545,2213836,"void reduceDuplicate(Node* root)
{
    if (root == nullptr) {
        return;
    }
    
    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicateNode = current->getNext();
            current->setNext(duplicateNode->getNext());
            delete duplicateNode;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_7,1419545,2213836,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e, nullptr);
    if(head == nullptr) head = tail = newNode;
    else {
        tail->next = newNode;
        tail= newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e, nullptr);
    if(index == 0) {
        newNode->next = head;
        head = newNode;
    }
    else {
        Node* current = head;
        for(int i = 0; i < index - 1; i++){
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    count++;
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
    return 0;
}
",1.0,1111111111
Singly_linked_list_8,1419545,2213836,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    return temp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int index = 0;
    while(temp) {
        if(temp->data == item) return index;
        temp = temp->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* temp = head;
    while(temp) {
        if(temp->data == item) return true;
        temp = temp->next;
    }
    return false;
    
}",1.0,1111111111
Singly_linked_list_9,1419545,2213836,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* removeNode = nullptr;
    Node* temp = head;
    if(index == 0) {
        removeNode = head;
        head = head->next;
    }
    else{
        for(int i = 0; i < index - 1; i++) {
            temp = temp->next;
        }
        removeNode = temp->next;
        temp->next = temp->next->next;
        if(index == count - 1) tail = temp;
    }
    T removedValue = removeNode->data;
    delete removeNode;
    count--;
    return removedValue;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    Node* previous = nullptr;

    while (current != nullptr) {
        if (current->data == item) {
            if (previous == nullptr) {
                head = current->next;
            } else {
                previous->next = current->next;
                if (current == tail) {
                    tail = previous;
                }
            }

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* temp  = head;
    while(temp) {
        Node* next = temp->next;
        delete temp;
        temp = next;
    }
    head  =tail = nullptr;
    count = 0;
}

",0.9,1111111111
Singly_linked_list_10,1419545,2213836,"LLNode* reverseLinkedList(LLNode* head) {
    if(!head || !head->next) return head;
    LLNode* prev = head, * curr = head->next, *post = head->next->next;
    head->next = NULL;
    while(post){
        curr->next = prev;
        prev = curr;
        curr = post;
        post = post->next;
    }
    curr->next = prev;
    return curr;
}
LLNode* foldLinkedList(LLNode* head) {
//! nếu nó chỉ có 1 phần tử hoặc không có phần tử nào thì return 
    if(head == NULL || head->next == NULL) return head;

    LLNode* curr = head, * curr2 = head->next;
//! Duyệt qua danh sách để tìm điểm chính giữa bằng cách di chuyển curr2 gấp đôi tốc độ.
    while(curr2 && curr2->next){
        curr2 = curr2->next->next;
        curr = curr->next;
    }
//! k true khi curr2 khác null
    bool k = curr2;
    curr2 = curr->next; 
    curr->next = NULL;
//! Đảo ngược nửa đầu của danh sách
    head = reverseLinkedList(head);
    curr = head;
//! nếu danh sách rẻ thì bỏ qua node đầu tiên khi đảo danh sách
    if(!k){
        curr = curr->next;
    }
//! cộng chúng lại với nhau
    while(curr && curr2){
        curr->val += curr2->val;
        curr = curr->next;
        curr2 = curr2->next;
    }
    return head;
    
}",1.0,1111111111
Singly_linked_list_11,1419545,2213836,"LLNode* replaceFirstGreater(LLNode* head) {
    if (head == nullptr) {
        return nullptr;
    }

    // Tạo một ngăn xếp rỗng để lưu trữ các nút
    std::stack<LLNode*> nodeStack;

    // Duyệt qua danh sách liên kết
    LLNode* current = head;
    while (current != nullptr) {
        // Kiểm tra nếu ngăn xếp không rỗng và giá trị của nút hiện tại
        // lớn hơn giá trị của nút ở đầu ngăn xếp
        while (!nodeStack.empty() && current->val > nodeStack.top()->val) {
            // Thay thế giá trị của nút ở đầu ngăn xếp bằng giá trị của nút hiện tại
            nodeStack.top()->val = current->val;
            // Loại bỏ nút khỏi ngăn xếp vì nó đã tìm thấy nút lớn hơn kế tiếp của nó
            nodeStack.pop();
        }
        // Đẩy nút hiện tại vào ngăn xếp
        nodeStack.push(current);
        // Di chuyển đến nút tiếp theo trong danh sách liên kết
        current = current->next;
    }

    // Sau khi duyệt qua, các nút còn lại trong ngăn xếp không có nút lớn hơn nào bên phải của chúng
    // Đặt giá trị của chúng thành 0
    while (!nodeStack.empty()) {
        nodeStack.top()->val = 0;
        nodeStack.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1419545,2213836,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    //! nếu không có phần tử nào hay chỉ có 1 phần tử thì return về chính nó
    if(!head || !head->next) return head;
//! trước hiện tại và sau
    LLNode* prev = head, * curr = head->next, *post = head->next->next;
    head->next = NULL;
    while(post){
//! Đảo ngược kết nối của nút hiện tại
        curr->next = prev;
//! Di chuyển prev tới nút hiện tại
        prev = curr;
//!  Di chuyển curr tới nút post
        curr = post;
//! Di chuyển post tới nút tiếp theo sau post
        post = post->next;
    }
//! Đảo ngược kết nối của nút cuối cùng
    curr->next = prev;
    return curr;
}
",1.0,1111111111
Singly_linked_list_13,1419545,2213836,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    //! trả về null nếu list rỗng
        if(!head) return NULL;
        LLNode* tmp = head;
        int size = 1;
        while (head->next) {
        head = head->next;
//!  Tăng biến size lên 1 để đếm số lượng nút
        size++;
    }
//! cuối danh liên kết trở tới đầu danh sách
        head->next = tmp;
//! Tính phần dư của k khi chia cho size để đảm bảo k không lớn hơn size
        k %= size;
        
//! Tính số bước di chuyển con trỏ để xoay danh sách
        k = size - k;
      
        while(k){
            head = head->next;
            k--;
        }
//! Lưu nút mới đứng đầu danh sách liên kết vào biến tmp
        tmp = head->next;
        head->next = NULL;
         return tmp;
}
",1.0,1111111111
Singly_linked_list_14,1419545,2213836,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (low > high || high < 0 || low >= size) {
        return; // Invalid range, no replacement needed
    }

    // Adjust low and high indices if they are out of bounds
    if (low < 0) {
        low = 0;
    }
    if (high >= size) {
        high = size - 1;
    }

    // Find the node at position (low - 1)
    Node* prevNode = nullptr;
    if (low > 0) {
        prevNode = head;
        for (int i = 0; i < low - 1; i++) {
            prevNode = prevNode->next;
        }
    }

    // Find the node at position high
    Node* currentNode = head;
    for (int i = 0; i < high; i++) {
        currentNode = currentNode->next;
    }

    // Delete nodes from position low to position high
    if (prevNode != nullptr) {
        prevNode->next = currentNode->next;
    } else {
        head = currentNode->next;
    }
    size -= (high - low + 1);

    // Find the last node of linked_list
    Node* lastNode = linked_list->head;
    while (lastNode != nullptr && lastNode->next != nullptr) {
        lastNode = lastNode->next;
    }

    // Insert linked_list after position (low - 1)
    if (prevNode != nullptr) {
        lastNode->next = prevNode->next;
        prevNode->next = linked_list->head;
    } else {
        lastNode->next = head;
        head = linked_list->head;
    }
    size += linked_list->size;

    // Update tail if needed
    if (linked_list->tail != nullptr) {
        tail = linked_list->tail;
    }

    // Reset linked_list
    linked_list->head = nullptr;
    linked_list->tail = nullptr;
    linked_list->size = 0;
}
",0.2,00100
Singly_linked_list_1,1419765,2212741,"// LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
//     // STUDENT ANSWER
//     if(l0==nullptr&&l1==nullptr) return nullptr;
//     unsigned long int res=0;
//     int mul1=1;
//     int count=1;
//     LLNode* tmp=l0;
//     while(tmp!=nullptr){
//         if(count!=1){
//             mul1*=10;

//         }
//         res=res+mul1*tmp->val;
//         count++;
//         tmp=tmp->next;
//     }
//     int mul2=1;
//     count=1;
//     LLNode* tmp2=l1;
//     while(tmp2!=nullptr){
//         if(count!=1){
//             mul2*=10;

//         }
//         res=res+mul2*tmp2->val;
//         count++;
//         tmp2=tmp2->next;
//     }
//     //  int res=num1+num2;
//     // cout<<res<<endl;
//     int mul=max(mul1,mul2);
//     mul*=10;
//     if(res/mul==0) mul/=10;
//     // string str=to_string(res);
//     // // cout<<str;
//     // int n=str.length();
//     // LLNode* final=new LLNode(str[n-1]-'0',nullptr);
//     // LLNode* tmp3=final;
//     // for(int i=n-2;i>=0;i--){
//     //     tmp3->next=new LLNode(str[i]-'0',nullptr);
//     //     tmp3=tmp3->next;
        
//     // }
//     //return final;
//     LLNode* final=new LLNode(res/mul,nullptr);
//     res%=mul;
//     mul/=10;
//     LLNode* tmp3=final;
//     while(mul!=1){
//         LLNode* add=new LLNode (res/mul,tmp3);
//         res%=mul;
//     mul/=10;
//     tmp3=add;
//     }
//     LLNode* insertNew=new LLNode(res,tmp3);
//     tmp3=insertNew;
//     return tmp3;
    
// }
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    if (l0 == nullptr || l1 == nullptr) return nullptr;

    int carry = 0;
    LLNode* result = nullptr;
    LLNode* current = nullptr;

    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        carry = sum / 10;
        int digit = sum % 10;

        if (result == nullptr) {
            result = new LLNode(digit, nullptr);
            current = result;
        } else {
            current->next = new LLNode(digit, nullptr);
            current = current->next;
        }

        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }

    return result;
}
",1.0,111111111111111
Singly_linked_list_2,1419765,2212741,"void Polynomial::insertTerm(const Term& term) {
   if(term.exp < 0 ||  term.coeff == 0) return;
     SLinkedList<Term>::Iterator it;
    int count = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == term.exp){
            t.coeff += term.coeff;
            if(t.coeff != 0) it.set(t);
            else it.remove();
            return;
        }
        else if(t.exp < term.exp){
            break;
        }
        count++;
    }
    this->terms->add(count, term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    if(exp < 0 ||coeff == 0) return;
     SLinkedList<Term>::Iterator it;
    int count = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == exp){  
            t.coeff += coeff;
            if(t.coeff != 0) it.set(t); 
            else it.remove();
            return;
        }
        else if(t.exp < exp){
            break; //! Dừng khi tìm được vị trí chèn.
        }
        count++;
    }
    Term t(coeff, exp);
    this->terms->add(count, t);
}",1.0,11111
Singly_linked_list_3,1419765,2212741,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    this->pList = pList;
    if (pList == NULL) {}
    else if (begin) {
        if (this->pList->head) {
            current = this->pList->head; 
            this->index = 0;
        }
        else {
            current = nullptr; 
            this->index = -1;
        }
    }
    else {
        current = nullptr;
        if (this->pList->head)
            index = this->pList->size();
        else index = 0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    if(current) {
        int index = this->pList->indexOf(this->current->data);
        if (!index) { 
            this->pList->removeAt(index);
            this->index = -1;
            current = NULL;
        }
        else {
            T e = this->pList->removeAt(index - 1);
            this->index = index - 1;
            current->data = e;
        }
    }
    else throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    if(current)
        current->data = e; 
    else throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    if(current)
        return current->data;
    else throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    return ((this->current != iterator.current) && (this->index != iterator.index));
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    if(current) {
        current = current->next; 
        index++;
        return *this; 
    }
    else throw std::out_of_range(""Segmentation fault!"");
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    if(current) { 
        Iterator i = *this;
        current = current->next; 
        index++; 
        return i; 
    }
    else throw std::out_of_range(""Segmentation fault!"");
}",1.0,11111
Singly_linked_list_4,1419765,2212741,"void LinkedList::partition(int k) {
    Node* tmp = this->head;
    Node* g1 = nullptr;
    Node* tmp1 = nullptr;
    Node* g2 = nullptr;
    Node* tmp2 = nullptr;
    Node* g3 = nullptr;
    Node* tmp3 = nullptr;

    while (tmp) {
        if (tmp->value < k) {
            if (g1) {
                tmp1->next = new Node(tmp->value);
                tmp1 = tmp1->next;
            }
            else {
                g1 = new Node(tmp->value);
                tmp1 = g1;
            }
        }
        else if (tmp->value == k) {
            if (g2) {
                tmp2->next = new Node(tmp->value);
                tmp2 = tmp2->next;
            }
            else {
                g2 = new Node(tmp->value);
                tmp2 = g2;
            }
        }
        else {
            if (g3) {
                tmp3->next = new Node(tmp->value);
                tmp3 = tmp3->next;
            }
            else {
                g3 = new Node(tmp->value);
                tmp3 = g3;
            }
        }
        tmp = tmp->next;
    }
     tmp=head;
    while (g1) {
    tmp->value=g1->value;
    g1=g1->next;
    tmp=tmp->next;
    }

    if (g2) {
        while (g2) {
    tmp->value=g2->value;
    g2=g2->next;
    tmp=tmp->next;
    }
    }

    if (g3) {
        while (g3) {
    tmp->value=g3->value;
    g3=g3->next;
    tmp=tmp->next;
    }
}
}",1.0,11111
Singly_linked_list_5,1419765,2212741,"void reduceDuplicate(Node* root)
{
    Node* tmp= root;
    int num=root->getData();
    while(tmp->getNext()){
        if(tmp->getNext()->getData()==num){
            if(tmp->getNext()->getNext()){
                Node* p=tmp->getNext();
                tmp->setNext(tmp->getNext()->getNext());
                delete p;
            }
            else{
                Node* p=tmp->getNext();
                tmp->setNext(nullptr);
                delete p;
            }
        }
        else{
            num=tmp->getNext()->getData();
                tmp=tmp->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1419765,2212741,"int Train::allocate(int containerSize) {
    TrainCar* tmp=head;
    int res=-1;
    int remain=999999;
    int count =1;
    tmp=tmp->next;
    while(tmp){
        if(tmp->remainingSpace>=containerSize){
            int minus=tmp->remainingSpace-containerSize;
            if(minus<remain){
                remain=minus;
                res=count;
            }
            count++;
            tmp=tmp->next;
        }
        else{
            count++;
            tmp=tmp->next;
        }
    }
    tmp=head;
     count=res;
    while(count>0){
        count--;
        tmp=tmp->next;
    }
    if(tmp!=head)
    tmp->remainingSpace=remain;
    return res;
}

int Train::totalRemainingSpace() {
    int res=0;
    TrainCar* tmp=head;
    while(tmp){
        res+=tmp->remainingSpace;
        tmp=tmp->next;
    }
    return res;
}",1.0,11111
Singly_linked_list_7,1419765,2212741,"template <class T>
void SLinkedList<T>::add(const T& e) {
    if (count == 0) {
        head = new Node(e, NULL);
        tail = head;
    }
    else {
        Node *tmp = new Node(e, NULL);
        tail->next = tmp;
        tail = tmp;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    if (count == 0 || index == count) add(e); 
    else if (index == 0){
        Node *tmp = new Node(e, NULL);
        tmp->next = head;
        head = tmp;
        count++;
    }
    else {
        Node *tmp = new Node(e, NULL);
        Node *tmp2 = head;
        while(--index){
            tmp2 = tmp2->next;
        }
        tmp->next = tmp2->next;
        tmp2->next = tmp;
        count++;
    }
}

template<class T>
int SLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Singly_linked_list_8,1419765,2212741,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index>count-1) return 0;
    Node* tmp=head;
    while(index>0){
        tmp=tmp->next;
        index--;
    }
    return tmp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index>count-1) return;
    Node*tmp=head;
    while(index>0){
        tmp=tmp->next;
        index--;
    }
    tmp->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !head;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int res=0;
    Node* tmp=head;
    while(tmp){
        if(tmp->data==item) return res;
        res++;
        tmp=tmp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* tmp=head;
    while(tmp){
        if(tmp->data==item) return 1;
        tmp=tmp->next;
    }
    return 0;
}",1.0,1111111111
Singly_linked_list_9,1419765,2212741,"template <class T>
T SLinkedList<T>::removeAt(int index)
{   
    // if(index>count-1||count<=0) return 0;
    /* Remove element at index and return removed value */
    if(index==0){
        Node* tmp=head;
        Node*p =tmp;
        tmp=tmp->next;
        head=tmp;
        int i=p->data;
        delete p;
        count--;
        return i;
    }
    else{
    Node* preN=head;
    while(index>1&&preN->next){
            preN=preN->next;
        --index;
    }
    
     if(preN->next){
         Node*p=preN->next;
         preN->next=p->next;
         if(!p->next) tail=preN;
         int i =p->data;
         delete p;
         count--;
        return i;
     }
        else return 0;
    // return 9;
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* tmp=head;
    Node* preN=head;
    while(tmp){
        if(tmp->data==item){
         if(tmp==head){
             Node*p =tmp;
             head=head->next;
             delete p;
             return 1;
         } 
         else{
             Node*p =tmp;
             preN->next=tmp->next;
             if(!p->next) tail=preN;
             delete p;
             
             count--;
             return 1;
         }
        }
        if(tmp==head)
        tmp=tmp->next;
        else{
            tmp=tmp->next;
            preN=preN->next;
        }
    }
    return 0;
    
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    while(head){
        Node* tmp=head;
        head=head->next;
        delete tmp;
        count--;
    }
}

",1.0,1111111111
Singly_linked_list_10,1419765,2212741,"void InsertFirst (LLNode* &head,int val){
    if(head){
        LLNode* p=new LLNode(val,head);
        head=p;
    }
    else{
        head=new LLNode(val,nullptr);
    }
}
LLNode* reverse(LLNode* head){
    LLNode* tmp=nullptr;
    while(head){
        InsertFirst(tmp,head->val);
        head=head->next;
    }
    return tmp;
}
LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* p=head;
    int count=0;
    while(p){
        count++;
        p=p->next;
    }
    int markIndex;
    markIndex=count/2;
    LLNode* firstHalf=reverse(head);
    
    LLNode* secondHalf;
    p=head;
    int i=markIndex;
    while(p&&i>0){
        p=p->next;
        i--;
        firstHalf=firstHalf->next;
    }
    secondHalf=p;
    LLNode* tmp=secondHalf;
    if(count%2!=0) tmp=tmp->next,firstHalf=firstHalf->next;
    while(tmp&&firstHalf){
        tmp->val+=firstHalf->val;
        tmp=tmp->next;
        firstHalf=firstHalf->next;
    }
    return secondHalf;
}",1.0,1111111111
Singly_linked_list_11,1419765,2212741,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    stack<LLNode*> myStack;
    LLNode* tmp=head;
    while(tmp){
        if(myStack.empty()) myStack.push(tmp);
        else{
            while(!myStack.empty()&&tmp->val>myStack.top()->val){
                myStack.top()->val=tmp->val;
                myStack.pop();
            }
            myStack.push(tmp);
        }
        tmp=tmp->next;
    }
    while(!myStack.empty()){
        myStack.top()->val=0;
                myStack.pop();
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1419765,2212741,"void InsertFirst (LLNode* &head,int val){
    if(head){
        LLNode* p=new LLNode(val,head);
        head=p;
    }
    else{
        head=new LLNode(val,nullptr);
    }
}
LLNode* reverseLinkedList(LLNode* head){
    LLNode* tmp=nullptr;
    while(head){
        InsertFirst(tmp,head->val);
        head=head->next;
    }
    return tmp;
}",1.0,1111111111
Singly_linked_list_13,1419765,2212741,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if(!head) return nullptr;
    int save[999999];
    LLNode* p=head;
    int i=k;
    int l=0;
    while(p){
        save[l]=p->val;
            p=p->next;
            l++;
    }
    p=head;
    while(i>0){
        if(p->next){
            p=p->next;
            i--;
        }
        else{
            p=head;
            i--;
        };
    }
    l=0;
    LLNode* tmp=head;
    while(p){
        p->val=save[l];
        tmp=tmp->next;
        p=p->next;
        l++;
    }
    p=head;
    while(tmp){
        p->val=save[l];
         tmp=tmp->next;
        p=p->next;
        l++;
    }
    
    return head;
}",1.0,1111111111
Singly_linked_list_14,1419765,2212741,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    Node* preLow=nullptr;
    Node* afterHigh=nullptr;
    int i=0;
    if(low==-1||low==0){
        Node* p=head;
        while(i<=high){
            p=p->next;
            if(p==nullptr){
                head=linked_list->head;
                tail=linked_list->tail;
                return;
            }
            i++;
        }
            afterHigh=p;
        head=linked_list->head;
        linked_list->tail->next=afterHigh;
        if(!afterHigh) tail=linked_list->tail;
        
    }
    else{
        int i=0;
        Node*p =head;
        while(i<low-1){
            p=p->next;
            i++;
        }
        preLow=p;
        while(i<=high){
            p=p->next;
            if(p==nullptr){
                preLow->next=linked_list->head;
                tail=linked_list->tail;
                return;
            }
            i++;
        }
            afterHigh=p;
        preLow->next=linked_list->head;
        linked_list->tail->next=afterHigh;
        if(!afterHigh) tail=linked_list->tail;
        
    }
    
}",1.0,11111
Singly_linked_list_1,1421645,2212372,"
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
 LLNode *l;
 int t=0;
 int a[100000];
 int i=0;
 while(l0||l1){
 if(!l0){a[i]=(t+l1->val)%10;
 t=(t+l1->val)/10;
l1=l1->next;
 }
 else  if(!l1){a[i]=(t+l0->val)%10;
 t=(t+l0->val)/10;
 l0=l0->next;
 }else{a[i]=(t+l0->val+l1->val)%10;
 t=(t+l0->val+l1->val)/10;
 l0=l0->next;
 l1=l1->next;
 }
 i++;
 }
 if(t==1){a[i]=1;
 i++;
 }
 int arr[i];
 for(int j=0;j<i;j++){
     arr[j]=a[j];
 }
l=LLNode::createWithIterators(arr, arr + sizeof(arr) / sizeof(int));
  return l;

}",1.0,111111111111111
Singly_linked_list_2,1421645,2212372,"void Polynomial::insertTerm(const Term& term) {
if(term.exp < 0 ||  term.coeff == 0) return;
     SLinkedList<Term>::Iterator it;
     int i = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == term.exp){
            t.coeff += term.coeff;
            if(t.coeff != 0) it.set(t);
            else it.remove();
            return;
        }
        else if(t.exp < term.exp){
            break;
        }
        i++;
    }
    this->terms->add(i,term);}

void Polynomial::insertTerm(double coeff, int exp) {
  if(exp < 0 ||coeff ==0) return;
     SLinkedList<Term>::Iterator it;
     int i = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == exp){  
            t.coeff += coeff; 
            if(t.coeff != 0.0000000f) it.set(t);  
            else it.remove();  
            return;
        }
        else if(t.exp < exp){
            break; 
        }
        i++;
    }
    Term t(coeff,exp);
    this->terms->add(i,t); 
}",1.0,11111
Singly_linked_list_3,1421645,2212372,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true:
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false:
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin) {
        if (pList != NULL) {
            current = pList->head;
            index = 0;
        }
        else {
            current = NULL;
            index = -1;
        }
    }
    else {
        current = NULL;
        if (pList != NULL) {
            index = pList->size();
        }
        else {
            index = 0;
        }
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove, current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current != NULL) {
        Node* A = pList->head;
        while (A->next != current) {
            A = A->next;
        }

        if (A == pList->head) {
            current = NULL;
            index = -1;
        }
        else {
            A->next = current->next;
            delete current;
            current = A;
        }
    }
    else {
        throw std::out_of_range(""Segmentation fault!"");
    }
}


template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else {
        current->data = e;
    }
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else {
        return current->data;
    }
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if (iterator.current == this->current && iterator.index == this->index) {
        return false;
    }
    return true;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else {
        current = current->next;
        if (current == NULL && pList != NULL) {
            index = pList->size();
        }
    }
    return *this;
}

// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else {
        Iterator temp(*this);
        current = current->next;
        if (current == NULL && pList != NULL) {
            index = pList->size();
        }
        return temp;
    }
}

",0.8,11110
Singly_linked_list_4,1421645,2212372,"void LinkedList::partition(int k) {
    if (size < 2) { return; }
    Node* I = new Node(-1);
    Node* VetI = I;
    Node* II = new Node(-1);
    Node* VetII = II;
    Node* III = new Node(-1);
    Node* VetIII = III;
    Node* travel = head;

    /*Vong lap phan loai*/
    for (int i = 0; i < this->size; i++) {
        /*Lay con tro travel de cuoi vong lap xoa di*/
        Node* deletetemp = travel;

        Node* connect = new Node(travel->value);
        connect->next = nullptr; // Initialize the next pointer

        if (travel->value < k) {
            I->next = connect;
            I = I->next;
        }
        else if (travel->value == k) {
            II->next = connect;
            II = II->next;
        }
        else {
            III->next = connect;
            III = III->next;
        }
        travel = travel->next;
        /*da xoa con tro travel cu*/
        delete deletetemp; // Use delete instead of delete[]
    }

    /*Connected 3 doan*/

    if (VetI->next != nullptr) {
        if (VetII->next != nullptr) {
            if (VetIII->next != nullptr) {
                I->next = VetII->next;
                II->next = VetIII->next;
                head = VetI->next;
                tail = III;
            }
            else {
                I->next = VetII->next;
                head = VetI->next;
                tail = II;
            }
        }
        else {
            if (VetIII->next != nullptr) {
                I->next = VetIII->next;
                head = VetI->next;
                tail = III;
            }
            else {
                head = VetI->next;
                tail = I;
            }
        }
    }
    else {
        if (VetII->next != nullptr) {
            if (VetIII->next != nullptr) {
                II->next = VetIII->next;
                head = VetII->next;
                tail = III;
            }
            else {
                head = VetII->next;
                tail = II;
            }
        }
        else {
            if (VetIII->next != nullptr) {
                head = VetIII->next;
                tail = III;
            }
            else {
                head = nullptr;
                tail = nullptr;
            }
        }
    }
    delete VetI;
    delete VetII;
    delete VetIII;
}
",1.0,11111
Singly_linked_list_5,1421645,2212372,"void reduceDuplicate(Node* root)
{ if(root && root->getNext() == NULL) return;
    Node* curr = root->getNext(),* prev = root;
    while(curr){
        if(curr->getData() == prev->getData()){
            prev->setNext(curr->getNext());
            curr = prev->getNext();
        }
        else{
            prev->setNext(curr);
            curr = curr->getNext();
        }
    }
}",0.6,1101001100
Singly_linked_list_7,1421645,2212372,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */

    Node* temp = new Node(e, NULL);
    if (count == 0) {
        head = temp;
        tail = temp;
    }
    else {
        tail->next = temp;
        tail = tail->next;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    Node* temp = new Node(e, NULL);
    if (index == 0) {
        if (count == 0) {
            head = temp;
            tail = temp;
        }
        else {
            temp->next = head;
            head = temp;
        }

        count++;
    }
    else if (index == count) {
        add(e);
    }
    else {
        Node* cur = head;
        Node* pre = NULL;
        for (int i = 0; i < index; i++) {
            pre = cur;
            cur = cur->next;
        }
        pre->next = temp;
        temp->next = cur;

        count++;
    }
}
template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1421645,2212372,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index<0 || index>count) {
        throw std::out_of_range(""out of range"");
    }
    else {
        Node* temp = head;
        for (int i = 0; i < index; i++) {
            temp = temp->next;
        }
        return temp->data;
    }
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index<0 || index>count) {

        throw std::out_of_range(""out of range"");
    }
    else {
        Node* temp = head;
        for (int i = 0; i < index; i++) {
            temp = temp->next;
        }
        temp->data = e;
    }
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !count;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    for (int i = 0; i < count; i++) {
        if (temp->data == item) {
            return i;
        }
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* temp = head;
    for (int i = 0; i < count; i++) {
        if (temp->data == item) {
            return true;
        }
        temp = temp->next;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1421645,2212372,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    if (index<0 || index>count) {
        throw std::out_of_range(""out of range"");
    }
    else {
        T a = 0;
        if (index == 0) {
            a = head->data;
            if (count == 0) {
                head = NULL;
                tail = NULL;
                count = 0;
            }
            else {
                head = head->next;
                if (count == 1) { tail = NULL; }
                count--;
            }
        }
        else {
            Node* pre = NULL;
            Node* temp = head;
            for (int i = 0; i < index; i++) {
                pre = temp;
                temp = temp->next;
            }
            a = temp->data;
            pre->next = temp->next;
            if (index == count - 1) {
                tail = pre;
            }
            delete[] temp;
            count--;
        }
        return a;
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* temp = head;
    for (int i = 0; i < count; i++) {
        if (temp->data == item) {
            removeAt(i);
            return true;
        }
        temp = temp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear() {
    /* Remove all elements in list */
    while (head != NULL) {

        Node* temp = head;
        head = head->next;
        delete temp;
    }
    count = 0;
    head = NULL;
    tail = NULL;
}
",1.0,1111111111
Singly_linked_list_10,1421645,2212372,"
    LLNode* reverseLinkedList(LLNode* head) {
    LLNode* temp2 = NULL;
    LLNode* a = NULL;
    while (head != NULL) {
        a = head;
        head = head->next;
        a->next = temp2;
        temp2 = a;
    }
    return a;
}


LLNode* foldLinkedList(LLNode* head) {
    if(head == NULL || head->next == NULL) return head;

    LLNode* curr = head, * curr2 = head->next;
    while(curr2 && curr2->next){
        curr2 = curr2->next->next;
        curr = curr->next;
    }
    bool k = curr2;
    curr2 = curr->next; 
    curr->next = NULL;
    head = reverseLinkedList(head);
    curr = head;
    if(!k){
        curr = curr->next;
    }
    while(curr && curr2){
        curr->val += curr2->val;
        curr = curr->next;
        curr2 = curr2->next;
    }
    return head;
    
}",1.0,1111111111
Singly_linked_list_11,1421645,2212372,"LLNode* replaceFirstGreater(LLNode* head) {
stack<LLNode*> stk;
    LLNode* node = head;
    while (node != nullptr) {
        while (!stk.empty() && stk.top()->val < node->val) {
            stk.top()->val = node->val;
            stk.pop();
        }

        stk.push(node);
        node = node->next;
    }
    while (!stk.empty()) {
        stk.top()->val = 0;
        stk.pop();
    }

    return head;}",1.0,1111111111
Singly_linked_list_12,1421645,2212372,"
    LLNode* reverseLinkedList(LLNode* head) {
    LLNode* temp2 = NULL;
    LLNode* a = NULL;
    while (head != NULL) {
        a = head;
        head = head->next;
        a->next = temp2;
        temp2 = a;
    }
    return a;
}
",1.0,1111111111
Singly_linked_list_13,1421645,2212372,"int countSingle(LLNode* head) {
    LLNode* temp = head;
    int i = 0;
    while (temp != NULL) {
        i++;
        temp = temp->next;
    }
    return i;
}
LLNode* rotateLinkedList(LLNode* head, int k) {
    int n = countSingle(head);
    if (n == 0 || n == 1) {
        return head;
    }
    k = k % n;
    if (k % n == 0) {
        return head;
    }
    LLNode* pre = NULL;
    LLNode* cur = head;
    for (int i = 0; i < n - k; i++) {
        pre = cur;
        cur = cur->next;
    }
    pre->next = NULL;
    LLNode* headresult = cur;
    while (cur->next != NULL) {
        cur = cur->next;
    }
    cur->next = head;
    return headresult;


}",1.0,1111111111
Singly_linked_list_1,1423383,2213836,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* dummy = new LLNode();  // Nút giả để đơn giản hóa việc xử lý
    
    LLNode* curr = dummy;  // Con trỏ trỏ tới nút hiện tại trong danh sách kết quả
    int carry = 0;  // Biến nhớ
    
    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;
        
        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        
        carry = sum / 10;  // Lấy phần nguyên của tổng để cập nhật biến nhớ
        int digit = sum % 10;  // Lấy phần dư của tổng để tạo nút mới
        
        curr->next = new LLNode(digit, nullptr);  // Tạo nút mới cho kết quả
        curr = curr->next;
    }
    
    LLNode* result = dummy->next;  // Danh sách kết quả bắt đầu từ nút sau nút giả
    delete dummy;  // Giải phóng nút giả
    
    return result;
}",1.0,111111111111111
Singly_linked_list_2,1423383,2213836,"void Polynomial::insertTerm(const Term& term) {
    if (term.coeff == 0) return; // Nếu hệ số bằng 0, không cần chèn, kết thúc phương thức.

    SLinkedList<Term>::Iterator i;
    int index = 0;
    for (i = terms->begin(); i != terms->end(); i++) {
        if (term.exp == (*i).exp) { // Nếu mũ trùng khớp với hạng tử hiện tại trong đa thức
            (*i).coeff += term.coeff; // Cộng hệ số của hạng tử được chèn vào hệ số của hạng tử hiện tại
            if ((*i).coeff == 0) {
                terms->removeAt(index); // Nếu tổng hệ số bằng 0, loại bỏ hạng tử hiện tại khỏi đa thức
            }
            return; // Kết thúc phương thức
        }
        else if (term.exp > (*i).exp) { // Nếu mũ lớn hơn mũ của hạng tử hiện tại trong đa thức
            terms->add(index, term); // Chèn hạng tử vào vị trí index trong danh sách các hạng tử trong đa thức
            return; // Kết thúc phương thức
        }
        index++; // Tăng chỉ số index để tiếp tục kiểm tra hạng tử tiếp theo trong đa thức
    }
    terms->add(index, term); // Nếu không có hạng tử nào có mũ lớn hơn, chèn hạng tử vào cuối danh sách
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    Term term(coeff, exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_3,1423383,2213836,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(pList == NULL) {}
    else if(begin) {
        if(this->pList->size() == 0) {
            this->current = NULL;
            index = -1;
            
        }
        else {
            this->current = pList->head;
            index = 0;
        }
    }
    
    else if(!begin) {
        this->current = NULL;
        if(this->pList->size() == 0) index = 0;
        else index = this->pList->size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    
    if(index == 0) {
        this->pList->removeAt(index);
        this->current = NULL;
        index = -1;
    }
    else {
        T e = this->pList->removeAt(index - 1);
        this->index = index - 1;
        current->data = e;
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if(iterator.index == this->index && iterator.current == this->current) return false;
    return true;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current = current->next;
    index++;
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    Iterator temp = *this;
    current = current->next;
    index++;
    return temp;
}",1.0,11111
Singly_linked_list_4,1423383,2213836,"void LinkedList::partition(int k) {
    // Kiểm tra xem danh sách liên kết có ít hơn 2 phần tử hay không
    if (head == NULL || head->next == NULL) {
        return;
    }

    Node* smallerHead = NULL;  // Đầu danh sách nhóm I
    Node* smallerTail = NULL;  // Đuôi danh sách nhóm I
    Node* equalHead = NULL;    // Đầu danh sách nhóm II
    Node* equalTail = NULL;    // Đuôi danh sách nhóm II
    Node* greaterHead = NULL;  // Đầu danh sách nhóm III
    Node* greaterTail = NULL;  // Đuôi danh sách nhóm III

    Node* current = head;
    
    // Duyệt qua danh sách liên kết và phân chia các phần tử vào các nhóm tương ứng
    while (current != NULL) {
        if (current->value < k) {
            // Phần tử nhỏ hơn k thuộc nhóm I
            if (smallerHead == NULL) {
                smallerHead = current;
                smallerTail = current;
            } else {
                smallerTail->next = current;
                smallerTail = current;
            }
        } else if (current->value == k) {
            // Phần tử bằng k thuộc nhóm II
            if (equalHead == NULL) {
                equalHead = current;
                equalTail = current;
            } else {
                equalTail->next = current;
                equalTail = current;
            }
        } else {
            // Phần tử lớn hơn k thuộc nhóm III
            if (greaterHead == NULL) {
                greaterHead = current;
                greaterTail = current;
            } else {
                greaterTail->next = current;
                greaterTail = current;
            }
        }
        
        current = current->next;
    }
    
    // Kết hợp các nhóm lại theo thứ tự I -> II -> III
    if (smallerHead != NULL) {
        head = smallerHead;
        smallerTail->next = equalHead;
    } else {
        head = equalHead;
    }
    
    if (equalHead != NULL) {
        equalTail->next = greaterHead;
    }
    
    if (greaterHead != NULL) {
        tail = greaterTail;
        tail->next = NULL;
    }
}",1.0,11111
Singly_linked_list_5,1423383,2213836,"void reduceDuplicate(Node* root)
{
    if (root == nullptr) {
        return;
    }
    
    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicateNode = current->getNext();
            current->setNext(duplicateNode->getNext());
            delete duplicateNode;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1423383,2213836,"int Train::allocate(int containerSize) {
if(this->size<=0) return -1;
 TrainCar*  temp=this->head;
 int index=-1;
 int minRemainingSpace = 32767;
 for (int i = 0; i < this->size; ++i) {
        if (temp->remainingSpace >= containerSize && temp->remainingSpace < minRemainingSpace) {
            index = i;
            minRemainingSpace = temp->remainingSpace;
        }
        temp = temp->next;
    }
    temp=this->head;
 for(int i=0;i<index;++i)
 temp=temp->next;
 if (temp != nullptr&& index!=-1) 
{
    temp->remainingSpace -= containerSize;
}
 return index;
}

int Train::totalRemainingSpace() {
    int totalSpace = 0;
    TrainCar* current = head->next;

    while (current != nullptr) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }

    return totalSpace;
}",1.0,11111
Singly_linked_list_7,1423383,2213836,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e, nullptr);
    if(head == nullptr) head = tail = newNode;
    else {
        tail->next = newNode;
        tail= newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e, nullptr);
    if(index == 0) {
        newNode->next = head;
        head = newNode;
    }
    else {
        Node* current = head;
        for(int i = 0; i < index - 1; i++){
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    count++;
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
    return 0;
}
",1.0,1111111111
Singly_linked_list_8,1423383,2213836,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    return temp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int index = 0;
    while(temp) {
        if(temp->data == item) return index;
        temp = temp->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* temp = head;
    while(temp) {
        if(temp->data == item) return true;
        temp = temp->next;
    }
    return false;
    
}",1.0,1111111111
Singly_linked_list_9,1423383,2213836,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* removeNode = nullptr;
    Node* temp = head;
    if(index == 0) {
        removeNode = head;
        head = head->next;
    }
    else{
        for(int i = 0; i < index - 1; i++) {
            temp = temp->next;
        }
        removeNode = temp->next;
        temp->next = temp->next->next;
        if(index == count - 1) tail = temp;
    }
    T removedValue = removeNode->data;
    delete removeNode;
    count--;
    return removedValue;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    Node* previous = nullptr;

    while (current != nullptr) {
        if (current->data == item) {
            if (previous == nullptr) {
                head = current->next;
            } else {
                previous->next = current->next;
                if (current == tail) {
                    tail = previous;
                }
            }

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* temp  = head;
    while(temp) {
        Node* next = temp->next;
        delete temp;
        temp = next;
    }
    head  =tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1423383,2213836,"LLNode* reverseLinkedList(LLNode* head) {
    if(!head || !head->next) return head;
    LLNode* prev = head, * curr = head->next, *post = head->next->next;
    head->next = NULL;
    while(post){
        curr->next = prev;
        prev = curr;
        curr = post;
        post = post->next;
    }
    curr->next = prev;
    return curr;
}
LLNode* foldLinkedList(LLNode* head) {
//! nếu nó chỉ có 1 phần tử hoặc không có phần tử nào thì return 
    if(head == NULL || head->next == NULL) return head;

    LLNode* curr = head, * curr2 = head->next;
//! Duyệt qua danh sách để tìm điểm chính giữa bằng cách di chuyển curr2 gấp đôi tốc độ.
    while(curr2 && curr2->next){
        curr2 = curr2->next->next;
        curr = curr->next;
    }
//! k true khi curr2 khác null
    bool k = curr2;
    curr2 = curr->next; 
    curr->next = NULL;
//! Đảo ngược nửa đầu của danh sách
    head = reverseLinkedList(head);
    curr = head;
//! nếu danh sách rẻ thì bỏ qua node đầu tiên khi đảo danh sách
    if(!k){
        curr = curr->next;
    }
//! cộng chúng lại với nhau
    while(curr && curr2){
        curr->val += curr2->val;
        curr = curr->next;
        curr2 = curr2->next;
    }
    return head;
    
}",1.0,1111111111
Singly_linked_list_11,1423383,2213836,"LLNode* replaceFirstGreater(LLNode* head) {
    if (head == nullptr) {
        return nullptr;
    }

    // Tạo một ngăn xếp rỗng để lưu trữ các nút
    std::stack<LLNode*> nodeStack;

    // Duyệt qua danh sách liên kết
    LLNode* current = head;
    while (current != nullptr) {
        // Kiểm tra nếu ngăn xếp không rỗng và giá trị của nút hiện tại
        // lớn hơn giá trị của nút ở đầu ngăn xếp
        while (!nodeStack.empty() && current->val > nodeStack.top()->val) {
            // Thay thế giá trị của nút ở đầu ngăn xếp bằng giá trị của nút hiện tại
            nodeStack.top()->val = current->val;
            // Loại bỏ nút khỏi ngăn xếp vì nó đã tìm thấy nút lớn hơn kế tiếp của nó
            nodeStack.pop();
        }
        // Đẩy nút hiện tại vào ngăn xếp
        nodeStack.push(current);
        // Di chuyển đến nút tiếp theo trong danh sách liên kết
        current = current->next;
    }

    // Sau khi duyệt qua, các nút còn lại trong ngăn xếp không có nút lớn hơn nào bên phải của chúng
    // Đặt giá trị của chúng thành 0
    while (!nodeStack.empty()) {
        nodeStack.top()->val = 0;
        nodeStack.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1423383,2213836,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    //! nếu không có phần tử nào hay chỉ có 1 phần tử thì return về chính nó
    if(!head || !head->next) return head;
//! trước hiện tại và sau
    LLNode* prev = head, * curr = head->next, *post = head->next->next;
    head->next = NULL;
    while(post){
//! Đảo ngược kết nối của nút hiện tại
        curr->next = prev;
//! Di chuyển prev tới nút hiện tại
        prev = curr;
//!  Di chuyển curr tới nút post
        curr = post;
//! Di chuyển post tới nút tiếp theo sau post
        post = post->next;
    }
//! Đảo ngược kết nối của nút cuối cùng
    curr->next = prev;
    return curr;
}",1.0,1111111111
Singly_linked_list_13,1423383,2213836,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    //! trả về null nếu list rỗng
        if(!head) return NULL;
        LLNode* tmp = head;
        int size = 1;
        while (head->next) {
        head = head->next;
//!  Tăng biến size lên 1 để đếm số lượng nút
        size++;
    }
//! cuối danh liên kết trở tới đầu danh sách
        head->next = tmp;
//! Tính phần dư của k khi chia cho size để đảm bảo k không lớn hơn size
        k %= size;
        
//! Tính số bước di chuyển con trỏ để xoay danh sách
        k = size - k;
      
        while(k){
            head = head->next;
            k--;
        }
//! Lưu nút mới đứng đầu danh sách liên kết vào biến tmp
        tmp = head->next;
        head->next = NULL;
         return tmp;
}
",1.0,1111111111
Singly_linked_list_1,1424132,2213248,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* head = nullptr;
    LLNode** p = &head;
    while(*p) {
        p = &((*p)->next);
    }
    int in = 0;
    while(l0 != nullptr || l1 != nullptr || in > 0) {
        int num0 = 0, num1 = 0;
        if(l0 != nullptr) {
            num0 = l0->val;
            l0 = l0->next;
        }
        if(l1 != nullptr) {
            num1 = l1->val;
            l1 = l1->next;
        }
        int value = (num0 + num1 + in) % 10;
        in = (num0 + num1 + in) / 10;
        *p = new LLNode(value, nullptr);
        p = &((*p)->next);
    }
    return head;
}",0.3,111111111111111
Singly_linked_list_2,1424132,2213248,"void Polynomial::insertTerm(const Term& term) {
     SLinkedList<Term>::Iterator it;
    
    // Iterate through the terms to find the correct position to insert the new term
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        if (term.exp > (*it).exp) {
            break; // Found the correct position to insert
        } else if (term.exp == (*it).exp) {
            // Terms with the same exponent, add coefficients
            (*it).coeff += term.coeff;
            return; // We're done
        }
    }
    
    // Insert the term at the correct position in descending order of exponents
    this->terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    SLinkedList<Term>::Iterator it;
     for (it = this->terms->begin(); it != this->terms->end(); it++) {
         if((*it).exp == exp) (*it).coeff = coeff;
     }
}",0.2,00010
Singly_linked_list_1,1424351,2213035,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    int carry = 0;
    LLNode* dummy = new LLNode(); 
    LLNode* current = dummy; 

    while (l0 || l1 || carry) {
        int sum = carry;
        if (l0) {
            // cout<<l0->val<<endl;
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1) {
            // cout<<l1->val<<endl;
            sum += l1->val;
            l1 = l1->next;
        }
        // cout<<""carry ""<<carry<<endl;
        carry = sum / 10;
        int digit = sum % 10;
        // cout<<""sum ""<<sum<<endl;
        current->next = new LLNode(digit, nullptr);
        current = current->next;
        // cout<<""current->val ""<<current->val<<endl;
    }

    LLNode* result = dummy->next;  
    delete dummy; 
    return result;
}",1.0,111111111111111
Singly_linked_list_2,1424351,2213035,"void Polynomial::insertTerm(const Term &term)
{
    if (term.coeff != 0)
    {
        int i = 0;
        SLinkedList<Term>::Iterator it;
        bool termInserted = false;
        for (it = this->terms->begin(); it != this->terms->end(); it++)
        {
            if (term.exp > (*it).exp)
            {
                this->terms->add(i, term);
                termInserted = true;
                break;
            }
            else if (term.exp == (*it).exp)
            {
                double newCoeff = term.coeff + (*it).coeff;

                if (newCoeff != 0)
                {
                    Term newTerm(newCoeff, term.exp);
                    this->terms->set(i, newTerm); 
                }
                else
                {
                    this->terms->removeAt(i); 
                }

                termInserted = true;
                break;
            }
            i++;
        }
        if (!termInserted)
        {
            this->terms->add(term);
        }
    }
}


void Polynomial::insertTerm(double coeff, int exp)
{
    Term term(coeff, exp);
    this->insertTerm(term);
}",1.0,11111
Singly_linked_list_3,1424351,2213035,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList; 
    if (begin) {
        if (pList) {
            index = 0; 
            current = pList->head; 
        }
        else{
            index = -1; 
            current = nullptr; 
        }
    }
    else {
        current = nullptr;
        if (pList) index = pList->size();
        else index = 0; 
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    if (this != &iterator) {
        this->current = iterator.current; 
        this->index = iterator.index; 
        this->pList = iterator.pList; 
    }
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (this->current == nullptr) throw std::out_of_range(""""); 
    Node* p = pList->head; 
    for (int i = 1; i < this->index; i++) p = p->next;  
    if (index == 0) p = nullptr; 
    this->pList->removeAt(this->index); 
    this->current = p; 
    index--; 
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (this->current == nullptr) throw std::out_of_range(""""); 
    this->current->data = e; 
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (!current) throw std::out_of_range("""");  
    return this->current->data; 
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if (this->pList == iterator.pList && this->current == iterator.current && this->index == iterator.index) return true; 
    return false; 
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
* Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (this->current == nullptr) throw std::out_of_range(""""); 
    current = current->next; 
    index++; 
    if (current == nullptr) current = pList->head; 
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator it = *this; 
    
    if (this->current == nullptr && index == pList->size()) throw std::out_of_range(""""); 
    if (current == nullptr && index == -1) current = pList->head; 
    else current = current->next; 
    index++; 
    return it; 
}",0.8,11110
Singly_linked_list_4,1424351,2213035,"void LinkedList::partition(int k) {
    if (head == nullptr || head->next == nullptr) {
        return; // Không cần phân chia nếu danh sách trống hoặc chỉ có một phần tử
    }

    Node* group1_head = nullptr;
    Node* group1_tail = nullptr;
    Node* group2_head = nullptr;
    Node* group2_tail = nullptr;
    Node* group3_head = nullptr;
    Node* group3_tail = nullptr;

    Node* current = head;

    while (current != nullptr) {
        Node* next = current->next;
        current->next = nullptr; // Đảm bảo tách nút ra khỏi danh sách gốc

        if (current->value < k) {
            // Thuộc nhóm I
            if (group1_head == nullptr) {
                group1_head = current;
                group1_tail = current;
            } else {
                group1_tail->next = current;
                group1_tail = current;
            }
        } else if (current->value == k) {
            // Thuộc nhóm II
            if (group2_head == nullptr) {
                group2_head = current;
                group2_tail = current;
            } else {
                group2_tail->next = current;
                group2_tail = current;
            }
        } else {
            // Thuộc nhóm III
            if (group3_head == nullptr) {
                group3_head = current;
                group3_tail = current;
            } else {
                group3_tail->next = current;
                group3_tail = current;
            }
        }

        current = next;
    }

    if(group1_head != nullptr && group2_head != nullptr && group3_head != nullptr){
        head = group1_head;
        group1_tail->next = group2_head;
        group2_tail->next = group3_head;
        tail = group3_tail;
    } else
    if(group1_head == nullptr && group2_head != nullptr && group3_head != nullptr){
        head = group2_head;
        group2_tail->next = group3_head;
        tail = group3_tail;
    } else
    if(group1_head != nullptr && group2_head == nullptr && group3_head != nullptr){
        head = group1_head;
        group1_tail->next = group3_head;
        tail = group3_tail;
    } else
    if(group1_head != nullptr && group2_head != nullptr && group3_head == nullptr){
        head = group1_head;
        group1_tail->next = group2_head;
        tail = group2_tail;
    } else
    if(group1_head == nullptr && group2_head == nullptr && group3_head != nullptr){
        head = group3_head;
        tail = group3_tail;
    } else
    if(group1_head == nullptr && group2_head != nullptr && group3_head == nullptr){
        head = group2_head;
        tail = group2_tail;
    } else
    if(group1_head != nullptr && group2_head == nullptr && group3_head == nullptr){
        head = group1_head;
        tail = group1_tail;
    } else
    {
        head = tail = nullptr;
    }
    
}
",1.0,11111
Singly_linked_list_5,1424351,2213035,"void reduceDuplicate(Node* root) {
    Node* current = root;
    while (current != nullptr && current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* temp = current->getNext();
            current->setNext(temp->getNext());
            delete temp;
        } else {
            current = current->getNext();
        }
    }
}
",1.0,1111111111
Singly_linked_list_6,1424351,2213035,"int Train::allocate(int containerSize) {
    TrainCar* current = head->next;
    int index = 1;
    int minIndex = -1;
    int minRemainingSpace = 9999;

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize && current->remainingSpace < minRemainingSpace) {
            minRemainingSpace = current->remainingSpace;
            minIndex = index;
        }
        current = current->next;
        index++;
    }

    if (minIndex != -1) {
        TrainCar* selected = head;
        for (int i = 0; i < minIndex; i++) {
            selected = selected->next;
        }
        selected->remainingSpace -= containerSize;
    }

    return minIndex;
}

int Train::totalRemainingSpace() {
    TrainCar* current = head->next;
    int totalSpace = 0;

    while (current != nullptr) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }

    return totalSpace;
}
",1.0,11111
Singly_linked_list_7,1424351,2213035,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* tmp = new Node();
    tmp->data = e;
    if(this->count == 0)
    {
        tmp->data = e;
        this->head = this->tail =  tmp;
        this->count++;
    }
    else
    {
        tail->next = tmp;
        tail= tmp;
        this->count++;
    }
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index < 0 || index > this->count)
    {
        throw ""Index is out of range"";
    }
    if(index == count){
        return SLinkedList<T>::add(e);
    }
    if( index == 0) {
         Node* tmp = new Node();
         tmp->data = e;
         tmp->next = head;
         head = tmp;
         this->count ++;
    } else
    {
        Node* tmp = new Node();
        tmp->data = e; 
        Node *prev = head;
        for( int i = 0; i < index - 1; i++)
        {
            prev = prev->next;
        }
        tmp->next = prev->next;
        prev->next = tmp;
        this->count++;
    }
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}
",1.0,1111111111
Singly_linked_list_8,1424351,2213035,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if( index < 0 || index > this->count)
    {
         throw std::out_of_range("" Index is out of range"");
    }
    Node* tmp = head;
    for(int i = 0; i < index; i++)
    {
        tmp = tmp->next;
    }
    return tmp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if( index < 0 || index > this->count)
    {
         throw std::out_of_range("" Index is out of range"");
    }
    Node* tmp = head;
    for(int i = 0; i < index; i++)
    {
        tmp = tmp->next;
    }
    tmp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return this->count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* tmp = head;
    for(int i = 0; i < this->count; i++)
    {
        if( tmp->data == item){
            return i;
        }
        tmp = tmp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    return SLinkedList<T>::indexOf(item) != -1;
    
}",1.0,1111111111
Singly_linked_list_9,1424351,2213035,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
if(index < 0 || index > this->count) throw std::out_of_range(""Out of range"");
        if( index == 0) {
            Node* tmp = head;
            head = head->next;
            delete tmp;
            count--;
        } else 
        {
            Node* tmp = head;
            Node* temp = head;
            int i=0;
            for(; tmp != nullptr; tmp = tmp->next)
            {   if(i == index) break;
                 temp = tmp;
                 i++;
            }
            temp->next = tmp->next;
            if( tmp == tail) tail = temp; 
            int tmp1 = tmp->data;
            count--;
            delete tmp;
            return tmp1;
        }
        return 0;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(SLinkedList<T>::contains(item) == true){
        return SLinkedList<T>::removeAt(SLinkedList<T>::indexOf(item)) == item;}
        else return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* tmp = head;
    while(head != NULL)
    {
        tmp = head;
        head = head->next;
        delete tmp;
        this->count--;
    }
    head = tail = NULL;
}",1.0,1111111111
Singly_linked_list_10,1424351,2213035,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* temp2 = NULL;
    LLNode* a = NULL;
    while (head != NULL) {
        a = head;
        head = head->next;
        a->next = temp2;
        temp2 = a;
    }
    return a;
}


LLNode* foldLinkedList(LLNode* head) {
    if(head == NULL || head->next == NULL) return head;

    LLNode* curr = head, * curr2 = head->next;
    while(curr2 && curr2->next){
        curr2 = curr2->next->next;
        curr = curr->next;
    }
    bool k = curr2;
    curr2 = curr->next; 
    curr->next = NULL;
    head = reverseLinkedList(head);
    curr = head;
    if(!k){
        curr = curr->next;
    }
    while(curr && curr2){
        curr->val += curr2->val;
        curr = curr->next;
        curr2 = curr2->next;
    }
    return head;
    
}",1.0,1111111111
Singly_linked_list_11,1424351,2213035,"LLNode* replaceFirstGreater(LLNode* head) {
    if (head == nullptr) {
        return nullptr;
    }

    std::stack<LLNode*> nodeStack;
    LLNode* current = head;
    while (current != nullptr) {
        while (!nodeStack.empty() && current->val > nodeStack.top()->val) {
            nodeStack.top()->val = current->val;
            nodeStack.pop();
        }
        nodeStack.push(current);
        current = current->next;
    }
    while (!nodeStack.empty()) {
        nodeStack.top()->val = 0;
        nodeStack.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1424351,2213035,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* next = nullptr;
    
    while(current != NULL){
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    return prev;
}",1.0,1111111111
Singly_linked_list_13,1424351,2213035,"int getsize(LLNode* head){
    int i = 1;
    LLNode* currentt = head;
    while(currentt->next != NULL){
        currentt = currentt->next;
        i++;
    }
    return i;
}

LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || k == 0) {
        return head;
    }
    int n = getsize(head);
    LLNode* current = head;
    LLNode* temp = head;
    k = k%n;
    for(int i = 1; i < n-k; i++){
        current = current->next;
        // cout<<current->val;
    }
    temp = current->next;
    current->next = NULL;
    current = temp;
    while(current->next != NULL){
        current = current->next;
    }
    current->next = head;
    
    return temp;
}



// 0 null<-2-4->6->6->3
//         p cn
// 1 null<-2<-4->6->6->3
//           p  cn
// 2 null<-2<-4<-6->6->3
//               p  cn
// 3    3<-2<-4<-6<-6--3
//                  p  cn",1.0,1111111111
Singly_linked_list_14,1424351,2213035,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (low >= high || high < 0) {
        return;
    }
    if (low < 0) {
        low = 0;
    }
    if (high >= size) {
        high = size - 1;
    }

    Node* prevNode = NULL;
    Node* currentNode = head;
    for (int i = 0; i < low; i++) {
        prevNode = currentNode;
        currentNode = currentNode->next;
    }

    if (prevNode) {
        prevNode->next = linked_list->head;
    } else {
        head = linked_list->head;
    }
    Node*temp = currentNode;
    for (int i = 0; i < high-low; i++) {
        temp = temp->next;
    }

    linked_list->tail->next = temp->next;
    size = size - (high - low + 1) + linked_list->size;
}",0.8,110
Singly_linked_list_1,1424607,2211367,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode dummy(0);
    LLNode* result = &dummy;
    int carry = 0;

    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;
        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }

        carry = sum / 10;
        sum %= 10;

        result->next = new LLNode(sum);
        result = result->next;
    }

    return dummy.next;
}",1.0,111111111111111
Singly_linked_list_2,1424607,2211367,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1424607,2211367,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1424607,2211367,"void reduceDuplicate(Node* root)
{
}",0.2,0000101000
Singly_linked_list_2,1425451,2210458,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_3,1425451,2210458,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true:
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false:
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin == true)
    {
        if (pList != nullptr)
        {
            current = pList->head;
            index = 0;
        }
        else
        {
            current = nullptr;
            index = -1;
        }
    }
    else
    {
        current = nullptr;
        if (pList != nullptr)
        {
            index = pList->size();
        }
        else
        {
            index = 0;
        }
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        this->pList->removeAt(index);
        if (current == pList->head)
        {
            current = nullptr;
            index = -1;
        }
        else
        {
            Node* prev = pList->head;
            for (int i = 0; i < index - 1; i++)
            {
                prev = prev->next;
            }
            //prev->next = current->next;
            current = prev;
            index--;
        }
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current->data = e;
    }
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        return current->data;
    }
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if (current != iterator.current /*&& index != iterator.index*/)
    {
        return true;
    }
    else
    {
        return false;
    }
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else if (current->next == pList->head)
    {
        current = pList->head;
    }
    else
    {
        current = current->next;
    }
    index++;
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else if (current->next == pList->head)
    {
        current = pList->head;
    }
    else
    {
        current = current->next;
    }
    index++;
    return *this;
}
",0.9,11111
Singly_linked_list_4,1425451,2210458,"void LinkedList::partition(int k) {
    Node* groupI = NULL;
    Node* groupII = NULL;
    Node* groupIII = NULL;
    Node* lastI = NULL;
    Node* lastII = NULL;
    Node* lastIII = NULL;

    Node* current = head;
    while (current != NULL) {
        if (current->value < k) {
            if (groupI == NULL) {
                groupI = new Node(current);
                lastI = groupI;
            } else {
                lastI->next = new Node(current);
                lastI = lastI->next;
            }
        } else if (current->value == k) {
            if (groupII == NULL) {
                groupII = new Node(current);
                lastII = groupII;
            } else {
                lastII->next = new Node(current);
                lastII = lastII->next;
            }
        } else {
            if (groupIII == NULL) {
                groupIII = new Node(current);
                lastIII = groupIII;
            } else {
                lastIII->next = new Node(current);
                lastIII = lastIII->next;
            }
        }
        current = current->next;
    }

    head = lastI;
    if (lastI != NULL) {
        //lastI->next = groupII;
        head = groupII;
    } else if (groupII != NULL) {
        head = groupIII;
        //lastII->next = groupIII;
    } else {
        head = NULL;
    }

    /*if (lastII != NULL) {
        lastII->next = groupIII;
    }*/

    tail = (lastIII != NULL) ? lastIII : (lastII != NULL) ? lastII : lastI;
}",1.0,0
Singly_linked_list_5,1425451,2210458,"void reduceDuplicate(Node* root)
{
    Node* current = root;
	Node* next = nullptr;
    while (current != nullptr && current->getNext() != nullptr)
    {
        if (current->getData() == current->getNext()->getData())
        {
			next = current->getNext()->getNext();
			delete current->getNext();
			current->setNext(next);
		}
        else
        {
			current = current->getNext();
		}
	}
}",1.0,1111111111
Singly_linked_list_6,1425451,2210458,"int Train::allocate(int containerSize)
{
    TrainCar* current = this->head;
    int index = 0;
    int min = 2147483647, indexMin = 0;
    bool found = false;
    while (current != NULL) {
        if (current->remainingSpace >= containerSize && current->remainingSpace < min) {
            //current->remainingSpace -= containerSize;
            //return index;
            min = current->remainingSpace;
            indexMin = index;
            found = true;
        }
        current = current->next;
        index++;
    }
    if (!found) return -1;
    index = 0;
    current = this->head;
    while (index < indexMin)
    {
        current = current->next;
		index++;
    }
    current->remainingSpace -= containerSize;
    return indexMin;
}


int Train::totalRemainingSpace() 
{
    int totalSpace = 0;
    TrainCar* current = this->head;
    while (current != NULL) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }
    return totalSpace;
}",1.0,11111
Singly_linked_list_1,1425953,2212282,"LLNode* addLinkedList(LLNode* l1, LLNode* l2) {
    LLNode* dummy = new LLNode(), *temp = dummy, *temp1 = dummy;
        int remain=0, calculate, final;
        while(l1 || l2) {
            calculate  = (l1?l1->val:0) + (l2?l2->val:0)+remain;
            final = (calculate > 9 ? calculate-10 : calculate);
            remain     = calculate < 10 ? 0 : 1;
            
            temp->next = new LLNode(final);
            
            l1         =   l1?l1->next:NULL;
            l2         =   l2?l2->next:NULL;
            temp       =   temp->next;
        }
        if(calculate > 9) temp->next = new LLNode(1);
        dummy = dummy->next;
        delete temp1;
        return dummy;
}",1.0,111111111111111
Singly_linked_list_3,1425953,2212282,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    pList = pList;
    if(begin) {
        if(pList) {
            current = pList->head;
            index = 0;
        }
        else {
            current = NULL;
            index = -1;
        }
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    if (this != &iterator)  // Avoid self-assignment
    {
        current = iterator.current;
        index = iterator.index;
        pList = iterator.pList;
    }
    
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
        return;
    }

    Node* nodeToRemove = current;
    
    if (index == 0) {
        current = nullptr;
        index = -1;
    } else {
        Node* prevNode = pList->head;
        for (int i = 0; i < index-1; ++i) {
            prevNode = prevNode->next;
        }
        prevNode->next = current->next;
        current = prevNode;
        --index;
        //cái lồn mẹ nó bkel như cái cc đụ má đéo cho coi test cây
        //djt me may
        //cho can ngu loz
        //djtsdfasdfasdfasdfsdf
    }

    delete nodeToRemove;
}


template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }

    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }

    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return (current != iterator.current) || (index != iterator.index);
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    
    if (current == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }

    if (current->next == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }

    current = current->next;
    index++;

    return *this; 
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator temp = *this;  
    
    if (current == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }

    if (current->next == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }

    current = current->next;
    index++;

    return temp;
}",0.76,11110
Singly_linked_list_4,1425953,2212282,"void LinkedList::partition(int k) {
    LinkedList* s[3];
    LinkedList* output = new LinkedList();
    for(int i=0; i<3; i++) s[i] = new LinkedList();
    
    Node* temp = head;
    while(temp != NULL) {
        int val = temp->value;
        if(val < k)         s[0]->add(val);
        else if(val == k)   s[1]->add(val);
        else                s[2]->add(val);
        temp = temp->next;
    }
    
    for(int i=0; i<3; ++i) {
        temp = s[i]->head;
        while(temp != NULL) {
            output->add(temp->value);
            temp = temp->next;
        }
    }
    
    head = output->head;
    tail = output->tail;
}",1.0,11111
Singly_linked_list_5,1425953,2212282,"void reduceDuplicate(Node* root) {
    if(!root) return;
    Node* pretemp = root;
    Node* temp    = root->getNext();
    
    while(temp) {
        if(temp->getData() == pretemp->getData()) {
            Node* a = temp;
            temp = temp->getNext();
            pretemp->setNext(temp);
            delete a;
        }
        else {
            pretemp = temp;
            temp = temp->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1425953,2212282,"int Train::allocate(int containerSize) {
    if(size == 0) {return -1;}
    int index = 0;
    int saveIndex = 0;
    TrainCar* temp = head;
    TrainCar* output = head;
    while(temp) {
        if(temp->remainingSpace >= containerSize) {
            if(output->remainingSpace >= containerSize) {
                if(output->remainingSpace > temp->remainingSpace) {
                    output = temp;
                    saveIndex = index;
                }
            }
            else {
                output = temp;
                saveIndex = index;
            }
        }
        index++;
        temp = temp->next;
    }
    if(output->remainingSpace < containerSize) return -1;
    output->remainingSpace -= containerSize;
    return saveIndex;
}

int Train::totalRemainingSpace() {
    if(size == 0) return -1;
    TrainCar* temp = head;
    int sum = 0;
    while(temp) {
        sum += temp->remainingSpace;
        temp = temp->next;
    }
    return sum;
}",1.0,11111
Singly_linked_list_7,1425953,2212282,"template <class T>
void SLinkedList<T>::add(const T& e) {
    if(count == 0) {
        head = new Node(e, NULL);
        tail = head;
    }
    else {
        tail->next = new Node(e, NULL);
        tail = tail->next;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    if(index < 0 || index > count) return;
    
    if(index == 0) {
        if(count == 0) this->add(e);
        else {
            Node* temp = new Node(e, head);
            head = temp;
            ++count;
        }
    }
    
    else if(index == count) {
        this->add(e);   
    }
    
    else {
        Node* temp = head;
        while(index-- != 1) temp = temp->next;
        
        Node* tmp = new Node(e, temp->next);
        temp->next = tmp;
        ++count;
    }
}

template<class T>
int SLinkedList<T>::size() {
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1425953,2212282,"template<class T>
T SLinkedList<T>::get(int index) {
    Node* temp = head;
    while(index-- && temp->next) temp = temp->next;
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    Node* temp = head;
    while(index-- && temp->next) temp = temp->next;
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    return count==0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    int num = 0;
    Node* temp = head;
    while(temp) {
        if(temp->data == item) return num;
        ++num;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    Node* temp = head;
    while(temp) {
        if(temp->data == item) return 1;
        temp = temp->next;
    }
    
    return 0;
}",1.0,1111111111
Singly_linked_list_9,1425953,2212282,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    int save;
    Node* temp = head;
    
    if(index <= 0) {
        save = temp->data;
        head = head->next;
        delete temp;
    }
    else if(index >= count-1) {
        int find = count-1;
        while(--find) temp = temp->next;
        save = tail->data;
        delete tail;
        tail = temp;
    }
    else {
        while(--index) temp = temp->next;
        Node* tmp = temp->next;
        save = tmp->data;
        temp->next = tmp->next;
        delete tmp;
    }
    
    --count;
    return save;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    int index = 0;
    Node* temp = head;
    while(temp) {
        if(temp->data == item) {
            removeAt(index);
            return 1;
        }
        temp = temp->next;
        ++index;
    }
    return 0;
}

template<class T>
void SLinkedList<T>::clear(){
    int index = 0;
    while(index < count) removeAt(index++);
    
    head = NULL;
    tail = NULL;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1425953,2212282,"LLNode* foldLinkedList(LLNode* head) {
    if(!head) return NULL;
    
    int count = 0, i = 0;
    for(LLNode* temp = head; temp; temp=temp->next) count++;
    
    int* arr = new int[count];
    for(LLNode* temp = head; temp; temp=temp->next) {
        arr[i++] = temp->val;
    }
    
    int left  = 0;
    int right = count-1;
    LLNode* output = new LLNode(arr[left++]+arr[right--], NULL);
    
    while(left <= right) {
        int mid = left==right ? arr[left] : arr[left] + arr[right];
        output = new LLNode(mid, output);
        left++; right--;
    }
    
    return output;
}",1.0,1111111111
Singly_linked_list_11,1425953,2212282,"LLNode* replaceFirstGreater(LLNode* head) {
    
    for(LLNode* temp = head; temp; temp = temp->next) {
        bool found = 0;
        for(LLNode* tmp = temp; tmp; tmp = tmp->next) {
            if(temp->val < tmp->val) {
                temp->val = tmp->val;
                found = 1;
                break;
            }
        }
        if(!found) temp->val = 0;
    }
    
    return head;
}",1.0,1111111111
Singly_linked_list_12,1425953,2212282,"void delete_and_move(LLNode* &head) {
    LLNode* tmp = head;
    head = head->next;
    delete tmp;
}

LLNode* reverseLinkedList(LLNode* head) {
    if(!head) return NULL;
    
    LLNode* temp = new LLNode(head->val, NULL);
    delete_and_move(head);
    
    while(head) {
        LLNode* newTemp = new LLNode(head->val, temp);
        temp = newTemp;
        delete_and_move(head);
    }
    
    return temp;
}",1.0,1111111111
Singly_linked_list_13,1425953,2212282,"LLNode* generate(LLNode* head, int k) {
    if(k==0) return head;
    if(head) {
        LLNode** temp  = &head;
        while((*temp)->next) temp = &((*temp)->next);
        head = new LLNode((*temp)->val, head);
        delete *temp;
        *temp = NULL;
        return generate(head, k-1);
    }
    else return head;
}  

LLNode* rotateLinkedList(LLNode* head, int k) {
    int count = 0;
    for(LLNode* temp = head; temp; temp = temp->next) ++count;
    return generate(head,count==0?count:k%count);
}

",1.0,1111111111
Singly_linked_list_14,1425953,2212282,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if(low <= 0)     low = 0;
    if(low > high)   return;
    if(high >= size) high = size-1;
    
    LinkedList* l1 = new LinkedList();
    Node* s2 = head;
    Node* s3 = linked_list->head;
    
    int index = 0;
    
    while(s2 || s3) {
        if(index < low) {
            l1->add(s2->value);
            s2 = s2->next;
            index++;
        }
        else if(index > high) {
            l1->add(s2->value);
            s2 = s2->next;
            index++;
        }
        else {
            if(s3) {
                l1->add(s3->value);
                s3 = s3->next;
            }
            else {
                for(;index<=high;++index) s2 = s2->next;
            }
        }
    }
    
    head = l1->head;
    tail = l1->tail;
    size = l1->size;
}",1.0,11111
Singly_linked_list_1,1426368,2210578,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
     LLNode* dummy = new LLNode(0);
    LLNode* curr = dummy;
    int carry = 0;
    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;
        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        curr->next = new LLNode(sum % 10);
        carry = sum / 10;
        curr = curr->next;
    }
    return dummy->next;
}",1.0,111111111111111
Singly_linked_list_2,1426368,2210578,"void Polynomial::insertTerm(const Term& term) {
    if (term.coeff == 0.0) return; // Ignore zero coefficients

    SLinkedList<Term>::Iterator it;
    int i = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++, i++) {
        if ((*it).exp < term.exp) {
            this->terms->add(i, term);
            return;
        }
        else if ((*it).exp == term.exp) {
            (*it).coeff += term.coeff;
            if ((*it).coeff == 0.0) {
                this->terms->removeAt(i);
            }
            return;
        }
    }

    this->terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    insertTerm(Term(coeff, exp));
}
",1.0,11111
Singly_linked_list_3,1426368,2210578,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */this->pList = pList;
    if (begin && pList != NULL) {
        this->current = pList->head;
        this->index = 0;
    } else {
        this->current = NULL;
        this->index = pList == NULL ? 0 : pList->size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */ this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    current = current->next;
    pList->removeAt(index);
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */ if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */ if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */ if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    return current->data;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */ if (current == NULL || current->next == NULL) throw std::out_of_range(""Segmentation fault!"");
    current = current->next;
    index++;
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */ Iterator iterator = *this;
    ++*this;
    return iterator;
}",0.8,11110
Singly_linked_list_4,1426368,2210578,"void LinkedList::partition(int k) {
     Node* smallerHead = NULL;
    Node* smallerLast = NULL;
    Node* equalHead = NULL;
    Node* equalLast = NULL;
    Node* greaterHead = NULL;
    Node* greaterLast = NULL;

    Node* current = head;
    while (current != NULL) {
        Node* nextNode = current->next;
        current->next = NULL;
        if (current->value < k) {
            if (smallerHead == NULL) {
                smallerHead = smallerLast = current;
            } else {
                smallerLast->next = current;
                smallerLast = current;
            }
        } else if (current->value == k) {
            if (equalHead == NULL) {
                equalHead = equalLast = current;
            } else {
                equalLast->next = current;
                equalLast = current;
            }
        } else {
            if (greaterHead == NULL) {
                greaterHead = greaterLast = current;
            } else {
                greaterLast->next = current;
                greaterLast = current;
            }
        }
        current = nextNode;
    }

    if (smallerHead == NULL) {
        if (equalHead == NULL) {
            head = greaterHead;
        } else {
            equalLast->next = greaterHead;
            head = equalHead;
        }
    } else {
        if (equalHead == NULL) {
            smallerLast->next = greaterHead;
        } else {
            smallerLast->next = equalHead;
            equalLast->next = greaterHead;
        }
        head = smallerHead;
    }
}",0.8,10111
Singly_linked_list_5,1426368,2210578,"void reduceDuplicate(Node* root)
{
    if (root == nullptr || root->getNext() == nullptr) {
        return;
    }

    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* nextNext = current->getNext()->getNext();
            delete current->getNext();
            current->setNext(nextNext);
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1426368,2210578,"int Train::allocate(int containerSize) {
TrainCar* current = this->head->next;
    TrainCar* minSpaceCar = nullptr;
    int index = 1;
    int minIndex = -1;

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize) {
            if (minSpaceCar == nullptr || current->remainingSpace < minSpaceCar->remainingSpace) {
                minSpaceCar = current;
                minIndex = index;
            }
        }
        current = current->next;
        index++;
    }

    if (minSpaceCar == nullptr) {
        return -1;
} minSpaceCar->remainingSpace -= containerSize;

    return minIndex;
}
int Train::totalRemainingSpace() {
int totalSpace = 0;
    TrainCar* current = this->head->next;

    while (current != nullptr) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }

    return totalSpace;
}",1.0,11111
Singly_linked_list_7,1426368,2210578,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if (count == 0) {
        head = tail = newNode;
    } else {
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        index= count;
    }
    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head = newNode;
        if (tail == NULL) {
            tail = newNode;
        }
    } else {
        Node* prev = head;
        for (int i = 0; i < index - 1; i++) {
            prev = prev->next;
        }
        newNode->next = prev->next;
        prev->next = newNode;
        if (newNode->next == NULL) {
            tail = newNode;
        }
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1426368,2210578,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count)
        index=count;
    Node* temp = head;
    for (int i = 0; i < index; i++)
        temp = temp->next;
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count)
        throw std::out_of_range(NULL);
    Node* temp = head;
    for (int i = 0; i < index; i++)
        temp = temp->next;
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
     Node* temp = head;
    int index = 0;
    while (temp != NULL) {
        if (temp->data == item)
            return index;
        temp = temp->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
     return indexOf(item) != -1;
}",0.8,111111110
Singly_linked_list_9,1426368,2210578,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
     if (index < 0 || index >= count)
       index=count;
    Node* temp = head;
    Node* prev = NULL;
    for (int i = 0; i < index; i++) {
        prev = temp;
        temp = temp->next;
    }
    T data = temp->data;
    if (prev == NULL) {
        head = temp->next;
    } else {
        prev->next = temp->next;
    }
    if (temp == tail) {
        tail = prev;
    }
    delete temp;
    count--;
    return data;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
     Node* temp = head;
    Node* prev = NULL;
    while (temp != NULL) {
        if (temp->data == item) {
            if (prev == NULL) {
                head = temp->next;
            } else {
                prev->next = temp->next;
            }
            if (temp == tail) {
                tail = prev;
            }
            delete temp;
            count--;
            return true;
        }
        prev = temp;
        temp = temp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != NULL) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    tail = NULL;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1426368,2210578,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* curr = head;
    while (curr != nullptr) {
        LLNode* nextTemp = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}

LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    // Find the middle of the linked list
    LLNode* slow = head;
    LLNode* fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // Reverse the second half of the linked list
    LLNode* secondHalfHead = reverseLinkedList(slow);
    LLNode* firstHalfHead = head;

    // Merge the two halves by adding the corresponding values
    while (secondHalfHead != nullptr) {
        firstHalfHead->val += secondHalfHead->val;
        if (firstHalfHead->next == nullptr || firstHalfHead->next == secondHalfHead) {
            firstHalfHead->next = secondHalfHead->next;
            break;
        }
        firstHalfHead = firstHalfHead->next;
        secondHalfHead = secondHalfHead->next;
    }

    return head;
}
",0.1,0010000000
Singly_linked_list_11,1426368,2210578,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
   stack<LLNode*> nodeStack;
    LLNode* temp = head;
    while (temp != nullptr) {
        while (!nodeStack.empty() && nodeStack.top()->val < temp->val) {
            nodeStack.top()->val = temp->val;
            nodeStack.pop();
        }
        nodeStack.push(temp);
        temp = temp->next;
    }
    while (!nodeStack.empty()) {
        nodeStack.top()->val = 0;
        nodeStack.pop();
    }
    return head;}",1.0,1111111111
Singly_linked_list_12,1426368,2210578,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* next = nullptr;
    while (current != nullptr) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    head = prev;
    return head;
}",1.0,1111111111
Singly_linked_list_13,1426368,2210578,"LLNode* rotateLinkedList(LLNode* head, int k) {
   if (head == nullptr || head->next == nullptr || k == 0) {
        return head;
    }
    
    LLNode* temp = head;
    int length = 1;
    while (temp->next != nullptr) {
        temp = temp->next;
        length++;
    }
    
    temp->next = head;
    
    k = k % length; 
    k = length - k; 
    while (k--) {
        temp = temp->next;
    }
    
    head = temp->next;
    temp->next = nullptr;
    
    return head;
}",1.0,1111111111
Singly_linked_list_14,1426368,2210578,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    Node* prev = NULL;
    Node* current = this->head;
    int count = 0;

    while (current != NULL && count < low) {
        prev = current;
        current = current->next;
        count++;
    }

    if (low < 0) {
        current = this->head;
        prev = NULL;
    }

    while (current != NULL && count <= high) {
        Node* nextNode = current->next;
        delete current;
        current = nextNode;
        count++;
        size--;
    }

    if (prev == NULL || low <= 0) {
        this->head = linked_list->head;
    } else {
        prev->next = linked_list->head;
    }

    linked_list->tail->next = current;
    if (current == NULL) {
        this->tail = linked_list->tail;
    }
    this->size += linked_list->size;

}",1.0,11111
Singly_linked_list_1,1426504,2212372,"
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
 LLNode *l;
 int t=0;
 int a[100000];
 int i=0;
 while(l0||l1){
 if(!l0){a[i]=(t+l1->val)%10;
 t=(t+l1->val)/10;
l1=l1->next;
 }
 else  if(!l1){a[i]=(t+l0->val)%10;
 t=(t+l0->val)/10;
 l0=l0->next;
 }else{a[i]=(t+l0->val+l1->val)%10;
 t=(t+l0->val+l1->val)/10;
 l0=l0->next;
 l1=l1->next;
 }
 i++;
 }
 if(t==1){a[i]=1;
 i++;
 }
 int arr[i];
 for(int j=0;j<i;j++){
     arr[j]=a[j];
 }
l=LLNode::createWithIterators(arr, arr + sizeof(arr) / sizeof(int));
  return l;

}",1.0,111111111111111
Singly_linked_list_2,1426504,2212372,"void Polynomial::insertTerm(const Term& term) {
if(term.exp < 0 ||  term.coeff == 0) return;
     SLinkedList<Term>::Iterator it;
     int i = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == term.exp){
            t.coeff += term.coeff;
            if(t.coeff != 0) it.set(t);
            else it.remove();
            return;
        }
        else if(t.exp < term.exp){
            break;
        }
        i++;
    }
    this->terms->add(i,term);}

void Polynomial::insertTerm(double coeff, int exp) {
  if(exp < 0 ||coeff ==0) return;
     SLinkedList<Term>::Iterator it;
     int i = 0;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        Term t = *it;
        if(t.exp == exp){  
            t.coeff += coeff; 
            if(t.coeff != 0.0000000f) it.set(t);  
            else it.remove();  
            return;
        }
        else if(t.exp < exp){
            break; 
        }
        i++;
    }
    Term t(coeff,exp);
    this->terms->add(i,t); 
}",1.0,11111
Singly_linked_list_3,1426504,2212372,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true:
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false:
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin) {
        if (pList != NULL) {
            current = pList->head;
            index = 0;
        }
        else {
            current = NULL;
            index = -1;
        }
    }
    else {
        current = NULL;
        if (pList != NULL) {
            index = pList->size();
        }
        else {
            index = 0;
        }
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove, current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current != NULL) {
        Node* A = pList->head;
        if (A == pList->head) {
            current = NULL;
            index = -1;
        }
        while (A->next !=curent) {
           A->next = current->next;
            delete current;
            current = A;
            A = A->next;
        }

    }
    else {
        throw std::out_of_range(""Segmentation fault!"");
    }
}


template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else {
        current->data = e;
    }
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else {
        return current->data;
    }
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if (iterator.current == this->current && iterator.index == this->index) {
        return false;
    }
    return true;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
 if (current != NULL) {
        Node* A = pList->head;
        while (A->next != current) {
            A = A->next;
        }

        if (A == pList->head) {
            current = NULL;
            index = -1;
        }
        else {
            A->next = current->next;
            delete current;
            current = A;
        }
    }
    else {
        throw std::out_of_range(""Segmentation fault!"");
    }
}

// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else {
        Iterator temp(*this);
        current = current->next;
        if (current == NULL && pList != NULL) {
            index = pList->size();
        }
        return temp;
    }
}

",0.8,
Singly_linked_list_4,1426504,2212372,"void LinkedList::partition(int k) {
    if (size < 2) { return; }
    Node* I = new Node(-1);
    Node* VetI = I;
    Node* II = new Node(-1);
    Node* VetII = II;
    Node* III = new Node(-1);
    Node* VetIII = III;
    Node* travel = head;

    /*Vong lap phan loai*/
    for (int i = 0; i < this->size; i++) {
        /*Lay con tro travel de cuoi vong lap xoa di*/
        Node* deletetemp = travel;

        Node* connect = new Node(travel->value);
        connect->next = nullptr; // Initialize the next pointer

        if (travel->value < k) {
            I->next = connect;
            I = I->next;
        }
        else if (travel->value == k) {
            II->next = connect;
            II = II->next;
        }
        else {
            III->next = connect;
            III = III->next;
        }
        travel = travel->next;
        /*da xoa con tro travel cu*/
        delete deletetemp; // Use delete instead of delete[]
    }

    /*Connected 3 doan*/

    if (VetI->next != nullptr) {
        if (VetII->next != nullptr) {
            if (VetIII->next != nullptr) {
                I->next = VetII->next;
                II->next = VetIII->next;
                head = VetI->next;
                tail = III;
            }
            else {
                I->next = VetII->next;
                head = VetI->next;
                tail = II;
            }
        }
        else {
            if (VetIII->next != nullptr) {
                I->next = VetIII->next;
                head = VetI->next;
                tail = III;
            }
            else {
                head = VetI->next;
                tail = I;
            }
        }
    }
    else {
        if (VetII->next != nullptr) {
            if (VetIII->next != nullptr) {
                II->next = VetIII->next;
                head = VetII->next;
                tail = III;
            }
            else {
                head = VetII->next;
                tail = II;
            }
        }
        else {
            if (VetIII->next != nullptr) {
                head = VetIII->next;
                tail = III;
            }
            else {
                head = nullptr;
                tail = nullptr;
            }
        }
    }
    delete VetI;
    delete VetII;
    delete VetIII;
}
",1.0,11111
Singly_linked_list_5,1426504,2212372,"void reduceDuplicate(Node* root)
{
    if(root == nullptr || root->getNext() == nullptr)
        return;
    Node* temp = root;
    while(temp)
    {
        while(temp && temp->getData() == root->getData())
            temp = temp->getNext();
        root->setNext(temp);
        root = temp;
    }
    
}",1.0,1111111111
Singly_linked_list_6,1426504,2212372,"int Train::allocate(int containerSize) {
    TrainCar* current = head->next;
    int index = 1;
    int minIndex = -1;
    int minRemainingSpace = 9999;

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize && current->remainingSpace < minRemainingSpace) {
            minRemainingSpace = current->remainingSpace;
            minIndex = index;
        }
        current = current->next;
        index++;
    }

    if (minIndex != -1) {
        TrainCar* selected = head;
        for (int i = 0; i < minIndex; i++) {
            selected = selected->next;
        }
        selected->remainingSpace -= containerSize;
    }

    return minIndex;
}

int Train::totalRemainingSpace() {
    TrainCar* current = head->next;
    int totalSpace = 0;

    while (current != nullptr) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }

    return totalSpace;
}
",1.0,11111
Singly_linked_list_7,1426504,2212372,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */

    Node* temp = new Node(e, NULL);
    if (count == 0) {
        head = temp;
        tail = temp;
    }
    else {
        tail->next = temp;
        tail = tail->next;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    Node* temp = new Node(e, NULL);
    if (index == 0) {
        if (count == 0) {
            head = temp;
            tail = temp;
        }
        else {
            temp->next = head;
            head = temp;
        }

        count++;
    }
    else if (index == count) {
        add(e);
    }
    else {
        Node* cur = head;
        Node* pre = NULL;
        for (int i = 0; i < index; i++) {
            pre = cur;
            cur = cur->next;
        }
        pre->next = temp;
        temp->next = cur;

        count++;
    }
}
template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1426504,2212372,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index<0 || index>count) {
        throw std::out_of_range(""out of range"");
    }
    else {
        Node* temp = head;
        for (int i = 0; i < index; i++) {
            temp = temp->next;
        }
        return temp->data;
    }
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index<0 || index>count) {

        throw std::out_of_range(""out of range"");
    }
    else {
        Node* temp = head;
        for (int i = 0; i < index; i++) {
            temp = temp->next;
        }
        temp->data = e;
    }
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !count;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    for (int i = 0; i < count; i++) {
        if (temp->data == item) {
            return i;
        }
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* temp = head;
    for (int i = 0; i < count; i++) {
        if (temp->data == item) {
            return true;
        }
        temp = temp->next;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1426504,2212372,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    if (index<0 || index>count) {
        throw std::out_of_range(""out of range"");
    }
    else {
        T a = 0;
        if (index == 0) {
            a = head->data;
            if (count == 0) {
                head = NULL;
                tail = NULL;
                count = 0;
            }
            else {
                head = head->next;
                if (count == 1) { tail = NULL; }
                count--;
            }
        }
        else {
            Node* pre = NULL;
            Node* temp = head;
            for (int i = 0; i < index; i++) {
                pre = temp;
                temp = temp->next;
            }
            a = temp->data;
            pre->next = temp->next;
            if (index == count - 1) {
                tail = pre;
            }
            delete[] temp;
            count--;
        }
        return a;
    }
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* temp = head;
    for (int i = 0; i < count; i++) {
        if (temp->data == item) {
            removeAt(i);
            return true;
        }
        temp = temp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear() {
    /* Remove all elements in list */
    while (head != NULL) {

        Node* temp = head;
        head = head->next;
        delete temp;
    }
    count = 0;
    head = NULL;
    tail = NULL;
}
",1.0,1111111111
Singly_linked_list_10,1426504,2212372,"
    LLNode* reverseLinkedList(LLNode* head) {
    LLNode* temp2 = NULL;
    LLNode* a = NULL;
    while (head != NULL) {
        a = head;
        head = head->next;
        a->next = temp2;
        temp2 = a;
    }
    return a;
}


LLNode* foldLinkedList(LLNode* head) {
    if(head == NULL || head->next == NULL) return head;

    LLNode* curr = head, * curr2 = head->next;
    while(curr2 && curr2->next){
        curr2 = curr2->next->next;
        curr = curr->next;
    }
    bool k = curr2;
    curr2 = curr->next; 
    curr->next = NULL;
    head = reverseLinkedList(head);
    curr = head;
    if(!k){
        curr = curr->next;
    }
    while(curr && curr2){
        curr->val += curr2->val;
        curr = curr->next;
        curr2 = curr2->next;
    }
    return head;
    
}",1.0,1111111111
Singly_linked_list_11,1426504,2212372,"LLNode* replaceFirstGreater(LLNode* head) {
stack<LLNode*> stk;
    LLNode* node = head;
    while (node != nullptr) {
        while (!stk.empty() && stk.top()->val < node->val) {
            stk.top()->val = node->val;
            stk.pop();
        }

        stk.push(node);
        node = node->next;
    }
    while (!stk.empty()) {
        stk.top()->val = 0;
        stk.pop();
    }

    return head;}",1.0,1111111111
Singly_linked_list_12,1426504,2212372,"
    LLNode* reverseLinkedList(LLNode* head) {
    LLNode* temp2 = NULL;
    LLNode* a = NULL;
    while (head != NULL) {
        a = head;
        head = head->next;
        a->next = temp2;
        temp2 = a;
    }
    return a;
}
",1.0,1111111111
Singly_linked_list_13,1426504,2212372,"int countSingle(LLNode* head) {
    LLNode* temp = head;
    int i = 0;
    while (temp != NULL) {
        i++;
        temp = temp->next;
    }
    return i;
}
LLNode* rotateLinkedList(LLNode* head, int k) {
    int n = countSingle(head);
    if (n == 0 || n == 1) {
        return head;
    }
    k = k % n;
    if (k % n == 0) {
        return head;
    }
    LLNode* pre = NULL;
    LLNode* cur = head;
    for (int i = 0; i < n - k; i++) {
        pre = cur;
        cur = cur->next;
    }
    pre->next = NULL;
    LLNode* headresult = cur;
    while (cur->next != NULL) {
        cur = cur->next;
    }
    cur->next = head;
    return headresult;


}",1.0,1111111111
Singly_linked_list_14,1426504,2212372,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (low >= high || high < 0) {
        return;
    }
    if (low < 0) {
        low = 0;
    }
    if (high >= size) {
        high = size - 1;
    }

    Node* prevNode = NULL;
    Node* currentNode = head;
    for (int i = 0; i < low; i++) {
        prevNode = currentNode;
        currentNode = currentNode->next;
    }

    if (prevNode) {
        prevNode->next = linked_list->head;
    } else {
        head = linked_list->head;
    }
    Node*temp = currentNode;
    for (int i = 0; i < high-low; i++) {
        temp = temp->next;
    }

    linked_list->tail->next = temp->next;
    size = size - (high - low + 1) + linked_list->size;
}",0.4,110
Singly_linked_list_1,1426525,2013048,"LLNode* addLinkedList(LLNode* l0, LLNode* l1){
    vector<int> List;
    LLNode* lt0 = l0;
    LLNode* lt1 = l1;
    int sum = 0, remain = 0;
    for(lt0 = l0, lt1 = l1; lt0 != NULL || lt1 != NULL || remain;){
            if(lt0 != NULL && lt1 != NULL){
                sum = lt0->val + lt1->val + remain;
                lt0 = lt0->next;
                lt1 = lt1->next;
            }else if (lt0 == NULL && lt1 != NULL){
                sum = lt1->val + remain;
                lt1 = lt1->next;
            }else if (lt1 == NULL && lt0 != NULL){
                sum = lt0->val + remain;
                lt0 = lt0->next;
            }
            else{
                sum = remain;
            }
            List.push_back(sum%10);
            remain = (sum >= 10)? 1 : 0;
    }
    int N = List.size();
    int* arrNum = new int[N];
    for(int i = 0; i < N; i++) arrNum[i] = List[i];
    return LLNode::createWithIterators(arrNum, arrNum + N); 
};",1.0,111111111111111
Singly_linked_list_2,1426525,2013048,"    void Polynomial::insertTerm(const Term& term){
        if(!term.coeff) return;
        int S = this->terms->size();
        if(S == 0){
            this->terms->add(0, term);
            return;
        }
        int index = 0, indexToInsert = -1, isSameEx = 0;
        while(index < S){
            if(term.exp >= this->terms->get(index).exp){
                indexToInsert = index;
                isSameEx = (term.exp == this->terms->get(index).exp) ? 1 : 0;
                break;
            }
            index++;
        }
        if(indexToInsert == -1){
            this->terms->add(S, term);
        }else{
            if(isSameEx){
                int newCo = term.coeff + this->terms->get(indexToInsert).coeff;
                Term temp(newCo, term.exp);
                if(newCo){
                    this->terms->set(indexToInsert, temp);
                }else{
                    this->terms->removeAt(indexToInsert);
                }
            }else{
                this->terms->add(indexToInsert, term);
            }
        }
    }
    void Polynomial::insertTerm(double coeff, int exp){
        Term term(coeff, exp);
        insertTerm(term);
    }",1.0,11111
Singly_linked_list_3,1426525,2013048,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    this->pList = pList;
    if (begin) {
        if(pList) {
            current = pList->head;
            index = 0;
        }else{
            pList = NULL;
            index = -1;
        }
    } else {
        current = nullptr;
        index = pList->count;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator){
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove(){
    if (current == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }
    if (index == 0) {
        pList->head = current->next;
    } else {
        Node* prev = pList->head;
        for (int i = 0; i < index - 1; i++) {
            prev = prev->next;
        }
        prev->next = current->next;
    }
    delete current;
    if (index == 0) {
        current = nullptr;
        index = -1;
    } else {
        current = pList->head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        index--;
    }
    pList->count--;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e){
    if (current) {
        current->data = e;
    }
}

template <class T>
T& SLinkedList<T>::Iterator::operator*(){
    if (current != NULL) {
            return current->data;
    }
    else{
        throw std::out_of_range(""Segmentation fault!"");
    }
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator){
    return this->current != iterator.current;
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++(){
    if (current) {
        current = current->next;
        index++;
    }
    return *this;
}

template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,11111
Singly_linked_list_4,1426525,2013048,"void LinkedList::partition(int k) {
    Node *start[3] = {nullptr, nullptr, nullptr};
    Node *end[3] = {nullptr, nullptr, nullptr};
    Node* current = head;
    while (current != nullptr) {
        Node* next = current->next;
        current->next = nullptr;
        int i = (current->value < k) ? 0 : ((current->value == k) ? 1 : 2);
        if (end[i] == nullptr) {
            start[i] = end[i] = current;
        } else {
            end[i]->next = current;
            end[i] = current;
        }
        current = next;
    }
    if (start[0] != nullptr) {
        head = start[0];
        tail = end[0];
        if (start[1] != nullptr) {
            tail->next = start[1];
            tail = end[1];
            if (start[2] != nullptr) {
                tail->next = start[2];
                tail = end[2];
            }
        } else if (start[2] != nullptr) {
            tail->next = start[2];
            tail = end[2];
        }
    } else if (start[1] != nullptr) {
        head = start[1];
        tail = end[1];
        if (start[2] != nullptr) {
            tail->next = start[2];
            tail = end[2];
        }
    } else if (start[2] != nullptr) {
        head = start[2];
        tail = end[2];
    }
}",1.0,11111
Singly_linked_list_5,1426525,2013048,"void reduceDuplicate(Node* root)
{
    if (root == nullptr || root->getNext() == nullptr) {
        // Danh sách rỗng hoặc chỉ có một phần tử, không cần giảm duplicate.
        return;
    }

    Node* current = root;

    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            // Phát hiện phần tử trùng lặp, loại bỏ phần tử tiếp theo.
            Node* duplicate = current->getNext();
            current->setNext(duplicate->getNext());
            delete duplicate;
        } else {
            // Chuyển sang phần tử tiếp theo trong danh sách.
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1426525,2013048,"#include <climits>
int Train::allocate(int containerSize) {
    TrainCar* current = head->next;
    int index = 1;
    int smallestIndex = -1;
    int smallestRemainingSpace = INT_MAX;

    // Find the first train car that can accommodate the container.
    while (current != nullptr) {
        if (current->remainingSpace >= containerSize) {
            // If the current train car can accommodate the container.
            if (current->remainingSpace - containerSize < smallestRemainingSpace) {
                smallestRemainingSpace = current->remainingSpace - containerSize;
                smallestIndex = index;
            }
        }
        current = current->next;
        index++;
    }

    if (smallestIndex != -1) {
        // If a suitable train car is found.
        TrainCar* selectedCar = head;
        for (int i = 1; i < smallestIndex; i++) {
            selectedCar = selectedCar->next;
        }
        selectedCar->next->remainingSpace -= containerSize;
    }

    return smallestIndex;
}

int Train::totalRemainingSpace() {
    TrainCar* current = head->next;
    int totalRemaining = 0;

    while (current != nullptr) {
        totalRemaining += current->remainingSpace;
        current = current->next;
    }

    return totalRemaining;
}",1.0,11111
Singly_linked_list_7,1426525,2013048,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    add(this->count, e);
}

template<class T>
void SLinkedList<T>::add(int index, const T &e) {
    /* Insert an element into the list at given index. */ 
    if(index < 0 || index > this->count){
        return;
    }
    if(index == 0){
        Node *temp = new Node(e, this->head);
        this->head = temp;
        this->tail = (!this->count) ? temp : tail;
    }else{
        Node *p = this->head;
        for(int i = 0; i < index - 1; i++){
            p = p->next;
        }
        Node *temp = new Node(e, p->next);
        p->next = temp;
        tail = (index == this->count) ? temp : tail;
    }
    this->count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}",1.0,1111111111
Singly_linked_list_8,1426525,2013048,"template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;   
}


template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        return T(); 
    }
    int i = 0;
    Node* ptr = this->head;
    while(i != index && ptr != NULL){
        ptr = ptr->next;
        i++;
    }
    return ptr->data;    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        return; 
    }
    int i = 0;
    Node* ptr = this->head;
    while(i != index && ptr != NULL){
        ptr = ptr->next;
        i++;
    }
    ptr->data = e;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int i = 0;
    Node* ptr = this->head;
    while(ptr != NULL){
        if(item == ptr->data)
            return i;
        ptr = ptr->next;
        i++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (indexOf(item) != -1)? true : false;
}",1.0,1111111111
Singly_linked_list_9,1426525,2013048,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        return T();
    }
    T removedValue;
    if (index == 0) {
        // Removing the first node
        Node* removedNode = head;
        head = head->next;
        removedValue = removedNode->data;
        delete removedNode;
        if (count == 1) {
            tail = nullptr;
        }
    } else {
        // Removing a node at a specific index
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        Node* removedNode = current->next;
        current->next = removedNode->next;
        removedValue = removedNode->data;
        delete removedNode;
        if (index == count - 1) {
            tail = current;
        }
    }
    count--;
    return removedValue; 
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int index = indexOf(item);
    if (index != -1){
        removeAt(index);
    }else{
        return false;
    }
    return true;
    
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (this->head != nullptr) {
        Node* temp = this->head;
        this->head = this->head->next;
        delete temp;
    }
    this->tail = nullptr;
    this->count = 0;
}",1.0,1111111111
Singly_linked_list_10,1426525,2013048,"LLNode* foldLinkedList(LLNode *head){
        int size = 0;
        for( LLNode* p0 = head; p0 != NULL; p0 = p0->next){
            size++;
        }
        int arr2[size], i = 0, s = (size+1)/2, arr3[s];
        for( LLNode* p0 = head; p0 != NULL; p0 = p0->next, i++){
            arr2[i] = p0->val;
        }
        for(i = 0; i < size/2; i++){
            arr3[i] = arr2[i] + arr2[size-i-1];
        }   
        if(size%2 == 1){
            arr3[s -1] = arr2[size/2];        
        }
        for(i = 0; i < s/2; i++){
            int temp = arr3[i];
            arr3[i] = arr3[s-i-1];
            arr3[s-i-1] = temp;
        } 
        LLNode* result = LLNode::createWithIterators(arr3, arr3 + sizeof(arr3) / sizeof(int));  
        return result;
}",1.0,1111111111
Singly_linked_list_11,1426525,2013048,"LLNode* replaceFirstGreater(LLNode* head) {
  stack<LLNode*> s;
  LLNode* current = head;
  
  // Traverse the linked list
  while (current != nullptr) {
    
    // Check if the current node's value is greater than the top element in the stack
    while (!s.empty() && current->val > s.top()->val) {
      s.top()->val = current->val;
      s.pop();
    }
    
    // Push the current node to the stack
    s.push(current);
    
    // Move to the next node
    current = current->next;
  }
  
  // Set the value of remaining nodes in the stack to 0
  while (!s.empty()) {
    s.top()->val = 0;
    s.pop();
  }
  
  return head;
}",1.0,1111111111
Singly_linked_list_12,1426525,2013048,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
        LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* nextNode = nullptr;

    while (current != nullptr) {
        nextNode = current->next;
        current->next = prev;
        prev = current;
        current = nextNode;
    }

    return prev; // 'prev' is the new head of the reversed list
}",1.0,1111111111
Singly_linked_list_13,1426525,2013048,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
     if (!head || k <= 0) {
        return head; // Nothing to rotate for an empty list or non-positive k
    }

    // Find the length of the linked list
    int length = 0;
    LLNode* current = head;
    while (current) {
        length++;
        current = current->next;
    }

    // Calculate the effective rotation
    int effectiveRotation = k % length;
    if (effectiveRotation == 0) {
        return head; // No actual rotation needed
    }

    // Find the (length - effectiveRotation)th node
    current = head;
    for (int i = 1; i < length - effectiveRotation; i++) {
        current = current->next;
    }

    // Update the pointers to rotate the linked list
    LLNode* newHead = current->next;
    current->next = nullptr;
    current = newHead;
    while (current->next) {
        current = current->next;
    }
    current->next = head;

    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1426525,2013048,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    // Xử lý các trường hợp đặc biệt
    if (linked_list == NULL || low > high) {
        return;
    }

    // Xóa các phần tử từ low đến high trong danh sách liên kết hiện tại
    Node* current = head;
    Node* prev = NULL;

    for (int i = 0; i < low && current != NULL; ++i) {
        prev = current;
        current = current->next;
    }

    for (int i = low; i <= high && current != NULL; ++i) {
        Node* nextNode = current->next;
        delete current;
        current = nextNode;
        size--;
    }

    // Nếu low là âm, đặt head là head của linked_list
    if (low < 0) {
        head = linked_list->head;
    }
    // Ngược lại, thêm linked_list sau vị trí (low - 1)
    else {
        if (prev != NULL) {
            prev->next = linked_list->head;
        }
    }

    // Nếu high lớn hơn hoặc bằng size, đặt tail là tail của linked_list
    if (high >= size || current == NULL) {
        tail = linked_list->tail;
    }

    // Cập nhật kích thước
    size += linked_list->size;

    // Xóa linked_list
    linked_list->head = linked_list->tail = NULL;
    linked_list->size = 0;
}",0.2,00100
Singly_linked_list_5,1426682,2211170,"void reduceDuplicate(Node* root)
 {
    if (root == nullptr)
        return;

    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicate = current->getNext();
            current->setNext(duplicate->getNext());
            delete duplicate;
        } else {
            current = current->getNext();
        }
    }
}
",1.0,1111111111
Singly_linked_list_6,1426682,2211170,"
int Train::allocate(int containerSize) {
    TrainCar* current = head->next;
    int index = 1;
    int minIndex = -1;
    int minRemainingSpace = 1000000; // A large enough value as a placeholder

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize && current->remainingSpace < minRemainingSpace) {
            minIndex = index;
            minRemainingSpace = current->remainingSpace;
        }
        current = current->next;
        index++;
    }

    if (minIndex != -1) {
        current = head->next;
        for (int i = 1; i < minIndex; i++) {
            current = current->next;
        }
        current->remainingSpace -= containerSize;
    }

    return minIndex;
}

int Train::totalRemainingSpace() {
    int sum = 0;
    TrainCar* current = head->next;

    while (current != nullptr) {
        sum += current->remainingSpace;
        current = current->next;
    }

    return sum;
}
",1.0,11111
Singly_linked_list_7,1426682,2211170,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
        Node* newNode = new Node(e, nullptr);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
        if (index < 0 || index > count) {
        throw out_of_range(""Index out of range"");
    }

    if (index == count) {
        add(e);
        return;
    }

    Node* newNode = new Node(e, nullptr);
    if (index == 0) {
        newNode->next = head;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Singly_linked_list_8,1426682,2211170,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
        if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw out_of_range(""Index out of range"");
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
        return count == 0;
        
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
        Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
        return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1426682,2211170,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
        if (index < 0 || index >= count) {
        throw out_of_range(""Index out of range"");
    }

    T removedData;
    if (index == 0) {
        Node* removedNode = head;
        removedData = removedNode->data;
        head = head->next;
        delete removedNode;
        if (count == 1) {
            tail = nullptr;
        }
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        Node* removedNode = current->next;
        removedData = removedNode->data;
        current->next = removedNode->next;
        delete removedNode;
        if (index == count - 1) {
            tail = current;
        }
    }
    count--;
    return removedData;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
        if (head == nullptr) {
        return false;
    }

    if (head->data == item) {
        Node* removedNode = head;
        head = head->next;
        delete removedNode;
        count--;
        if (count == 0) {
            tail = nullptr;
        }
        return true;
    }

    Node* current = head;
    while (current->next != nullptr) {
        if (current->next->data == item) {
            Node* removedNode = current->next;
            current->next = removedNode->next;
            delete removedNode;
            count--;
            if (current->next == nullptr) {
                tail = current;
            }
            return true;
        }
        current = current->next;
    }

    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
        Node* current = head;
    while (current != nullptr) {
        Node* next = current->next;
        delete current;
        current = next;
    }
    head = nullptr;
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1426682,2211170,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* curr = head;

    while (curr != nullptr) {
        LLNode* nextNode = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextNode;
    }

    return prev;
}

LLNode* findMiddleNode(LLNode* head) {
    LLNode* slow = head;
    LLNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow;
}

LLNode* mergeNodes(LLNode* node1, LLNode* node2) {
    if (node1 == nullptr)
        return node2;
    if (node2 == nullptr)
        return node1;

    LLNode* mergedHead = nullptr;
    LLNode* mergedTail = nullptr;

    while (node1 != nullptr && node2 != nullptr) {
        int sum = node1->val + node2->val;
        LLNode* newNode = new LLNode(sum, nullptr);

        if (mergedHead == nullptr) {
            mergedHead = newNode;
            mergedTail = newNode;
        } else {
            mergedTail->next = newNode;
            mergedTail = newNode;
        }

        node1 = node1->next;
        node2 = node2->next;
    }

    if (node1 != nullptr)
        mergedTail->next = node1;
    if (node2 != nullptr)
        mergedTail->next = node2;

    return mergedHead;
}

LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr)
        return head;

    LLNode* slow = head;
    LLNode* fast = head->next;

    // Move the 'slow' pointer to the middle node
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    LLNode* secondHalf = slow->next;
    slow->next = nullptr;

    secondHalf = reverseLinkedList(secondHalf);
    head = mergeNodes(head, secondHalf);

    // Reverse the resulting folded list
    head = reverseLinkedList(head);

    return head;
}",1.0,1111111111
Singly_linked_list_11,1426682,2211170,"LLNode* replaceFirstGreater(LLNode* head) {
    if (head == nullptr)
        return nullptr;

    std::stack<LLNode*> st;
    LLNode* curr = head;

    // Traverse the list to find the first greater node for each node
    while (curr != nullptr) {
        while (!st.empty() && st.top()->val < curr->val) {
            st.top()->val = curr->val;
            st.pop();
        }
        st.push(curr);
        curr = curr->next;
    }

    // Set the value of remaining nodes to 0
    while (!st.empty()) {
        st.top()->val = 0;
        st.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1426682,2211170,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* curr = head;

    while (curr != nullptr) {
        LLNode* nextNode = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextNode;
    }

    return prev;
}",1.0,1111111111
Singly_linked_list_13,1426682,2211170,"int getLength(LLNode* head) {
    int length = 0;
    LLNode* curr = head;
    while (curr != nullptr) {
        length++;
        curr = curr->next;
    }
    return length;
}

LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || k <= 0)
        return head;

    int length = getLength(head);
    k = k % length; // Adjust k if it's larger than the length of the list

    if (k == 0)
        return head;

    LLNode* curr = head;
    LLNode* prev = nullptr;

    // Traverse to the kth node from the end
    int steps = length - k;
    while (steps > 0) {
        prev = curr;
        curr = curr->next;
        steps--;
    }

    // Update the pointers to rotate the list
    prev->next = nullptr;
    LLNode* newHead = curr;

    // Traverse to the end of the list and connect it to the original head
    while (curr->next != nullptr) {
        curr = curr->next;
    }
    curr->next = head;

    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1426682,2211170,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (low <= high && high >= 0) {
        // Adjust low and high if they exceed the size of the linked list
        if (low < 0)
            low = 0;
        if (high >= size)
            high = size - 1;

        Node* curr = head;
        Node* prev = nullptr;
        int position = 0;

        // Traverse to the node at position low
        while (curr != nullptr && position < low) {
            prev = curr;
            curr = curr->next;
            position++;
        }

        // Delete nodes from position low to position high
        int deleteCount = high - low + 1;
        while (curr != nullptr && deleteCount > 0) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
            deleteCount--;
            size--;
        }

        // Connect the replaced linked list
        if (prev != nullptr)
            prev->next = linked_list->head;
        else
            head = linked_list->head;

        if (linked_list->tail != nullptr)
            linked_list->tail->next = curr;
        else
            tail = curr;

        // Update the size of this linked list
        size = size - (high - low + 1) + linked_list->size;
    }
}",0.4,110
Singly_linked_list_1,1428015,2213248,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* head = nullptr;
    LLNode** p = &head;
    while(*p) {
        p = &((*p)->next);
    }
    int in = 0;
    while(l0 != nullptr || l1 != nullptr || in > 0) {
        int num0 = 0, num1 = 0;
        if(l0 != nullptr) {
            num0 = l0->val;
            l0 = l0->next;
        }
        if(l1 != nullptr) {
            num1 = l1->val;
            l1 = l1->next;
        }
        int value = (num0 + num1 + in) % 10;
        in = (num0 + num1 + in) / 10;
        *p = new LLNode(value, nullptr);
        p = &((*p)->next);
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1428015,2213248,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    SLinkedList<Term>::Iterator it;
    int i = 0;
    if(term.coeff == 0){
        return;
    }
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        if (term.exp > (*it).exp) {
            // Insert the term before the current iterator position
            if(!(it != this->terms->begin())){
                this->terms->add(0,term);
            }
            else{
                this->terms->add(i,term);
            }
            //this->terms->insertBefore(it, term);
            return;
        }
        else if(term.exp == (*it).exp){
            Term newTerm(term.coeff + (*it).coeff,term.exp);
            if(newTerm.coeff == 0){
                this->terms->removeAt(i);
            }
            else{
                this->terms->set(i,newTerm);
            }
            return;
        }
        i++;
    }
    // If no term with a higher exponent is found, insert at the end
    this->terms->add(i,term);
}


void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff, exp);
    insertTerm(term);
}",0.9,11111
Singly_linked_list_4,1428015,2213248,"void LinkedList::partition(int k) {
    Node* l1 = nullptr;
    Node* ptail1 = nullptr;
    Node* l2 = nullptr;
    Node* ptail2 = nullptr;
    Node* l3 = nullptr;
    Node* ptail3 = nullptr;
    for(Node* temp = this->head; temp != nullptr; temp = temp->next) {
        Node** p;
        if(temp->value < k) {
            p = &l1;
            while((*p)) {
                p = &((*p)->next);
            }
            (*p) = new Node(temp->value, nullptr);
            ptail1 = *p;
        }
        else if(temp->value == k) {
            p = &l2;
            while((*p)) {
                p = &((*p)->next);
            }
            (*p) = new Node(temp->value, nullptr);
            ptail2 = *p;
        }
        else {
            p = &l3;
            while((*p)) {
                p = &((*p)->next);
            }
            (*p) = new Node(temp->value, nullptr);
            ptail3 = *p;
        }
    }
    Node* temp = this->head;
    while (temp) {
        Node* prev = temp;
        temp = temp->next;
        delete prev;
    }
    if(l1 != nullptr) {
        this->head = l1;
        if(l2 != nullptr) {
            ptail1->next = l2;
            if(l3 != nullptr) {
                ptail2->next = l3;
                this->tail = ptail3;
            }
            else this->tail = ptail2;
        }
        else this->tail = ptail1;
    }
    else if(l2 != nullptr) {
        this->head = l2;
        if(l3 != nullptr) {
            ptail2->next = l3;
            this->tail = ptail3;
        }
        else this->tail = ptail2;
    }
    else {
        this->head = l3;
        this->tail = ptail3;
    }
}",1.0,11111
Singly_linked_list_6,1428015,2213248,"int Train::allocate(int containerSize) {
    TrainCar* pr = NULL;
    int i = 0;
    int min = 0, index = 0; 
    for(TrainCar* p = this->head; p != NULL; p = p->next) {
        if(p->remainingSpace >= containerSize) {
            if(min == 0) min = p->remainingSpace + 1;
            if(p->remainingSpace < min) {
                min = p->remainingSpace;
                pr = p;
                index = i;
            }
        }
        i++;
    }
    if(pr != NULL) {
        pr->remainingSpace = pr->remainingSpace - containerSize;
        return index;
    }
    else return -1;
}

int Train::totalRemainingSpace() {
    int total = 0;
    for(TrainCar* pr = this->head; pr != NULL; pr = pr->next) {
        total += pr->remainingSpace;
    }
    return total;
}",1.0,11111
Singly_linked_list_7,1428015,2213248,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if(this->head != nullptr) {
        this->tail->next = new Node(e);
        this->tail = this->tail->next;
    }
    else {
        this->head = new Node(e);
        this->tail = this->head;
    }
    this->count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    Node** p = &this->head;
    while(index && (*p)) {
        p = &((*p)->next);
        index--;
    }
    (*p) = new Node(e, *p);
    this->count++;
    if((*p)->next == nullptr) this->tail = *p;
}

template<class T>
int SLinkedList<T>::size() {
    return this->count;
    //return 0;
}
",0.85,1111111111
Singly_linked_list_8,1428015,2213248,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    Node* temp = this->head;
    for(int i = 0; i < index; i++) {
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    Node* temp = this->head;
    for(int i = 0; i < index; i++) {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(count == 0) return 1;
    else return 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for(Node* temp = this->head; temp != nullptr; temp = temp->next) {
        if(temp->data == item) return index;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for(Node* temp = this->head; temp != nullptr; temp = temp->next) {
        if(temp->data == item) return true;
    }
    return false;
}",0.3,1110
Singly_linked_list_1,1428026,2213250,"void addLinked(LLNode * tail, LLNode *l0 , int& carry)
{
    
    while(l0)
    {
        int n = l0->val +carry;
        carry = n/10;
        n %=10;
        tail ->next = new LLNode(n,NULL);
        tail = tail ->next;
        l0=l0->next;
    }
}
LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    int carry =0;
    LLNode * p0 = l0;
    LLNode * p1 = l1;
    LLNode * head = NULL;
    LLNode * tail =NULL;
    while(p0 && p1)
    {
        int n = p0->val + p1->val +carry;
        carry = n/10;
        n %=10;
        if(!head)
        {
            tail = new LLNode(n,NULL);
            head = tail;
        }
        else
        {
            tail->next = new LLNode(n,NULL);
            tail = tail->next;
        }
        p0=p0->next;
        p1=p1->next;
    }
    if(p0)
    {
        addLinked(tail, p0 , carry);
    }
    else if(p1)
    {
        addLinked(tail, p1 , carry);
    }
    if(carry)
    {
        tail ->next = new LLNode(carry,NULL);
        tail = NULL;
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1428026,2213250,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.coeff == 0 )return;
    int n = terms->size();
    if(n==0){
        terms->add(term);
        return;
    }
    
    for(int i=0 ; i<n;i++){
       Term temp = terms->get(i);
       if(temp.exp==term.exp){
           Term newterm(temp.coeff+term.coeff,temp.exp);
           terms->set(i,newterm);
           if(terms->get(i).coeff == 0 ) terms->removeAt(i);
           return;
       }
       else if(temp.exp < term.exp ){
           terms->add(i,term);
           return;
       }
    }
    terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff,exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_3,1428026,2213250,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(begin){
        if(pList != NULL){
            current = pList -> head;
            this -> index =0;
        }
        else{
            current = NULL;
            index = -1;
        }
    }
    else{
        current = NULL;
        index = (pList == NULL)? 0 : pList-> size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this-> current = iterator.current;
    this-> pList = iterator.pList;
    this-> index = iterator.index;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        pList-> removeAt(index);
        index--;
    }
    
    if(index == -1){
        current = NULL;
    }
    else{
        current = pList->head;
        for (int i =0; i < index; i++){
            current = current->next;
        }
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if( current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    current-> data = e;
    
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    return current -> data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return !(this-> current == iterator.current && this-> index == iterator.index) ;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == NULL && index == -1){
        current = pList-> head;
        index++;
    }
    else if (current == NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        current = current -> next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,11111
Singly_linked_list_4,1428026,2213250,"void LinkedList::partition(int k) {
    Node *p1 = NULL;
    Node *p2 = NULL;
    Node *p3 = NULL;
    Node *temp1 = NULL;
    Node *temp2 = NULL;
    Node *temp3 = NULL;
    Node *p =head;
    while(p)
    {
        if(p->value < k)
        {
            if(p1 == NULL)
            {
                p1=p;
                temp1 =p;
            }
            else
            {
                temp1->next =p;
                temp1 = temp1->next;
            }
        }
        else if(p->value == k)
        {
            if(!p2)
            {
                p2 =p;
                temp2 =p;
            }
            else
            {
                temp2->next =p;
                temp2 = temp2->next;
            }
        }
        else
        {
            if(!p3)
            {
                p3 =p;
                temp3 =p;
            }
            else
            {
                temp3->next =p;
                temp3 = temp3->next;
            }
        }
        p =p->next;
        if(temp1) temp1->next =NULL;
        if(temp2) temp2->next =NULL;
        if(temp3) temp3->next =NULL;
    }
    
    if(temp1) temp1->next = p2;
    if(temp2) temp2->next = p3;
    if(temp3) temp3->next =NULL;
    
    if(p1) head =p1;
    else if(p2) head = p2;
    else head = p3;
    
    if(temp3) tail = temp3;
    else if(temp2) tail = temp2;
    else tail = temp1;
}",1.0,11111
Singly_linked_list_5,1428026,2213250,"#include <vector>

void reduceDuplicate(Node* root)
{
    vector<int> contain;
    Node* run = root;
    while (run) {
        if ((int)contain.size() == 0) {
            contain.push_back(run->getData());
        }
        else {
            if (run->getData() != contain[contain.size() - 1]) contain.push_back(run->getData());
        }
        run = run->getNext();
    }
    Node* temp = root;
    Node* prev = root;
        for (int i = 0; i < (int)contain.size(); i++) {
            temp->setData(contain[i]);
            prev=temp;
            temp =temp->getNext();
        }
        prev->setNext(nullptr);
}",1.0,1111111111
Singly_linked_list_6,1428026,2213250,"int Train::allocate(int containerSize) {
    TrainCar* run = this->head;
    TrainCar* here = nullptr;
    int ans = 0 ;
    int idx = 0 ;
    int res = 1e9;
    while(run){
        if(containerSize<=run->remainingSpace){
            if(run->remainingSpace-containerSize < res){
                res = run->remainingSpace - containerSize;
                ans = idx;
                here = run;
            }
        }
        idx++;
        run=run->next;
    }
    if(here!=nullptr){
        here->remainingSpace = res;
        return ans;
    }
    return -1;
}

int Train::totalRemainingSpace() {
    int S = 0 ;
    TrainCar* run = this->head;
    while(run){
        S+=run->remainingSpace;
        run=run->next;
    }
    return S;
}",1.0,11111
Singly_linked_list_7,1428026,2213250,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if (head)
    {
        tail->next = new Node(e, nullptr);
        tail = tail->next;
    }
    else
    {
        head = new Node(e, nullptr);
        tail = head;
    }
    ++count;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index==count)
    {
        (*this).add(e);
        return;
    }
    if (index==0)
    {
        this->head = new Node(e, head);
        ++count;
        return;
    }
    Node* run = head;
    Node* pre = nullptr;
    for (int i = 0; i<index; ++i)
    {
        pre = run;
        run = run->next;
    }
    pre->next = new Node(e, run);
    ++count;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1428026,2213250,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index<0 || index>=count) throw std::out_of_range(""Index is out of range"");
    Node* temp = this->head;
    while(index--){
        temp = temp->next;
    }
    return temp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index<0 || index>=count) throw std::out_of_range(""Index is out of range"");
    Node* temp = this->head;
    while(index--){
        temp=temp->next;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (head==nullptr)? 1:0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int idx = 0 ;
    Node* temp = this->head;
    while(temp){
        if(temp->data == item){
            return idx;
        }
        idx++;
        temp=temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (indexOf(item)==-1)? 0:1;
}",1.0,1111111111
Singly_linked_list_9,1428026,2213250,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    T val = 0 ;
    if(index==0) { val = this->head->data ; this->head = this->head->next;}
    else{
        Node* curr = head ;
        Node* prev = head;
        while(index--){
            prev = curr;
            curr = curr->next;
        }
        if(this->tail != curr ){
            prev->next = curr->next;
        }
        else{
            this->tail = prev;
        }
        val = curr->data;
    }
    count--;
    return val;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int idx = 0 ;
    Node* temp = head;
    while(temp){
        if(temp->data == item){
            this->removeAt(idx);
            return true;
        }
        idx++;
        temp=temp->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    head = nullptr;
    tail = nullptr;
    count = 0 ;
}

",1.0,1111111111
Singly_linked_list_10,1428026,2213250,"LLNode* reverse(LLNode* head) {
    LLNode * phead = NULL;
    while(head)
    {
        LLNode* p = head;
        head =head->next;
        if(phead == NULL)
        {
            p->next = NULL;
            phead = p;
        }
        else
        {
            p->next = phead;
            phead = p;
        }
    }
    return phead;
}
LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    LLNode*p = head;
    int n=0;
    while(p)
    {
        n++;
        p=p->next;
    }
    if(n ==0) return head;
    p = head;
    if(n%2 == 1) n+=1;
    for(int i=1;i<n/2;i++)
    {
        p = p->next;
    }
    LLNode * p1= p->next;
    p->next =NULL;
    LLNode * p2 = reverse(p1);
    p = head;
    while(p2)
    {
        p->val += p2->val;
        p=p->next;
        p2 = p2->next;
    }
    p = reverse(head);
    return p;
    
}",1.0,1111111111
Singly_linked_list_11,1428026,2213250,"LLNode* replaceFirstGreater(LLNode* head) {
    // STUDENT ANSWER
    LLNode* temp = head ;
    while(temp){
        LLNode* run = temp;
        while(run){
            if(run->val > temp->val){
                temp->val = run->val;
                break;
            }
            run=run->next;
        }
        if(run==nullptr) temp->val = 0;
        temp=temp->next;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1428026,2213250,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode * phead = NULL;
    while(head)
    {
        LLNode* p = head;
        head =head->next;
        if(phead == NULL)
        {
            p->next = NULL;
            phead = p;
        }
        else
        {
            p->next = phead;
            phead = p;
        }
    }
    return phead;
}",1.0,1111111111
Singly_linked_list_13,1428026,2213250,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    LLNode *p = head;
    int n=0;
    while(p!=NULL)
    {
        p=p->next;
        n++;
    }
    if(n ==0 || k ==0) return head;
    
    p = head;
    if(n<=k)
    {
        while(true)
        {
            if(p->next->next == NULL)
            {
                LLNode* p1 = p->next;
                p->next =NULL;
                p1->next =head;
                return p1;
            }
            p=p->next;
        }
        
    }
    for(int i=1;i<n-k;i++)
    {
        p =p ->next;
    }
    LLNode* p1 =p->next;
    p->next = NULL;
    LLNode *p2 = p1;
    while(p2->next)
    {
        p2 = p2->next;
    }
    p2->next = head;
    return p1;
}",1.0,1111111111
Singly_linked_list_14,1428026,2213250,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if(low<0) low=0;
    if(high>=size) high = size - 1;
    if(low==0){
        Node* temp = this->head;
        for(int i=1 ; i<=high ;i++){
            temp=temp->next;
        }
        this->head = linked_list->head;
        if(temp!=this->tail ){
            linked_list->tail->next = temp->next;
        }
        else{
            this->tail = linked_list->tail;
        }
    }
    else{
        Node* run = this->head;
        Node* low_node = nullptr , *high_node = nullptr;
        for(int i=0 ; i<=high ; i++){
            if(i==low-1) low_node = run ;
            else if(i==high) high_node = run;
            run=run->next;
        }
        if(high!=size-1){
            low_node->next = linked_list->head;
            linked_list->tail->next = high_node->next;
        }
        else{
            low_node->next= linked_list->head;
            this->tail = linked_list->tail;
        }
    }
    this->size = this->size - (high-low+1) + linked_list->size;
    
}",1.0,11111
Singly_linked_list_1,1429075,2210055,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
     LLNode *res = new LLNode();
  LLNode *cur = res;
  int carry = 0;
  while (l0 != nullptr || l1 != nullptr)
  {
    int sum = carry;
    if (l0 != nullptr)
    {
      sum += l0->val;
      l0 = l0->next;
    }
    if (l1 != nullptr)
    {
      sum += l1->val;
      l1 = l1->next;
    }
    carry = sum / 10;
    cur->next = new LLNode(sum % 10, nullptr);
    cur = cur->next;
  }
  if (carry > 0)
  {
    cur->next = new LLNode(carry, nullptr);
  }
  return res->next;
}
",1.0,111111111111111
Singly_linked_list_2,1429075,2210055,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1429075,2210055,"void LinkedList::partition(int k) {
    

}",0.2,00100
Singly_linked_list_10,1429075,2210055,"LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
}",0.1,
Singly_linked_list_7,1429505,2210458,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e, nullptr);
    if (head == nullptr)
    {
        head = newNode;
        tail = newNode;
    }
    else
    {
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        throw std::out_of_range(""Index is out of range"");
    }
    if (index == 0)
    {
        Node* newNode = new Node(e, head);
        //newNode->next = head;
        head = newNode;
        if (count == 0)
        {
            tail = newNode;
        }
    }
    else if (index == count)
    {
        Node* newNode = new Node(e, nullptr);
        tail->next = newNode;
        tail = newNode;
    }
    else
    {
        /*while (count < index - 1)
        {
            iterate = iterate->next;
            count++;
        }
        Node* newNode = new Node(e, iterate->next);
        iterate->next = newNode; */
		Node* temp = head;
        for (int i = 0; i < index - 1; i++) {
			temp = temp->next;
		}   
		Node* newNode = new Node(e, temp->next);
		temp->next = newNode;
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    /*
    int count = 0;
    Node* iterate = head;
    while (iterate != nullptr)
    {
        iterate = iterate->next;
        count++;
    }
    */
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1429505,2210458,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index > count)
    {
        throw std::out_of_range(""Index is out of range"");
    }
    Node* iterate = head;
    int countNode = 0;
    while (countNode < index)
    {
        iterate = iterate->next;
        countNode++;
    }
    return iterate->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index > count)
    {
        throw std::out_of_range(""Index is out of range"");
    }
    else
    {
        Node* iterate = head;
        int countNode = 0;
        while (countNode < index)
        {
            iterate = iterate->next;
            countNode++;
        }
        iterate->data = e;
    }
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !count;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* iterate = head;
    int index = 0;
    while (iterate != nullptr)
    {
        if (iterate->data == item)
            return index;
        else
        {
            iterate = iterate->next;
            index++;
        }
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* iterate = head;
    while (iterate != nullptr)
    {
        if (iterate->data == item)
            return true;
        else
        {
            iterate = iterate->next;
        }
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1429505,2210458,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index is out of range"");
    }
    Node* current = head;
    Node* prev = NULL;
    for (int i = 0; i < index; i++) {
        prev = current;
        current = current->next;
    }
    T removedData = current->data;
    if (prev == NULL) {
        head = current->next;
    } else {
        prev->next = current->next;
    }
    if (current == tail) {
        tail = prev;
    }
    delete current;
    count--;
    return removedData;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    Node* prev = NULL;
    while (current != NULL) {
        if (current->data == item) {
            if (prev == NULL) {
                head = current->next;
            } else {
                prev->next = current->next;
            }
            if (current == tail) {
                tail = prev;
            }
            delete current;
            count--;
            return true;
        }
        prev = current;
        current = current->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */\
    count = 0;
    if (head == nullptr || count == 0)
        return;
    else if (head != nullptr || count == 1)
    {
        delete head;
        head = nullptr;
        tail = nullptr;
    }
    else
    {
        Node* iterate = head;
        Node* deleteNode = iterate;
        while (iterate != nullptr)
        {
            iterate = iterate->next;
            deleteNode = iterate;
            delete deleteNode;
        }
        head = nullptr;
        tail = nullptr;
    }

}

",1.0,1111111111
Singly_linked_list_10,1429505,2210458,"LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    // Find the middle of the list and count the nodes
    LLNode* slow = head, * fast = head;
    int count = 0;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        count += 2;
    }
    if (fast != nullptr) {
        count++; // The list has an odd number of nodes
    }

    // If the list has an even number of nodes, move the slow pointer one step back
    if (count % 2 == 0) {
        LLNode* temp = head;
        while (temp->next != slow) {
            temp = temp->next;
        }
        slow = temp;
    }

    // Reverse the second half of the list
    LLNode* prev = nullptr, * curr = slow->next;
    while (curr != nullptr) {
        LLNode* nextTemp = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextTemp;
    }
    slow->next = nullptr;

    // Merge the two halves of the list
    LLNode* first = head;
    LLNode* second = prev;
    while (second != nullptr) {
        int temp = first->val;
        first->val += second->val;
        second->val = temp;
        if (first->next == nullptr) {
            first->next = second;
            break;
        }
        first = first->next;
        second = second->next;
    }

    // Reverse the entire list
    prev = nullptr;
    curr = head;
    while (curr != nullptr) {
        LLNode* nextTemp = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextTemp;
    }
    head = prev;

    return head;
}",0.5,1010101010
Singly_linked_list_11,1429505,2210458,"LLNode* replaceFirstGreater(LLNode* head) 
{
    return nullptr;
}",0.1,0010000000
Singly_linked_list_12,1429505,2210458,"LLNode* reverseLinkedList(LLNode* head) 
{
    LLNode *prev = nullptr, *curr = head, *next = nullptr;
    while (curr != nullptr) {
        next = curr->next; // Temporarily store the next node
        curr->next = prev; // Reverse the link
        prev = curr; // Move prev and curr one step forward
        curr = next;
    }
    head = prev; // Reset head to the new start
    return head;
}",1.0,1111111111
Singly_linked_list_13,1429505,2210458,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || head->next == nullptr || k == 0) {
        return head;
    }

    // Determine the length of the list
    int len = 1;
    LLNode* tail = head;
    while (tail->next != nullptr) {
        tail = tail->next;
        len++;
    }

    // Connect the tail to the head to form a circular list
    tail->next = head;

    // Find the new tail, which is (len - k % len - 1) nodes away from the head
    for (int i = 0; i < len - k % len - 1; i++) {
        head = head->next;
    }

    // The new head is the next node
    LLNode* newHead = head->next;

    // Break the circular list
    head->next = nullptr;

    return newHead;
}",1.0,1111111111
Singly_linked_list_1,1429925,2211876,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    int carry = 0;
    LLNode dummyHead; 
    LLNode* current = &dummyHead;

    while (l0 || l1 || carry) {
        int sum = carry;
        if (l0) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1) {
            sum += l1->val;
            l1 = l1->next;
        }

        carry = sum / 10;
        current->next = new LLNode(sum % 10);
        current = current->next;
    }
    return dummyHead.next;
    // STUDENT ANSWER
}",1.0,111111111111111
Singly_linked_list_2,1429925,2211876,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_4,1429925,2211876,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1429925,2211876,"void reduceDuplicate(Node* root)
{
    if (root == nullptr)
    {
        
        return;
    }

    Node* current = root;

    while (current->getNext() != nullptr)
    {
        if (current->getData() == current->getNext()->getData())
        {
            
            Node* duplicate = current->getNext();
            current->setNext(duplicate->getNext());
            delete duplicate; 
        }
        else
        {
           
            current = current->getNext();
        }
    }
}
",1.0,1111111111
Singly_linked_list_1,1430223,2210034,"#include<cmath>
LLNode* addLinkedList(LLNode* l0, LLNode* l1){
    LLNode dummy;
    LLNode* tail = &dummy;
    int carry = 0;
    while (l0 || l1 || carry) {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        carry = sum / 10;
        tail->next = new LLNode(sum % 10);
        tail = tail->next;
        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }
    return dummy.next;
}",1.0,111111111111111
Singly_linked_list_2,1430223,2210034,"void Polynomial::insertTerm(const Term& term) {
    if (term.coeff == 0) return; // Ignore zero coefficients

    // Iterate over the terms in the polynomial
    for (int i = 0; i < this->terms->size(); i++) {
        // If the exponent of the current term is less than the exponent of the term to be inserted
        if (this->terms->get(i).exp < term.exp) {
            // Insert the term before the current term
            this->terms->add(i, term);
            return;
        }
        // If the exponent of the current term is equal to the exponent of the term to be inserted
        else if (this->terms->get(i).exp == term.exp) {
            // Add the coefficients and update the current term
            Term currentTerm = this->terms->get(i);
            currentTerm.coeff += term.coeff;
            // If the coefficient becomes zero, remove the term
            if (currentTerm.coeff == 0) {
                this->terms->removeAt(i);
            } else {
                this->terms->set(i, currentTerm);  // Set back updated term
            }
            return;
        }
    }

    // If no suitable position was found in the list, append the term at the end
    this->terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    insertTerm(Term(coeff, exp));
}",1.0,11111
Singly_linked_list_1,1430263,2210103,"
bool addLastLL(LLNode*& head, int data, LLNode*& tail)
{
    LLNode* p = new LLNode(data, nullptr);
    if (head != nullptr)
    {
        tail->next = p;
    }
    else
    {
        head = p;
    }
    return true;
}

LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    int r = 0;
    int value = 0;
    LLNode* result = nullptr;
    LLNode* tail = nullptr;
    while (l0 != nullptr || l1 != nullptr || r != 0)
    {
        if (l0 == nullptr && l1 != nullptr)
        {
            value = r + l1->val;
            l1 = l1->next;
            r = 0;
        }
        else if (l1 == nullptr && l0 != nullptr)
        {
            value = r + l0->val;
            l0 = l0->next;
            r = 0;
        }
        else if (l1 != nullptr && l0 != nullptr)
        {
            value = r + l1->val + l0->val;
            l0 = l0->next;
            l1 = l1->next;
            r = 0;
        }
        if (value >= 10)
        {
            r = value / 10;
            value = value % 10;
        }
        else
        {
            value = r + value;
            r = 0;
        }
        addLastLL(result, value, tail);
        if (tail) {
            tail = tail->next;
        }
        else
        {
            tail = result;
        }
        value = 0;
    }
    return result;
}",1.0,111111111111111
Singly_linked_list_2,1430263,2210103,"void Polynomial::insertTerm(const Term &term)
{
    // HE SO bang 0
    if (term.coeff == 0)
        return;

    // List Terms dang empty
    if (this->terms->size() == 0)
    {
        this->terms->add(term);
    }
    // List Terms ko empty
    else
    {
        int currentEXP = 0;
        int totalEXP = this->terms->size();

        // vong lap de update List term
        for (currentEXP = 0; currentEXP < totalEXP; currentEXP++)
        {
            // Truy cap vao data kieu Term tai node i
            // get tra ve data
            Term currentTemrNode = this->terms->get(currentEXP);

            /******************************************
            *           ...8 7 6 5 4 3 2 1 0          *
            ******************************************/

            // Neu nhu so mu hien tai > so mu truyen vao
            // tiep tuc vong lap for
            if (currentTemrNode.exp > term.exp)
            {
                continue;
            }
            else
            {
                // Neu nhu so mu hien tai < so mu truyen vao
                // thi ta them terms vao vi tri currentEXP
                if (currentTemrNode.exp < term.exp)
                {
                    this->terms->add(currentEXP, term);
                    break;
                }
                // Neu nhu so mu hien tai = so mu truyen vao
                else
                {
                    // Tao ra 1 term node moi
                    Term replaceTerm(currentTemrNode.coeff + term.coeff, term.exp);

                    // Neu nhu he so tao ra bang 0
                    // xoa node tai vi tri currentEXP
                    if (currentTemrNode.coeff + term.coeff == 0)
                        this->terms->removeAt(currentEXP);

                    // Neu tao ra so != 0
                    // thay the term tai vi tri node currentEXP bang term moi voi data moi
                    // coeff va exp
                    else
                        this->terms->set(currentEXP, replaceTerm);

                    // thoat khoi vong lap
                    break;
                }
            }
        }

        // Them vao cuoi
        // So mu truyen vao la be nhat
        if (currentEXP == totalEXP)
            this->terms->add(term);
    }
}

void Polynomial::insertTerm(double coeff, int exp)
{
    // Tao ra term node moi
    Term term(coeff, exp);

    // Su dung lai insert(const *term)
    this->insertTerm(term);
}
",1.0,11111
Singly_linked_list_3,1430263,2210103,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T> *pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        *
        * begin = true:
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        *
        * begin = false:
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;

    // BEGIN (true)
    if (begin == true)
    {
        // Danh sach khong NULL
        // neu pList dang NULL thi ta se ko goi ham size() hay count dc
        // nen code nhu ben duoi
        if (!this->pList == 0)
        {
            this->current = this->pList->head;
            this->index = 0;
        }
        else // Danh sach NULL
        {
            this->current = NULL;
            this->index = -1;
        }
    }
    else // END (false)
    {
        if (!this->pList == 0)
        {
            this->current = NULL;
            this->index = this->pList->size();
        }
        else
        {
            this->current = NULL;
            this->index = 0;
        }
    }
}

// Remove
template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */

    // current == NULL
    if (this->current == NULL)
        throw std::out_of_range(""Segmentation fault!"");
    // remove at front
    else if (this->current == this->pList->head)
    {
        this->pList->removeAt(0);
        this->current = NULL;
    }
    // remove
    else
    {
        // tim vi tri cua current
        int countIndex = 0;
        Node *temp = this->pList->head;

        while (temp != this->current)
        {
            countIndex += 1;
            temp = temp->next;
        }
        // countIndex va temp deu dang o tai current

        int x = 0;
        Node *temp_2 = this->pList->head;
        // Phan tu dung truoc 1 don vi
        while (x != countIndex - 1)
        {
            temp_2 = temp_2->next;
            x++;
        }

        temp_2->next = temp->next;
        this->current = temp_2;
        delete temp;
        this->pList->count -= 1;
    }
}

// Set
template <class T>
void SLinkedList<T>::Iterator::set(const T &e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    this->current->data = e;
}

// Operator *
template <class T>
T &SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    return this->current->data;
}

// Operator =
template <class T>
typename SLinkedList<T>::Iterator
    &
    SLinkedList<T>::Iterator::operator=(const Iterator &iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

// Operator !=
template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator &iterator)
{
    //Returns true if two iterators points the same node and index
    if (this->current != iterator.current)
        return true;
    else
        return false;
}

// Prefix ++a overload
template <class T>
typename SLinkedList<T>::Iterator
    &
    SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */

    this->current = this->current->next;
    return *this;
}

// Postfix a++ overload
template <class T>
typename SLinkedList<T>::Iterator
SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    SLinkedList<T>::Iterator result = *this;
    ++(*this);
    return result;
}",1.0,11111
Singly_linked_list_4,1430263,2210103,"void LinkedList::partition(int k) {
    LinkedList* one = new LinkedList();
    LinkedList* two = new LinkedList();
    LinkedList* three = new LinkedList();
    for (Node* p = head; p != nullptr; p = p->next)
    {
        if (p->value < k)
        {
            one->add(p->value);
        }
        else if (p->value == k)
        {
            two->add(p->value);
        }
        else
        {
            three->add(p->value);
        }
    }
    if (one->tail != nullptr)
    {
        one->tail->next = two->head;
        if (two->tail != nullptr)
        {
            two->tail->next = three->head;
            if (three->tail != nullptr)
            {
                tail = three->tail;
            }
            else
            {
                tail = two->tail;
            }
        }
        else
        {
            one->tail->next = three->head;
            if (three->tail != nullptr)
            {
                tail = three->tail;
            }
            else
            {
                tail = one->tail;
            }
        }
        head = one->head;

    }
    else
    {
        if (two->tail != nullptr)
        {
            two->tail->next = three->head;
            head = two->head;
            if (three->tail != nullptr)
            {
                tail = three->tail;
            }
            else
            {
                tail = two->tail;
            }
        }
        else
        {
            head = three->head;
            tail = three->tail;
        }
        tail = three->tail;
    }
}",1.0,11111
Singly_linked_list_5,1430263,2210103,"
void deleteNode(Node*& root)
{

}

void reduceDuplicate(Node* root)
{
    Node* p = root;
    while (p != nullptr)
    {
        if (p->getNext() != nullptr && (p->getNext()->getData() == p->getData()))
        {
            Node* q = p->getNext();
            p->setNext(p->getNext()->getNext());
            delete q;
        }
        else
        {
            p = p->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1430263,2210103,"int Train::allocate(int containerSize) {
  TrainCar* min = nullptr;
  int minIndex = 0;
  int index = 0;
  TrainCar* current = head;
  while (current) {
    if (current->remainingSpace >= containerSize) {
      if (min == nullptr || current->remainingSpace < min->remainingSpace) {
        min = current;
        minIndex = index;
      }
    }
    current = current->next;
    index += 1;
  }
  if (min == nullptr) return -1;
  min->remainingSpace -= containerSize;
  return minIndex;
}

int Train::totalRemainingSpace() {
  int sum = 0;
  TrainCar* current = head;
  while (current) {
    sum += current->remainingSpace;
    current=current->next;
  }
  return sum;
}",1.0,11111
Singly_linked_list_7,1430263,2210103,"template <class T>
void SLinkedList<T>::add(const T& e) {
    Node* p = new Node(e, nullptr);
    if (head != nullptr)
    {
        Node* q = head;
        while (q->next != nullptr)
        {
            q = q->next;
        }
        q->next = p;
        tail = q->next;
    }
    else
    {
        head = p;
        tail = head;
        count = 1;
    }

}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    Node* first = head;
    Node* last = head;
    Node* q = new Node(e, nullptr);
    int i = 0;
    if (head != nullptr)
    {
        while (last != nullptr)
        {
            if (index == 0)
            {
                q->next = head;
                head = q;
                break;
            }
            first = last;
            last = last->next;
            i++;
            if (i == index)
            {
                first->next = q;
                q->next = last;
                if (last == nullptr)
                {
                    tail = q;
                }
            }
        }
    }
    else
    {
        head = q;
        tail = head;
        count = 1;
    }
}

template<class T>
int SLinkedList<T>::size() {
    count = 0;
    Node* p = head;
    while (p != nullptr)
    {
        count++;
        p = p->next;
    }
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1430263,2210103,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index <0 || index > size()) throw out_of_range(""The index is out of range!"");
    if(size() == 0) throw(""List is empty"");
    else {
        Node* temp = this->head;
        for (int i = 0; i < index; i++) 
        temp = temp->next;
        return temp->data; 
    }
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index <0 || index > size()) {
        throw out_of_range(""The index is out of range!"");
    }
    if(size() == 0) throw(""List is empty"");
    else {
        Node* temp = this->head;
        for (int i = 0; i < index; i++) {
            temp = temp->next;
        }
        temp->data = e;
    }
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(size() == 0){
        return true;
    } 
    else return false;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if (empty()) return -1;
    else {
        Node* temp = this->head;
        for (int i = 0; i < this->count; i++) {
            if(temp->data == item) {
                return i;
            }
            temp = temp->next;
        }
    }
    return -1;   
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if(indexOf(item) == -1) return false;
    else return true;
}",1.0,1111111111
Singly_linked_list_9,1430263,2210103,"template<class T>
T SLinkedList<T>::removeAt(int index){
    if(index <0 || index >size()) {
        throw out_of_range(""The index is out of range!"");
    } 
    if(empty()) throw(""List is empty"");

    Node* temp = this-> head;
    T dataDelete;
    
    if(index == 0 && size()> 1){
        dataDelete = temp->data;
        this->head = temp->next;
        delete temp;
    }


    else if(index == size()-1){
        for(int i = 0; i < size()-2; i ++){
            temp = temp->next;
        }
        dataDelete = this->tail->data;
        delete this->tail;
        this->tail = temp;
        temp->next = NULL;
    }

    else if(index > 0 && index < size()-1){
        for(int i = 0; i < index - 1; i++){
            temp = temp->next;
        }
        Node* temp2 = temp->next;
        dataDelete = temp2->data;
        temp->next = temp2->next;
        delete temp2;
        temp2 = NULL;
    }

    else if(index == 0 && size() == 1){
        dataDelete = this->head->data;
        delete this->head;
        this->head = NULL;
        this->tail = NULL;
    }
    this->count--;
    return dataDelete;
}

template<class T>
bool SLinkedList<T>::removeItem(const T& item){
    if(indexOf(item) != -1){
        removeAt(indexOf(item));
        return true;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    while(size() != 0){
        removeAt(0);
    }
}
",1.0,1111111111
Singly_linked_list_10,1430263,2210103,"LLNode* foldLinkedList(LLNode* head) {
    int size = 0;
    LLNode* p = head;
    while (p != nullptr)
    {
        size++;
        p = p->next;
    }
    int* arr = new int[size];
    for (int i = 0; i < size; i++)
    {
        arr[i] = head->val;
        head = head->next;
    }
    int n = (size + 1) / 2;
    int* newArr = new int[n];
    for (int i = 0; i < (size + 1) / 2; i++)
    {
        if (size % 2 == 0)
        {
            newArr[n - 1 - i] = arr[i] + arr[size - 1 - i];
        }
        else
        {
            if (i == size / 2)
            {
                newArr[n - 1 - i] = arr[i];
            }
            else
            {
                newArr[n - 1 - i] = arr[i] + arr[size - 1 - i];
            }
        }
    }
    LLNode* head3 = LLNode::createWithIterators(newArr, newArr + n);
    return head3;
}",1.0,1111111111
Singly_linked_list_11,1430263,2210103,"LLNode* replaceFirstGreater(LLNode* head) {
    LLNode* start = head;
    LLNode* end = head;
    bool isBigger = true;
    if (head != nullptr)
    {
        end = start->next;
        while (start->next != nullptr)
        {
            while (end != nullptr)
            {
                if (end->val > start->val)
                {
                    start->val = end->val;
                    isBigger = true;
                    break;
                }
                else
                {
                    end = end->next;
                    isBigger = false;
                    continue;
                }
            }
            if (!isBigger)
            {
                start->val = 0;
            }
            start = start->next;
            end = start->next;
        }
        start->val = 0;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1430263,2210103,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* p = head;
    int size = 0;
    while (p != nullptr)
    {
        size++;
        p = p->next;
    }
    int* arr = new int[size];
    for (int i = 0; i < size; i++)
    {
        arr[size - 1 - i] = head->val;
        head = head->next;
    }
    head = LLNode::createWithIterators(arr, arr + size);
    return head;
}",1.0,1111111111
Singly_linked_list_13,1430263,2210103,"LLNode* rotateLinkedList(LLNode* head, int k) {
    for (int i = 0; i < k; i++)
    {
        LLNode* p = head;
        if (p == nullptr)
        {
            return p;
        }
        if (p->next == nullptr)
        {
            return p;
        }
        while (p->next->next != nullptr)
        {
            p = p->next;
        }
        LLNode* q = p->next;
        p->next = nullptr;
        q->next = head;
        head = q;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_14,1430263,2210103,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (low < 0)
    {
        low = 0;
    }
    if (high >= size)
    {
        high = size - 1;
    }
    bool isRemove = false;
    int i = 0;
    Node* startRemove = head;
    Node* p = head;
    while (p != nullptr) {
        if (i == high)
        {
            p->next = linked_list->head;
            linked_list->tail->next = startRemove->next;
            break;
        }
        if (i == low)
        {
            isRemove = true;
        }
        if (!isRemove)
        {
            p = startRemove;
            startRemove = startRemove->next;
            i++;
        }
        else
        {
            startRemove = startRemove->next;
            i++;
            continue;
        }
    }
    if (low == 0)
    {
        head = head->next;
    }
    if (high == size - 1)
    {
        tail = linked_list->tail;
    }
}",1.0,11111
Singly_linked_list_1,1430546,2211367,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode dummy(0);
    LLNode* result = &dummy;
    int carry = 0;

    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;
        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }

        carry = sum / 10;
        sum %= 10;

        result->next = new LLNode(sum);
        result = result->next;
    }

    return dummy.next;
}",1.0,111111111111111
Singly_linked_list_2,1430546,2211367,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.coeff==0) return;
    if(terms->empty()) {terms->add(term); return;}
    int c=0;
    SLinkedList<Term>::Iterator it;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        if((*it).exp==term.exp){
            (*it).coeff+=term.coeff;
            terms->removeItem(Term(0,term.exp));
            return;
        }else
        if((*it).exp<term.exp){
            terms->add(c,term);
            return;
        }
        c++;
    }
    terms->add(c,term);
}


void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    if(coeff==0) return;
    if(terms->empty()) {terms->add(Term(coeff,exp)); return;}
    int c=0;
    SLinkedList<Term>::Iterator it;
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        if((*it).exp==exp){
            (*it).coeff+=coeff;
            terms->removeItem(Term(0,exp));
            return;
        }else
        if((*it).exp<exp){
            terms->add(c,Term(coeff,exp));
            return;
        }
        c++;
    }
    terms->add(c,Term(coeff,exp));
}",1.0,11111
Singly_linked_list_3,1430546,2211367,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList=pList;
    if(begin){
        if(pList!=NULL) {current=pList->head; index=0;}
        else {current=NULL; index=-1;}
    }else{
        current=NULL;
        if(pList!=NULL) index=pList->count;
        else index=0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current=iterator.current;
    this->index=iterator.index;
    this->pList=iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(current==NULL) throw std::out_of_range(""Segmentation fault!"");
    if(index==0) {
        pList->removeAt(0);
        this->current=NULL;
        this->index=-1;
        return;
    }
    pList->removeAt(index);
    int a=index-1;
    current=pList->head;
    while(a>0){
        current=current->next;
        a--;
    }
    index--;
    
    
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current==NULL) throw std::out_of_range(""Segmentation fault!"");
    current->data=e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current==NULL) throw std::out_of_range(""Segmentation fault!"");
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if(this->current==0) return 0;
    else return 1;
    
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current==NULL) throw std::out_of_range(""Segmentation fault!"");
    if(current->next==pList->head) pList->head=current;
    current=current->next;
    index++;
    return *this;
    
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current==NULL) throw std::out_of_range(""Segmentation fault!"");
    SLinkedList<int>::Iterator it=*this;
    current=current->next;
    index++;
    return it;
}",1.0,11111
Singly_linked_list_4,1430546,2211367,"void LinkedList::partition(int k) {
LinkedList* beforek  =  new LinkedList();
        LinkedList* afterk = new LinkedList();
        LinkedList* klist = new LinkedList();
        Node* tmp= this->head;
        for(int i = 0; i < size; i++){
            if(tmp->value < k){
                beforek->add(tmp->value);        }
            else if(tmp->value>k){
                afterk->add(tmp->value);
            }
            else{
                klist->add(tmp->value);
            }
            tmp = tmp->next;
        }
      if (beforek->head != nullptr) {
        head = beforek->head;
        beforek->tail->next = klist->head;
    } else if (klist->head != nullptr) {
        head = klist->head;
    }

    if (klist->tail != nullptr) {
        klist->tail->next = afterk->head;
    }

    if (afterk->tail != nullptr) {
        tail = afterk->tail;
    } else if (klist->tail != nullptr) {
        tail = klist->tail;
    } else {
        tail = beforek->tail;
    }
}",1.0,11111
Singly_linked_list_5,1430546,2211367,"void reduceDuplicate(Node* root)
{
    Node* tmp  = root;
    while(tmp->getNext()!=NULL){
        if (tmp->getData()==tmp->getNext()->getData()){
            tmp->setNext(tmp->getNext()->getNext());
        }
        else tmp=tmp->getNext();
    }
}",1.0,1111111111
Singly_linked_list_7,1430546,2211367,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
        if (head == nullptr) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
        count++;
    
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
            throw std::out_of_range(""Index out of bounds"");
        }

        Node* newNode = new Node(e);
        if (index == 0) {
            newNode->next = head;
            head = newNode;
            if (tail == nullptr) {
                tail = newNode->next;
            }
        } else {
            Node* prev = head;
            for (int i = 0; i < index - 1; i++) {
                prev = prev->next;
            }
            newNode->next = prev->next;
            prev->next = newNode;
            if (newNode->next == nullptr) {
                tail = newNode;
            }
        }
        count++;
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
  count = 0; // Initialize count to 0
    Node* tmp = head;
    while(tmp != nullptr){
        count++;
        tmp = tmp->next;
    }
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1430546,2211367,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index>=count) throw out_of_range(""ngu vc"");
    Node *p=head;
    while(index!=0){
        p=p->next;
        index--;
    }
    return p->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index>=count) throw out_of_range(""ngu vc"");
    Node *p=head;
    while(index!=0){
        p=p->next;
        index--;
    }
    p->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !(head);
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *p=head;
    int idx=0;
    while(p->data!=item){
        p=p->next;
        idx++;
        if(p==NULL) return -1;
    }
    return idx;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node *p=head;
    while(p->data!=item){
        p=p->next;
        if(p==NULL) return 0;
    }
    return 1;
}",0.65,1111111111
Singly_linked_list_9,1430546,2211367,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of bounds"");
    }

    Node* removedNode = nullptr;
    if (index == 0) {
        // Remove the first node
        removedNode = head;
        head = head->next;
        if (head == nullptr) {
            // If the list becomes empty, update tail
            tail = nullptr;
        }
    } else {
        Node* prev = head;
        for (int i = 0; i < index - 1; i++) {
            prev = prev->next;
        }
        removedNode = prev->next;
        prev->next = removedNode->next;
        if (prev->next == nullptr) {
            // If the last element is removed, update tail
            tail = prev;
        }
    }

    T removedValue = removedNode->data;
    delete removedNode;
    count--;
    return removedValue;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* prev = nullptr;
    Node* current = head;

    while (current != nullptr) {
        if (current->data == item) {
            if (prev == nullptr) {
                // If the first element matches, update head
                head = current->next;
            } else {
                prev->next = current->next;
                if (current->next == nullptr) {
                    // If the last element is removed, update tail
                    tail = prev;
                }
            }
            delete current;
            count--;
            return true;
        }
        prev = current;
        current = current->next;
    }

    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
     while (head != nullptr) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1430546,2211367,"LLNode* reverseList1(LLNode* head) {
        LLNode* lastnode = head;
        while(lastnode&&lastnode->next){
            LLNode* nextnode = lastnode->next;
            lastnode->next = nextnode->next;
            nextnode->next = head;
            head = nextnode;
        }
        return head;
     }
     LLNode* reverseList(LLNode* head, int index){
        LLNode* tmp = head;
        LLNode* newhead = new LLNode(head->val);
        LLNode* p = newhead;
        for(int i = 1; i < index;i++){
            p->next = new LLNode(tmp->next->val);
            p = p->next;
            tmp = tmp->next;
        }
        return reverseList1(newhead);
         
     }
int size(LLNode* head){
    int count = 0;
    if(head==NULL){
        return 0;
    }
    else{
        LLNode* tmp = head;
        while(tmp!=NULL){
            count++;
            tmp=tmp->next;
        }
    }
    return count;

}
LLNode* foldLinkedList(LLNode* head) {
    if(head==NULL) return NULL;
   int k;
    int n = size(head);
    k = (n%2==0) ? n/2 : (n + 1)/2;
    LLNode* newnode = reverseList(head,k);
    LLNode* dummy = new LLNode(0,NULL);
    LLNode* result = dummy;
    if(n%2!=0){
    result->next = new LLNode(newnode->val,NULL);
    result = result->next;
    }
    LLNode* tmp = head;
    for(int i = 0; i < k;i++){
        tmp = tmp->next;
    }
    LLNode* newnode2 = new LLNode(tmp->val,NULL);
    LLNode* p = newnode2;
    for(int i = k + 1; i < n;i++){
        p->next = new LLNode(tmp->next->val,NULL);
        p = p->next;
        tmp = tmp->next;
    }
    while(newnode2!=NULL&&newnode!=NULL){
        int sum = 0;
        if(newnode2!=NULL){
            sum += newnode2->val;
            newnode2 = newnode2->next;
        }
        if(newnode!=NULL){
            sum+= (n%2==0) ? (newnode->val) : (newnode->next->val);
            newnode = newnode->next;
        }
        result->next = new LLNode(sum,NULL);
        result = result->next;
    }
    return dummy->next;
}",1.0,1111111111
Singly_linked_list_11,1430546,2211367,"LLNode* replaceFirstGreater(LLNode* head) {
    if (!head) {
        return nullptr;
    }

    std::stack<LLNode*> greaterNodes;  // Stack to store nodes with values greater than the current node
    LLNode* current = head;

    while (current) {
        while (!greaterNodes.empty() && greaterNodes.top()->val < current->val) {
            // Replace values of nodes in the stack with the current node's value
            greaterNodes.top()->val = current->val;
            greaterNodes.pop();
        }

        // Push the current node onto the stack
        greaterNodes.push(current);
        current = current->next;
    }

    // Set values of nodes without greater nodes to 0
    while (!greaterNodes.empty()) {
        greaterNodes.top()->val = 0;
        greaterNodes.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1430546,2211367,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* next = nullptr;

    while (current) {
        // Store the next node to avoid losing the reference
        next = current->next;
        // Reverse the link
        current->next = prev;
        // Move to the next pair of nodes
        prev = current;
        current = next;
    }

    // Update the head to point to the new first node (prev)
    head = prev;

    return head;
}",1.0,1111111111
Singly_linked_list_13,1430546,2211367,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if (!head || k == 0) {
        return head; // Nothing to rotate
    }

    // Find the length of the linked list
    int length = 1;
    LLNode* tail = head;
    while (tail->next) {
        tail = tail->next;
        length++;
    }

    // Calculate the actual rotation amount
    k = k % length;

    // If k is zero, no rotation is needed
    if (k == 0) {
        return head;
    }

    // Find the new head and the node just before it
    LLNode* newHead = head;
    LLNode* prevNewHead = nullptr;
    for (int i = 0; i < length - k; i++) {
        prevNewHead = newHead;
        newHead = newHead->next;
    }

    // Update the next pointers to rotate the list
    prevNewHead->next = nullptr;
    tail->next = head;

    return newHead;
}",1.0,1111111111
Singly_linked_list_1,1431570,2213248,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* head = nullptr;
    LLNode** p = &head;
    while(*p) {
        p = &((*p)->next);
    }
    int in = 0;
    while(l0 != nullptr || l1 != nullptr || in > 0) {
        int num0 = 0, num1 = 0;
        if(l0 != nullptr) {
            num0 = l0->val;
            l0 = l0->next;
        }
        if(l1 != nullptr) {
            num1 = l1->val;
            l1 = l1->next;
        }
        int value = (num0 + num1 + in) % 10;
        in = (num0 + num1 + in) / 10;
        *p = new LLNode(value, nullptr);
        p = &((*p)->next);
    }
    return head;
}",1.0,111111111111111
Singly_linked_list_2,1431570,2213248,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    SLinkedList<Term>::Iterator it;
    int i = 0;
    if(term.coeff == 0){
        return;
    }
    for (it = this->terms->begin(); it != this->terms->end(); it++) {
        if (term.exp > (*it).exp) {
            // Insert the term before the current iterator position
            if(!(it != this->terms->begin())){
                this->terms->add(0,term);
            }
            else{
                this->terms->add(i,term);
            }
            //this->terms->insertBefore(it, term);
            return;
        }
        else if(term.exp == (*it).exp){
            Term newTerm(term.coeff + (*it).coeff,term.exp);
            if(newTerm.coeff == 0){
                this->terms->removeAt(i);
            }
            else{
                this->terms->set(i,newTerm);
            }
            return;
        }
        i++;
    }
    // If no term with a higher exponent is found, insert at the end
    this->terms->add(i,term);
}


void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff, exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_3,1431570,2213248,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(begin){
        if(pList){
        index = 0;
        current = pList->head;
        }
        else{
            index = -1;
            current = nullptr;
        }
    }
    else{
        if(!pList){
            index = 0;
            current = nullptr;
        }
        else{
            index = pList->count;
            current = nullptr;
        }
    }
    
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    //if(current == nullptr){
    //    throw std::out_of_range(""Segmentation fault!"");
    //}
    if(index == 0){
        pList->removeAt(0) ;
        current = nullptr;
        index = -1;
    }
    else{
        Node *temp = pList->head;
        for(int i = 0; i < index - 1; i++){
            temp = temp->next;
        }
        current = temp;
        pList->removeAt(index);
        index--;
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == nullptr){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        this->current->data = e;
    }
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == nullptr){
        throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        return current->data;
    }

}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return (current != iterator.current);
    
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == pList->tail)
    {
        //throw std::out_of_range(""Segmentation fault!""); // Handle the case where the iterator is already at the end
    }

    if (index == -1)
    {
        current = pList->head ; // Reached the end of the list
        index = 0; // Indicate that the iterator is at the end
    }
    else
    {
        current = current->next; // Move to the next node
        index++;
    }
    return *this; // Return the updated iterator
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator temp = *this; // make a copy of itself
    ++*this; // use prefix increment operator to advance itself
    return temp; // return a copy of itself before advancing
}",1.0,11111
Singly_linked_list_4,1431570,2213248,"void LinkedList::partition(int k) {
    Node* l1 = nullptr;
    Node* ptail1 = nullptr;
    Node* l2 = nullptr;
    Node* ptail2 = nullptr;
    Node* l3 = nullptr;
    Node* ptail3 = nullptr;
    for(Node* temp = this->head; temp != nullptr; temp = temp->next) {
        Node** p;
        if(temp->value < k) {
            p = &l1;
            while((*p)) {
                p = &((*p)->next);
            }
            (*p) = new Node(temp->value, nullptr);
            ptail1 = *p;
        }
        else if(temp->value == k) {
            p = &l2;
            while((*p)) {
                p = &((*p)->next);
            }
            (*p) = new Node(temp->value, nullptr);
            ptail2 = *p;
        }
        else {
            p = &l3;
            while((*p)) {
                p = &((*p)->next);
            }
            (*p) = new Node(temp->value, nullptr);
            ptail3 = *p;
        }
    }
    Node* temp = this->head;
    while (temp) {
        Node* prev = temp;
        temp = temp->next;
        delete prev;
    }
    if(l1 != nullptr) {
        this->head = l1;
        if(l2 != nullptr) {
            ptail1->next = l2;
            if(l3 != nullptr) {
                ptail2->next = l3;
                this->tail = ptail3;
            }
            else this->tail = ptail2;
        }
        else this->tail = ptail1;
    }
    else if(l2 != nullptr) {
        this->head = l2;
        if(l3 != nullptr) {
            ptail2->next = l3;
            this->tail = ptail3;
        }
        else this->tail = ptail2;
    }
    else {
        this->head = l3;
        this->tail = ptail3;
    }
}",1.0,11111
Singly_linked_list_5,1431570,2213248,"void reduceDuplicate(Node* root)
{
    Node* prev = root;
    Node* current = root->getNext();
    while(current != nullptr) {
        if(prev->getData() == current->getData()) {
            Node* temp = current;
            current = current->getNext();
            prev->setNext(current);
            delete temp;
        }
        else {
            prev = prev->getNext();
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1431570,2213248,"int Train::allocate(int containerSize) {
    TrainCar* pr = NULL;
    int i = 0;
    int min = 0, index = 0; 
    for(TrainCar* p = this->head; p != NULL; p = p->next) {
        if(p->remainingSpace >= containerSize) {
            if(min == 0) min = p->remainingSpace + 1;
            if(p->remainingSpace < min) {
                min = p->remainingSpace;
                pr = p;
                index = i;
            }
        }
        i++;
    }
    if(pr != NULL) {
        pr->remainingSpace = pr->remainingSpace - containerSize;
        return index;
    }
    else return -1;
}

int Train::totalRemainingSpace() {
    int total = 0;
    for(TrainCar* pr = this->head; pr != NULL; pr = pr->next) {
        total += pr->remainingSpace;
    }
    return total;
}",1.0,11111
Singly_linked_list_7,1431570,2213248,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if(this->head != nullptr) {
        this->tail->next = new Node(e);
        this->tail = this->tail->next;
    }
    else {
        this->head = new Node(e);
        this->tail = this->head;
    }
    this->count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    Node** p = &this->head;
    while(index && (*p)) {
        p = &((*p)->next);
        index--;
    }
    (*p) = new Node(e, *p);
    this->count++;
    if((*p)->next == nullptr) this->tail = *p;
}

template<class T>
int SLinkedList<T>::size() {
    return this->count;
    //return 0;
}
",1.0,1111111111
Singly_linked_list_8,1431570,2213248,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index >= this->count)  throw std::out_of_range(""Segmentation fault!"");
    Node* temp = this->head;
    for(int i = 0; i < index; i++) {
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index >= this->count)  throw std::out_of_range(""Segmentation fault!"");
    Node* temp = this->head;
    for(int i = 0; i < index; i++) {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(count == 0) return 1;
    else return 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for(Node* temp = this->head; temp != nullptr; temp = temp->next) {
        if(temp->data == item) return index;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for(Node* temp = this->head; temp != nullptr; temp = temp->next) {
        if(temp->data == item) return true;
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1431570,2213248,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(index >= this->count)  throw std::out_of_range(""Segmentation fault!"");
    Node** p = &this->head;
    Node* prev = nullptr;
    while(index) {
        prev = *p;
        p = &((*p)->next);
        index--;
    }
    Node* temp = *p;
    (*p) = (*p)->next;
    T value = temp->data;
    delete temp;
    this->count--;
    if(!(*p)) this->tail = prev;
    return value;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node** p = &(this->head);
    Node* prev = nullptr;
    while((*p)) {
        if((*p)->data == item) {
            Node* temp = *p;
            (*p) = (*p)->next;
            delete temp;
            this->count--;
            if(!(*p)) this->tail = prev;
            return 1;
        }
        prev = *p;
        p = &((*p)->next);
    }
    return 0;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node** p = &(this->head);
    while((*p)) {
        Node* temp = *p;
        (*p) = (*p)->next;
        delete temp;
    }
    this->count = 0;
}

",0.9,1111111111
Singly_linked_list_10,1431570,2213248,"LLNode* foldLinkedList(LLNode* head) {
    int size = 0;
    for(LLNode* pr = head; pr!= nullptr; pr = pr ->next) {
        size++;
    }
    LLNode* phead = nullptr;
    LLNode* pb = head;
    for(int i = 0; i < size/2; i++) {
        pb = pb -> next;
    }
    if(size % 2 != 0) {
        phead = new LLNode(pb->val);
        pb = pb->next;
    }
    int n = size/2;
    while(pb != nullptr) {
        LLNode* pa = head;
        for(int i = 0; i < n - 1; i++) {
            pa = pa->next;
        }
        LLNode** p = &(phead);
        while((*p)) {
            p = &((*p)->next);
        }
        (*p) = new LLNode(pa->val + pb->val);
        pb = pb->next;
        n--;
    }
    return phead;
}",1.0,1111111111
Singly_linked_list_11,1431570,2213248,"LLNode* replaceFirstGreater(LLNode* head) {
    for(LLNode* pr = head; pr != nullptr; pr = pr->next) {
        LLNode* p = pr->next;
        while(p != nullptr) {
            if(p->val > pr->val) {
                pr->val = p->val;
                break;
            }
            p = p->next;
        }
        if(p == nullptr) pr->val = 0;
    }
    return head;
}",1.0,1111111111
Singly_linked_list_12,1431570,2213248,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* newhead = nullptr;
    for(LLNode* pr = head; pr != nullptr; pr = pr->next) {
        newhead = new LLNode(pr->val, newhead);
    }
    head->clear();
    return newhead;
}",1.0,1111111111
Singly_linked_list_13,1431570,2213248,"LLNode* rotateLinkedList(LLNode* head, int k) {
    int size = 0;
    for(LLNode* pr = head; pr != nullptr; pr = pr->next) {
        size++;
    }
    if(size <= 1) {
        return head;
    }  
    else{
        k = k % size;
        for(int i = 0; i < k; i++) {
            LLNode** pr = &head;
            while((*pr)->next) {
                pr = &((*pr)->next);
            }
            (*pr)->next = head;
            head = (*pr);
            (*pr) = nullptr;
        }
        return head;
    }
}",1.0,1111111111
Singly_linked_list_14,1431570,2213248,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    Node* prel = this->head;
    Node* afth = this->head;
    for(int i = 0; i < low - 1; i++) {
        prel = prel->next;
    }
    for(int i = 0; afth != nullptr && i <= high; i++) {
        afth = afth->next;
    }
    int delete_count = 0;
    for(Node* pr = prel->next; pr != afth; ) {
        Node* temp = pr;
        pr = pr->next;
        delete temp;
        delete_count++;
    }
    if(low <= 0) {
        Node* temp = this->head;
        this->head = nullptr;
        delete temp;
    }
    if(head) {
        head->next = linked_list->head;
    }
    else head = linked_list->head;
    linked_list->tail->next = afth;
    if(!afth)  this->tail = linked_list->tail;
    this->size = this->size - delete_count + linked_list->size;
}",0.8,10111
Singly_linked_list_1,1431705,2211170,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
            LLNode* dummyHead = new LLNode(0);
        LLNode* curr = dummyHead;
        int carry = 0;
        while (l0 != NULL || l1 != NULL || carry != 0) {
            int x = l0 ? l0->val : 0;
            int y = l1 ? l1->val : 0;
            int sum = carry + x + y;
            carry = sum / 10;
            curr->next = new LLNode(sum % 10);
            curr = curr->next;
            l0 = l0 ? l0->next : nullptr;
            l1 = l1 ? l1->next : nullptr;
        }
        return dummyHead->next;
}",1.0,111111111111111
Singly_linked_list_2,1431705,2211170,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if (term.coeff != 0){
        if (terms->size() == 0 || terms->get(terms->size() - 1).exp > term.exp)
        terms->add(term);
    else{
        int i = 0;
        SLinkedList<Term>::Iterator it;
        for (it = this->terms->begin(); it !=this->terms->end(); it++){
            if (term.exp == (*it).exp){
                if (term.coeff + (*it).coeff == 0) it.remove();
                else it.set(Term(term.coeff + (*it).coeff, term.exp));
                break;
            }
        
            if (term.exp > (*it).exp){
            terms->add(i, term);
            break;
        }
        i++;
    }
    }
}
    
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff, exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_4,1431705,2211170,"void LinkedList::partition(int k) {
    Node* group1Head = nullptr;
    Node* group1Tail = nullptr;
    Node* group2Head = nullptr;
    Node* group2Tail = nullptr;
    Node* group3Head = nullptr;
    Node* group3Tail = nullptr;

    Node* current = head;

    while (current != nullptr) {
        Node* nextNode = current->next;
        current->next = nullptr;

        if (current->value < k) {
            if (group1Head == nullptr) {
                group1Head = current;
                group1Tail = current;
            } else {
                group1Tail->next = current;
                group1Tail = current;
            }
        } else if (current->value == k) {
            if (group2Head == nullptr) {
                group2Head = current;
                group2Tail = current;
            } else {
                group2Tail->next = current;
                group2Tail = current;
            }
        } else {
            if (group3Head == nullptr) {
                group3Head = current;
                group3Tail = current;
            } else {
                group3Tail->next = current;
                group3Tail = current;
            }
        }

        current = nextNode;
    }

    head = nullptr;
    tail = nullptr;
    size = 0;

    if (group1Head != nullptr) {
        head = group1Head;
        tail = group1Tail;
        size += group1Tail->value - group1Head->value + 1;
    }

    if (group2Head != nullptr) {
        if (head == nullptr) {
            head = group2Head;
            tail = group2Tail;
            size += group2Tail->value - group2Head->value + 1;
        } else {
            tail->next = group2Head;
            tail = group2Tail;
            size += group2Tail->value - group2Head->value + 1;
        }
    }

    if (group3Head != nullptr) {
        if (head == nullptr) {
            head = group3Head;
            tail = group3Tail;
            size += group3Tail->value - group3Head->value + 1;
        } else {
            tail->next = group3Head;
            tail = group3Tail;
            size += group3Tail->value - group3Head->value + 1;
        }
    }
}",0.6,10110
Singly_linked_list_5,1431705,2211170,"void reduceDuplicate(Node* root)
 {
    if (root == nullptr)
        return;

    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicate = current->getNext();
            current->setNext(duplicate->getNext());
            delete duplicate;
        } else {
            current = current->getNext();
        }
    }
}
",1.0,1111111111
Singly_linked_list_6,1431705,2211170,"
int Train::allocate(int containerSize) {
    TrainCar* current = head->next;
    int index = 1;
    int minIndex = -1;
    int minRemainingSpace = 1000000; // A large enough value as a placeholder

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize && current->remainingSpace < minRemainingSpace) {
            minIndex = index;
            minRemainingSpace = current->remainingSpace;
        }
        current = current->next;
        index++;
    }

    if (minIndex != -1) {
        current = head->next;
        for (int i = 1; i < minIndex; i++) {
            current = current->next;
        }
        current->remainingSpace -= containerSize;
    }

    return minIndex;
}

int Train::totalRemainingSpace() {
    int sum = 0;
    TrainCar* current = head->next;

    while (current != nullptr) {
        sum += current->remainingSpace;
        current = current->next;
    }

    return sum;
}
",1.0,11111
Singly_linked_list_7,1431705,2211170,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
        Node* newNode = new Node(e, nullptr);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
        if (index < 0 || index > count) {
        throw out_of_range(""Index out of range"");
    }

    if (index == count) {
        add(e);
        return;
    }

    Node* newNode = new Node(e, nullptr);
    if (index == 0) {
        newNode->next = head;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Singly_linked_list_8,1431705,2211170,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
        if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw out_of_range(""Index out of range"");
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
        return count == 0;
        
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
        Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
        return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1431705,2211170,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
        if (index < 0 || index >= count) {
        throw out_of_range(""Index out of range"");
    }

    T removedData;
    if (index == 0) {
        Node* removedNode = head;
        removedData = removedNode->data;
        head = head->next;
        delete removedNode;
        if (count == 1) {
            tail = nullptr;
        }
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        Node* removedNode = current->next;
        removedData = removedNode->data;
        current->next = removedNode->next;
        delete removedNode;
        if (index == count - 1) {
            tail = current;
        }
    }
    count--;
    return removedData;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
        if (head == nullptr) {
        return false;
    }

    if (head->data == item) {
        Node* removedNode = head;
        head = head->next;
        delete removedNode;
        count--;
        if (count == 0) {
            tail = nullptr;
        }
        return true;
    }

    Node* current = head;
    while (current->next != nullptr) {
        if (current->next->data == item) {
            Node* removedNode = current->next;
            current->next = removedNode->next;
            delete removedNode;
            count--;
            if (current->next == nullptr) {
                tail = current;
            }
            return true;
        }
        current = current->next;
    }

    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
        Node* current = head;
    while (current != nullptr) {
        Node* next = current->next;
        delete current;
        current = next;
    }
    head = nullptr;
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1431705,2211170,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* curr = head;

    while (curr != nullptr) {
        LLNode* nextNode = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextNode;
    }

    return prev;
}

LLNode* findMiddleNode(LLNode* head) {
    LLNode* slow = head;
    LLNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow;
}

LLNode* mergeNodes(LLNode* node1, LLNode* node2) {
    if (node1 == nullptr)
        return node2;
    if (node2 == nullptr)
        return node1;

    LLNode* mergedHead = nullptr;
    LLNode* mergedTail = nullptr;

    while (node1 != nullptr && node2 != nullptr) {
        int sum = node1->val + node2->val;
        LLNode* newNode = new LLNode(sum, nullptr);

        if (mergedHead == nullptr) {
            mergedHead = newNode;
            mergedTail = newNode;
        } else {
            mergedTail->next = newNode;
            mergedTail = newNode;
        }

        node1 = node1->next;
        node2 = node2->next;
    }

    if (node1 != nullptr)
        mergedTail->next = node1;
    if (node2 != nullptr)
        mergedTail->next = node2;

    return mergedHead;
}

LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr)
        return head;

    LLNode* slow = head;
    LLNode* fast = head->next;

    // Move the 'slow' pointer to the middle node
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    LLNode* secondHalf = slow->next;
    slow->next = nullptr;

    secondHalf = reverseLinkedList(secondHalf);
    head = mergeNodes(head, secondHalf);

    // Reverse the resulting folded list
    head = reverseLinkedList(head);

    return head;
}",1.0,1111111111
Singly_linked_list_11,1431705,2211170,"LLNode* replaceFirstGreater(LLNode* head) {
    if (head == nullptr)
        return nullptr;

    std::stack<LLNode*> st;
    LLNode* curr = head;

    // Traverse the list to find the first greater node for each node
    while (curr != nullptr) {
        while (!st.empty() && st.top()->val < curr->val) {
            st.top()->val = curr->val;
            st.pop();
        }
        st.push(curr);
        curr = curr->next;
    }

    // Set the value of remaining nodes to 0
    while (!st.empty()) {
        st.top()->val = 0;
        st.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1431705,2211170,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* curr = head;

    while (curr != nullptr) {
        LLNode* nextNode = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextNode;
    }

    return prev;
}",1.0,1111111111
Singly_linked_list_13,1431705,2211170,"int getLength(LLNode* head) {
    int length = 0;
    LLNode* curr = head;
    while (curr != nullptr) {
        length++;
        curr = curr->next;
    }
    return length;
}

LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || k <= 0)
        return head;

    int length = getLength(head);
    k = k % length; // Adjust k if it's larger than the length of the list

    if (k == 0)
        return head;

    LLNode* curr = head;
    LLNode* prev = nullptr;

    // Traverse to the kth node from the end
    int steps = length - k;
    while (steps > 0) {
        prev = curr;
        curr = curr->next;
        steps--;
    }

    // Update the pointers to rotate the list
    prev->next = nullptr;
    LLNode* newHead = curr;

    // Traverse to the end of the list and connect it to the original head
    while (curr->next != nullptr) {
        curr = curr->next;
    }
    curr->next = head;

    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1431705,2211170,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (low <= high && high >= 0) {
        // Adjust low and high if they exceed the size of the linked list
        if (low < 0)
            low = 0;
        if (high >= size)
            high = size - 1;

        Node* curr = head;
        Node* prev = nullptr;
        int position = 0;

        // Traverse to the node at position low
        while (curr != nullptr && position < low) {
            prev = curr;
            curr = curr->next;
            position++;
        }

        // Delete nodes from position low to position high
        int deleteCount = high - low + 1;
        while (curr != nullptr && deleteCount > 0) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
            deleteCount--;
            size--;
        }

        // Connect the replaced linked list
        if (prev != nullptr)
            prev->next = linked_list->head;
        else
            head = linked_list->head;

        if (linked_list->tail != nullptr)
            linked_list->tail->next = curr;
        else
            tail = curr;

        // Update the size of this linked list
        size = size - (high - low + 1) + linked_list->size;
    }
}",0.4,110
Singly_linked_list_1,1432029,2211878,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* dummy = new LLNode(0);
    LLNode* curr = dummy;
    int carry = 0;
    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;
        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        carry = sum / 10;
        curr->next = new LLNode(sum % 10);
        curr = curr->next;
    }
    return dummy->next;
}
",1.0,111111111111111
Singly_linked_list_2,1432029,2211878,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    SLinkedList<Term>::Iterator it;
    int index = 0;
    if(term.coeff){
    for (it = this->terms->begin(); it != this->terms->end(); it++, index++) {
        if ((*it).exp == term.exp) {
            (*it).coeff += term.coeff;
            if((*it).coeff==0) this->terms->removeAt(index);
            return;
        }
        else if((*it).exp < term.exp){
            this->terms->add(index,term);
            return;
        }
    }
    this->terms->add(term);
    }
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term term(coeff,exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_3,1432029,2211878,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList=pList;
    if(begin){
        if(pList){
            this->current=pList->head;
            this->index=0;
        }
        else{
            this->current=NULL;
            this->index=-1;
        }
    }
    else {
        this->current=NULL;
        if(pList!=NULL) this->index=pList->size();
        else this->index=0;
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current=iterator.current;
    this->index=iterator.index;
    this->pList=iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    else
    {
        pList->removeAt(index);
        if (index != 0)
        {
            Node* temp = pList->head;
            int tempIndex = 0;
            while (tempIndex < index - 1)
            {
                temp = temp->next;
                tempIndex++;
            }
            current = temp;
            index--;
        }
        else
        {
            current = NULL;
            index = -1;
        }
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    else this->current->data=e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(this->current==NULL) throw std::out_of_range(""Segmentation fault!"");
    else return this->current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if(this->current==iterator.current&&this->index==iterator.index) return false;
    return true;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    
    if (current == NULL && index != 0)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current = current->next;
        index++;
        return *this;
    }
}

// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator *tmp=this;
    if(this->current==NULL){
        throw std::out_of_range(""Segmentation fault!"");
    }
    this->current=this->current->next;
    this->index+=1;
    return *tmp;
}",1.0,11111
Singly_linked_list_4,1432029,2211878,"void LinkedList::partition(int k) {
    Node* smallerHead = NULL;
    Node* smallerTail = NULL;
    Node* equalHead = NULL;
    Node* equalTail = NULL;
    Node* greaterHead = NULL;
    Node* greaterTail = NULL;

    Node* curr = this->head;
    while (curr != NULL) {
        if (curr->value < k) {
            if (smallerHead == NULL) {
                smallerHead = curr;
                smallerTail = curr;
            } else {
                smallerTail->next = curr;
                smallerTail = curr;
            }
        } else if (curr->value == k) {
            if (equalHead == NULL) {
                equalHead = curr;
                equalTail = curr;
            } else {
                equalTail->next = curr;
                equalTail = curr;
            }
        } else {
            if (greaterHead == NULL) {
                greaterHead = curr;
                greaterTail = curr;
            } else {
                greaterTail->next = curr;
                greaterTail = curr;
            }
        }
        curr = curr->next;
    }

    if (smallerHead == NULL) {
        this->head = equalHead;
        equalTail->next = greaterHead;
    } else {
        this->head = smallerHead;
        smallerTail->next = equalHead;

        if (equalHead == NULL) {
            smallerTail->next = greaterHead;
        } else {
            equalTail->next = greaterHead;
        }
    }

    if (greaterHead == NULL) {
        this->tail = equalTail != NULL ? equalTail : smallerTail;
    } else {
        this->tail = greaterTail;
    }

    if (this->tail != NULL) {
        this->tail->next = NULL;
    }
}",1.0,11111
Singly_linked_list_5,1432029,2211878,"void reduceDuplicate(Node* root) {
    Node* current = root;
    while (current && current->getNext()) {
        if (current->getData() == current->getNext()->getData()) {
            Node* temp = current->getNext();
            current->setNext(temp->getNext());
            delete temp;
        } else {
            current = current->getNext();
        }
    }
}
",1.0,1111111111
Singly_linked_list_7,1432029,2211878,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e, nullptr);
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    count++;
    
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
            throw std::out_of_range(""Index out of range"");
        }
        if (index == count) {
            add(e);
            return;
        }
        Node* newNode = new Node(e, nullptr);
        if (index == 0) {
            newNode->next = head;
            head = newNode;
        } else {
            Node* current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current->next;
            }
            newNode->next = current->next;
            current->next = newNode;
        }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1432029,2211878,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
     if (index < 0 || index >= count) {
            throw std::out_of_range(""Index out of range"");
        }
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
            throw std::out_of_range(""Index out of range"");
        }
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
        for (int i = 0; i < count; i++) {
            if (current->data == item) {
                return i;
            }
            current = current->next;
        }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1432029,2211878,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count)
        throw out_of_range(""Index out of range."");

    Node *current = head;
    Node *previous = nullptr;
    T removedValue;

    if (index == 0)
    {
        removedValue = head->data;
        head = head->next;
        delete current;
    }
    else
    {
        for (int i = 0; i < index; i++)
        {
            previous = current;
            current = current->next;
        }

        removedValue = current->data;
        previous->next = current->next;
        if (current == tail)
            tail = previous;
        delete current;
    }

    count--;
    return removedValue;

}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *current = head;
    Node *previous = nullptr;

    while (current != nullptr)
    {
        if (current->data == item)
        {
            if (previous == nullptr) // first element in the list
            {
                head = current->next;
                if (current == tail)
                    tail = nullptr;
            }
            else
            {
                previous->next = current->next;
                if (current == tail)
                    tail = previous;
            }

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;

}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node *current = head;
    while (current != nullptr)
    {
        Node *next = current->next;
        delete current;
        current = next;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_11,1432029,2211878,"LLNode* replaceFirstGreater(LLNode* head) {
    if (head == nullptr) {
        return nullptr;
    }
    
    stack<LLNode*> stack;
    stack.push(head);
    
    LLNode* current = head->next;
    
    while (current != nullptr) {
        while (!stack.empty() && current->val > stack.top()->val) {
            stack.top()->val = current->val;
            stack.pop();
        }
        
        stack.push(current);
        current = current->next;
    }
    
    while (!stack.empty()) {
        stack.top()->val = 0;
        stack.pop();
    }
    
    return head;
}",1.0,1111111111
Singly_linked_list_12,1432029,2211878,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* curr = head;
    LLNode* next = nullptr;

    while (curr != nullptr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}
",1.0,1111111111
Singly_linked_list_13,1432029,2211878,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || k <= 0) {
        return head;
    }
    
    LLNode* current = head;
    int count = 1;
    
    while (current->next != nullptr) {
        current = current->next;
        count++;
    }
    
    current->next = head;
    
    k = k % count;
    
    for (int i = 0; i < count - k; i++) {
        current = current->next;
    }
    
    head = current->next;
    current->next = nullptr;  // Break the circular link
    
    return head;
}
",1.0,1111111111
Singly_linked_list_14,1432029,2211878,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (low < 0) {
        low = 0;
    }
    if (high >= size) {
        high = size - 1;
    }
    Node* current = head;
    Node* prev = nullptr;
    int index = 0;
    
    while (current != nullptr && index < low) {
        prev = current;
        current = current->next;
        index++;
    }
    
    while (current != nullptr && index <= high) {
        Node* next = current->next;
        delete current;
        current = next;
        index++;
    }
    
    if (prev != nullptr) {
        prev->next = current;
    } else {
        head = current;
    }
    if (low - 1 < 0) {
        Node* linked_list_tail = linked_list->tail;
        
        if (linked_list_tail != nullptr) {
            linked_list_tail->next = head;
            head = linked_list->head;
        }
    } else {
        Node* insert_after = head;
        index = 0;
        
        while (insert_after != nullptr && index < low - 1) {
            insert_after = insert_after->next;
            index++;
        }
        
        // Insert nodes from linked_list after insert_after
        Node* linked_list_tail = linked_list->tail;
        
        if (linked_list_tail != nullptr) {
            linked_list_tail->next = insert_after->next;
            insert_after->next = linked_list->head;
        }
    }
}
",0.4,110
Singly_linked_list_1,1432125,1913560,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* dummy = new LLNode();
    LLNode* curr = dummy;
    int carry = 0;

    while (l0 || l1 || carry) {
        int sum = carry;

        if (l0) {
            sum += l0->val;
            l0 = l0->next;
        }

        if (l1) {
            sum += l1->val;
            l1 = l1->next;
        }

        carry = sum / 10;
        curr->next = new LLNode(sum % 10);
        curr = curr->next;
    }

    return dummy->next;
}",1.0,111111111111111
Singly_linked_list_4,1432125,1913560,"void LinkedList::partition(int k) {
    if (head == NULL || head->next == NULL)
        return;

    Node* group1Head = NULL;
    Node* group1Tail = NULL;
    Node* group2Head = NULL;
    Node* group2Tail = NULL;
    Node* group3Head = NULL;
    Node* group3Tail = NULL;

    Node* current = head;

    while (current != NULL) {
        Node* nextNode = current->next;
        if (current->value < k) {
            if (group1Head == NULL) {
                group1Head = current;
                group1Tail = current;
            } else {
                group1Tail->next = current;
                group1Tail = current;
            }
        } else if (current->value == k) {
            if (group2Head == NULL) {
                group2Head = current;
                group2Tail = current;
            } else {
                group2Tail->next = current;
                group2Tail = current;
            }
        } else {
            if (group3Head == NULL) {
                group3Head = current;
                group3Tail = current;
            } else {
                group3Tail->next = current;
                group3Tail = current;
            }
        }
        current->next = NULL;
        current = nextNode;
    }

    // Connect the groups together
    if (group1Head != NULL) {
        head = group1Head;
        if (group2Head != NULL) {
            group1Tail->next = group2Head;
            if (group3Head != NULL) {
                group2Tail->next = group3Head;
                tail = group3Tail;
            } else {
                tail = group2Tail;
            }
        } else {
            if (group3Head != NULL) {
                group1Tail->next = group3Head;
                tail = group3Tail;
            } else {
                tail = group1Tail;
            }
        }
    } else {
        if (group2Head != NULL) {
            head = group2Head;
            if (group3Head != NULL) {
                group2Tail->next = group3Head;
                tail = group3Tail;
            } else {
                tail = group2Tail;
            }
        } else {
            head = group3Head;
            tail = group3Tail;
        }
    }
}",1.0,11111
Singly_linked_list_5,1432125,1913560,"void reduceDuplicate(Node* root) {
    if (root == nullptr)
        return;

    Node* current = root;

    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* temp = current->getNext();
            current->setNext(temp->getNext());
            delete temp;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1432125,1913560,"//int Train::allocate(int containerSize) {
//     TrainCar* current = head->next;
//     int index = 1;
//     int temp = current->remainingSpace;
//     int count = 1;

//     while (current != NULL) {
//         if (current->remainingSpace >= containerSize) {
//             temp = min(temp, current->remainingSpace);
//             count = index;
//             current = current->next;
//             index++;
//             if (current == NULL) {
//                 current = head;
//                 index = 0;
//             }
//             while (index < count) {
//                 index += 1;
//                 current = current->next;
//             }
//             current->remainingSpace -= containerSize;
//         }
//     }

//     return -1;
// }

int Train::allocate(int containerSize) {
    TrainCar* current = head->next;
    int index = 1;

    while (current != nullptr) {
        if (current->remainingSpace >= containerSize) {
            current->remainingSpace -= containerSize;
            return index;
        }
        current = current->next;
        index++;
    }

    return -1;
}

// int Train::allocate(int containerSize) {
//     TrainCar* current = head->next;
//     int index = 1;
//     int foundIndex = -1;
//     int minRemainingSpace = -1;

//     while (current != NULL) {
//         if (current->remainingSpace >= containerSize && current->remainingSpace < minRemainingSpace) {
//             foundIndex = index;
//             minRemainingSpace = current->remainingSpace;
//         }

//         current = current->next;
//         index++;
//     }

//     if (foundIndex != -1) {
//         current = head;
//         for (int i = 0; i < foundIndex; i++) {
//             current = current->next;
//         }
//         current->remainingSpace -= containerSize;
//     }

//     return foundIndex;
// }

int Train::totalRemainingSpace() {
    int total = 0;
    TrainCar* current = head->next;

    while (current != NULL) {
        total += current->remainingSpace;
        current = current->next;
    }

    return total;
}",0.2,00000
Singly_linked_list_7,1432125,1913560,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* pNew= new Node(e,NULL);
    if(this->count==0)
    {
        this->head=pNew;
        this->tail=pNew;
        this->count+=1;
    }
    else
    {
        tail->next=pNew;
        this->tail=pNew;
        this->count+=1;
    }
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    Node* pNew= new Node(e,NULL);
    if(index==count)
    {
        this->add(e);
    }
    else if(index==0)
    {
        
        pNew->next=head;
        this->head=pNew;
        this->count+=1;
        
    }
    else
    {
        Node* temp=this->head;
        for(int i=0;i<count;i++)
        {
            if(i==index-1)
            {
                pNew->next=temp->next;
                temp->next=pNew;
                count+=1;
                break;
            }
            temp=temp->next;
        }
    }
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1432125,1913560,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    Node* cur = this->head;
    for(int i=0;i<index && cur;i++) cur = cur->next;
    if(cur) return cur->data;
    return -1;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    Node* cur = this->head;
    for(int i=0;i<index && cur;i++) cur = cur->next;
    if(cur) cur->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (this->count == 0);
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if(this->count == 0) return -1;
    else if(this->count == 1){
        if(this->head->data == item) return 0;
        else return -1;
    }
    else{
        Node* cur = this->head;
        for(int i=0;cur;i++){
            if(cur->data == item) return i;
            cur = cur->next;
        }
        return -1;
    }
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return(this->indexOf(item) != -1);
}",1.0,1111111111
Singly_linked_list_9,1432125,1913560,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Invalid index"");
    }
    
    Node* del = head;
    T removedValue;
    
    if (index == 0) {
        head = head->next;
        if (head == nullptr) {
            tail = nullptr;
        }
        removedValue = del->data;
        delete del;
        del = nullptr;
    } else {
        Node* pre = nullptr;
        for (int i = 0; i < index; i++) {
            pre = del;
            del = del->next;
        }
        
        pre->next = del->next;
        if (del == tail) {
            tail = pre;
        }
        removedValue = del->data;
        delete del;
        del = nullptr;
    }
    
    count--;
    return removedValue;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* del = head;
    Node* pre = nullptr;
    if (del != nullptr && del->data == item) {
        head = del->next;
        if (head == nullptr) {
            tail = nullptr;
        }
        delete del;
        del = nullptr;
        count--;
        return true;
    }
    
    while (del != nullptr && del->data != item) {
        pre = del;
        del = del->next;
    }
    
    if (del == nullptr) {
        return false;
    }
    
    pre->next = del->next;
    if (del == tail) {
        tail = pre;
    }
    
    delete del;
    del = nullptr;
    count--;
    return true;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* current = head;
    while (current != nullptr) {
        Node* nextNode = current->next;
        delete current;
        current = nextNode;
    }
    head = nullptr;
    tail = nullptr;
    count = 0;
}

",0.75,1111111111
Singly_linked_list_10,1432125,1913560,"LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    
    // Find the middle node of the linked list
    LLNode* slow = head;
    LLNode* fast = head;
    LLNode* prev = nullptr;
    
    while (fast != nullptr && fast->next != nullptr) {
        prev = slow;
        slow = slow->next;
        fast = fast->next->next;
    }
    
    // Split the linked list into two halves
    prev->next = nullptr;
    
    // Reverse the second half of the linked list
    LLNode* current = slow;
    LLNode* nextNode = nullptr;
    LLNode* prevNode = nullptr;
    
    while (current != nullptr) {
        nextNode = current->next;
        current->next = prevNode;
        prevNode = current;
        current = nextNode;
    }
    
    // Merge the intersecting nodes by taking their sum
    LLNode* first = head;
    LLNode* second = prevNode;
    
    while (second != nullptr) {
        LLNode* firstNext = first->next;
        LLNode* secondNext = second->next;
        
        first->next = second;
        second->next = firstNext;
        
        first = firstNext;
        second = secondNext;
    }
    
    return head;
}",0.1,0
Singly_linked_list_11,1432125,1913560,"LLNode* replaceFirstGreater(LLNode* head) {
    if (head == nullptr) {
        return nullptr;
    }
    
    // Create a stack to store nodes in descending order of values
    std::stack<LLNode*> nodeStack;
    LLNode* current = head;
    
    // Traverse the linked list
    while (current != nullptr) {
        // Compare the current node's value with the values of nodes in the stack
        while (!nodeStack.empty() && nodeStack.top()->val < current->val) {
            // Replace the value of the top node in the stack with the current node's value
            nodeStack.top()->val = current->val;
            nodeStack.pop();
        }
        
        // Push the current node into the stack
        nodeStack.push(current);
        current = current->next;
    }
    
    // Set the value of remaining nodes in the stack to 0
    while (!nodeStack.empty()) {
        nodeStack.top()->val = 0;
        nodeStack.pop();
    }
    
    return head;
}",1.0,1111111111
Singly_linked_list_12,1432125,1913560,"LLNode* reverseLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    
    LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* next = nullptr;
    
    while (current != nullptr) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    
    return prev;
}",1.0,1111111111
Singly_linked_list_13,1432125,1913560,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || head->next == nullptr || k <= 0) {
        return head;
    }
    
    // Calculate the length of the linked list
    int length = 1;
    LLNode* tail = head;
    while (tail->next != nullptr) {
        tail = tail->next;
        length++;
    }
    
    // Adjust the value of k to be within the range [0, length)
    k = k % length;
    if (k == 0) {
        return head;
    }
    
    // Find the new head and tail nodes after rotation
    int stepsToNewHead = length - k;
    LLNode* newTail = head;
    for (int i = 1; i < stepsToNewHead; i++) {
        newTail = newTail->next;
    }
    LLNode* newHead = newTail->next;
    
    // Perform the rotation
    newTail->next = nullptr;
    tail->next = head;
    
    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1432125,1913560,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    if (low > high || high < 0) {
        return;
    }
    
    // Delete elements in the specified range
    Node* prev = nullptr;
    Node* current = head;
    int count = 0;
    
    while (current != nullptr && count < low) {
        prev = current;
        current = current->next;
        count++;
    }
    
    while (current != nullptr && count <= high) {
        Node* nextNode = current->next;
        delete current;
        current = nextNode;
        count++;
    }
    
    if (prev == nullptr) {
        head = current;
    } else {
        prev->next = current;
    }
    
    if (current == nullptr) {
        tail = prev;
    }
    
    // Insert linked_list into the specified position
    if (prev == nullptr) {
        linked_list->tail->next = head;
        head = linked_list->head;
    } else {
        linked_list->tail->next = current;
        prev->next = linked_list->head;
    }
    
    if (tail == nullptr || high >= size) {
        tail = linked_list->tail;
    }
    
    size += linked_list->size;
}",1.0,11111
Singly_linked_list_1,1432409,2212988,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    // STUDENT ANSWER
    LLNode* head = new LLNode(0,nullptr);
    LLNode*tail = head;
    int carry = 0;
    while(l0!=nullptr || l1!=nullptr|| carry!=0){
        int digit0 = l0!=nullptr ? l0->val: 0;
        int digit1 = l1!=nullptr ? l1->val: 0;
        int val = digit0+digit1+carry;
        carry = val/10;
        val = val%10;
        LLNode* temp = new LLNode(val,nullptr);
        tail->next = temp;
        tail = temp;
        l0=l0!=nullptr ? l0->next: nullptr; 
        l1=l1!=nullptr ? l1->next: nullptr;
    }
    return head->next;
}",1.0,111111111111111
Singly_linked_list_2,1432409,2212988,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
    if(term.coeff == 0) return;
    SLinkedList<Term>::Iterator it;
    int index = 0;
    for(it = this->terms->begin();it!=this->terms->end();it++,index++){
        if(term.exp > (*it).exp ){
            this->terms->add(index,term);
            return;
        }
        else if((*it).exp == term.exp){
            (*it).coeff += term.coeff;
            if((*it).coeff == 0){
                this->terms->removeAt(index);
                
            }
            return;
        }
        
    }
    
    this->terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
    Term temp(coeff,exp);
    insertTerm(temp);
}",1.0,11111
Singly_linked_list_3,1432409,2212988,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin == true){
         if(pList != nullptr) {
        current  = pList->head;
            index = 0;
        }
        else {
            current = nullptr;
            index = -1;
        }
    
    }
    else{
        current =nullptr;
        if(pList == nullptr ){
            index = 0;
        }
        else {
            index = pList->size();
        }
    }
    
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
    
}
// sử dụng removeAt
template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(current == nullptr){
        throw std::out_of_range(""segmentation fault!"");
    }
    Node* temp = pList->head;
    if (pList->head == current) {
                pList->removeAt(0); // sử dụng removeAt
                current = nullptr;
                index = -1;
                return;
    }
    
    while(temp->next!=current){
        temp=temp->next;
    }
    pList->removeAt(index); // sử dụng removeAt
    current = temp;
    index--;
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == nullptr){
        throw std:: out_of_range(""Segmentation fault!"");
    }
    current->data= e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == nullptr){
        throw std:: out_of_range(""Segmentation fault!"");
    }
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    return (this->current != iterator.current || this->index != iterator.index);
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(!current){
        throw std:: out_of_range(""Segmentation fault!"");
    }
    
    if(index == -1){
        
        current =pList-> head;
    }
    else{
    current = current->next;
    }
    index++;
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    Iterator temp = *this;  
    ++(*this);  
    return temp;
}",1.0,11111
Singly_linked_list_4,1432409,2212988,"void LinkedList::partition(int k) {
    if(!head || !head->next) return;
    
    Node* head1 = nullptr;
    Node* head2 = nullptr;
    Node* head3 = nullptr;
    Node* tail1 = nullptr;
    Node* tail2 = nullptr;
    Node* tail3 = nullptr;
    Node* current = head;
    
    while(current!=nullptr){
        Node* p = new Node(current->value,nullptr);
        if(p->value < k){
            if(!head1 ){
                head1=p;
                tail1=p;
            }
            else{
                tail1->next = p;
                tail1=p;
            }
        }
        else if(p->value == k){
            if(!head2 ){
                head2=p;
                tail2=p;
            }
            else{
                tail2->next = p;
                tail2=p;
            }
        }
        else{
            if(!head3 ){
                head3=p;
                tail3=p;
            }
            else{
                tail3->next = p;
                tail3=p;
            }
        }
        // nooi 3 group lai
        if(tail1){
            if(tail2){
                tail1->next = head2;
                tail2->next = head3;
                
            }
            else{
                tail1->next = head3;
            }
            this->head = head1;
        }
        else if(tail2){
            tail2->next = head3;
            this->head = head2;
        }
        else
        {
            this->head = head3;
        }
        current=current->next;
    }
    if(tail3){
        this->tail = tail3;
        this->tail->next =nullptr;
    }
    else if(tail2){
        this->tail = tail2;
        this->tail->next =nullptr;
    }
    else {this->tail = tail1;
        this->tail->next =nullptr;
    }
}",1.0,11111
Singly_linked_list_7,1432409,2212988,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* temp = new Node(e, NULL);
    if( head  == nullptr) {
        head = temp;
        tail = temp;
    }
    else {
        tail -> next = temp;
        tail = temp;
    }
    
    count ++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    // Insert an element into the list at given index. 
    Node* temp = new Node(e, NULL);
    
    if( index == 0 ){
            temp -> next = head;
            head = temp;
        if(count == 0) {
            tail = temp;
        }
    }
    else {
        Node* p = head;
        for(int i = 0; i < index - 1; i++) {
            p = p -> next;
        }
        temp -> next = p -> next;
        p -> next = temp;
        if(index == count) {
            tail = temp;
        }
    }
    count ++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1432409,2212988,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index <0 || index >= count){
        throw std::out_of_range(""-1"");
    }
    Node* temp = head;
    for (int i = 0; i < index; i++) {
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index <0 || index >= count){
        throw std::out_of_range(""-1"");
    }
    Node* temp = head;
    for (int i = 0; i < index; i++) {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    for (int i = 0; i < count; i++) {
        if (current->data == item) {
            return i;
        }
        current = current->next;
    }
    return -1;
    
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) !=-1;
    
}
",1.0,1111111111
Singly_linked_list_9,1432409,2212988,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(index < 0 || index >= count) {
        throw std::out_of_range(""-1"");
    }
    Node* current = head;
    if(index == 0){
        T value = head->data;
        head = head->next;
        delete current;
        count --;
        return value;
    }
    for(int i= 0;i<index-1;i++){
        current = current->next;
    }
    Node* p = current ->next;
    
    current->next = (p->next ==nullptr) ? nullptr:p->next;
    T value = p->data;
    if(current ->next == nullptr){
        tail = current;
    }
    delete p;
    count --;
    return value;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
  
    for(int i = 0; i<count ; i++){
        if(current->data == item){
            removeAt(i);
            return true;
        }
        current = current->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Singly_linked_list_12,1432409,2212988,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if(head == nullptr) return nullptr;
    LLNode* temp = head;
    LLNode* tempHead = new LLNode(temp->val,nullptr);
    temp = temp->next;
    while(temp!=nullptr){
        LLNode* p = new LLNode(temp->val,tempHead);
        tempHead = p;
        temp= temp->next;
    }
    return tempHead;
}
",1.0,1111111111
Singly_linked_list_13,1432409,2212988,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    if(head == nullptr||k==0) return head;
    int count = 1;
    LLNode* temp = head;
    while(temp->next != nullptr){
        temp = temp->next;
        count ++;
    }
    if(k== count) return temp;
    k=k%count;
    LLNode* newHead = head;
    LLNode* p = newHead;
    for(int i = 0; i< count - k;i++){
        p = newHead;
        newHead=newHead->next;
    }
    p->next = nullptr;
    LLNode*tail = newHead;
    while(tail->next !=nullptr){
        tail = tail->next;
    }
    tail->next = head;
    return newHead;
}
",1.0,1111111111
Singly_linked_list_1,1432650,2112585,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
 LLNode* dummy = new LLNode(0, NULL);
  LLNode* cur = dummy;
  int carry = 0;
  
  while (l0 != NULL || l1 != NULL || carry != 0) {
    int x = l0 ? l0->val : 0;
    int y = l1 ? l1->val : 0;
    int sum = x + y + carry;
    
    cur->next = new LLNode(sum % 10, NULL);
    cur = cur->next;
    
    carry = sum / 10;
    if (l0) l0 = l0->next;
    if (l1) l1 = l1->next;
  }
  
  return dummy->next; 
}",1.0,111111111111111
Singly_linked_list_4,1432650,2112585,"void LinkedList::partition(int k) {

}",0.2,00100
Singly_linked_list_5,1432650,2112585,"void reduceDuplicate(Node* root)
{
    if (root == nullptr) {
        return;
    }

    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* temp = current->getNext();
            current->setNext(temp->getNext());
            delete temp;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_7,1432650,2112585,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e, nullptr);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        throw std::out_of_range(""Invalid index"");
    }
    if (index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e, nullptr);
    if (index == 0) {
        newNode->next = head;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1432650,2112585,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Invalid index"");
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Invalid index"");
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1432650,2112585,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
     if (index < 0 || index >= count) {
        throw std::out_of_range(""Invalid index"");
    }
    T removedData;
    if (index == 0) {
        Node* removedNode = head;
        head = head->next;
        removedData = removedNode->data;
        delete removedNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        Node* removedNode = current->next;
        current->next = removedNode->next;
        removedData = removedNode->data;
        delete removedNode;
        if (index == count - 1) {
            tail = current;
        }
    }
    count--;
    return removedData;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
     Node* current = head;
    Node* previous = nullptr;
    while (current != nullptr) {
        if (current->data == item) {
            if (previous == nullptr) {
                head = current->next;
            } else {
                previous->next = current->next;
            }
            if (current == tail) {
                tail = previous;
            }
            delete current;
            count--;
            return true;
        }
        previous = current;
        current = current->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* current = head;
    while (current != nullptr) {
        Node* next = current->next;
        delete current;
        current = next;
    }
    head = nullptr;
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1432650,2112585,"LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    // Find the middle node of the linked list
    LLNode* slow = head;
    LLNode* fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // Reverse the second half of the linked list
    LLNode* prev = nullptr;
    LLNode* current = slow;
    while (current != nullptr) {
        LLNode* next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }

    // Merge the intersecting nodes by taking their sum
    LLNode* firstHalf = head;
    LLNode* secondHalf = prev;
    LLNode* result = nullptr;
    while (firstHalf != nullptr) {
        LLNode* temp = firstHalf->next;
        firstHalf->next = result;
        result = firstHalf;
        firstHalf = temp;
        if (secondHalf != nullptr) {
            result->val += secondHalf->val;
            secondHalf = secondHalf->next;
        }
    }

    return result;
}",0.1,0010000000
Singly_linked_list_11,1432650,2112585,"LLNode* replaceFirstGreater(LLNode* head) {
    if (head == nullptr) {
        return nullptr;
    }

    LLNode* current = head;
    while (current != nullptr) {
        LLNode* nextGreater = current->next;
        while (nextGreater != nullptr && nextGreater->val <= current->val) {
            nextGreater = nextGreater->next;
        }

        if (nextGreater != nullptr) {
            current->val = nextGreater->val;
        } else {
            current->val = 0;
        }

        current = current->next;
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1432650,2112585,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* current = head;
    while (current != nullptr) {
        LLNode* next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    return prev;
}",1.0,1111111111
Singly_linked_list_13,1432650,2112585,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || head->next == nullptr || k == 0) {
        return head;
    }

    // Calculate the length of the linked list
    int length = 1;
    LLNode* tail = head;
    while (tail->next != nullptr) {
        tail = tail->next;
        length++;
    }

    // Adjust the value of k to be within the range of the linked list length
    k = k % length;
    if (k == 0) {
        return head;
    }

    // Find the new head and tail of the rotated linked list
    LLNode* newTail = head;
    for (int i = 1; i < length - k; i++) {
        newTail = newTail->next;
    }
    LLNode* newHead = newTail->next;

    // Rotate the linked list
    newTail->next = nullptr;
    tail->next = head;

    return newHead;
}",1.0,1111111111
Singly_linked_list_1,1433443,2211876,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    int carry = 0;
    LLNode dummyHead; 
    LLNode* current = &dummyHead;

    while (l0 || l1 || carry) {
        int sum = carry;
        if (l0) {
            sum += l0->val;
            l0 = l0->next;
        }
        if (l1) {
            sum += l1->val;
            l1 = l1->next;
        }

        carry = sum / 10;
        current->next = new LLNode(sum % 10);
        current = current->next;
    }
    return dummyHead.next;
    // STUDENT ANSWER
}",1.0,111111111111111
Singly_linked_list_2,1433443,2211876,"void Polynomial::insertTerm(const Term& term) {
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    // STUDENT ANSWER
}",0.2,00010
Singly_linked_list_5,1433443,2211876,"void reduceDuplicate(Node* root)
{
    if (root == nullptr)
    {
        
        return;
    }

    Node* current = root;

    while (current->getNext() != nullptr)
    {
        if (current->getData() == current->getNext()->getData())
        {
            
            Node* duplicate = current->getNext();
            current->setNext(duplicate->getNext());
            delete duplicate; 
        }
        else
        {
           
            current = current->getNext();
        }
    }
}
",1.0,1111111111
Singly_linked_list_7,1433443,2211876,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e, nullptr);
        if (head == nullptr) {
           
            head = newNode;
            tail = newNode;
        } else {
            
            tail->next = newNode;
            tail = newNode;
        }
        count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
            
            cerr << ""Index out of bounds."" << endl;
            return;
        }

        if (index == count) {
            
            add(e);
        } else {
            Node* newNode = new Node(e, nullptr);
            if (index == 0) {
                
                newNode->next = head;
                head = newNode;
            } else {
              
                Node* current = head;
                for (int i = 0; i < index - 1; i++) {
                    current = current->next;
                }
                newNode->next = current->next;
                current->next = newNode;
            }
            count++;
        }
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1433443,2211876,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
     if (index < 0 || index >= count) {
            throw std::out_of_range(""Index out of range."");
        }

        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }

        return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
            throw std::out_of_range(""Index out of range."");
        }

        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }

        current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
        int index = 0;

        while (current != nullptr) {
            if (current->data == item) {
                return index;
            }
            current = current->next;
            index++;
        }

        return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Singly_linked_list_9,1433443,2211876,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
            throw std::out_of_range(""Index out of range."");
        }

        T removedValue;

        if (index == 0) {
            
            Node* temp = head;
            head = head->next;
            removedValue = temp->data;
            delete temp;
        } else {
            
            Node* current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current->next;
            }
            Node* temp = current->next;
            current->next = temp->next;
            removedValue = temp->data;
            delete temp;
        }

        count--;
        return removedValue;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
        Node* previous = nullptr;

        while (current != nullptr) {
            if (current->data == item) {
                if (previous == nullptr) {
                 
                    head = head->next;
                } else {
                    previous->next = current->next;
                }
                delete current;
                count--;
                return true;
            }
            previous = current;
            current = current->next;
        }

        return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
        tail = nullptr;
        count = 0;
}

",0.1,10
Singly_linked_list_10,1433443,2211876,"LLNode* reverse(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* current = head;
    while (current != nullptr) {
        LLNode* nextNode = current->next;
        current->next = prev;
        prev = current;
        current = nextNode;
    }
    return prev;
}

LLNode* merge(LLNode* first, LLNode* second) {
    LLNode* dummy = new LLNode();
    LLNode* current = dummy;

    while (first != nullptr || second != nullptr) {
        if (first != nullptr) {
            current->val += first->val;
            first = first->next;
        }
        if (second != nullptr) {
            current->val += second->val;
            second = second->next;
        }

        if (first != nullptr || second != nullptr) {
            current->next = new LLNode();
            current = current->next;
        }
    }

    LLNode* result = dummy->next;
    delete dummy;
    return result;
}
LLNode* foldLinkedList(LLNode* head) {
    // STUDENT ANSWER
    if (head == nullptr || head->next == nullptr) {
        return head; 
    }

    
    LLNode* slow = head;
    LLNode* fast = head;

    while (fast->next != nullptr && fast->next->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

   
    LLNode* secondHalf = slow->next;
    slow->next = nullptr;

   
    secondHalf = reverse(secondHalf);

    
    return merge(head, secondHalf);
}",0.1,0010000000
Singly_linked_list_1,1434687,2210034,"#include<cmath>
LLNode* addLinkedList(LLNode* l0, LLNode* l1){
    LLNode dummy;
    LLNode* tail = &dummy;
    int carry = 0;
    while (l0 || l1 || carry) {
        int sum = (l0 ? l0->val : 0) + (l1 ? l1->val : 0) + carry;
        carry = sum / 10;
        tail->next = new LLNode(sum % 10);
        tail = tail->next;
        if (l0) l0 = l0->next;
        if (l1) l1 = l1->next;
    }
    return dummy.next;
}",1.0,111111111111111
Singly_linked_list_2,1434687,2210034,"void Polynomial::insertTerm(const Term& term) {
    if (term.coeff == 0) return; // Ignore zero coefficients

    // Iterate over the terms in the polynomial
    for (int i = 0; i < this->terms->size(); i++) {
        // If the exponent of the current term is less than the exponent of the term to be inserted
        if (this->terms->get(i).exp < term.exp) {
            // Insert the term before the current term
            this->terms->add(i, term);
            return;
        }
        // If the exponent of the current term is equal to the exponent of the term to be inserted
        else if (this->terms->get(i).exp == term.exp) {
            // Add the coefficients and update the current term
            Term currentTerm = this->terms->get(i);
            currentTerm.coeff += term.coeff;
            // If the coefficient becomes zero, remove the term
            if (currentTerm.coeff == 0) {
                this->terms->removeAt(i);
            } else {
                this->terms->set(i, currentTerm);  // Set back updated term
            }
            return;
        }
    }

    // If no suitable position was found in the list, append the term at the end
    this->terms->add(term);
}

void Polynomial::insertTerm(double coeff, int exp) {
    insertTerm(Term(coeff, exp));
}",1.0,11111
Singly_linked_list_4,1434687,2210034,"void LinkedList::partition(int k) {
    Node* current = head;
    Node* groupIHead = NULL;
    Node* groupITail = NULL;
    Node* groupIIHead = NULL;
    Node* groupIITail = NULL;
    Node* groupIIIHead = NULL;
    Node* groupIIITail = NULL;

    while (current != NULL) {
        if (current->value < k) {
            if (groupIHead == NULL) {
                groupIHead = current;
                groupITail = current;
            } else {
                groupITail->next = current;
                groupITail = current;
            }
        } else if (current->value == k) {
            if (groupIIHead == NULL) {
                groupIIHead = current;
                groupIITail = current;
            } else {
                groupIITail->next = current;
                groupIITail = current;
            }
        } else {
            if (groupIIIHead == NULL) {
                groupIIIHead = current;
                groupIIITail = current;
            } else {
                groupIIITail->next = current;
                groupIIITail = current;
            }
        }
        current = current->next;
    }

    if (groupIHead != NULL) {
        head = groupIHead;
        tail = groupITail;
    }
    if (groupIIHead != NULL) {
        if (head == NULL) {
            head = groupIIHead;
        } else {
            tail->next = groupIIHead;
        }
        tail = groupIITail;
    }
    if (groupIIIHead != NULL) {
        if (head == NULL) {
            head = groupIIIHead;
        } else {
            tail->next = groupIIIHead;
        }
        tail = groupIIITail;
    }

    // Ensure the end of the list is null
    if (tail != NULL) {
        tail->next = NULL;
    }
}",0.8,11101
Singly_linked_list_5,1434687,2210034,"void reduceDuplicate(Node* root) {
    if (root == nullptr || root->getNext() == nullptr) {
        // Danh sách rỗng hoặc chỉ có một node, không cần xử lý.
        return;
    }

    Node* current = root;

    while (current != nullptr && current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            // Nếu giá trị của node hiện tại giống với giá trị của node kế tiếp,
            // ta loại bỏ node kế tiếp.
            Node* duplicate = current->getNext();
            current->setNext(duplicate->getNext());
            delete duplicate; // Loại bỏ node trùng lặp.
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1434687,2210034,"int Train::allocate(int containerSize) {
    TrainCar* current = head->next;
    TrainCar* minSpaceCar = NULL;
    int idx = 1;
    int minIdx = -1;

    while (current != NULL) {
        if (current->remainingSpace >= containerSize) {
            if (minSpaceCar == NULL || current->remainingSpace < minSpaceCar->remainingSpace) {
                minSpaceCar = current;
                minIdx = idx;
            }
        }
        current = current->next;
        idx++;
    }

    if (minSpaceCar != NULL) {
        minSpaceCar->remainingSpace -= containerSize;
        return minIdx;
    } else {
        return -1; // Cannot load the container
    }
}

int Train::totalRemainingSpace() {
    int totalSpace = 0;
    TrainCar* current = head->next;

    while (current != NULL) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }

    return totalSpace;
}",1.0,11111
Singly_linked_list_7,1434687,2210034,"template <class T>
void SLinkedList<T>::add(const T& e) {
    Node* newNode = new Node(e, NULL);
    if (count == 0) {
        head = tail = newNode;
    } else {
        tail->next = newNode;
        tail = newNode;
    }
    count++;
    
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
     if (index < 0 || index > count) {
        throw ""Index out of bounds"";
    }
    Node* newNode = new Node(e, NULL);
    if (index == 0) {
        newNode->next = head;
        head = newNode;
        if (tail == NULL) {
            tail = newNode;
        }
    } else {
        Node* prevNode = head;
        for (int i = 0; i < index - 1; i++) {
            prevNode = prevNode->next;
        }
        newNode->next = prevNode->next;
        prevNode->next = newNode;
        if (newNode->next == NULL) {
            tail = newNode;
        }
    }
    count++;
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
   return count;
}
",1.0,1111111111
Singly_linked_list_8,1434687,2210034,"template<class T>
T SLinkedList<T>::get(int index) {
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }

    return current->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }

    current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
     return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
   int index = 0;
    Node* current = head;
    while (current != NULL) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1; // Item not found
    
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
   return indexOf(item) != -1;
    
}",1.0,1111111111
Singly_linked_list_9,1434687,2210034,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
      if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }

    T removedData;
    if (index == 0) {
        // Removing the first node
        Node* removedNode = head;
        head = head->next;
        removedData = removedNode->data;
        delete removedNode;
        if (count == 1) {
            // If there was only one element, update the tail as well
            tail = nullptr;
        }
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        Node* removedNode = current->next;
        current->next = removedNode->next;
        if (index == count - 1) {
            // If removing the last element, update the tail
            tail = current;
        }
        removedData = removedNode->data;
        delete removedNode;
    }

    count--;
    return removedData;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    Node* current = head;
    Node* prev = nullptr;
    while (current != nullptr) {
        if (current->data == item) {
            if (prev == nullptr) {
                // Removing the first element
                head = current->next;
                if (count == 1) {
                    // If there was only one element, update the tail as well
                    tail = nullptr;
                }
            } else {
                prev->next = current->next;
                if (current == tail) {
                    // If removing the last element, update the tail
                    tail = prev;
                }
            }
            delete current;
            count--;
            return true;
        }
        prev = current;
        current = current->next;
    }
    return false; // Item not found
    
}

template<class T>
void SLinkedList<T>::clear(){
    Node* current = head;
    while (current != nullptr) {
        Node* next = current->next;
        delete current;
        current = next;
    }
    head = nullptr;
    tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1434687,2210034,"LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    // Find the middle of the linked list
    LLNode *slow = head, *fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // Reverse the second half of the linked list
    LLNode *prev = nullptr, *curr = slow, *next;
    while (curr != nullptr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    // Merge the two halves of the linked list
    LLNode *first = head, *second = prev;
    while (second->next != nullptr) {
        LLNode *temp = first->next;
        first->next = second;
        first = temp;

        temp = second->next;
        second->next = first;
        second = temp;
    }

    return head;
}",0.1,0010000000
Singly_linked_list_11,1434687,2210034,"LLNode* replaceFirstGreater(LLNode* head) {
    stack<LLNode*> s;
    LLNode* current = head;

    while (current != nullptr) {
        while (!s.empty() && s.top()->val < current->val) {
            s.top()->val = current->val;
            s.pop();
        }
        s.push(current);
        current = current->next;
    }

    while (!s.empty()) {
        s.top()->val = 0;
        s.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1434687,2210034,"LLNode* reverseLinkedList(LLNode* head) {
    LLNode* prev = nullptr;
    LLNode* current = head;
    LLNode* next = nullptr;

    while (current != nullptr) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }

    return prev;
}",1.0,1111111111
Singly_linked_list_13,1434687,2210034,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || head->next == nullptr || k <= 0) {
        return head;
    }

    // Find the length of the linked list
    int len = 1;
    LLNode* tail = head;
    while (tail->next != nullptr) {
        tail = tail->next;
        len++;
    }

    // Connect the tail to the head to form a circular linked list
    tail->next = head;

    // Find the new tail, which is (len - k % len - 1) nodes ahead of the head
    LLNode* newTail = head;
    for (int i = 0; i < len - k % len - 1; i++) {
        newTail = newTail->next;
    }

    // The new head is just next to the new tail
    LLNode* newHead = newTail->next;

    // Break the circular linked list to get the rotated linked list
    newTail->next = nullptr;

    return newHead;
}",1.0,1111111111
Singly_linked_list_14,1434687,2210034,"
void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    Node* prev = nullptr;
    Node* current = head;
    int index = 0;

    // Find the node before the low position
    while (current != nullptr && index < low) {
        prev = current;
        current = current->next;
        index++;
    }

    // Find the node after the high position
    Node* afterHigh = current;
    while (afterHigh != nullptr && index <= high) {
        afterHigh = afterHigh->next;
        index++;
    }

    // Connect the node before the low position to the head of linked_list
    if (prev == nullptr) {
        head = linked_list->head;
    } else {
        prev->next = linked_list->head;
    }

    // Connect the tail of linked_list to the node after the high position
    linked_list->tail->next = afterHigh;

    // Update tail if necessary
    if (high >= size - 1) {
        tail = linked_list->tail;
    }

    // Update size
    size = size - (high - low + 1) + linked_list->size;
}",1.0,11111
Singly_linked_list_1,1434756,2213836,"LLNode* addLinkedList(LLNode* l0, LLNode* l1) {
    LLNode* dummy = new LLNode();  // Nút giả để đơn giản hóa việc xử lý
    
    LLNode* curr = dummy;  // Con trỏ trỏ tới nút hiện tại trong danh sách kết quả
    int carry = 0;  // Biến nhớ
    
    while (l0 != nullptr || l1 != nullptr || carry != 0) {
        int sum = carry;
        
        if (l0 != nullptr) {
            sum += l0->val;
            l0 = l0->next;
        }
        
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        
        carry = sum / 10;  // Lấy phần nguyên của tổng để cập nhật biến nhớ
        int digit = sum % 10;  // Lấy phần dư của tổng để tạo nút mới
        
        curr->next = new LLNode(digit, nullptr);  // Tạo nút mới cho kết quả
        curr = curr->next;
    }
    
    LLNode* result = dummy->next;  // Danh sách kết quả bắt đầu từ nút sau nút giả
    delete dummy;  // Giải phóng nút giả
    
    return result;
}",1.0,111111111111111
Singly_linked_list_2,1434756,2213836,"void Polynomial::insertTerm(const Term& term) {
    if (term.coeff == 0) return; // Nếu hệ số bằng 0, không cần chèn, kết thúc phương thức.

    SLinkedList<Term>::Iterator i;
    int index = 0;
    for (i = terms->begin(); i != terms->end(); i++) {
        if (term.exp == (*i).exp) { // Nếu mũ trùng khớp với hạng tử hiện tại trong đa thức
            (*i).coeff += term.coeff; // Cộng hệ số của hạng tử được chèn vào hệ số của hạng tử hiện tại
            if ((*i).coeff == 0) {
                terms->removeAt(index); // Nếu tổng hệ số bằng 0, loại bỏ hạng tử hiện tại khỏi đa thức
            }
            return; // Kết thúc phương thức
        }
        else if (term.exp > (*i).exp) { // Nếu mũ lớn hơn mũ của hạng tử hiện tại trong đa thức
            terms->add(index, term); // Chèn hạng tử vào vị trí index trong danh sách các hạng tử trong đa thức
            return; // Kết thúc phương thức
        }
        index++; // Tăng chỉ số index để tiếp tục kiểm tra hạng tử tiếp theo trong đa thức
    }
    terms->add(index, term); // Nếu không có hạng tử nào có mũ lớn hơn, chèn hạng tử vào cuối danh sách
    // STUDENT ANSWER
}

void Polynomial::insertTerm(double coeff, int exp) {
    Term term(coeff, exp);
    insertTerm(term);
}",1.0,11111
Singly_linked_list_3,1434756,2213836,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if(pList == NULL) {}
    else if(begin) {
        if(this->pList->size() == 0) {
            this->current = NULL;
            index = -1;
            
        }
        else {
            this->current = pList->head;
            index = 0;
        }
    }
    
    else if(!begin) {
        this->current = NULL;
        if(this->pList->size() == 0) index = 0;
        else index = this->pList->size();
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    
    if(index == 0) {
        this->pList->removeAt(index);
        this->current = NULL;
        index = -1;
    }
    else {
        T e = this->pList->removeAt(index - 1);
        this->index = index - 1;
        current->data = e;
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    return current->data;
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if(iterator.index == this->index && iterator.current == this->current) return false;
    return true;
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current = current->next;
    index++;
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    Iterator temp = *this;
    current = current->next;
    index++;
    return temp;
}",1.0,11111
Singly_linked_list_4,1434756,2213836,"void LinkedList::partition(int k) {
    // Kiểm tra xem danh sách liên kết có ít hơn 2 phần tử hay không
    if (head == NULL || head->next == NULL) {
        return;
    }

    Node* smallerHead = NULL;  // Đầu danh sách nhóm I
    Node* smallerTail = NULL;  // Đuôi danh sách nhóm I
    Node* equalHead = NULL;    // Đầu danh sách nhóm II
    Node* equalTail = NULL;    // Đuôi danh sách nhóm II
    Node* greaterHead = NULL;  // Đầu danh sách nhóm III
    Node* greaterTail = NULL;  // Đuôi danh sách nhóm III

    Node* current = head;
    
    // Duyệt qua danh sách liên kết và phân chia các phần tử vào các nhóm tương ứng
    while (current != NULL) {
        if (current->value < k) {
            // Phần tử nhỏ hơn k thuộc nhóm I
            if (smallerHead == NULL) {
                smallerHead = current;
                smallerTail = current;
            } else {
                smallerTail->next = current;
                smallerTail = current;
            }
        } else if (current->value == k) {
            // Phần tử bằng k thuộc nhóm II
            if (equalHead == NULL) {
                equalHead = current;
                equalTail = current;
            } else {
                equalTail->next = current;
                equalTail = current;
            }
        } else {
            // Phần tử lớn hơn k thuộc nhóm III
            if (greaterHead == NULL) {
                greaterHead = current;
                greaterTail = current;
            } else {
                greaterTail->next = current;
                greaterTail = current;
            }
        }
        
        current = current->next;
    }
    
    // Kết hợp các nhóm lại theo thứ tự I -> II -> III
    if (smallerHead != NULL) {
        head = smallerHead;
        smallerTail->next = equalHead;
    } else {
        head = equalHead;
    }
    
    if (equalHead != NULL) {
        equalTail->next = greaterHead;
    }
    
    if (greaterHead != NULL) {
        tail = greaterTail;
        tail->next = NULL;
    }
}",1.0,11111
Singly_linked_list_5,1434756,2213836,"void reduceDuplicate(Node* root)
{
    if (root == nullptr) {
        return;
    }
    
    Node* current = root;
    while (current->getNext() != nullptr) {
        if (current->getData() == current->getNext()->getData()) {
            Node* duplicateNode = current->getNext();
            current->setNext(duplicateNode->getNext());
            delete duplicateNode;
        } else {
            current = current->getNext();
        }
    }
}",1.0,1111111111
Singly_linked_list_6,1434756,2213836,"int Train::allocate(int containerSize) {
if(this->size<=0) return -1;
 TrainCar*  temp=this->head;
 int index=-1;
 int minRemainingSpace = 32767;
 for (int i = 0; i < this->size; ++i) {
        if (temp->remainingSpace >= containerSize && temp->remainingSpace < minRemainingSpace) {
            index = i;
            minRemainingSpace = temp->remainingSpace;
        }
        temp = temp->next;
    }
    temp=this->head;
 for(int i=0;i<index;++i)
 temp=temp->next;
 if (temp != nullptr&& index!=-1) 
{
    temp->remainingSpace -= containerSize;
}
 return index;
}

int Train::totalRemainingSpace() {
    int totalSpace = 0;
    TrainCar* current = head->next;

    while (current != nullptr) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }

    return totalSpace;
}",1.0,11111
Singly_linked_list_7,1434756,2213836,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e, nullptr);
    if(head == nullptr) head = tail = newNode;
    else {
        tail->next = newNode;
        tail= newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e, nullptr);
    if(index == 0) {
        newNode->next = head;
        head = newNode;
    }
    else {
        Node* current = head;
        for(int i = 0; i < index - 1; i++){
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
    count++;
    
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
    return 0;
}
",1.0,1111111111
Singly_linked_list_8,1434756,2213836,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    return temp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int index = 0;
    while(temp) {
        if(temp->data == item) return index;
        temp = temp->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* temp = head;
    while(temp) {
        if(temp->data == item) return true;
        temp = temp->next;
    }
    return false;
    
}",1.0,1111111111
Singly_linked_list_9,1434756,2213836,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* removeNode = nullptr;
    Node* temp = head;
    if(index == 0) {
        removeNode = head;
        head = head->next;
    }
    else{
        for(int i = 0; i < index - 1; i++) {
            temp = temp->next;
        }
        removeNode = temp->next;
        temp->next = temp->next->next;
        if(index == count - 1) tail = temp;
    }
    T removedValue = removeNode->data;
    delete removeNode;
    count--;
    return removedValue;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    Node* previous = nullptr;

    while (current != nullptr) {
        if (current->data == item) {
            if (previous == nullptr) {
                head = current->next;
            } else {
                previous->next = current->next;
                if (current == tail) {
                    tail = previous;
                }
            }

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* temp  = head;
    while(temp) {
        Node* next = temp->next;
        delete temp;
        temp = next;
    }
    head  =tail = nullptr;
    count = 0;
}

",1.0,1111111111
Singly_linked_list_10,1434756,2213836,"LLNode* reverseLinkedList(LLNode* head) {
    if(!head || !head->next) return head;
    LLNode* prev = head, * curr = head->next, *post = head->next->next;
    head->next = NULL;
    while(post){
        curr->next = prev;
        prev = curr;
        curr = post;
        post = post->next;
    }
    curr->next = prev;
    return curr;
}
LLNode* foldLinkedList(LLNode* head) {
//! nếu nó chỉ có 1 phần tử hoặc không có phần tử nào thì return 
    if(head == NULL || head->next == NULL) return head;

    LLNode* curr = head, * curr2 = head->next;
//! Duyệt qua danh sách để tìm điểm chính giữa bằng cách di chuyển curr2 gấp đôi tốc độ.
    while(curr2 && curr2->next){
        curr2 = curr2->next->next;
        curr = curr->next;
    }
//! k true khi curr2 khác null
    bool k = curr2;
    curr2 = curr->next; 
    curr->next = NULL;
//! Đảo ngược nửa đầu của danh sách
    head = reverseLinkedList(head);
    curr = head;
//! nếu danh sách rẻ thì bỏ qua node đầu tiên khi đảo danh sách
    if(!k){
        curr = curr->next;
    }
//! cộng chúng lại với nhau
    while(curr && curr2){
        curr->val += curr2->val;
        curr = curr->next;
        curr2 = curr2->next;
    }
    return head;
    
}",1.0,1111111111
Singly_linked_list_11,1434756,2213836,"LLNode* replaceFirstGreater(LLNode* head) {
    if (head == nullptr) {
        return nullptr;
    }

    // Tạo một ngăn xếp rỗng để lưu trữ các nút
    std::stack<LLNode*> nodeStack;

    // Duyệt qua danh sách liên kết
    LLNode* current = head;
    while (current != nullptr) {
        // Kiểm tra nếu ngăn xếp không rỗng và giá trị của nút hiện tại
        // lớn hơn giá trị của nút ở đầu ngăn xếp
        while (!nodeStack.empty() && current->val > nodeStack.top()->val) {
            // Thay thế giá trị của nút ở đầu ngăn xếp bằng giá trị của nút hiện tại
            nodeStack.top()->val = current->val;
            // Loại bỏ nút khỏi ngăn xếp vì nó đã tìm thấy nút lớn hơn kế tiếp của nó
            nodeStack.pop();
        }
        // Đẩy nút hiện tại vào ngăn xếp
        nodeStack.push(current);
        // Di chuyển đến nút tiếp theo trong danh sách liên kết
        current = current->next;
    }

    // Sau khi duyệt qua, các nút còn lại trong ngăn xếp không có nút lớn hơn nào bên phải của chúng
    // Đặt giá trị của chúng thành 0
    while (!nodeStack.empty()) {
        nodeStack.top()->val = 0;
        nodeStack.pop();
    }

    return head;
}",1.0,1111111111
Singly_linked_list_12,1434756,2213836,"LLNode* reverseLinkedList(LLNode* head) {
    // STUDENT ANSWER
    //! nếu không có phần tử nào hay chỉ có 1 phần tử thì return về chính nó
    if(!head || !head->next) return head;
//! trước hiện tại và sau
    LLNode* prev = head, * curr = head->next, *post = head->next->next;
    head->next = NULL;
    while(post){
//! Đảo ngược kết nối của nút hiện tại
        curr->next = prev;
//! Di chuyển prev tới nút hiện tại
        prev = curr;
//!  Di chuyển curr tới nút post
        curr = post;
//! Di chuyển post tới nút tiếp theo sau post
        post = post->next;
    }
//! Đảo ngược kết nối của nút cuối cùng
    curr->next = prev;
    return curr;
}",1.0,1111111111
Singly_linked_list_13,1434756,2213836,"LLNode* rotateLinkedList(LLNode* head, int k) {
    // STUDENT ANSWER
    //! trả về null nếu list rỗng
        if(!head) return NULL;
        LLNode* tmp = head;
        int size = 1;
        while (head->next) {
        head = head->next;
//!  Tăng biến size lên 1 để đếm số lượng nút
        size++;
    }
//! cuối danh liên kết trở tới đầu danh sách
        head->next = tmp;
//! Tính phần dư của k khi chia cho size để đảm bảo k không lớn hơn size
        k %= size;
        
//! Tính số bước di chuyển con trỏ để xoay danh sách
        k = size - k;
      
        while(k){
            head = head->next;
            k--;
        }
//! Lưu nút mới đứng đầu danh sách liên kết vào biến tmp
        tmp = head->next;
        head->next = NULL;
         return tmp;
}
",1.0,1111111111
Singly_linked_list_14,1434756,2213836,"void LinkedList::replace(LinkedList* linked_list, int low, int high) {
    Node* prev = NULL;
    Node* current = head;
    int count = 0;

    while (current != NULL && count < low) {
        prev = current;
        current = current->next;
        count++;
    }

    if (low <= 0) {
        head = linked_list->head;
    } else {
        prev->next = linked_list->head;
    }

    while (current != NULL && count <= high) {
        Node* temp = current;
        current = current->next;
        delete temp;
        count++;
    }

    linked_list->tail->next = current;

    size = size - (high - low + 1) + linked_list->size;
}",0.4,110
Singly_linked_list_3,1435381,2210458,"template <class T>
SLinkedList<T>::Iterator::Iterator(SLinkedList<T>* pList, bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true:
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false:
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    this->pList = pList;
    if (begin == true)
    {
        if (pList != nullptr)
        {
            current = pList->head;
            index = 0;
        }
        else
        {
            current = nullptr;
            index = -1;
        }
    }
    else
    {
        current = nullptr;
        if (pList != nullptr)
        {
            index = pList->size();
        }
        else
        {
            index = 0;
        }
    }
}

template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void SLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        this->pList->removeAt(index);
        if (current == pList->head)
        {
            current = nullptr;
            index = -1;
        }
        else
        {
            Node* prev = pList->head;
            for (int i = 0; i < index - 1; i++)
            {
                prev = prev->next;
            }
            //prev->next = current->next;
            current = prev;
            index--;
        }
    }
}

template <class T>
void SLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current->data = e;
    }
}

template <class T>
T& SLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        return current->data;
    }
}

template <class T>
bool SLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
    if (current != iterator.current /*&& index != iterator.index*/)
    {
        return true;
    }
    else
    {
        return false;
    }
}
// Prefix ++ overload
template <class T>
typename SLinkedList<T>::Iterator& SLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else if (current->next == pList->head)
    {
        current = pList->head;
    }
    else
    {
        current = current->next;
    }
    index++;
    return *this;
}
// Postfix ++ overload
template <class T>
typename SLinkedList<T>::Iterator SLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else if (current->next == pList->head)
    {
        current = pList->head;
    }
    else
    {
        current = current->next;
    }
    index++;
    return *this;
}
",1.0,11111
Singly_linked_list_5,1435381,2210458,"void reduceDuplicate(Node* root)
{
    Node* current = root;
	Node* next = nullptr;
    while (current != nullptr && current->getNext() != nullptr)
    {
        if (current->getData() == current->getNext()->getData())
        {
			next = current->getNext()->getNext();
			delete current->getNext();
			current->setNext(next);
		}
        else
        {
			current = current->getNext();
		}
	}
}",1.0,1111111111
Singly_linked_list_6,1435381,2210458,"int Train::allocate(int containerSize)
{
    TrainCar* current = this->head;
    int index = 0;
    int min = 2147483647, indexMin = 0;
    bool found = false;
    while (current != NULL) {
        if (current->remainingSpace >= containerSize && current->remainingSpace < min) {
            //current->remainingSpace -= containerSize;
            //return index;
            min = current->remainingSpace;
            indexMin = index;
            found = true;
        }
        current = current->next;
        index++;
    }
    if (!found) return -1;
    index = 0;
    current = this->head;
    while (index < indexMin)
    {
        current = current->next;
		index++;
    }
    current->remainingSpace -= containerSize;
    return indexMin;
}


int Train::totalRemainingSpace() 
{
    int totalSpace = 0;
    TrainCar* current = this->head;
    while (current != NULL) {
        totalSpace += current->remainingSpace;
        current = current->next;
    }
    return totalSpace;
}",1.0,11111
Singly_linked_list_7,1435381,2210458,"template <class T>
void SLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e, nullptr);
    if (head == nullptr)
    {
        head = newNode;
        tail = newNode;
    }
    else
    {
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template<class T>
void SLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        throw std::out_of_range(""Index is out of range"");
    }
    if (index == 0)
    {
        Node* newNode = new Node(e, head);
        //newNode->next = head;
        head = newNode;
        if (count == 0)
        {
            tail = newNode;
        }
    }
    else if (index == count)
    {
        Node* newNode = new Node(e, nullptr);
        tail->next = newNode;
        tail = newNode;
    }
    else
    {
        /*while (count < index - 1)
        {
            iterate = iterate->next;
            count++;
        }
        Node* newNode = new Node(e, iterate->next);
        iterate->next = newNode; */
		Node* temp = head;
        for (int i = 0; i < index - 1; i++) {
			temp = temp->next;
		}   
		Node* newNode = new Node(e, temp->next);
		temp->next = newNode;
    }
    count++;
}

template<class T>
int SLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    /*
    int count = 0;
    Node* iterate = head;
    while (iterate != nullptr)
    {
        iterate = iterate->next;
        count++;
    }
    */
    return count;
}
",1.0,1111111111
Singly_linked_list_8,1435381,2210458,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index > count)
    {
        throw std::out_of_range(""Index is out of range"");
    }
    Node* iterate = head;
    int countNode = 0;
    while (countNode < index)
    {
        iterate = iterate->next;
        countNode++;
    }
    return iterate->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index > count)
    {
        throw std::out_of_range(""Index is out of range"");
    }
    else
    {
        Node* iterate = head;
        int countNode = 0;
        while (countNode < index)
        {
            iterate = iterate->next;
            countNode++;
        }
        iterate->data = e;
    }
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !count;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* iterate = head;
    int index = 0;
    while (iterate != nullptr)
    {
        if (iterate->data == item)
            return index;
        else
        {
            iterate = iterate->next;
            index++;
        }
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* iterate = head;
    while (iterate != nullptr)
    {
        if (iterate->data == item)
            return true;
        else
        {
            iterate = iterate->next;
        }
    }
    return false;
}",1.0,1111111111
Singly_linked_list_9,1435381,2210458,"template <class T>
T SLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index is out of range"");
    }
    Node* current = head;
    Node* prev = NULL;
    for (int i = 0; i < index; i++) {
        prev = current;
        current = current->next;
    }
    T removedData = current->data;
    if (prev == NULL) {
        head = current->next;
    } else {
        prev->next = current->next;
    }
    if (current == tail) {
        tail = prev;
    }
    delete current;
    count--;
    return removedData;
}

template <class T>
bool SLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    Node* prev = NULL;
    while (current != NULL) {
        if (current->data == item) {
            if (prev == NULL) {
                head = current->next;
            } else {
                prev->next = current->next;
            }
            if (current == tail) {
                tail = prev;
            }
            delete current;
            count--;
            return true;
        }
        prev = current;
        current = current->next;
    }
    return false;
}

template<class T>
void SLinkedList<T>::clear(){
    /* Remove all elements in list */\
    count = 0;
    if (head == nullptr || count == 0)
        return;
    else if (head != nullptr || count == 1)
    {
        delete head;
        head = nullptr;
        tail = nullptr;
    }
    else
    {
        Node* iterate = head;
        Node* deleteNode = iterate;
        while (iterate != nullptr)
        {
            iterate = iterate->next;
            deleteNode = iterate;
            delete deleteNode;
        }
        head = nullptr;
        tail = nullptr;
    }

}

",1.0,1111111111
Singly_linked_list_10,1435381,2210458,"LLNode* foldLinkedList(LLNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    // Find the middle of the list and count the nodes
    LLNode* slow = head, * fast = head;
    int count = 0;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        count += 2;
    }
    if (fast != nullptr) {
        count++; // The list has an odd number of nodes
    }

    // If the list has an even number of nodes, move the slow pointer one step back
    if (count % 2 == 0) {
        LLNode* temp = head;
        while (temp->next != slow) {
            temp = temp->next;
        }
        slow = temp;
    }

    // Reverse the second half of the list
    LLNode* prev = nullptr, * curr = slow->next;
    while (curr != nullptr) {
        LLNode* nextTemp = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextTemp;
    }
    slow->next = nullptr;

    // Merge the two halves of the list
    LLNode* first = head;
    LLNode* second = prev;
    while (second != nullptr) {
        int temp = first->val;
        first->val += second->val;
        second->val = temp;
        if (first->next == nullptr) {
            first->next = second;
            break;
        }
        first = first->next;
        second = second->next;
    }

    // Reverse the entire list
    prev = nullptr;
    curr = head;
    while (curr != nullptr) {
        LLNode* nextTemp = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextTemp;
    }
    head = prev;

    return head;
}",0.5,1010101010
Singly_linked_list_12,1435381,2210458,"LLNode* reverseLinkedList(LLNode* head) 
{
    LLNode *prev = nullptr, *curr = head, *next = nullptr;
    while (curr != nullptr) {
        next = curr->next; // Temporarily store the next node
        curr->next = prev; // Reverse the link
        prev = curr; // Move prev and curr one step forward
        curr = next;
    }
    head = prev; // Reset head to the new start
    return head;
}",1.0,1111111111
Singly_linked_list_13,1435381,2210458,"LLNode* rotateLinkedList(LLNode* head, int k) {
    if (head == nullptr || head->next == nullptr || k == 0) {
        return head;
    }

    // Determine the length of the list
    int len = 1;
    LLNode* tail = head;
    while (tail->next != nullptr) {
        tail = tail->next;
        len++;
    }

    // Connect the tail to the head to form a circular list
    tail->next = head;

    // Find the new tail, which is (len - k % len - 1) nodes away from the head
    for (int i = 0; i < len - k % len - 1; i++) {
        head = head->next;
    }

    // The new head is the next node
    LLNode* newHead = head->next;

    // Break the circular list
    head->next = nullptr;

    return newHead;
}",1.0,1111111111
OOP_1,1288039,2110501,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(((this->x)-pointA.x)*((this->x)-pointA.x)+((this->y)-pointA.y)*((this->y)-pointA.y));
    }
};",1.0,1111111111
OOP_2,1288039,2110501,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
    private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(((this->x)-pointA.x)*((this->x)-pointA.x)+((this->y)-pointA.y)*((this->y)-pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        this->center=Point();
        this->radius=0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center=center;
         this->radius=radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center=circle.center;
         this->radius=circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center=point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius=radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1288039,2110501,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(((this->x)-pointA.x)*((this->x)-pointA.x)+((this->y)-pointA.y)*((this->y)-pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
         this->center=Point();
         this->radius=0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center=center;
         this->radius=radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        if(center.distanceToPoint(point)<radius)  return true;
        return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         if(containsPoint(pointA)&&containsPoint(pointB)&&containsPoint(pointC))    return true;
         return false;
    }
};",1.0,1111111111
OOP_4,1288039,2110501,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(((this->x)-pointA.x)*((this->x)-pointA.x)+((this->y)-pointA.y)*((this->y)-pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
         this->center=Point();
         this->radius=0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center=center;
         this->radius=radius;
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double x2,y2;
        x2=circle.center.getX();
        y2=circle.center.getY();
        this->center.setX(x2);
        this->center.setY(y2);
        this->radius=circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        if((this->center.getX()==circle.center.getX())&&(this->center.getY()==circle.center.getY())&&this->radius==circle.radius)    return true;
        return false;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double x,y;
        in>>x;
        circle.center.setX(x);
        in>>y;
        circle.center.setY(y);
        in>>circle.radius;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1288039,2110501,"Character::Character() {
    // STUDENT ANSWER
    this->hp=0;
    this->x=0;
    this->y=0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp=hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x=x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    return abs(this->x-other->x)+abs(this->y-other->y);
    
}",1.0,111111
OOP_6,1288039,2110501,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->x=other.x;
    this->y=other.y;
    this->hp=other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    if(this->hp<=other.hp)  return true;
    return false;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<this->hp<<""-""<<this->x<<""-""<<this->y;
}",1.0,11111
OOP_7,1288039,2110501,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player: private Character
{
    public:
    Player()
    {
        setX(0);
        setY(0);
        setHp(0);
    }
    Player(int hp, int x, int y)
    {
        setX(x);
        setY(y);
        setHp(hp);
    }
    void printPlayerData()
    {
        cout<<getHp()<<""-""<<getX()<<""-""<<getY();
    }
    void moveTo(int x, int y)
    {
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_8,1288039,2110501,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->publishingYear=0;
         this->title=NULL;
         this->authors=NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear=publishingYear;
        this->title = strcpy(new char[strlen(title) + 1], title);
		this->authors = strcpy(new char[strlen(authors) + 1], authors);
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->publishingYear=book.publishingYear;
        this->title = strcpy(new char[strlen(book.title) + 1], book.title);
		this->authors = strcpy(new char[strlen(book.authors) + 1], book.authors);
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = strcpy(new char[strlen(title) + 1], title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        this->authors = strcpy(new char[strlen(authors) + 1], authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear=publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete[] title;
         delete[] authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1288039,2110501,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear=0;
         this->title=NULL;
         this->authors=NULL;
         
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear=publishingYear;
        this->title = strcpy(new char[strlen(title) + 1], title);
		this->authors = strcpy(new char[strlen(authors) + 1], authors);
    }
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
          string s1 = string(book.authors);
        string s2 = string(author);
        int check = s1.find(s2);
        if (check == -1) return false;
        else{
            if ((s1[check + s2.length()] == 0 && s1[check - 2] == ',')|| s1[check + s2.length()] == ',')
                return true;
            else return false;
        }
    }
};",1.0,1111111111
OOP_10,1288039,2110501,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear=0;
         this->title=NULL;
         this->authors=NULL;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear=publishingYear;
        this->title = strcpy(new char[strlen(title) + 1], title);
		this->authors = strcpy(new char[strlen(authors) + 1], authors);
    }
    
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
        cout<<book.title <<endl;
		for (char* str = book.authors; *str; )
			if (*str == ',')    for (cout << endl, ++str; *str && isspace(*str); ++str);
			else	            cout << *str++;
		cout <<endl << book.publishingYear <<endl;
    }
};",1.0,1111111111
OOP_11,1288039,2110501,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         this->color=color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         this->size=size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         this->numberOfItems = 0;
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if (numberOfItems >= 5) return -1;
        else
        {
            toyBox[numberOfItems] = new CarToy(carToy.price, carToy.color);
            numberOfItems++;
        }
        return numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if (numberOfItems >= 5) return -1;
        else
        {
            toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
            numberOfItems++;
        }
        return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1339379,2211878,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        return sqrt(pow(x - pointA.x,2)+pow(y - pointA.y,2));
    }
};",1.0,1111111111
OOP_2,1339379,2211878,"class Point
{
    private:
        double x, y;
    
    public:
    Point()
    {
        x = 0;
        y = 0;
    }
    Point(double x, double y)
    {
         this->x = x;
         this->y = y;
    }
    
    void setX(double x){
        this->x = x;
    }
    
    void setY(double y){
        this->y = y;
    }
    
    double getX() const
    {   return x;   }

    double getY() const
    {   return y;   }
    
    
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(point.getX());
        this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
        return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1339379,2211878,"class Point
{
    public:
    double x,y;
    Point(){
        x = 0;
        y = 0;
    }
    Point(double x, double y){
        this->x = x;
        this->y = y;
    }
    
    double distance(Point A){
        return sqrt(pow(this->x - A.x, 2) + pow(this->y - A.y, 2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        center.x = 0;
        center.y = 0;
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.x = center.x;
        this->center.y = center.y;
        this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double dis = center.distance(point);
        return dis < radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC);
    }
};",1.0,1111111111
OOP_4,1339379,2211878,"class Point
{
    public:
    double x,y;
    Point(){
        x = 0;
        y = 0;
    }
    Point(double x, double y){
        this->x = x;
        this->y = y;
    }
    
    double distance(Point A){
        return sqrt(pow(this->x - A.x, 2) + pow(this->y - A.y, 2));
    }
    
    double getX(){
        return x;
    }
    
    double getY(){
        return y;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.x = 0;
        center.y = 0;
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.x = center.x;
        this->center.y = center.y;
        this->radius = radius;
    }
    
    Point getcenter() const{
        return this->center;
    }
    void setcenter(double x, double y){
        this->center.x = x;
        this->center.y = y;
    }
    void setRadius(double radius){
        this->radius = radius;
    }
    double getRadius(){
        return radius;
    }
    void operator=(const Circle &circle)
    {
        Point Cir_cen = circle.getcenter();
        
        this->center.x = Cir_cen.x;
        this->center.y = Cir_cen.y;
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        Point Cir_cen = circle.getcenter();
        return (this->center.x == Cir_cen.x) && (this->center.y == Cir_cen.y) && (this->radius == circle.radius) ;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        double x, y, radius;
        in >> x >> y >> radius;
        circle.setcenter(x,y);
        circle.setRadius(radius);
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1339379,2211878,"Character::Character() {
    // STUDENT ANSWER
    x = 0;
    y = 0;
    hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->x = x;
    this->y = y;
    this->hp = hp;
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this-> y = y; 
}

int ab(int x){
    if(x < 0) x *= -1;
    return x;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    return ab(this->x - other->getX()) + ab(this->y - other->getY());
}",1.0,111111
OOP_6,1339379,2211878,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    x = other.x;
    y = other.y;
    hp = other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return (this->hp <= other.hp);
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<hp<<""-""<<x<<""-""<<y;
}",1.0,11111
OOP_7,1339379,2211878,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player : private Character {
public:
    Player() : Character() {}
    Player(int hp, int x, int y) : Character(hp, x, y) {}
    
    void printPlayerData() {
        cout << hp << ""-"" << getX() << ""-"" << getY() << endl;
    }
    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};
",1.0,11111
OOP_8,1339379,2211878,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->title, title);
        strcpy(this->authors, authors);
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        this->title = new char[strlen(book.title) + 1];
        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->title, book.title);
        strcpy(this->authors, book.authors);
        this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        return title;
    }

    char* getAuthors() const
    {
        return authors;
    }

    int getPublishingYear() const
    {
        return publishingYear;
    }

    ~Book()
    {
        delete []title;
        delete []authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1339379,2211878,"char* trim(char* str)
{
    int len = strlen(str);
    while (len > 0 && isspace(str[len - 1]))
    {
        str[len - 1] = '\0';
        len--;
    }
    while (*str && isspace(*str))
    {
        str++;
    }
    return str;
}

class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }
    
    Book(const char *title, const char *authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->title, title);
        strcpy(this->authors, authors);
        this->publishingYear = publishingYear;
    }

    ~Book()
    {
        //delete []title;
        //delete []authors;
    }
    
    friend bool checkAuthor(Book book, const char* author)
    {   
        char* tempAuthors = new char[strlen(book.authors) + 1];
        strcpy(tempAuthors, book.authors);

        char* token = strtok(tempAuthors, "","");
        while (token != nullptr)
        {
            char* trimmedAuthor = trim(token);

            if (strcmp(trimmedAuthor, author) == 0)
            {
                //delete []tempAuthors;
                return true;
            }

            token = strtok(nullptr, "","");
        }   

        //delete []tempAuthors;
        return false;
    }
};
",1.0,1111111111
OOP_10,1339379,2211878,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->title, title);
        strcpy(this->authors, authors);
        this->publishingYear = publishingYear;
    }
    
    ~Book()
    {
        //delete []title;
        //delete []authors;
    }
    
    friend class Printer;
};

class Printer
{
public:
     static void printBook(const Book book)
    {   int tilen = strlen(book.title);
        for(int i = 0; i < tilen; i++){
            cout << book.title[i];
        } cout<<endl;
        
        int aulen = strlen(book.authors);
        int i = 0;
        while(i < aulen && book.authors[i] !='\0'){
            if(!(book.authors[i] ==',' && book.authors[i+1] == ' ')){
                cout<< book.authors[i];
            }else{
                cout<<endl;
                i++;;
            }
            i++;
        } cout <<endl;
        cout << book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1339379,2211878,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        numberOfItems = 0;
        for(int i = 0; i < 5;i++){
            toyBox[i] = nullptr;
        }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(numberOfItems >= 5) return -1;
        toyBox[numberOfItems] = new CarToy(carToy.price,carToy.color);
        numberOfItems++;
        return numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(numberOfItems >= 5) return -1;
        toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price,puzzleToy.size);
        numberOfItems++;
        return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1342054,2210997,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         
         */
         this -> x = 0;
         this -> y = 0;
    
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this -> x = x;
         this -> y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this -> x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this -> y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double dx = x - pointA.getX();
        double dy = y - pointA.getY();
        return sqrt(dx * dx + dy * dy);
    }
};",1.0,1111111111
OOP_2,1342054,2210997,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        
         this -> x = 0;
         this -> y = 0;
    
    }

    Point(double x, double y)
    {
      
         this -> x = x;
         this -> y = y;
    }

    void setX(double x)
    {
        
         this -> x = x;
    }

    void setY(double y)
    {
       
         this -> y = y;
    }

    double getX() const
    {
      
         return this->x;
    }

    double getY() const
    {
       
         return this->y;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        this->center = circle.center; 
        this->radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        center = point;
    }

    void setRadius(double radius)
    {
        this -> radius = radius;
    }

    Point getCenter() const
    {
        return center;
    }
    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1342054,2210997,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        
         this -> x = 0;
         this -> y = 0;
    
    }

    Point(double x, double y)
    {
      
         this -> x = x;
         this -> y = y;
    }

    void setX(double x)
    {
        
         this -> x = x;
    }

    void setY(double y)
    {
       
         this -> y = y;
    }

    double getX() const
    {
      
         return this->x;
    }

    double getY() const
    {
       
         return this->y;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    
    bool containsPoint(const Point point)
    {
        double dis = sqrt((point.getX()-center.getX())*(point.getX()-center.getX()) + (point.getY()-center.getY())*(point.getY()-center.getY()));
        return dis<radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC);
    }
};",1.0,1111111111
OOP_4,1342054,2210997,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        
         this -> x = 0;
         this -> y = 0;
    
    }

    Point(double x, double y)
    {
      
         this -> x = x;
         this -> y = y;
    }

    void setX(double x)
    {
        
         this -> x = x;
    }

    void setY(double y)
    {
       
         this -> y = y;
    }

    double getX() const
    {
      
         return this->x;
    }

    double getY() const
    {
       
         return this->y;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    
    void operator=(const Circle &circle)
    {
        center = circle.center;
        radius = circle.radius;
    
    }

    bool operator==(const Circle &circle)
    {
        return center.getX() == circle.center.getX() && center.getY() == circle.center.getY() && radius == circle.radius;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        double a,b,c;
        in >> a >> b >> c;
        circle.center = Point(a,b);
        circle.radius = c;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1342054,2210997,"Character::Character() {
    // STUDENT ANSWER
    this->x = 0;
    this->y = 0;
    this->hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this -> hp =hp;
    this -> x = x;
    this -> y = y;
}

int Character::getHp() {
   return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this -> hp= hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this -> y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    return abs(x-other->getX()) + abs(y-other->getY());
}",1.0,111111
OOP_6,1342054,2210997,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->x =other.x;
    this->y =other.y;
    this->hp =other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return this->hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<this->hp<<""-""<<this->x<<""-""<<this->y;
}",1.0,11111
OOP_7,1342054,2210997,"class Player : private Character {
public:
    Player() : Character() {}
    Player(int hp, int x, int y) : Character(hp, x, y) {}
    void printPlayerData() {
        cout << getHp() << ""-"" << getX() << ""-"" << getY();
    }

    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_8,1342054,2210997,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        this->title = NULL;
        this->authors = NULL;
        this->publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
       this->title= new char[strlen(title)+1];
       int i = 0;
       while (title[i] != '\0')
       {
           this->title[i]=title[i];
           i++;
       }
       this->title[i]='\0';
       this->authors = new char[strlen(authors)+1];
        i = 0;
       while (authors[i] != '\0')
       {
           this->authors[i]=authors[i];
           i++;
       }
       this->authors[i]='\0';
       this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        this->title=NULL;
        this->authors = NULL;
        this->publishingYear = book.publishingYear;
        setTitle(book.title);
        setAuthors(book.authors);
    }
    
    void setTitle(const char* title)
    {
        if (this->title != nullptr) delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
         if (this->authors != nullptr)  delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        return title;
    }

    char* getAuthors() const
    {
        return authors;
    }

    int getPublishingYear() const
    {
        return publishingYear;
    }

    ~Book()
    {
       delete[] title;
       delete[] authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1342054,2210997,"
class Book {
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        this->title = nullptr;
        this->authors = nullptr;
        this->publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
       this->title = new char[strlen(title) + 1];
       strcpy(this->title, title);
       
       this->authors = new char[strlen(authors) + 1];
       strcpy(this->authors, authors);
       
       this->publishingYear = publishingYear;
    }

   ~Book()
    {
       delete[] title;
       delete[] authors;
    }

    friend bool checkAuthor(const Book& book, const char* author)
{
    const char* authorsList = book.authors;
    while (*authorsList) {
        while (*authorsList && *authorsList == ' ') {
            authorsList++;
        }
        const char* start = authorsList;
        const char* end = nullptr;
        while (*authorsList && *authorsList != ',') {
            if (*authorsList != ' ') {
                end = authorsList + 1;
            }
            authorsList++;
        }

        if (!end) {
            end = authorsList;
        }

        if (strncmp(start, author, end - start) == 0) {
            return true; 
        }

        if (*authorsList == ',') {
            authorsList++; 
        }
    }

    return false; 
}







};",1.0,1111111111
OOP_10,1342054,2210997,"class Book {
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        this->title = nullptr;
        this->authors = nullptr;
        this->publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }

    ~Book()
    {
        delete[] title;
        delete[] authors;
    }

    friend class Printer;
};


class Printer {
public:
    static void printBook(const Book& book)
    {
        cout << book.title << endl;
        const char* authors = book.authors;
        while (*authors) {
            while (*authors && *authors == ' ') {
                authors++;
            }
            const char* start = authors;
            while (*authors && *authors != ',') {
                authors++;
            }
            const char* end = authors;
            while (end > start && *(end - 1) == ' ') {
                end--;
            }
            while (start < end) {
                cout << *start;
                start++;
            }
            
            cout << endl;
            
            if (*authors == ',') {
                authors++; 
            }
        }
        
        cout << book.publishingYear << endl;
    }
};",1.0,1111111111
OOP_11,1342054,2210997,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        numberOfItems = 0;
        for (int i=0;i<5;i++)
        {
            toyBox[i] = NULL;
        }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems >=5) return -1;
         toyBox[numberOfItems] = new CarToy(carToy.price,carToy.color);
         numberOfItems ++;
         return numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        if (numberOfItems >= 5)  return -1; 
        

        toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
        numberOfItems++;
        return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1346991,2210055,"class Point
{
private:
  double x, y;

public:
  Point()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero x-y coordinate
     */
    this->x = 0;

    this->y = 0;
  }

  Point(double x, double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
    this->y = y;
  }

  void setX(double x)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
  }

  void setY(double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->y = y;
  }

  double getX() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->x;
  }

  double getY() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->y;
  }

  double distanceToPoint(const Point &pointA)
  {
    /*
     * STUDENT ANSWER
     * TODO: calculate the distance from this point to point A in the coordinate plane
     */
    return sqrt((2 - pointA.x) * (2 - pointA.x) + (3 - pointA.y) * (3 - pointA.y));
  }
};",0.6,1111110000
OOP_1,1353066, ,"class Point
{
private:
  double x, y;

public:
  Point()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero x-y coordinate
     */
    this->x = 0;
    this->y = 0;
  }

  Point(double x, double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
    this->y = y;
  }

  void setX(double x)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
  }

  void setY(double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->y = y;
  }

  double getX() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->x;
  }

  double getY() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->y;
  }

  double distanceToPoint(const Point &pointA)
  {
    /*
     * STUDENT ANSWER
     * TODO: calculate the distance from this point to point A in the coordinate plane
     */
    return sqrt((2 - this->x) * (2 - this->x) + (3 - this->y) * (3 - this->y));
  }
};",0.3,1011000000
OOP_5,1353066, ,"Character::Character()
{
  // STUDENT ANSWER
  this->x = 0;
  this->y = 0;
  this->hp = 0;
}

Character::Character(int hp, int x, int y)
{
  // STUDENT ANSWER
  this->x = x;
  this->y = y;
  this->hp = hp;
}

int Character::getHp()
{
  // STUDENT ANSWER
  return this->hp;
}

void Character::setHp(int hp)
{
  // STUDENT ANSWER
  this->hp = hp;
}

int Character::getX()
{
  return this->x;
  // STUDENT ANSWER
}

void Character::setX(int x)
{
  // STUDENT ANSWER
  this->x = x;
}

int Character::getY()
{
  // STUDENT ANSWER
  return this->y;
}

void Character::setY(int y)
{
  // STUDENT ANSWER
  this->y = y;
}

int Character::getManhattanDistTo(Character *other)
{
  // STUDENT ANSWER
  return 6;
}",1.0,111111
OOP_6,1353066, ,"// Copy all data from Character other
void Character::operator=(const Character &other)
{
  // STUDENT ANSWEr
  this->x = other.x;
  this->y = other.y;
  this->hp = other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character &other)
{
  // STUDENT ANSWER
  return this->hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()()
{
  // STUDENT ANSWER
  cout << this->getHp() << ""-"" << this->getX() << ""-"" << this->getY();
}",1.0,11111
OOP_7,1353066, ,"class Player
{
private:
  int x;
  int y;
  int hp;

public:
  Player();
  Player(int hp, int x, int y);
  void moveTo(int x, int y);
  void printPlayerData();
  int getHP()
  {
    return hp;
  }
  int getX()
  {
    return x;
  }
  int getY()
  {
    return y;
  }
};
Player::Player()
{
  // STUDENT ANSWER
  this->x = 0;
  this->y = 0;
  this->hp = 0;
}

Player::Player(int hp, int x, int y)
{
  // STUDENT ANSWER
  this->x = x;
  this->y = y;
  this->hp = hp;
}

void Player::printPlayerData()
{
  // STUDENT ANSWER
  cout << this->getHP() << ""-"" << this->getX() << ""-"" << this->getY();
}

void Player::moveTo(int x, int y)
{
  this->x = x;
  this->y = y;
}",0.6,1110
OOP_8,1353066, ,"class Book
{
private:
  char *title;
  char *authors;
  int publishingYear;

public:
  Book()
  {
    /*
     * STUDENT ANSWER
     */
    this->title = nullptr;
    this->authors = nullptr;
    this->publishingYear = 0;
  }

  Book(const char *title, const char *authors, int publishingYear)
  {
    /*
     * STUDENT ANSWER
     */
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);
    this->publishingYear = publishingYear;
  }

  ~Book()
  {
    /*
     * STUDENT ANSWER
     */
    delete[] title;
    delete[] authors;
  }

  friend class Printer;
};

class Printer
{
public:
  static void printBook(const Book book)
  {
    /*
     * STUDENT ANSWER
     */
    cout << book.title << endl
         << book.authors << endl
         << book.publishingYear << endl;
  }
};",1.0,
OOP_1,1355841, ,"class Point
{
private:
  double x, y;

public:
  Point()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero x-y coordinate
     */
    this->x = 0;
    this->y = 0;
  }

  Point(double x, double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
    this->y = y;
  }

  void setX(double x)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
  }

  void setY(double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->y = y;
  }

  double getX() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->x;
  }

  double getY() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->y;
  }

  double distanceToPoint(const Point &pointA)
  {
    /*
     * STUDENT ANSWER
     * TODO: calculate the distance from this point to point A in the coordinate plane
     */
    double distance = sqrt(pow(this->x - pointA.x, 2) + pow(this->y - pointA.y, 2));
    return distance;
  }
};",1.0,1111111111
OOP_2,1355841, ,"class Point
{
  /*
   * STUDENT ANSWER
   * TODO: using code template in previous question
   */
private:
  double x, y;

public:
  Point()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero x-y coordinate
     */
    this->x = 0;
    this->y = 0;
  }

  Point(double x, double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
    this->y = y;
  }

  void setX(double x)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
  }

  void setY(double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->y = y;
  }

  double getX() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->x;
  }

  double getY() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->y;
  }

  double distanceToPoint(const Point &pointA)
  {
    /*
     * STUDENT ANSWER
     * TODO: calculate the distance from this point to point A in the coordinate plane
     */
    double distance = sqrt(pow(this->x - pointA.x, 2) + pow(this->y - pointA.y, 2));
    return distance;
  }
};

class Circle
{
private:
  Point center;
  double radius;

public:
  Circle()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero center's x-y and radius
     */
    this->center.setX(0);
    this->center.setY(0);
    this->radius = 0;
  }

  Circle(Point center, double radius)
  {
    /*
     * STUDENT ANSWER
     */
    this->center.setX(center.getX());
    this->center.setY(center.getY());
    this->radius = radius;
  }

  Circle(const Circle &circle)
  {
    /*
     * STUDENT ANSWER
     */
    this->center = circle.center;
    this->radius = circle.radius;
  }

  void setCenter(Point point)
  {
    /*
     * STUDENT ANSWER
     */
    this->center.setX(point.getX());
    this->center.setY(point.getY());
  }

  void setRadius(double radius)
  {
    /*
     * STUDENT ANSWER
     */
    this->radius = radius;
  }

  Point getCenter() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->center;
  }

  double getRadius() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->radius;
  }

  void printCircle()
  {
    printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
  }
};",1.0,1111111111
OOP_3,1355841, ,"class Point
{
  /*
   * STUDENT ANSWER
   * TODO: using code template in previous question
   */
private:
  double x, y;

public:
  Point()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero x-y coordinate
     */
    this->x = 0;
    this->y = 0;
  }

  Point(double x, double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
    this->y = y;
  }

  void setX(double x)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
  }

  void setY(double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->y = y;
  }

  double getX() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->x;
  }

  double getY() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->y;
  }

  double distanceToPoint(const Point &pointA)
  {
    /*
     * STUDENT ANSWER
     * TODO: calculate the distance from this point to point A in the coordinate plane
     */
    double distance = sqrt(pow(this->x - pointA.x, 2) + pow(this->y - pointA.y, 2));
    return distance;
  }
};

class Circle
{
private:
  Point center;
  double radius;

public:
  Circle()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero center's x-y and radius
     */
    this->center.setX(0);
    this->center.setY(0);
    this->radius = 0;
  }

  Circle(Point center, double radius)
  {
    /*
     * STUDENT ANSWER
     */
    this->center.setX(center.getX());
    this->center.setY(center.getY());
    this->radius = radius;
  }

  bool containsPoint(const Point point)
  {
    /*
     * STUDENT ANSWER
     * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).
             If contain, return true.
     */
    double distance = sqrt(pow(this->center.getX() - point.getX(), 2) + pow(this->center.getY() - point.getY(), 2));
    return distance < this->radius;
  }

  bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
  {
    /*
     * STUDENT ANSWER
     * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).
             If contain, return true.
     */
    double distance1 = sqrt(pow(this->center.getX() - pointA.getX(), 2) + pow(this->center.getY() - pointA.getY(), 2));
    double distance2 = sqrt(pow(this->center.getX() - pointB.getX(), 2) + pow(this->center.getY() - pointB.getY(), 2));
    double distance3 = sqrt(pow(this->center.getX() - pointC.getX(), 2) + pow(this->center.getY() - pointC.getY(), 2));
    return distance1 < this->radius && distance2 < this->radius && distance3 < this->radius;
  }
};",1.0,1111111111
OOP_4,1355841, ,"
class Point
{
  /*
   * STUDENT ANSWER
   * TODO: using code template in previous question
   */
private:
  double x, y;

public:
  Point()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero x-y coordinate
     */
    this->x = 0;
    this->y = 0;
  }

  Point(double x, double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
    this->y = y;
  }

  void setX(double x)
  {
    /*
     * STUDENT ANSWER
     */
    this->x = x;
  }

  void setY(double y)
  {
    /*
     * STUDENT ANSWER
     */
    this->y = y;
  }

  double getX() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->x;
  }

  double getY() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->y;
  }

  double distanceToPoint(const Point &pointA)
  {
    /*
     * STUDENT ANSWER
     * TODO: calculate the distance from this point to point A in the coordinate plane
     */
    double distance = sqrt(pow(this->x - pointA.x, 2) + pow(this->y - pointA.y, 2));
    return distance;
  }
};

class Circle
{
private:
  Point center;
  double radius;

public:
  Circle()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero center's x-y and radius
     */
    this->center.setX(0);
    this->center.setY(0);
    this->radius = 0;
  }

  Circle(Point center, double radius)
  {
    /*
     * STUDENT ANSWER
     */
    this->center.setX(center.getX());
    this->center.setY(center.getY());
    this->radius = radius;
  }

  void operator=(const Circle &circle)
  {
    /*
     * STUDENT ANSWER
     */
    this->center = circle.center;
    this->radius = circle.radius;
  }

  bool operator==(const Circle &circle)
  {
    /*
     * STUDENT ANSWER
     */
    if (this->center.getX() == circle.center.getX() && this->center.getY() == circle.center.getY() && this->radius == circle.radius)
      return true;
    return false;
  }

  friend istream &operator>>(istream &in, Circle &circle)
  {
    /*
     * STUDENT ANSWER
     */
    double x, y, radious;
    in >> x >> y >> radious;
    circle.center.setX(x);
    circle.center.setY(y);
    circle.radius = radious;
    return in;
  }

  void printCircle()
  {
    printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
  }
};",1.0,1111111111
OOP_5,1355841, ,"Character::Character()
{
  // STUDENT ANSWER
  this->x = 0;
  this->y = 0;
  this->hp = 0;
}

Character::Character(int hp, int x, int y)
{
  // STUDENT ANSWER
  this->x = x;
  this->y = y;
  this->hp = hp;
}

int Character::getHp()
{
  // STUDENT ANSWER
  return this->hp;
}

void Character::setHp(int hp)
{
  // STUDENT ANSWER
  this->hp = hp;
}

int Character::getX()
{
  return this->x;
  // STUDENT ANSWER
}

void Character::setX(int x)
{
  // STUDENT ANSWER
  this->x = x;
}

int Character::getY()
{
  // STUDENT ANSWER
  return this->y;
}

void Character::setY(int y)
{
  // STUDENT ANSWER
  this->y = y;
}

int Character::getManhattanDistTo(Character *other)
{
  // STUDENT ANSWER
  return 6;
}",1.0,111111
OOP_6,1355841, ,"// Copy all data from Character other
void Character::operator=(const Character &other)
{
  // STUDENT ANSWEr
  this->x = other.x;
  this->y = other.y;
  this->hp = other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character &other)
{
  // STUDENT ANSWER
  return this->hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()()
{
  // STUDENT ANSWER
  cout << this->getHp() << ""-"" << this->getX() << ""-"" << this->getY();
}",1.0,11111
OOP_7,1355841, ,"class Player : protected Character
{
private:
  int x;
  int y;
  int hp;

public:
  Player();
  Player(int hp, int x, int y);
  void moveTo(int x, int y);
  void printPlayerData();
  int getHP()
  {
    return hp;
  }
  int getX()
  {
    return x;
  }
  int getY()
  {
    return y;
  }
};
Player::Player()
{
  // STUDENT ANSWER
  this->x = 0;
  this->y = 0;
  this->hp = 0;
}

Player::Player(int hp, int x, int y)
{
  // STUDENT ANSWER
  this->x = x;
  this->y = y;
  this->hp = hp;
}

void Player::printPlayerData()
{
  // STUDENT ANSWER
  cout << this->getHP() << ""-"" << this->getX() << ""-"" << this->getY();
}

void Player::moveTo(int x, int y)
{
  this->x = x;
  this->y = y;
}",1.0,11111
OOP_8,1355841, ,"class Book
{
private:
  char *title;
  char *authors;
  int publishingYear;

public:
  Book()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero publishingYear and null pointer
     */
    this->title = nullptr;
    this->authors = nullptr;
    this->publishingYear = 0;
  }

  Book(const char *title, const char *authors, int publishingYear)
  {
    /*
     * STUDENT ANSWER
     */
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);
    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);
    this->publishingYear = publishingYear;
  }

  Book(const Book &book)
  {
    /*
     * STUDENT ANSWER
     * TODO: deep copy constructor
     */
    this->title = new char[strlen(book.title) + 1];
    strcpy(this->title, book.title);
    this->authors = new char[strlen(book.authors) + 1];
    strcpy(this->authors, book.authors);
    this->publishingYear = book.publishingYear;
  }

  void setTitle(const char *title)
  {
    /*
     * STUDENT ANSWER
     */
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);
  }

  void setAuthors(const char *authors)
  {
    /*
     * STUDENT ANSWER
     */
    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);
  }

  void setPublishingYear(int publishingYear)
  {
    /*
     * STUDENT ANSWER
     */
    this->publishingYear = publishingYear;
  }

  char *getTitle() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->title;
  }

  char *getAuthors() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->authors;
  }

  int getPublishingYear() const
  {
    /*
     * STUDENT ANSWER
     */
    return this->publishingYear;
  }

  ~Book()
  {
    /*
     * STUDENT ANSWER
     */
   delete[] this->title;
    delete[] this->authors;
  }

  void printBook()
  {
    printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
  }
};",1.0,1111111111
OOP_9,1355841, ,"class Book
{
private:
  char *title;
  char *authors;
  int publishingYear;

public:
  Book()
  {
    /*
     * STUDENT ANSWER
     */

    this->title = NULL;
    this->authors = NULL;
    this->publishingYear = 0;
  }

  Book(const char *title, const char *authors, int publishingYear)
  {
    /*
     * STUDENT ANSWER
     */
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);
    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);
    this->publishingYear = publishingYear;
  }

  ~Book()
  {
    /*
     * STUDENT ANSWER
     */
   ;
  }

  friend bool checkAuthor(Book book, const char *author)
  {
    /*
     * STUDENT ANSWER
     * TODO: returns true if the author is on the book's authors list, otherwise it returns false
     */
    char *temp = new char[strlen(book.authors) + 1];
    strcpy(temp, book.authors);
    char *token = strtok(temp, "","");
    if (strcmp(token, author) == 0)
    {
      return true;
    }
    token = strtok(NULL, "","");
    while (token != NULL)
    {
      if (strcmp(token + 1, author) == 0)
      {
        return true;
      }
      token = strtok(NULL, "","");
    }
    return false;
  }
};",1.0,1111111111
OOP_10,1355841, ,"
class Book
{
private:
  char *title;
  char *authors;
  int publishingYear;

public:
  Book()
  {
    /*
     * STUDENT ANSWER
     */

    this->title = NULL;
    this->authors = NULL;
    this->publishingYear = 0;
  }

  Book(const char *title, const char *authors, int publishingYear)
  {
    /*
     * STUDENT ANSWER
     */
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);
    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);
    this->publishingYear = publishingYear;
  }

  ~Book()
  {
    /*
     * STUDENT ANSWER
     */
  ;
  }

  friend class Printer;
};

class Printer
{
public:
  static void printBook(const Book book)
  {
    /*
     * STUDENT ANSWER
     */
    cout << book.title << endl;

    char *temp = new char[strlen(book.authors) + 1];
    strcpy(temp, book.authors);
    char *token = strtok(temp, "","");
       cout << token << endl;
 token = strtok(NULL, "","");

    while (token != NULL)
    {
      cout << token+1 << endl;
      token = strtok(NULL, "","");
    }
    cout << book.publishingYear << endl;
  }
};",1.0,1111111111
OOP_11,1355841, ,"enum Color
{
  red,
  green,
  blue
};
enum Size
{
  small,
  medium,
  big
};

class Toy
{
protected:
  double price;

public:
  Toy(double price)
  {
    this->price = price;
  }

  virtual void printType() = 0;
  friend class ToyBox;
};

class CarToy : public Toy
{
private:
  Color color;

public:
  CarToy(double price, Color color) : Toy(price)
  {
    /*
     * STUDENT ANSWER
     */
    this->color = color;
    this->price = price;
  }

  void printType()
  {
    cout << ""This is a car toy\n"";
  }

  friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
  Size size;

public:
  PuzzleToy(double price, Size size) : Toy(price)
  {
    /*
     * STUDENT ANSWER
     */
    this->price = price;
    this->size = size;
  }

  void printType()
  {
    cout << ""This is a puzzle toy\n"";
  }

  friend class ToyBox;
};

class ToyBox
{
private:
  Toy *toyBox[5];
  int numberOfItems;

public:
  ToyBox()
  {
    /*
     * STUDENT ANSWER
     * TODO: set zero numberOfItems and nullptr toyBox
     */
    this->numberOfItems = 0;
    for (int i = 0; i < 5; i++)
      toyBox[i] = nullptr;
  }

  int addItem(const CarToy &carToy)
  {
    /*
    * STUDENT ANSWER
    * TODO: function add a new Car toy to the box.
            If successfully added, the function returns the current number of toys in the box.
            If the box is full, return -1.
    */
    if (numberOfItems <= 4)
    {
      this->toyBox[numberOfItems] = new CarToy(carToy.price, carToy.color);
      numberOfItems++;
      return numberOfItems;
    }
    else
      return -1;
  }

  int addItem(const PuzzleToy &puzzleToy)
  {
    /*
    * STUDENT ANSWER
    * TODO: function add a new Puzzle toy to the box.
            If successfully added, the function returns the current number of toys in the box.
            If the box is full, return -1.
    */
    if (numberOfItems <= 4)
    {
      this->toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
      numberOfItems++;
      return numberOfItems;
    }
    else
      return -1;
  }

  void printBox()
  {
    for (int i = 0; i < numberOfItems; i++)
      toyBox[i]->printType();
  }
};",1.0,1111111111
OOP_1,1361882,2213250,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x)+(this->y -pointA.y)*(this->y- pointA.y));
    }
};",1.0,1111111111
OOP_2,1361882,2213250,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x)+(this->y -pointA.y)*(this->y- pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center.setX(0);
         this->center.setY(0);
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this ->center.setY(center.getY());
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(circle.center.getX());
         this-> center.setY(circle.center.getY());
         this-> radius = circle. radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(point.getX());
         center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1361882,2213250,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x) + (this->y -pointA.y)*(this->y- pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center.setX(0);
         this->center.setY(0);
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this ->center.setY(center.getY());
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(circle.center.getX());
         this-> center.setY(circle.center.getY());
         this-> radius = circle. radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(point.getX());
         center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return (point.distanceToPoint(getCenter()) < radius);
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         if (!containsPoint(pointA)||!containsPoint(pointB)||!containsPoint(pointC)){
             return false;
         }
         if ( pointA.distanceToPoint(pointB) > pointA.distanceToPoint(pointC) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointA.distanceToPoint(pointC) > pointA.distanceToPoint(pointB) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointB.distanceToPoint(pointC) > pointA.distanceToPoint(pointC) + pointA.distanceToPoint(pointB) ) return false;
         return true;
    }
};",1.0,1111111111
OOP_1,1362667,2212282,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y) : x(x), y(y)
    {
        /*  
         * STUDENT ANSWER
         */
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.getX() - x)*(pointA.getX() - x) + (pointA.getY()-y)*(pointA.getY()-y));
    }
};",1.0,1111111111
OOP_2,1362667,2212282,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y) : x(x), y(y)
    {
        /*  
         * STUDENT ANSWER
         */
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.getX() - x)*(pointA.getX() - x) + (pointA.getY()-y)*(pointA.getY()-y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius=0;
    }

    Circle(Point center, double radius)
    {
        this-> center=center;
        this->radius=radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.getCenter();
        radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        this->center =point;
    }

    void setRadius(double radius)
    {
         this->radius =radius;
    }

    Point getCenter() const
    {
        return center;
    }

    double getRadius() const
    {
        return radius;

    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1362667,2212282,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y) : x(x), y(y)
    {
        /*  
         * STUDENT ANSWER
         */
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.getX() - x)*(pointA.getX() - x) + (pointA.getY()-y)*(pointA.getY()-y));
    }
    
    bool operator!=(const Point & A) const {
        return A.getX()!=x || A.getY()!=y; 
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center=center;
        this->radius=radius;
    }

    bool containsPoint(const Point point)
    {
        return center.distanceToPoint(point) < radius;
        
    }
    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        return 
        (pointA != pointB) && (pointA != pointC) && (pointB != pointC)
        && center.distanceToPoint(pointA) < radius
        && center.distanceToPoint(pointB) < radius
        && center.distanceToPoint(pointC) < radius;
    }
};",1.0,1111111111
OOP_1,1367782,2211821,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
         this->y =y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x-pointA.getX())*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
    }
};",1.0,1111111111
OOP_2,1367782,2211821,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
         this->y =y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x-pointA.getX())*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->radius = 0;
         this->center.setX(0);
         this->center.setY(0);
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center =center;
         this->radius=radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = circle.getCenter();
         this->radius =circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center =point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius= radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1367782,2211821,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
         this->y =y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x-pointA.getX())*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->radius = 0;
         this->center.setX(0);
         this->center.setY(0);
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center =center;
         this->radius=radius;
    }

   
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         this->center.distanceToPoint(point);
         return this->center.distanceToPoint(point)<this->radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         return containsPoint(pointA)&&containsPoint(pointB)&&containsPoint(pointC);
    }
};",1.0,1111111111
OOP_4,1367782,2211821,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
         this->y =y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x-pointA.getX())*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
    }
     friend std::istream& operator>>(std::istream &in, Point &point)
    {
        // Triển khai hàm nhập cho lớp Point
        in >> point.x >> point.y;
        return in;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->radius = 0;
         this->center.setX(0);
         this->center.setY(0);
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center =center;
         this->radius=radius;
    }

    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = circle.center;
         this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         return (this->center.getX() == circle.center.getX())&&(this->radius == circle.radius)&&(this->center.getY() == circle.center.getY());
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        in >> circle.center ;
        in >> circle.radius;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1367782,2211821,"Character::Character() {
    // STUDENT ANSWER
    this->hp =0;
    this->x =0;
    this->y =0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp =hp;
    this->x =x;
    this->y =y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp =hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x=x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int x1 = this->x;
    int y1 = this->y;
    int x2 = other->getX();
    int y2 = other->getY();
    
    int manhattanDist = abs(x1 - x2) + abs(y1 - y2);
    
    return manhattanDist;

}",1.0,111111
OOP_6,1367782,2211821,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->setHp(other.hp);
    this->setX(other.x);
    this->setY(other.y);
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return this->hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << hp<<""-""<<x<<""-""<<y;
}",1.0,11111
OOP_7,1367782,2211821,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player : private Character {
public:
    Player():Character::Character(){};
    Player(int hp,int x,int y):Character::Character(hp, x, y){};
    void printPlayerData() {
        std::cout << hp << ""-"" << this->getX() << ""-"" << this->getY() ;
    }

    void moveTo(int x, int y) {
        this->setX(x);
        this->setY(y);
    }
};",1.0,11111
OOP_8,1367782,2211821,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->title =nullptr;
         this->authors=nullptr;
         this->publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
         this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
          this->title = new char[strlen(book.getTitle()) + 1];
        strcpy(this->title, book.getTitle());

        this->authors = new char[strlen(book.getAuthors()) + 1];
        strcpy(this->authors, book.getAuthors());
         this->publishingYear = book.getPublishingYear();
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
          this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
         this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear =publishingYear;
    }
    

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return publishingYear;
    }
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete[] title;
        delete[] authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1367782,2211821,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
   Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->title =nullptr;
         this->authors=nullptr;
         this->publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
         this->publishingYear = publishingYear;
    }
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete[] this->title;
         delete[] this->authors;
    }

    friend bool checkAuthor(const Book& book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
         char* token = strtok(book.authors, "","");
        while (token != nullptr) {
            while (*token == ' ') {
                token++;
            }
            char* ketThuc = token + strlen(token) - 1;
            while (*ketThuc == ' ' || *ketThuc == ',') {
                *ketThuc = '\0';
                ketThuc--;
            }
            if (strcmp(token, author) == 0) {
                return true; 
            }
            token = strtok(nullptr, "","");
        }
        return false; 
    }
};",1.0,1111111111
OOP_10,1367782,2211821,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
   Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->title =nullptr;
         this->authors=nullptr;
         this->publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
         this->publishingYear = publishingYear;
    }
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        if (this->title != nullptr) {
        delete[] this->title;
    }
    if (this->authors != nullptr) {
        delete[] this->authors;
    }
    }

    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book& book)
    {
        /*
         * STUDENT ANSWER
         */
         cout << book.title << ""\n"";

        char* tmp = new char[strlen(book.authors) + 1];
        strcpy(tmp, book.authors);

        char* token = strtok(tmp, "","");

        while (token) {
            cout << token << ""\n"";
            token = strtok(nullptr, "","");
            if (!token) break;
            if (*token == ' ') token++;
        }
        cout << book.publishingYear;
        delete[] tmp;
    }
};",1.0,1111111111
OOP_11,1367782,2211821,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         this->color=color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         this->size =size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         for (int i = 0; i < 5; i++) {
            toyBox[i] = nullptr;
        }
        numberOfItems =0;
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
          if (numberOfItems < 5) {
            toyBox[numberOfItems] = new CarToy(carToy.price, carToy.color);
            numberOfItems++;
            return numberOfItems;
        }
        return -1;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5) {
            toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
            numberOfItems++;
            return numberOfItems;
        }
        return -1;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1368498,2210578,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x=0;
        this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
        */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(x-pointA.getX(),2)+pow(y-pointA.getY(),2));
    }
};",1.0,1111111111
OOP_2,1368498,2210578,"class Point
{
    private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x=0;
        this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
        */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(x-pointA.getX(),2)+pow(y-pointA.getY(),2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius =0;
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
    }

    Circle(Point center, double radius)
    {
    
        this->center.setY(center.getY());
        this->center.setX(center.getX());
        this->radius=radius;
    }

    Circle(const Circle &circle)
    {
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius=circle.radius;
    }
    
    void setCenter(Point point)
    { this->center.setY(point.getY());
        this->center.setX(point.getX());
        
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */this->radius=radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1368498,2210578,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x=0;
        this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
        */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(x-pointA.getX(),2)+pow(y-pointA.getY(),2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        
        center.setX(0);
        center.setY(0);
        radius =0;
    }

    Circle(Point center, double radius)
    {
        this->center.setY(center.getY());
        this->center.setX(center.getX());
        this->radius=radius;
    }

    bool containsPoint(const Point point)
    {
        if(center.distanceToPoint(point)<radius) return true;
        else return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        if(pointA.distanceToPoint(pointB)+pointB.distanceToPoint(pointC)==pointA.distanceToPoint(pointC)||pointA.distanceToPoint(pointC)+pointB.distanceToPoint(pointC)==pointA.distanceToPoint(pointB)||pointA.distanceToPoint(pointC)+pointB.distanceToPoint(pointA)==pointC.distanceToPoint(pointB)) return false;
        
        if(center.distanceToPoint(pointA)<radius&&center.distanceToPoint(pointB)<radius&&center.distanceToPoint(pointC)<radius) return true;
        else return false;
    }
};",1.0,1111111111
OOP_4,1368498,2210578,"class Point
{
    private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x=0;
        this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
        */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(x-pointA.getX(),2)+pow(y-pointA.getY(),2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
     Circle()
    {
        
        center.setX(0);
        center.setY(0);
        radius =0;
    }

    Circle(Point center, double radius)
    {
        this->center.setY(center.getY());
        this->center.setX(center.getX());
        this->radius=radius;
    }
    
    void operator=(const Circle &circle)
    {
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius=circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        if(this->center.getX()==circle.center.getX()&&this->center.getY()==circle.center.getY()&&this->radius==circle.radius) return true;
        else return false;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
         double x, y, radius;
    in >> x >> y >> radius;
    circle.center.setX(x);
    circle.center.setY(y);
    circle.radius = radius;
    return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1368498,2210578,"Character::Character() {
    hp=0;
    x=0;
    y=0;
}

Character::Character(int hp, int x, int y) {
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    return hp;
}

void Character::setHp(int hp) {
    this->hp=hp;
}

int Character::getX() {
    return x;
}

void Character::setX(int x) {
   this->x=x;
}

int Character::getY() {
    return y;
}

void Character::setY(int y) {
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    int a=x-other->x;
    int b=y-other->y;
    if(a<0) a=-a;
    if(b<0) b=-b;
    return a+b;
}",1.0,111111
OOP_6,1368498,2210578,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    x=other.x;
    y=other.y;
    hp=other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return hp<=other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
   cout<<hp<<'-'<<x<<'-'<<y;
}",1.0,11111
OOP_7,1368498,2210578,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player: private Character{
  public:
    Player() : Character() {}
    Player(int hp, int x, int y) : Character(hp, x, y) {}

    void printPlayerData() {
        cout << getHp() << ""-"" << getX() << ""-"" << getY() << endl;
    }

    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }  
};
",1.0,11111
OOP_8,1368498,2210578,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
       title=nullptr;
       authors=nullptr;
       publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        title = new char[strlen(book.title) + 1];
        strcpy(title, book.title);

        authors = new char[strlen(book.authors) + 1];
        strcpy(authors, book.authors);

        publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        return title;
    }

    char* getAuthors() const
    {
        return authors;
    }

    int getPublishingYear() const
    {
        return publishingYear;
    }

    ~Book()
    {
        publishingYear = 0;
        if (title != nullptr) delete[] title;
        if (authors != nullptr) delete[] authors;
    }


    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_1,1368504,2212282,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y) : x(x), y(y)
    {
        /*  
         * STUDENT ANSWER
         */
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.getX() - x)*(pointA.getX() - x) + (pointA.getY()-y)*(pointA.getY()-y));
    }
};",1.0,1111111111
OOP_2,1368504,2212282,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y) : x(x), y(y)
    {
        /*  
         * STUDENT ANSWER
         */
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.getX() - x)*(pointA.getX() - x) + (pointA.getY()-y)*(pointA.getY()-y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius=0;
    }

    Circle(Point center, double radius)
    {
        this-> center=center;
        this->radius=radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.getCenter();
        radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        this->center =point;
    }

    void setRadius(double radius)
    {
         this->radius =radius;
    }

    Point getCenter() const
    {
        return center;
    }

    double getRadius() const
    {
        return radius;

    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1368504,2212282,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y) : x(x), y(y)
    {
        /*  
         * STUDENT ANSWER
         */
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.getX() - x)*(pointA.getX() - x) + (pointA.getY()-y)*(pointA.getY()-y));
    }
    
    bool operator!=(const Point & A) const {
        return A.getX()!=x || A.getY()!=y; 
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center=center;
        this->radius=radius;
    }

    bool containsPoint(const Point point)
    {
        return center.distanceToPoint(point) < radius;
        
    }
    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        return 
        (pointA != pointB) && (pointA != pointC) && (pointB != pointC)
        && center.distanceToPoint(pointA) < radius
        && center.distanceToPoint(pointB) < radius
        && center.distanceToPoint(pointC) < radius;
    }
};",1.0,1111111111
OOP_4,1368504,2212282,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y) : x(x), y(y)
    {
        /*  
         * STUDENT ANSWER
         */
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.getX() - x)*(pointA.getX() - x) + (pointA.getY()-y)*(pointA.getY()-y));
    }
    
    bool operator==(const Point & A) const {
        return A.getX()==x && A.getY()==y; 
    }
};

class Circle
{
public:
    Point center;
    double radius;
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius) : center(center), radius(radius)
    {
        
    }
    
    void operator=(const Circle &circle)
    {
        center = circle.center;
        radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        return circle.center == center && circle.radius == radius;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        double a;
        in >> a;
        circle.center.setX(a);
        in >> a;
        circle.center.setY(a);
        in >> circle.radius;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1368504,2212282,"Character::Character() : hp(0), x(0), y(0)
{
    // STUDENT ANSWER
}

Character::Character(int hp, int x, int y) : hp(hp), x(x), y(y)
{
    // STUDENT ANSWER
}

int Character::getHp() {
    return hp;
}

void Character::setHp(int hp) {
    this->hp = hp;
}

int Character::getX() {
    return x;
}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return y;
}

void Character::setY(int y) {
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    return abs(other->getX()-x) + abs(other->getY()-y);
}",1.0,111111
OOP_6,1368504,2212282,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    this->hp = other.hp;
    this->x  = other.x;
    this->y  = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1368504,2212282,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/

class Player : private Character{
    private:
    int hp;
    int x;
    int y;
    public:
    Player(){hp=0;x=0;y=0;} ;
    Player(int hp,int x,int y){this->hp=hp;this->x=x;this->y=y;} ;
    void printPlayerData(){
        cout<<this->hp<<""-""<<this->x<<""-""<<this->y;
    };
    void moveTo(int x, int y){this->x=x;this->y=y;};
};",1.0,11111
OOP_8,1368504,2212282,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title=NULL;
        authors=NULL;
        publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = (char*)title;
        this->authors = (char*)authors;
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        this->title = book.title;
        this->authors = book.authors;
        this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
       this->title= (char*)title;
    }

    void setAuthors(const char* authors)
    {
        this->authors = (char*)authors;
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear=publishingYear;
    }

    char* getTitle() const
    {
        return (char*)title;
    }

    char* getAuthors() const
    {
         return (char*)authors;
    }

    int getPublishingYear() const
    {
        return (int)publishingYear;
    }

    ~Book()
    {
      //  delete[] Book();
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1368504,2212282,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book() : title(NULL), authors(NULL), publishingYear(99999)
    {
        /*
         * STUDENT ANSWER
         */
    }

    Book(const char *title, const char *authors, int publishingYear)
    : title((char*)title), authors((char*)authors), publishingYear(publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
    }

    ~Book()
    {
        /*
         chocanngulozbithieunang
         */
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        string memayngu = """";
        string temp = book.authors;
        for(char c : temp) {
            if(c == ',') {
                if(memayngu == author) return 1;
                memayngu = """"; continue;
            }
            if(memayngu == """") if(c == ' ') continue;
            memayngu += c;
        }
        
        return memayngu == author;
    }
};",1.0,1111111111
OOP_10,1368504,2212282,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book() : title(NULL), authors(NULL), publishingYear(99999)
    {
        /*
         * STUDENT ANSWER
         */
    }

    Book(const char *title, const char *authors, int publishingYear)
    : title((char*)title), authors((char*)authors), publishingYear(publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
    }

    ~Book()
    {
        /*
         chocanngulozbithieunang
         */
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        cout << book.title << ""\n"";
        string memaybeo = """";
        
        string temp = book.authors;
        for(char c : temp) {
            if(c == ',') {cout << memaybeo << ""\n""; memaybeo = """"; continue;}
            
            if(memaybeo == """") if(c==' ') continue;
            
            memaybeo += c;
        }
        cout << memaybeo << endl;
        
        cout << book.publishingYear;
    }
};


//",1.0,1111111111
OOP_11,1368504,2212282,"enum Color{red,green,blue};
enum Size{small,medium,big};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price), color(color)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price), size(size)
    {
        /*
        chocanngulozzbithiennang
        va 
        vandekynanggiangdaycuanguyenducdung
        */
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox() : numberOfItems(0)
    {
        
    }
    
    int addItem(const CarToy& carToy)
    {
        if(numberOfItems >= 5) return -1;
        
        toyBox[numberOfItems] = new CarToy(carToy.price, carToy.color);
        return ++numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {   
        if(numberOfItems >= 5) return -1;
        
        toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
        return ++numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1369900,2213250,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x)+(this->y -pointA.y)*(this->y- pointA.y));
    }
};",1.0,1111111111
OOP_2,1369900,2213250,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x)+(this->y -pointA.y)*(this->y- pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center.setX(0);
         this->center.setY(0);
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this ->center.setY(center.getY());
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(circle.center.getX());
         this-> center.setY(circle.center.getY());
         this-> radius = circle. radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(point.getX());
         center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1369900,2213250,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x) + (this->y -pointA.y)*(this->y- pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center.setX(0);
         this->center.setY(0);
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this ->center.setY(center.getY());
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(circle.center.getX());
         this-> center.setY(circle.center.getY());
         this-> radius = circle. radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(point.getX());
         center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return (point.distanceToPoint(getCenter()) < radius);
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         if (!containsPoint(pointA)||!containsPoint(pointB)||!containsPoint(pointC)){
             return false;
         }
         if ( pointA.distanceToPoint(pointB) > pointA.distanceToPoint(pointC) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointA.distanceToPoint(pointC) > pointA.distanceToPoint(pointB) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointB.distanceToPoint(pointC) > pointA.distanceToPoint(pointC) + pointA.distanceToPoint(pointB) ) return false;
         return true;
    }
};",1.0,1111111111
OOP_4,1369900,2213250,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x) + (this->y -pointA.y)*(this->y- pointA.y));
    }
    friend istream& operator>>(istream& in, Point& point)
{
    double x, y;
    in >> x >> y;
    point.setX(x);
    point.setY(y);
    return in;
}
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center.setX(0);
         this->center.setY(0);
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this ->center.setY(center.getY());
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(circle.center.getX());
         this-> center.setY(circle.center.getY());
         this-> radius = circle. radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(point.getX());
         center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return (point.distanceToPoint(getCenter()) < radius);
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         if (!containsPoint(pointA)||!containsPoint(pointB)||!containsPoint(pointC)){
             return false;
         }
         if ( pointA.distanceToPoint(pointB) > pointA.distanceToPoint(pointC) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointA.distanceToPoint(pointC) > pointA.distanceToPoint(pointB) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointB.distanceToPoint(pointC) > pointA.distanceToPoint(pointC) + pointA.distanceToPoint(pointB) ) return false;
         return true;
    }
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         if (center.getX() == circle.center.getX() && center.getY() == circle.center.getY() && this->radius == circle.radius) return true;
         return false;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
    Point center;
    double radius;
    in >> center >> radius;
    circle.setCenter(center);
    circle.setRadius(radius);

    return in;
    }
};",1.0,1111111111
OOP_5,1369900,2213250,"Character::Character() {
    // STUDENT ANSWER
    hp = 0;
    x = 0;
    y = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this-> hp = hp;
    this-> x = x;
    this -> y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this-> hp= hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this-> x =x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this-> y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this-> y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
 return abs(this->x - other->x) + abs(this->y - other->y);}",1.0,111111
OOP_6,1369900,2213250,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    x = other.x;
    y = other.y;
    hp = other.hp;


}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    if(hp<= other.hp) return true;
    return false;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<hp<<""-""<<x<<""-""<<y;
}",1.0,11111
OOP_7,1369900,2213250,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player : private Character {
public:
    Player() : Character() {}  
    Player(int hp, int x, int y) : Character(hp, x, y) {}  
    
    void printPlayerData() {
        cout << getHp() << ""-"" << getX() << ""-"" << getY() << endl;
    }

    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_8,1369900,2213250,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         publishingYear = 0;
         title = NULL;
         authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);

    this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
    this->title = new char[strlen(book.title) + 1];
    strcpy(this->title, book.title);

    this->authors = new char[strlen(book.authors) + 1];
    strcpy(this->authors, book.authors);

    this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
    delete[] this->title;
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
    delete[] this->authors;
    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);

    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this-> publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    delete[] authors;
    delete[] title;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1369900,2213250,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         publishingYear = 0;
         title = NULL;
         authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);

    this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
    this->title = new char[strlen(book.title) + 1];
    strcpy(this->title, book.title);

    this->authors = new char[strlen(book.authors) + 1];
    strcpy(this->authors, book.authors);

    this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
    delete[] this->title;
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
    delete[] this->authors;
    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);

    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this-> publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    delete[] authors;
    delete[] title;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
    return (strcmp(book.getAuthors(), author) == 0);
    }
};",0.6,0110110101
OOP_1,1373146,2211738,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double X = (pointA.getX() - this->x)*(pointA.getX() - this->x);
        double Y = (pointA.getY() - this->y)*(pointA.getY() - this->y);
        return sqrt(X+Y);
    }
};",1.0,1111111111
OOP_2,1373146,2211738,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
    private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double X = (pointA.getX() - this->x)*(pointA.getX() - this->x);
        double Y = (pointA.getY() - this->y)*(pointA.getY() - this->y);
        return sqrt(X+Y);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        Point cen;
        this->center = cen;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = circle.getCenter();
        this->radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
        Point cen(point.getX(), point.getY());
        this->center = cen;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1373146,2211738,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
    private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double X = (pointA.getX() - this->x)*(pointA.getX() - this->x);
        double Y = (pointA.getY() - this->y)*(pointA.getY() - this->y);
        return sqrt(X+Y);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        Point cen;
        center = cen;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double res = center.distanceToPoint(point);
        if(res < this->radius) return true;
        return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        double res1 = center.distanceToPoint(pointA);
        double res2 = center.distanceToPoint(pointB);
        double res3 = center.distanceToPoint(pointC);
        
        double a = this->radius;
        if(res1 < a && res2 < a && res3 < a) return true;
        return false;
    }
};",1.0,1111111111
OOP_4,1373146,2211738,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
    private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double X = (pointA.getX() - this->x)*(pointA.getX() - this->x);
        double Y = (pointA.getY() - this->y)*(pointA.getY() - this->y);
        return sqrt(X+Y);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        Point cen;
        this->center = cen;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = circle.center;
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        if(this->radius == circle.radius &&
        this->center.getX() == circle.center.getX()
        && this->center.getY() == circle.center.getY()){
            return true;
        }
        return false;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double x, y;
        in >> x >> y >> circle.radius;
        Point cen(x,y);
        circle.center = cen;
        
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1373146,2211738,"Character::Character() {
    // STUDENT ANSWER
    hp = x = y = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    double X = abs((other->x - this->x));
    double Y = abs((other->y - this->y));
    
    return X+Y;
}",1.0,111111
OOP_6,1373146,2211738,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->hp = other.hp;
    this->x = other.x;
    this->y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    if(this->hp <= other.hp) return true;
    return false;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << to_string(this->hp) + ""-"" + to_string(this->x) + ""-""
    + to_string(this->y);
}",1.0,11111
OOP_7,1373146,2211738,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
    
*/
class Player: protected Character{
private:
    int hp, x, y;
public:
    Player(){
        hp = x = y = 0;
    }
    Player(int hp, int x, int y){
        this->hp = hp;
        this->x = x;
        this->y = y;
    }
    void printPlayerData(){
        cout << to_string(this->hp) << ""-"" << to_string(this->x)
         << ""-"" << to_string(this->y);
    }
    void moveTo(int x, int y){
        this->x = x;
        this->y = y;
    }
};",1.0,11111
OOP_8,1373146,2211738,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        int i = 0, j = 0;
        
        while(title[i] != '\0'){
            i++;
        }
        while(authors[j] != '\0'){
            j++;
        }
        this->title = new char[i];
        this->authors = new char[j];
        
        for(int k = 0; k < i; k++){
            this->title[k] = title[k];
        }
        for(int m = 0; m < j; m++){
            this->authors[m] = authors[m];
        }
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        int i = 0, j = 0;
        
        while(book.title[i] != '\0'){
            i++;
        }
        while(book.authors[j] != '\0'){
            j++;
        }
        this->title = new char[i];
        this->authors = new char[j];
        
        for(int k = 0; k < i; k++){
            this->title[k] = book.title[k];
        }
        for(int m = 0; m < j; m++){
            this->authors[m] = book.authors[m];
        }
        this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        string temp;
        int i = 0;
        while(title[i] != '\0'){
            i++;
        }
        this->title = new char[i];
        for(int k = 0; k < i; k++){
            this->title[k] = title[k];
        }
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        int i = 0;
        while(authors[i] != '\0'){
            i++;
        }
        this->authors = new char[i];
        for(int m = 0; m < i; m++){
            this->authors[m] = authors[m];
        }
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete [] title;
        delete [] authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1373146,2211738,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;
public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
        publishingYear = 0;
    }
    
    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         int i = 0, j = 0;
        while(title[i] != '\0'){
            i++;
        }
        while(authors[j] != '\0'){
            j++;
        }
        this->title = new char[i];
        this->authors = new char[j];
        
        for(int k = 0; k <= i; k++){
            this->title[k] = title[k];
        }
        for(int k = 0; k <= j; k++){
            this->authors[k] = authors[k];
        }
        this->publishingYear = publishingYear;
    }
    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        int i = 0, j = 0, k = 0;
        string temp1, temp2;
        string check[100000];
        while(book.authors[i] != '\0'){
            temp1 += book.authors[i++];
            if(book.authors[i] == ','){
                check[k++] = temp1;
                temp1 = """";
                i += 2;
            }
        }
        check[k] = temp1;
        while(author[j] != '\0'){
            temp2 += author[j];
            j++;
        }
        for(int m = 0; m < k; m++){
            if(temp2 == check[m]) return true;
        }
        return false;
    }
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        
        title = NULL;
        authors = NULL;
    }

    // friend bool checkAuthor(Book book, const char* author)
    // {
    //     /*
    //      * STUDENT ANSWER
    //      * TODO: returns true if the author is on the book's authors list, otherwise it returns false
    //      */
    //     int i = 0, j = 0;
    //     string temp1 = """", temp2 = """";
    //     while(book.authors[i] != '\0'){
    //         temp1 += book.authors[i++];
    //     }
    //     while(author[j] != '\0'){
    //         temp2 += author[j++];
            
    //     }
    //     int res = temp1.find(temp2);
    //     if(res != -1) return true;
    //     return false;
    // }
};",0.9,1110111111
OOP_10,1373146,2211738,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        int i = 0, j = 0;
        while(title[i] != '\0'){
            i++;
        }
        while(authors[j] != '\0'){
            j++;
        }
        this->title = new char[i];
        this->authors = new char[j];
        
        for(int k = 0; k < i; k++){
            this->title[k] = title[k];
        }
        for(int m = 0; m < j; m++){
            this->authors[m] = authors[m];
        }
        this->publishingYear = publishingYear;
    }
    
    // char* getTitle(){
    //     return this->title;
    // }
    // char* getAuthors(){
    //     return this->authors;
    // }
    // int getPublishingYear(){
    //     return this->publishingYear;
    // }
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        title = NULL;
        authors = NULL;
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
        char* get1 = book.title;
        char* get2 = book.authors;
        int publishingYear = book.publishingYear;
        string temp1, temp2;
        int i = 0, j = 0;
        while(get1[i] != '\0'){
            temp1 += get1[i++];
        }
        cout << temp1 << endl;
        while(get2[j] != '\0'){
            temp2 += get2[j++];
            if(get2[j] == ','){
                cout << temp2 << endl;
                temp2 = """";
                j += 2;
            }
        }
        cout << temp2 << endl;
        cout << publishingYear;
    }
};",0.9,1101111111
OOP_11,1373146,2211738,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        toyBox[0] = nullptr;
        numberOfItems = 0;
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(numberOfItems < 5) {
            toyBox[numberOfItems] = new CarToy(carToy);
            numberOfItems++;
            return numberOfItems;
        }
        else return -1;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(numberOfItems < 5){
            toyBox[numberOfItems] = new PuzzleToy(puzzleToy);
            numberOfItems++;
            return numberOfItems;
        }
        return -1;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1374003,2211170,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0.0;  
         y = 0.0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double dx = x - pointA.x;
         double dy = y - pointA.y;
         return sqrt(dx*dx - dy*dy);
    }
};",0.5,1011001001
OOP_1,1377483,2210535,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;

    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.x - this->x) * (pointA.x - this->x) + (pointA.y - this->y) * (pointA.y - this->y));
    }
};",1.0,1111111111
OOP_2,1377483,2210535,"class Point
{
    private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;

    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.x - this->x) * (pointA.x - this->x) + (pointA.y - this->y) * (pointA.y - this->y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        this->center.setX(0);
        this->center.setY(0);
        this->radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    Circle(const Circle& circle)
    {
        this->center = circle.center;
        this->radius = circle.radius;
    }

    void setCenter(Point point)
    {
        this->center.setX(point.getX());
        this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        
        return this->center;
    }

    double getRadius() const
    {
        
        return this->radius;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1377483,2210535,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;

    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.x - this->x) * (pointA.x - this->x) + (pointA.y - this->y) * (pointA.y - this->y));
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        this->center.setX(0);
        this->center.setY(0);
        this->radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    Circle(const Circle& circle)
    {
        this->center = circle.center;
        this->radius = circle.radius;
    }

    void setCenter(Point point)
    {
        this->center.setX(point.getX());
        this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        
        return this->center;
    }

    double getRadius() const
    {
        
        return this->radius;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    bool containsPoint(const Point point)
    {
        
        if (this->center.distanceToPoint(point) < this->radius) {
            return true;
        }
        else return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        
        if (containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC)) {
            return true;
        }
        else return false;
    }
    void operator=(const Circle& circle)
    {
        this->center = circle.center;
        this->radius = circle.radius;
    }

    bool operator==(const Circle& circle)
    {
        return  center.getX() == circle.center.getX() &&
                center.getY() == circle.center.getY() &&
                radius == circle.radius;
    }

    friend istream& operator >> (istream& in, Circle& circle)
    {
        double a, b, r;
        in >> a >> b >> r;
        circle.center.setX(a);
        circle.center.setY(b);
        circle.radius = r;
        return in;
    }
};",1.0,1111111111
OOP_4,1377483,2210535,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;

    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((pointA.x - this->x) * (pointA.x - this->x) + (pointA.y - this->y) * (pointA.y - this->y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        this->center.setX(0);
        this->center.setY(0);
        this->radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    Circle(const Circle& circle)
    {
        this->center = circle.center;
        this->radius = circle.radius;
    }

    void setCenter(Point point)
    {
        this->center.setX(point.getX());
        this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        
        return this->center;
    }

    double getRadius() const
    {
        
        return this->radius;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    bool containsPoint(const Point point)
    {
        /*
         * STUDENT ANSWER
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).
                 If contain, return true.
         */
        if (this->center.distanceToPoint(point) < this->radius) {
            return true;
        }
        else return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*
         * STUDENT ANSWER
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).
                 If contain, return true.
         */
        if (containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC)) {
            return true;
        }
        else return false;
    }
    void operator=(const Circle& circle)
    {
        this->center = circle.center;
        this->radius = circle.radius;
    }

    bool operator==(const Circle& circle)
    {
        return  center.getX() == circle.center.getX() &&
                center.getY() == circle.center.getY() &&
                radius == circle.radius;
    }

    friend istream& operator >> (istream& in, Circle& circle)
    {
        double a, b, r;
        in >> a >> b >> r;
        circle.center.setX(a);
        circle.center.setY(b);
        circle.radius = r;
        return in;
    }
};",1.0,1111111111
OOP_5,1377483,2210535,"double customAbs(double number) {
    return (number < 0) ? -number : number;
}
Character::Character() {
    this->hp = 0;
    this->x = 0;
    this->y = 0;

}

Character::Character(int hp, int x, int y) {
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    return this->hp;
}

void Character::setHp(int hp) {
    this->hp = hp;
}

int Character::getX() {
    return this->x;

}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return this->y;
}

void Character::setY(int y) {
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    int deltaX = customAbs(x - other->getX());
    int deltaY = customAbs(y - other->getY());
    return deltaX + deltaY;
}",1.0,111111
OOP_6,1377483,2210535,"void Character::operator=(const Character& other) {
    this->hp = other.hp;
    this->x = other.x;
    this->y = other.y;
}

bool Character::operator<(const Character& other) {
    return this->hp <= other.hp;

}

void Character::operator()() {
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1377483,2210535,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player : private Character {
public:
    Player() : Character() {}
    Player(int hp, int x, int y) : Character(hp, x, y) {}

    void printPlayerData() {
        std::cout << hp << ""-"" << getX() << ""-"" << getY();
    }

    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_8,1377483,2210535,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book() {
        title = nullptr;
        authors = nullptr;
        this->publishingYear = 0;
    }
    Book(const char* title, const char* authors, int publishingYear) {
        this->title = new char[strlen(title) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(title)); i++) {
            this->title[i] = title[i];
        }
        this->authors = new char[strlen(authors) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(authors)); i++) {
            this->authors[i] = authors[i];
        }
        this->publishingYear = publishingYear;
    }
    Book(const Book& other) {
        this->title = new char[strlen(other.title) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(other.title)); i++) {
            this->title[i] = other.title[i];
        }

        this->authors = new char[strlen(other.authors) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(other.authors)); i++) {
            this->authors[i] = other.authors[i];
        }

        this->publishingYear = other.publishingYear;
    }
    ~Book() {
        delete[] title;
        delete[] authors;
    }
    
    void setTitle(const char* title) {
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        for (int i = 0; title[i]; i++) {
            this->title[i] = title[i];
        }
        this->title[strlen(title)] = '\0';
    }
    void setAuthors(const char* authors) {
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        for (int i = 0; authors[i]; i++) {
            this->authors[i] = authors[i];
        }
        this->authors[strlen(authors)] = '\0';
    }
    void setPublishingYear(int publishingYear) {
        this->publishingYear = publishingYear;
    }
    char* getTitle() const {
        char* copy = new char[strlen(title) + 1];
        for (int i = 0; title[i]; i++) {
            copy[i] = title[i];
        }
        copy[strlen(title)] = '\0';
        return copy;
    }
    char* getAuthors() const {
        char* copy = new char[strlen(authors) + 1];
        for (int i = 0; authors[i]; i++) {
            copy[i] = authors[i];
        }
        copy[strlen(authors)] = '\0';
        return copy;
    }
    int getPublishingYear() const {
        return publishingYear;
    }
    void printBook() {
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1377483,2210535,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;
public:
    Book() {
        title = nullptr;
        authors = nullptr;
        this->publishingYear = 0;
    }
    Book(const char* title, const char* authors, int publishingYear) {
        this->title = new char[strlen(title) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(title)); i++) {
            this->title[i] = title[i];
        }
        this->authors = new char[strlen(authors) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(authors)); i++) {
            this->authors[i] = authors[i];
        }
        this->publishingYear = publishingYear;
    }
    Book(const Book& other) {
        this->title = new char[strlen(other.title) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(other.title)); i++) {
            this->title[i] = other.title[i];
        }

        this->authors = new char[strlen(other.authors) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(other.authors)); i++) {
            this->authors[i] = other.authors[i];
        }

        this->publishingYear = other.publishingYear;
    }
    ~Book() {
        delete[] title;
        delete[] authors;
    }
    
    void setTitle(const char* title) {
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        for (int i = 0; title[i]; i++) {
            this->title[i] = title[i];
        }
        this->title[strlen(title)] = '\0';
    }
    void setAuthors(const char* authors) {
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        for (int i = 0; authors[i]; i++) {
            this->authors[i] = authors[i];
        }
        this->authors[strlen(authors)] = '\0';
    }
    void setPublishingYear(int publishingYear) {
        this->publishingYear = publishingYear;
    }
    char* getTitle() const {
        char* copy = new char[strlen(title) + 1];
        for (int i = 0; title[i]; i++) {
            copy[i] = title[i];
        }
        copy[strlen(title)] = '\0';
        return copy;
    }
    char* getAuthors() const {
        char* copy = new char[strlen(authors) + 1];
        for (int i = 0; authors[i]; i++) {
            copy[i] = authors[i];
        }
        copy[strlen(authors)] = '\0';
        return copy;
    }
    int getPublishingYear() const {
        return publishingYear;
    }
    void printBook() {
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
    friend bool checkAuthor(Book book, const char* author)
    {
        char* token = strtok(book.authors, "","");
        while (token != nullptr)
        {
            // Trim leading and trailing spaces from the token
            char* trimmedAuthor = token;
            while (*trimmedAuthor == ' ')
                trimmedAuthor++;
            char* end = trimmedAuthor + strlen(trimmedAuthor) - 1;
            while (end > trimmedAuthor && *end == ' ')
                *end-- = '\0';

            if (strcmp(trimmedAuthor, author) == 0)
                return true;

            token = strtok(nullptr, "","");
        }

        return false;
    }
};",1.0,1111111111
OOP_10,1377483,2210535,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book() {
        title = nullptr;
        authors = nullptr;
        this->publishingYear = 0;
    }
    Book(const char* title, const char* authors, int publishingYear) {
        this->title = new char[strlen(title) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(title)); i++) {
            this->title[i] = title[i];
        }
        this->authors = new char[strlen(authors) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(authors)); i++) {
            this->authors[i] = authors[i];
        }
        this->publishingYear = publishingYear;
    }
    Book(const Book& other) {
        this->title = new char[strlen(other.title) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(other.title)); i++) {
            this->title[i] = other.title[i];
        }

        this->authors = new char[strlen(other.authors) + 1];
        for (int i = 0; i <= static_cast<int>(strlen(other.authors)); i++) {
            this->authors[i] = other.authors[i];
        }

        this->publishingYear = other.publishingYear;
    }
    ~Book() {
        delete[] title;
        delete[] authors;
    }
    
    void setTitle(const char* title) {
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        for (int i = 0; title[i]; i++) {
            this->title[i] = title[i];
        }
        this->title[strlen(title)] = '\0';
    }
    void setAuthors(const char* authors) {
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        for (int i = 0; authors[i]; i++) {
            this->authors[i] = authors[i];
        }
        this->authors[strlen(authors)] = '\0';
    }
    void setPublishingYear(int publishingYear) {
        this->publishingYear = publishingYear;
    }
    char* getTitle() const {
        char* copy = new char[strlen(title) + 1];
        for (int i = 0; title[i]; i++) {
            copy[i] = title[i];
        }
        copy[strlen(title)] = '\0';
        return copy;
    }
    char* getAuthors() const {
        char* copy = new char[strlen(authors) + 1];
        for (int i = 0; authors[i]; i++) {
            copy[i] = authors[i];
        }
        copy[strlen(authors)] = '\0';
        return copy;
    }
    int getPublishingYear() const {
        return publishingYear;
    }
    void printBook() {
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
    friend bool checkAuthor(Book book, const char* author)
    {
        char* token = strtok(book.authors, "","");
        while (token != nullptr)
        {
            // Trim leading and trailing spaces from the token
            char* trimmedAuthor = token;
            while (*trimmedAuthor == ' ')
                trimmedAuthor++;
            char* end = trimmedAuthor + strlen(trimmedAuthor) - 1;
            while (end > trimmedAuthor && *end == ' ')
                *end-- = '\0';

            if (strcmp(trimmedAuthor, author) == 0)
                return true;

            token = strtok(nullptr, "","");
        }

        return false;
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
        cout << book.getTitle() << endl;
        char *str = book.getAuthors();
        char* token = strtok(str, "","");
        while (token != nullptr) {
            char* trimmedAuthor = token;
            while (*trimmedAuthor == ' ')
            trimmedAuthor++;
            char* end = trimmedAuthor + strlen(trimmedAuthor) - 1;
            while (end > trimmedAuthor && *end == ' ')
            *end-- = '\0';
            cout << trimmedAuthor << endl;
            token = strtok(nullptr, "","");
        }
        delete[]str;
        cout << book.getPublishingYear() << endl;
    }
};",1.0,1111111111
OOP_11,1377483,2210535,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        this->numberOfItems = 0;
        for (int i = 0; i < 5; i++) {
            toyBox[i] = nullptr;
        }
    }

    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box.
                 If the box is full, return -1.
         */
        if (this->numberOfItems < 5) {
            this->toyBox[numberOfItems++] = new CarToy(carToy.price, carToy.color);
            return numberOfItems;
        }
        else return -1;
    }

    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box.
                 If the box is full, return -1.
         */
        if (this->numberOfItems < 5) {
            this->toyBox[numberOfItems++] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
            return numberOfItems;
        }
        else return -1;
    }

    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1383491,2212935,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};",1.0,1111111111
OOP_2,1383491,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(circle.center.getX());
         this->center.setY(circle.center.getY());
         this->radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(point.getX());
         this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1383491,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return this->center.distanceToPoint(point) < this->radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC);
    }
};",1.0,1111111111
OOP_4,1383491,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
    friend istream& operator >>(istream& input, Point& point) {
    input >> point.x >> point.y;
    return input;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = circle.radius;
         this->center = circle.center;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius == circle.radius && this->center.getX() == circle.center.getX() && this->center.getY() == circle.center.getY();
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         in >> circle.center >> circle.radius ;
         return in;
         
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1383491,2212935,"Character::Character() {
    // STUDENT ANSWER
    hp = 0;
    x = 0;
    y =0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int distX = abs(x - other->getX());
    int distY = abs(y - other->getY());
    return distX + distY;
}",1.0,111111
OOP_6,1383491,2212935,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    hp = other.hp;
    x = other.x;
    y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1383491,2212935,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player : public Character {
public:
    Player();
    Player(int hp, int x, int y);
    void printPlayerData();
    void moveTo(int x, int y);
};


Player::Player(){}

Player::Player(int hp, int x, int y)  {
    this->hp = hp;
    setX(x);
    setY(y);
}

void Player::printPlayerData() {
    cout << hp << ""-"" << getX() << ""-"" << getY();
}
void Player::moveTo(int x, int y) {
    setX(x);
    setY(y);
}

",0.6,1110
OOP_8,1383491,2212935,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book(): title(nullptr), authors(nullptr), publishingYear(0)
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         
    }

    Book(const char* title, const char* authors, int publishingYear): publishingYear(publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title) + 1];
        strcpy(this->title, book.title);

        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->authors, book.authors);
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete []title;
        delete []authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_1,1384254,2211170,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0;
         y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double dx = pointA.x - x;
         double dy = pointA.y - y;
         return sqrt(dx * dx + dy * dy);
    }
};",1.0,1111111111
OOP_2,1384254,2211170,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0;
         y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double dx = pointA.x - x;
         double dy = pointA.y - y;
         return sqrt(dx * dx + dy * dy);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center = Point();
         radius = 0.0;
         
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         center = circle.center;
         radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         center = point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1384254,2211170,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0.0;
         y = 0.0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double dx = pointA.x - x;
         double dy = pointA.y - y;
         return sqrt(dx * dx + dy * dy);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        center = Point();
        radius = 0.0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;

    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         double distance = center.distanceToPoint(point);
         return distance < radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        bool containsA = containsPoint(pointA);
        bool containsB = containsPoint(pointB);
        bool containsC = containsPoint(pointC);
        return containsA && containsB && containsC;
    }
};",1.0,1111111111
OOP_4,1384254,2211170,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0.0;
         y = 0.0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double dx = pointA.x - x;
         double dy = pointA.y - y;
         return sqrt(dx * dx + dy * dy);
    }
    
    bool operator==(const Point& other) const {
    return (x == other.x) && (y == other.y);
    }

    friend istream& operator>>(istream& is, Point& point) {
    is >> point.x >> point.y;
    return is;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        center = Point();
        radius = 0.0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;

    }

    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        if (this != &circle){
            center = circle.center;
            radius = circle.radius;
        }
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
          return (center == circle.center) && (radius == circle.radius);
    }

friend istream& operator>>(istream& is, Circle& circle) {
    is >> circle.center;
    is >> circle.radius;
    return is;
}

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1384254,2211170,"Character::Character() {
    // STUDENT ANSWER
    x = 0;
    y = 0;
    hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this-> hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;                    
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int dx = x - other->getX();
    if (dx < 0)
        dx *= -1;   
        
    int dy = y - other->getY();
    if (dy < 0)
        dy *= -1;
        
    return dx + dy;
}",1.0,111111
OOP_6,1384254,2211170,"void Character::operator=(const Character& other) {
    // STUDENT ANSWER
        hp = other.hp;
        x = other.x;
        y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return (hp <= other.hp);
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
     cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1384254,2211170,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player: private Character
{
public:
    Player() : Character() {}

    Player(int hp, int x, int y) : Character(hp, x, y) {}
    
        void printPlayerData() {
        cout << getHp() << ""-"" << getX() << ""-"" << getY(); 
    }

    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_1,1386422,2212303,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return (sqrt((x-pointA.getX())*(x-pointA.getX())+(y-pointA.getY())*(y-pointA.getY())));
    }
};",1.0,1111111111
OOP_2,1386422,2212303,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private: double x,y;
     public:
     Point(){
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
         this->x=x;
    }

    void setY(double y)
    {
         this->y=y;
    }

    double getX() const
    {
         return x;
    }

    double getY() const
    {
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
         return (sqrt((x-pointA.getX())*(x-pointA.getX())+(y-pointA.getY())*(y-pointA.getY())));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius=0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius=radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(circle.getCenter().getX());
         this->center.setY(circle.getCenter().getY());
         this->radius=circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWEr
         */
         this->center.setX(point.getX());
         this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius=radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1386422,2212303,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private: double x,y;
     public:
     Point(){
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
         this->x=x;
    }

    void setY(double y)
    {
         this->y=y;
    }

    double getX() const
    {
         return x;
    }

    double getY() const
    {
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
         return (sqrt((x-pointA.getX())*(x-pointA.getX())+(y-pointA.getY())*(y-pointA.getY())));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        center.setX(0);
         center.setY(0);
         radius=0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius=radius;
}
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return (radius>this->center.distanceToPoint(point));
        
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
       return(this->containsPoint(pointA)&&this->containsPoint(pointB)&&this->containsPoint(pointC));
        
    }
};",1.0,1111111111
OOP_4,1386422,2212303,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private: double x,y;
     public:
     Point(){
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
         this->x=x;
    }

    void setY(double y)
    {
         this->y=y;
    }

    double getX() const
    {
         return x;
    }

    double getY() const
    {
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
         return (sqrt((x-pointA.getX())*(x-pointA.getX())+(y-pointA.getY())*(y-pointA.getY())));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
   Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        center.setX(0);
         center.setY(0);
         radius=0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius=radius;
    
    }
     Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }
    void setRadius(double r){
        this->radius=r;
    }
    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
          this->center.setX(circle.getCenter().getX());
          this->center.setY(circle.getCenter().getY());
          this->radius=circle.getRadius();
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         return (this->radius==circle.getRadius()&&this->center.getX()==circle.getCenter().getX()&&this->center.getY()==circle.getCenter().getY());
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         double x,y,z;
          in >> x>>y>>z;
         circle=Circle(Point(x,y),z);
          return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1386422,2212303,"Character::Character() {
    // STUDENT ANSWER
    this->x=0; this->hp=0; this->y=0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->x=x; this->y=y; this->hp=hp;
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp=hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x=x;
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    return (abs(x - other->getX()) +abs(y - other->getY()));
}",1.0,111111
OOP_6,1386422,2212303,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    x=other.x;
    y=other.y;
    hp=other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return (hp<=other.hp);
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout  << hp << ""-"" << x << ""-"" << y ;
}",1.0,11111
OOP_7,1386422,2212303,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player:protected Character{
public:
    Player() : Character() {};
    Player(int hp, int x, int y):Character(hp, x, y){};
    void printPlayerData(){
        cout << this->getHp() << ""-"" << this->getX() << ""-"" << this->getY();
    }
    void moveTo(int x, int y){
        this->setX(x); this->setY(y);
    }
};",1.0,11111
OOP_8,1386422,2212303,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->title=nullptr; this->authors=nullptr;
         publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
          this->title = new char[strlen(title) + 1]; strcpy(this->title,title);
         this->authors=new char[strlen(authors) + 1]; strcpy(this->authors, authors);
         this->publishingYear=publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
         
          this->title = new char[strlen(book.getTitle()) + 1]; strcpy(this->title,book.getTitle());
         this->authors=new char[strlen(book.getAuthors()) + 1]; strcpy(this->authors, book.getAuthors());
        publishingYear = book.getPublishingYear();
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
         this->title = new char[strlen(title) + 1]; strcpy(this->title,title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
          this->authors=new char[strlen(authors) + 1]; strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear=publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete title;
         delete authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1386422,2212303,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
         title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
          this->title = new char[strlen(title) + 1]; strcpy(this->title,title);
         this->authors=new char[strlen(authors) + 1]; strcpy(this->authors, authors);
         this->publishingYear=publishingYear;
    }
     const char *getAuthors() const
    {
        return authors;
    }
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
       
    }
    
    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
       if (author == nullptr || book.authors == nullptr||book.title==nullptr||book.publishingYear==0)
            return false;
        if(strcmp(book.authors, author)==0) return true;
       char * pch;
       pch = strtok(book.authors, "","");
       while (pch != nullptr)
      {
       if(strcmp(pch, author)==0) return true;
       pch = strtok (NULL, "","");
        if(pch!=nullptr)
       pch++;
      }   
      return false;
    };
};",1.0,1111111111
OOP_10,1386422,2212303,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->title = new char[strlen(title) + 1]; strcpy(this->title,title);
         this->authors=new char[strlen(authors) + 1]; strcpy(this->authors, authors);
         this->publishingYear=publishingYear;
    }
    
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
        cout<<book.title<<endl;
       
            
        
        char * pch;
        pch = strtok(book.authors, "","");
        while (pch != nullptr)
      {
        cout<<pch<<endl;
        pch = strtok (NULL, "","");
        if(pch!=nullptr)
        pch++;
      }   
        cout<<book.publishingYear<<endl;
    }
};",1.0,1111111111
OOP_11,1386422,2212303,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->color=color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->size=size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        numberOfItems=0;
        for(int i=0; i<5; i++){
            toyBox[i]=nullptr;
        }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if(numberOfItems>=5) return -1;
         
         toyBox[numberOfItems]= new CarToy(carToy);
         numberOfItems++;
         return numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(numberOfItems>=5) return -1;
         
        toyBox[numberOfItems]= new PuzzleToy(puzzleToy);
        numberOfItems++;
        return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1387767,2210200,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0, y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d = 0;
         d = sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
         return d;
    }
};",1.0,1111111111
OOP_2,1387767,2210200,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0, y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d = 0;
         d = sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
         return d;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         *this = circle;
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1387767,2210200,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0, y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d = 0;
         d = sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
         return d;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         *this = circle;
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double d = this->center.distanceToPoint(point);
        if(d < radius) return true;
        else return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        double d1 = this->center.distanceToPoint(pointA);
        double d2 = this->center.distanceToPoint(pointB);
        double d3 = this->center.distanceToPoint(pointC);
        return (d1 < radius && d2 < radius && d3 < radius);
    }
};

",1.0,1111111111
OOP_4,1387767,2210200,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0, y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d = 0;
         d = sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
         return d;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         *this = circle;
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->radius = circle.radius;
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double X = circle.center.getX();
        double Y = circle.center.getY();
        return (this->radius == circle.radius && this->center.getX() == X && this->center.getY() == Y);
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double X, Y;
        in >> X >> Y >> circle.radius;
        circle.center.setX(X);
        circle.center.setY(Y);
        return in;
    }
    
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double d = this->center.distanceToPoint(point);
        if(d < radius) return true;
        else return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        double d1 = this->center.distanceToPoint(pointA);
        double d2 = this->center.distanceToPoint(pointB);
        double d3 = this->center.distanceToPoint(pointC);
        return (d1 < radius && d2 < radius && d3 < radius);
    }
};
",1.0,1111111111
OOP_5,1387767,2210200,"Character::Character() {
    // STUDENT ANSWER
    this->x = 0, this->y = 0, this->hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->x = x, this->y = y, this->hp = hp;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int d = abs(this->getX() - other->getX()) + abs(this->getY() - other->getY());
    return d;
}",1.0,111111
OOP_6,1387767,2210200,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    Character temp = other;
    this->setX(temp.getX());
    this->setY(temp.getY());
    this->setHp(temp.getHp());
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    Character temp = other;
    int hpB = temp.getHp();
    return (this->hp <= hpB);
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << this->hp << ""-"" << this->x << ""-"" << this->y;
}",1.0,11111
OOP_7,1387767,2210200,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/

class Player : private Character{
private:
    int x, y, hp;
public:
    Player(){
        this->hp = 0;
        this->x = 0;
        this->y = 0;
    }
    Player(int hp, int x, int y){
        this->setX(x);
        this->setY(y);
        this->setHp(hp);
    }
    void printPlayerData(){
        cout << this->getHp() << ""-"" << this->getX() << ""-"" << this->getY();
    }
    void moveTo(int x, int y){
        this->setX(x);
        this->setY(y);
    }
    
};",1.0,11111
OOP_8,1387767,2210200,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        publishingYear = 0;
        title = NULL;
        authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
        int size = 0;
        while(authors[size] != '\0'){
            ++size;
        }
        this->authors = new char[size+1];
        for(int i = 0; i < size; i++){
            this->authors[i] = authors[i];
        }
        this->authors[size] = '\0';
        size = 0;
        while(title[size] != '\0'){
            ++size;
        }
        this->title = new char[size+1];
        for(int i = 0; i < size; i++){
            this->title[i] = title[i];
        }
        this->title[size] = '\0';
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->publishingYear = book.getPublishingYear();
        int size = 0;
        char *temp = book.getAuthors();
        while(temp[size] != '\0'){
            ++size;
        }
        this->authors = new char[size+1];
        for(int i = 0; i < size; i++){
            this->authors[i] = temp[i];
        }
        this->authors[size] = '\0';
        size = 0;
        temp = book.getTitle();
        while(temp[size] != '\0'){
            ++size;
        }
        this->title = new char[size+1];
        for(int i = 0; i < size; i++){
            this->title[i] = temp[i];
        }
        this->title[size] = '\0';
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        if(this->title){
            delete this->title;
        }
        int i = 0;
        while(title[i] != '0'){
            ++i;
        }
        this->title = new char[i+1];
        i = 0;
        while(title[i] != '\0'){
            this->title[i] = title[i];
            ++i;
        }
        this->title[i] = '\0';
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        int i = 0;
        if(this->authors){
            delete this->authors;
        }
        while(authors[i] != '\0'){
            ++i;
        }
        this->authors = new char[i + 1];
        i = 0;
        while(authors[i] != '\0'){
            this->authors[i] = authors[i];
            ++i;
        }
        this->authors[i] = '\0';
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        if(authors) delete authors;
        if(title) delete title;
        publishingYear = 0;
        authors = NULL;
        title = NULL;
        
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_1,1389595,2212935,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};",1.0,1111111111
OOP_2,1389595,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(circle.center.getX());
         this->center.setY(circle.center.getY());
         this->radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(point.getX());
         this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1389595,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return this->center.distanceToPoint(point) < this->radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC);
    }
};",1.0,1111111111
OOP_4,1389595,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
    friend istream& operator >>(istream& input, Point& point) {
    input >> point.x >> point.y;
    return input;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = circle.radius;
         this->center = circle.center;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius == circle.radius && this->center.getX() == circle.center.getX() && this->center.getY() == circle.center.getY();
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         in >> circle.center >> circle.radius ;
         return in;
         
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1389595,2212935,"Character::Character() {
    // STUDENT ANSWER
    hp = 0;
    x = 0;
    y =0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int distX = abs(x - other->getX());
    int distY = abs(y - other->getY());
    return distX + distY;
}",1.0,111111
OOP_6,1389595,2212935,"void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    hp = other.hp;
    x = other.x;
    y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1389595,2212935,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player : public Character {
public:
    Player();
    Player(int hp, int x, int y);
    void printPlayerData();
    void moveTo(int x, int y);
};
Player::Player():Character(){}


void Player::printPlayerData() {
    std::cout << getHp() << ""-"" << getX() << ""-"" << getY() << std::endl;
}

void Player::moveTo(int x, int y) {
    setX(x);
    setY(y);
}


",0.6,
OOP_8,1389595,2212935,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book(): title(nullptr), authors(nullptr), publishingYear(0)
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         
    }

    Book(const char* title, const char* authors, int publishingYear): publishingYear(publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title) + 1];
        strcpy(this->title, book.title);

        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->authors, book.authors);
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete []title;
        delete []authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_11,1389595,2212935,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox() :  numberOfItems(0)
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         for (int i = 0; i < 5; i++){
             toyBox[i] = nullptr;
         }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5){
             toyBox[numberOfItems] = new CarToy(carToy);
             numberOfItems++;
             return numberOfItems;
         }
         return -1;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5){
             toyBox[numberOfItems] = new PuzzleToy(puzzleToy);
             numberOfItems++;
             return numberOfItems;
         }
         return -1;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1389893,2213836,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((x - pointA.x)*(x - pointA.x) + (y - pointA.y)*(y - pointA.y));
    }
};",1.0,1111111111
OOP_1,1390897,2213298,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(this->x - pointA.getX(), 2) + pow(this->y - pointA.getY(), 2));
    }
};",1.0,1111111111
OOP_2,1390897,2213298,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(this->x - pointA.getX(), 2) + pow(this->y - pointA.getY(), 2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        this->center.setX(0);
        this->center.setY(0);
        this->radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(point.getX());
         this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1390897,2213298,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(this->x - pointA.getX(), 2) + pow(this->y - pointA.getY(), 2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        this->center.setX(0);
        this->center.setY(0);
        this->radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }   

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double distance = sqrt(pow(this->center.getX() - point.getX(), 2) + pow(this->center.getY() - point.getY(), 2));
        return distance < this->radius;
    }
    
    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        return this->containsPoint(pointA) && this->containsPoint(pointB) && this->containsPoint(pointC);
    }

};",1.0,1111111111
OOP_4,1390897,2213298,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(this->x - pointA.getX(), 2) + pow(this->y - pointA.getY(), 2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        this->center.setX(0);
        this->center.setY(0);
        this->radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        return this->radius == circle.radius && this->center.getX() == circle.center.getX() && this->center.getY() == circle.center.getY();
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double x, y, r;
        in >> x >> y >> r;
        circle.center.setX(x);
        circle.center.setY(y);
        circle.radius = r;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1390897,2213298,"Character::Character() {
    // STUDENT ANSWER
    this->x = this->y = this->hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->x = x;
    this->y = y;
    this->hp = hp;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    return abs(x - other->getX()) + abs(y - other->getY());
}",1.0,111111
OOP_6,1390897,2213298,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->hp = other.hp;
    this->x = other.x;
    this->y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return this->hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << this->hp << ""-"" << this->x << ""-"" << this->y;
}",1.0,11111
OOP_7,1390897,2213298,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player : private Character {
public:
    Player() : Character() {}
    Player(int hp, int x, int y) : Character(hp, x, y) {}
    void printPlayerData() {
        operator()();
    }
    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_8,1390897,2213298,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title)+1];
        strcpy(this->title, title);
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors, authors);
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title)+1];
        strcpy(this->title, book.title);
        this->authors = new char[strlen(book.authors)+1];
        strcpy(this->authors, book.authors);
        this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title)+1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete []title;
        delete []authors;
        publishingYear = 0;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1390897,2213298,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title)+1];
        strcpy(this->title, title);
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors, authors);
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title)+1];
        strcpy(this->title, book.title);
        this->authors = new char[strlen(book.authors)+1];
        strcpy(this->authors, book.authors);
        this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title)+1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete []title;
        delete []authors;
        publishingYear = 0;
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        char* authors = book.getAuthors();
        if (!(author || authors)) return false;
        char* token = strtok(authors, "","");
        while (token != nullptr) {
            if (strcmp(token, author) == 0) {
                return true;
            }
            token = strtok(nullptr, "","");
        }
        return false;
    }
};",0.9,1110110101
OOP_10,1390897,2213298,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title)+1];
        strcpy(this->title, title);
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors, authors);
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title)+1];
        strcpy(this->title, book.title);
        this->authors = new char[strlen(book.authors)+1];
        strcpy(this->authors, book.authors);
        this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title)+1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete []title;
        delete []authors;
        publishingYear = 0;
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
        cout << book.getTitle() << '\n';
        char *authors = book.getAuthors();
        char* token = strtok(authors, "","");
        while (token != nullptr) {
            cout << token << '\n';
            token = strtok(nullptr, "","");
            if (token == nullptr) break;
            token++;
        }
        cout << book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1390897,2213298,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        numberOfItems = 0;
        for(int i = 0; i < 5; i++) toyBox[i] = nullptr;
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if (this->numberOfItems >= 5) return -1;
        else {
            toyBox[numberOfItems] = new CarToy(carToy.price, carToy.color);
            numberOfItems++;
            return numberOfItems;
        }
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if (this->numberOfItems >= 5) return -1;
        else {
            toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
            numberOfItems++;
            return numberOfItems;
        }
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1391282,2110501,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x-pointA.x)*(this->x-pointA.x)+(this->y-pointA.y)*(this->y-pointA.y));
    }
};",1.0,1111111111
OOP_2,1391282,2110501,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x-pointA.x)*(this->x-pointA.x)+(this->y-pointA.y)*(this->y-pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center.setX(0);
         this->center.setY(0);
         this->radius=0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius=radius;
         
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center=circle.center;
         this->radius=circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(point.getX());
         this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius=radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1391282,2110501,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x-pointA.x)*(this->x-pointA.x)+(this->y-pointA.y)*(this->y-pointA.y));
    }
};


class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center.setX(0);
         this->center.setY(0);
         this->radius=0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius=radius;
         
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         if(this->center.distanceToPoint(point)<this->radius) return true;
         return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        if(this->containsPoint(pointA)&&this->containsPoint(pointB)&&this->containsPoint(pointC)) return true;
        return false;        
    }
};",1.0,1111111111
OOP_5,1391282,2110501,"Character::Character() {
    // STUDENT ANSWER
    this->hp=0;
    this->x=0;
    this->y=0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp=hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x=x;
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    return abs(this->x-other->getX())+abs(this->y-other->getY());
}",1.0,111111
OOP_6,1391282,2110501,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->hp=other.hp;
    this->x=other.x;
    this->y=other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    if(this->hp<=other.hp)   return true;
    return false;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<this->hp;
    cout<<""-"";
    cout<<this->x;
    cout<<""-"";
    cout<<this->y;
}",1.0,11111
OOP_1,1391300,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.getX() - this->x),2)+pow((pointA.getY() - this->y),2));
        
    }
};",1.0,1111111111
OOP_2,1391300,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.getX() - this->x),2)+pow((pointA.getY() - this->y),2));
        
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this-> center = Point();
         this-> radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center = center;
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center= circle.getCenter();
         this->radius= circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = radius ;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->center;   
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1391300,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.getX() - x),2)+pow((pointA.getY() - y),2));
        
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
         this->center= Point();
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius=radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return this->center.distanceToPoint(point) < this->radius;
    }

    bool  containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         if(!(this->center.distanceToPoint(pointA)<this->radius&&this->center.distanceToPoint(pointB)<this->radius&&this->center.distanceToPoint(pointC)<this->radius))
         return 0;
        //   double a= pointA.distanceToPoint(pointB);
        //   double b= pointA.distanceToPoint(pointC);
        //   double c= pointB.distanceToPoint(pointC);
        //   if(a+b==c||a+c==b||b+c==a) return 0;
         return 1;
    }
};",1.0,1111111111
OOP_1,1391610,2210103,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        double result_x, result_y;
        if ((x <= 0 && pointA.x >= 0) || (x >= 0 && pointA.x <= 0))
        {
            result_x = abs(abs(x) + abs(pointA.x));
        }
        else
        {
            result_x = abs(abs(x) - abs(pointA.x));
        }
        if ((y <= 0 && pointA.y >= 0) || (y >= 0 && pointA.y <= 0))
        {
            result_y = abs(abs(y) + abs(pointA.y));
        }
        else
        {
            result_y = abs(abs(y) - abs(pointA.y));
        }
        double result = sqrt(result_x * result_x + result_y * result_y);
        return result;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    Circle(const Circle& circle)
    {
        this->center.setX(circle.getCenter().getX());
        this->center.setY(circle.getCenter().getY());
        this->radius = circle.radius;
    }

    void setCenter(Point point)
    {
        this->center.setX(point.getX());
        this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        return center;
    }

    double getRadius() const
    {
        return radius;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_2,1391610,2210103,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        double result_x, result_y;
        if ((x <= 0 && pointA.x >= 0) || (x >= 0 && pointA.x <= 0))
        {
            result_x = abs(abs(x) + abs(pointA.x));
        }
        else
        {
            result_x = abs(abs(x) - abs(pointA.x));
        }
        if ((y <= 0 && pointA.y >= 0) || (y >= 0 && pointA.y <= 0))
        {
            result_y = abs(abs(y) + abs(pointA.y));
        }
        else
        {
            result_y = abs(abs(y) - abs(pointA.y));
        }
        double result = sqrt(result_x * result_x + result_y * result_y);
        return result;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    Circle(const Circle& circle)
    {
        this->center.setX(circle.getCenter().getX());
        this->center.setY(circle.getCenter().getY());
        this->radius = circle.radius;
    }

    void setCenter(Point point)
    {
        this->center.setX(point.getX());
        this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        return center;
    }

    double getRadius() const
    {
        return radius;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_4,1391610,2210103,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        double result_x, result_y;
        if ((x <= 0 && pointA.x >= 0) || (x >= 0 && pointA.x <= 0))
        {
            result_x = abs(abs(x) + abs(pointA.x));
        }
        else
        {
            result_x = abs(abs(x) - abs(pointA.x));
        }
        if ((y <= 0 && pointA.y >= 0) || (y >= 0 && pointA.y <= 0))
        {
            result_y = abs(abs(y) + abs(pointA.y));
        }
        else
        {
            result_y = abs(abs(y) - abs(pointA.y));
        }
        double result = sqrt(result_x * result_x + result_y * result_y);
        return result;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    void operator=(const Circle& circle)
    {
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius = circle.radius;
    }

    bool operator==(const Circle& circle)
    {
        if (this->center.getX() == circle.center.getX() && this->center.getY() == circle.center.getY() && this->radius == circle.radius)
        {
            return 1;
        }
        return 0;
    }

    friend istream& operator >> (istream& in, Circle& circle)
    {
        double x_X, y_Y, radius_Radius;
        in >> x_X >> y_Y >> radius_Radius;
        circle.center.setX(x_X);
        circle.center.setY(y_Y);
        circle.radius = radius_Radius;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1391610,2210103,"Character::Character() {
    this->hp = 0;
    this->x = 0;
    this->y = 0;
}

Character::Character(int hp, int x, int y) {
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    return hp;
}

void Character::setHp(int hp) {
    this->hp = hp;
}

int Character::getX() {
    return x;
}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return y;
}

void Character::setY(int y) {
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    int result_x = 0;
    int result_y = 0;
    if ((x <= 0 && other->x >= 0) || (x >= 0 && other->x <= 0))
    {
        result_x = abs(abs(x) + abs(other->x));
    }
    else
    {
        result_x = abs(x - other->x);
    }
    if ((y <= 0 && other->y >= 0) || (y >= 0 && other->y <= 0))
    {
        result_y = abs(abs(y) + abs(other->y));
    }
    else
    {
        result_y = abs(y - other->y);
    }
    return result_x + result_y;
}
",1.0,111111
OOP_6,1391610,2210103,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    hp = other.hp;
    x = other.x;
    y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    if (hp <= other.hp)
    {
        return 1;
    }
    return 0;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1391610,2210103,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player : private Character {
public:
    Player() : Character() {

    }

    Player(int hp, int x, int y) : Character(hp, x, y) {

    }

    void printPlayerData() {
        cout << this->getHp() << ""-"" << this->getX() << ""-"" << this->getY() << endl;
    }

    void moveTo(int x, int y) {
        this->setX(x);
        this->setY(y);
    }
};",1.0,11111
OOP_8,1391610,2210103,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        this->title = nullptr;
        this->authors = nullptr;
        this->publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        char* title_temp;
        this->title = new char[30];
        title_temp = this->title;
        while (*title) {
            *title_temp++ = *title++;
        }
        *title_temp = '\0';
        char* authors_temp;
        this->authors = new char[30];
        authors_temp = this->authors;
        while (*authors) {
            *authors_temp++ = *authors++;
        }
        *authors_temp = '\0';
        this->publishingYear = publishingYear;
    }

    Book(const Book& book)
    {
        if (this->title != nullptr) {
            delete[] this->title;
            this->title = nullptr;
        }
        if (this->authors != nullptr) {
            delete[] this->authors;
            this->authors = nullptr;
        }
        char* temp = book.title;
        this->title = new char[30];
        char* title_temp = this->title;
        while (*temp) {
            *title_temp++ = *temp++;
        }
        *title_temp = '\0';
        this->authors = new char[30];
        char* authors_temp = this->authors;
        temp = book.authors;
        while (*temp) {
            *authors_temp++ = *temp++;
        }
        *authors_temp = '\0';
        this->publishingYear = book.publishingYear;
    }

    void setTitle(const char* title)
    {
        if (this->title != nullptr) {
            delete[] this->title;
            this->title = nullptr;
        }
        this->title = new char[30];
        char* title_temp = this->title;
        while (*title) {
            *title_temp++ = *title++;
        }
        *title_temp = '\0';
    }

    void setAuthors(const char* authors)
    {
        if (this->authors != nullptr) {
            delete[] this->authors;
            this->authors = nullptr;
        }
        this->authors = new char[30];
        char* authors_temp = this->authors;
        while (*authors) {
            *authors_temp++ = *authors++;
        }
        *authors_temp = '\0';
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        return this->title;
    }

    char* getAuthors() const
    {
        return this->authors;
    }

    int getPublishingYear() const
    {
        return this->publishingYear;
    }

    ~Book()
    {
        if (title != nullptr) {
            delete[] title;
            title = nullptr;
        }
        if (authors != nullptr) {
            delete[] authors;
            authors = nullptr;
        }
        publishingYear = 0;
    }

    void printBook() {
        cout << this->title << endl << this->authors << endl << this->publishingYear;
    }
};",1.0,1111111111
OOP_9,1391610,2210103,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->title, title);
        strcpy(this->authors, authors);
        this->publishingYear = publishingYear;
    }

    ~Book()
    {
        if (title != nullptr) {
            delete[] title;
            title = nullptr;
        }
        if (authors != nullptr) {
            delete[] authors;
            authors = nullptr;
        }
        publishingYear = 0;
    }

    friend bool checkAuthor(Book& book, const char* author)
    {
        const char* delim = "",\0"";
        char* author_find = strtok(book.authors, delim);
        while (author_find)
        {
            if (strcmp(author_find, author) == 0)
            {
                return 1;
            }
            author_find = strtok(nullptr, delim);
            if (author_find && author_find[0] == ' ')
            {
                author_find++;
            }
        }
        return 0;
    }
};
",1.0,1111111111
OOP_10,1391610,2210103,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
        this->publishingYear = publishingYear;
    }

    ~Book()
    {
        if (this->title != nullptr)
        {
            delete[] title;
            title = nullptr;
        }
        if (this->authors != nullptr)
        {
            delete[] authors;
            authors = nullptr;
        }
        publishingYear = 0;
    }

    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book& book)
    {
        cout << book.title << endl;
        char* author_find = strtok(book.authors, "","");
        while (author_find)
        {
            cout << author_find << endl;
            author_find = strtok(nullptr, "","");
            if (author_find && author_find[0] == ' ')
            {
                author_find++;
            }
        }
        cout << book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1391610,2210103,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        for (int i = 0; i < 5; i++) {
            toyBox[i] = nullptr;
        }
        this->numberOfItems = 0;
    }

    int addItem(const CarToy& carToy)
    {
        if (numberOfItems < 5) {
            toyBox[numberOfItems++] = new CarToy(carToy.price, carToy.color);
            return numberOfItems;
        }
        return -1;
    }

    int addItem(const PuzzleToy& puzzleToy)
    {
        if (numberOfItems < 5) {
            toyBox[numberOfItems++] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
            return numberOfItems;
        }
        return -1;
    }

    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1392657,2213250,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x)+(this->y -pointA.y)*(this->y- pointA.y));
    }
};",1.0,1111111111
OOP_2,1392657,2213250,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x) + (this->y -pointA.y)*(this->y- pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center.setX(0);
         this->center.setY(0);
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this ->center.setY(center.getY());
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(circle.center.getX());
         this-> center.setY(circle.center.getY());
         this-> radius = circle. radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(point.getX());
         center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return (point.distanceToPoint(getCenter()) < radius);
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         if (!containsPoint(pointA)||!containsPoint(pointB)||!containsPoint(pointC)){
             return false;
         }
         if ( pointA.distanceToPoint(pointB) > pointA.distanceToPoint(pointC) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointA.distanceToPoint(pointC) > pointA.distanceToPoint(pointB) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointB.distanceToPoint(pointC) > pointA.distanceToPoint(pointC) + pointA.distanceToPoint(pointB) ) return false;
         return true;
    }
};",1.0,1111111111
OOP_3,1392657,2213250,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x) + (this->y -pointA.y)*(this->y- pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center.setX(0);
         this->center.setY(0);
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this ->center.setY(center.getY());
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(circle.center.getX());
         this-> center.setY(circle.center.getY());
         this-> radius = circle. radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(point.getX());
         center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return (point.distanceToPoint(getCenter()) < radius);
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         if (!containsPoint(pointA)||!containsPoint(pointB)||!containsPoint(pointC)){
             return false;
         }
         if ( pointA.distanceToPoint(pointB) > pointA.distanceToPoint(pointC) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointA.distanceToPoint(pointC) > pointA.distanceToPoint(pointB) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointB.distanceToPoint(pointC) > pointA.distanceToPoint(pointC) + pointA.distanceToPoint(pointB) ) return false;
         return true;
    }
};",1.0,1111111111
OOP_4,1392657,2213250,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this -> x =0;
         this -> y =0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x =x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y =y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this-> x - pointA.x)*(this-> x - pointA.x) + (this->y -pointA.y)*(this->y- pointA.y));
    }
    friend istream& operator>>(istream& in, Point& point)
{
    double x, y;
    in >> x >> y;
    point.setX(x);
    point.setY(y);
    return in;
}
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center.setX(0);
         this->center.setY(0);
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this ->center.setY(center.getY());
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(circle.center.getX());
         this-> center.setY(circle.center.getY());
         this-> radius = circle. radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center.setX(point.getX());
         center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return (point.distanceToPoint(getCenter()) < radius);
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         if (!containsPoint(pointA)||!containsPoint(pointB)||!containsPoint(pointC)){
             return false;
         }
         if ( pointA.distanceToPoint(pointB) > pointA.distanceToPoint(pointC) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointA.distanceToPoint(pointC) > pointA.distanceToPoint(pointB) + pointB.distanceToPoint(pointC) ) return false;
         if ( pointB.distanceToPoint(pointC) > pointA.distanceToPoint(pointC) + pointA.distanceToPoint(pointB) ) return false;
         return true;
    }
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         if (center.getX() == circle.center.getX() && center.getY() == circle.center.getY() && this->radius == circle.radius) return true;
         return false;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
    Point center;
    double radius;
    in >> center >> radius;
    circle.setCenter(center);
    circle.setRadius(radius);

    return in;
    }
};",1.0,1111111111
OOP_5,1392657,2213250,"Character::Character() {
    // STUDENT ANSWER
    hp = 0;
    x = 0;
    y = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this-> hp = hp;
    this-> x = x;
    this -> y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this-> hp= hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this-> x =x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this-> y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this-> y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
 return abs(this->x - other->x) + abs(this->y - other->y);}",1.0,111111
OOP_6,1392657,2213250,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    x = other.x;
    y = other.y;
    hp = other.hp;


}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    if(hp<= other.hp) return true;
    return false;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<hp<<""-""<<x<<""-""<<y;
}",1.0,11111
OOP_7,1392657,2213250,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player : private Character {
public:
    Player() : Character() {}  
    Player(int hp, int x, int y) : Character(hp, x, y) {}  
    
    void printPlayerData() {
        cout << getHp() << ""-"" << getX() << ""-"" << getY() << endl;
    }

    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_8,1392657,2213250,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         publishingYear = 0;
         title = NULL;
         authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);

    this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
    this->title = new char[strlen(book.title) + 1];
    strcpy(this->title, book.title);

    this->authors = new char[strlen(book.authors) + 1];
    strcpy(this->authors, book.authors);

    this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
    delete[] this->title;
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
    delete[] this->authors;
    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);

    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this-> publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    delete[] authors;
    delete[] title;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1392657,2213250,"#include <string>
#include <vector>
class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         publishingYear = 0;
         title = NULL;
         authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);

    this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
    this->title = new char[strlen(book.title) + 1];
    strcpy(this->title, book.title);

    this->authors = new char[strlen(book.authors) + 1];
    strcpy(this->authors, book.authors);

    this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
    delete[] this->title;
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
    delete[] this->authors;
    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);

    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this-> publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    delete[] authors;
    delete[] title;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
         string str ;
         string temp;
         for(unsigned int i=0 ; i<strlen(author);i++){
             temp.push_back(author[i]);
         }
         for(unsigned int i=0 ; i<strlen(book.authors);i++){
             str.push_back(book.authors[i]);
         }
         int j = 0 ;
	     vector<string> contain;
	     for(int i=0 ; i<(int)str.size();i++){
		if(str[i]==','){
			contain.push_back(str.substr(j,i-j));
			j=i+2;
		}
		else if(i==(int)str.size()-1){
			contain.push_back(str.substr(j));
		}
	}
	for(int i = 0 ; i<(int)contain.size();i++){
	    //cout<<contain[i]<<endl;
	    //cout<<temp<<endl;
	    if(contain[i]==temp) return true;
	}
	return false;
    }
    friend class Printer;
};",1.0,1111111111
OOP_10,1392657,2213250,"#include <string>
#include <vector>
class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         publishingYear = 0;
         title = NULL;
         authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);

    this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
    this->title = new char[strlen(book.title) + 1];
    strcpy(this->title, book.title);

    this->authors = new char[strlen(book.authors) + 1];
    strcpy(this->authors, book.authors);

    this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
    delete[] this->title;
    this->title = new char[strlen(title) + 1];
    strcpy(this->title, title);

    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
    delete[] this->authors;
    this->authors = new char[strlen(authors) + 1];
    strcpy(this->authors, authors);

    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this-> publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    delete[] authors;
    delete[] title;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
         string str ;
         string temp;
         for(unsigned int i=0 ; i<strlen(book.authors);i++){
             str.push_back(book.authors[i]);
         }
         int j = 0 ;
	     vector<string> contain;
	     for(int i=0 ; i<(int)str.size();i++){
		if(str[i]==','){
			contain.push_back(str.substr(j,i-j));
			j=i+2;
		}
		else if(i==(int)str.size()-1){
			contain.push_back(str.substr(j));
		}
	}
	cout<<book.title<<endl;
	for(unsigned int i = 0 ; i < contain.size();i++){
	    cout<<contain[i]<<endl;
	}
	cout<<book.publishingYear;
         
    }
};",1.0,1111111111
OOP_11,1392657,2213250,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         for(int i=0 ; i<5;i++) toyBox[i]=nullptr;
         numberOfItems = 0;
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if(numberOfItems<5){
             toyBox[numberOfItems] = new CarToy(carToy.price , carToy.color);
             return ++numberOfItems;
         }
         else return -1;
         
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if(numberOfItems<5){
             toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price,puzzleToy.size);
             return ++numberOfItems;
         }
         else return -1;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_7,1393548,1912532,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player: protected Character {
    private:
    Character character;
    public:
    Player()
    {
        this->character.setHp(0);
        this->character.setX(0);
        this->character.setY(0);
    }
    Player(int hp, int x, int y)
    {
        this->character.setHp(hp);
        this->character.setX(x);
        this->character.setY(y);
    }
    void printPlayerData()
    {
        cout<< this->character.getHp() << '-'<< this->character.getX() <<'-'<< this->character.getY();
    }
    void moveTo(int x, int y)
    {
        this->character.setX(x);
        this->character.setY(y);
    }
};",1.0,11111
OOP_1,1397476,2213836,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((x - pointA.x)*(x - pointA.x) + (y - pointA.y)*(y - pointA.y));
    }
};",1.0,1111111111
OOP_2,1397476,2213836,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }
};


class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        radius = circle.radius;
        center = circle.center;
    }
    
    void setCenter(Point point)
    {
        center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1397476,2213836,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        //* xem khoảng cách từ điểm tới tâm có nhỏ hơn bán kính không
        return point.distanceToPoint(center) < radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        return (pointA.distanceToPoint(center) < radius) && (pointB.distanceToPoint(center) < radius) && (pointC.distanceToPoint(center) < radius);
    }
};",1.0,1111111111
OOP_4,1397476,2213836,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }

    bool same(const Point& point) const{
        return x == point.x && y == point.y;
    }
};


class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }
    
    void operator=(const Circle &circle)
    {
        this->radius = circle.radius;
        this->center = circle.center;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        return (this->radius == circle.radius) && this->center.same(circle.center);
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        double x, y;
        in >> x >> y >> circle.radius;
        circle.center.setX(x);
        circle.center.setY(y);
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1397476,2213836,"Character::Character() {
    x = y = hp = 0;
}

Character::Character(int hp, int x, int y) {
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    return hp;
}

void Character::setHp(int hp) {
    this->hp = hp;
}

int Character::getX() {
    return x;
}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return y;
}

void Character::setY(int y) {
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    return abs(x - other->x) + abs(y - other->y);
}",1.0,111111
OOP_6,1397476,2213836,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    this->hp = other.hp;
    this->x = other.x;
    this->y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return this->hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1397476,2213836,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/

class Player:Character{
    public:
    Player():Character(){}
    Player(int hp, int x, int y) : Character(hp, x, y){}
    void printPlayerData() {
        cout << this->getHp() << ""-"" << this->getX() << ""-"" << this->getY();
    }
    void moveTo(int x, int y) {
        this->setX(x);
        this->setY(y);
    }
};
",1.0,11111
OOP_8,1397476,2213836,"#include<iostream>

using namespace std;


class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title = new char[1000];
        authors = new char[1000];
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = publishingYear;
        int i = 0;
        while(title[i]) {
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
        
        int j = 0;
        while(authors[j]) {
            this->authors[j] = authors[j];
            j++;
        }
        this->authors[j] = '\0';
    }

    Book(const Book &book)
    {
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = book.publishingYear;
        int i = 0;
        while(book.title[i]) {
            this->title[i] = book.title[i];
            i++;
        }
        this->title[i] = '\0';
        
        int j = 0;
        while(book.authors[j]) {
            this->authors[j] = book.authors[j];
            j++;
        }
        this->authors[j] = '\0';
    }
    
    void setTitle(const char* title)
    {
        int i = 0;
        while(title[i]) {
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
    }

    void setAuthors(const char* authors)
    {
        int j = 0;
        while(authors[j]) {
            this->authors[j] = authors[j];
            j++;
        }
        this->authors[j] = '\0';
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        return title;
    }

    char* getAuthors() const
    {
        return authors;
    }

    int getPublishingYear() const
    {
        return publishingYear;
    }

    ~Book()
    {
        delete[] title;
        delete[] authors;
        publishingYear = 0;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1397476,2213836,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        title = new char[1000];
        authors = new char[1000];
        publishingYear = 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = publishingYear;
        int i = 0;
        while(title[i]) {
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
        
        i = 0;
        while(authors[i]) {
            this->authors[i] = authors[i];
            i++;
        }
        this->authors[i] = '\0';
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        int i = 0;
        while(book.authors[i]) { //* duyệt từng kí tự authors của book
            bool result = true;
            char arr[1000];
            int j = 0;
            //* lưu tác giả vào arr
            while(book.authors[i] && book.authors[i] != ',') {
                arr[j] = book.authors[i];
                j++;
                i++;
            }
            arr[j] = '\0';
            //* xét arr có kí tự khác author không
            j = 0;
            while(arr[j] && author[j]){
                if(arr[j] != author[j]) {
                    result = false;
                    break;
                }
                j++;
            }
            if(!arr[j] && !author[j] && result) return true;
            i += 2; //* duyệt tiếp bỏ qua dấu ','
        }
        return false;
    }
};",1.0,1111111111
OOP_10,1397476,2213836,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:

    Book()
    {
        title = new char[1000];
        authors = new char[1000];
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = publishingYear;
        int i = 0;
        while(title[i]){
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
        i = 0;
        while(authors[i]){
            this->authors[i] = authors[i];
            i++;
        }
        this->authors[i] = '\0';

    }

    
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {   
        cout << book.title << endl;
        int i = 0;
        while(book.authors[i]) {
            char arr[1000];
            int j = 0;
            while(book.authors[i] && book.authors[i] != ',') {
                arr[j++] = book.authors[i++];
            }
            arr[j] = '\0';
            cout << arr << endl;
            i += 2;
        }
        cout << book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1397476,2213836,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price), color(color)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price), size(size)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        for(int i = 0; i < 5; i++) toyBox[i] = NULL;
        numberOfItems = 0;
    }
    
    int addItem(const CarToy& carToy)
    {
        if(numberOfItems == 5) return -1;
        int i = 0;
        while(toyBox[i] != NULL) i++;
        toyBox[i] = new CarToy(carToy);
        numberOfItems ++;
        return numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        if(numberOfItems == 5) return -1;
        int i = 0;
        while(toyBox[i] != NULL) i++;
        toyBox[i] = new PuzzleToy(puzzleToy);
        numberOfItems ++;
        return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1399513,2211170,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0;
         y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double dx = pointA.x - x;
         double dy = pointA.y - y;
         return sqrt(dx * dx + dy * dy);
    }
};",1.0,1111111111
OOP_2,1399513,2211170,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0;
         y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double dx = pointA.x - x;
         double dy = pointA.y - y;
         return sqrt(dx * dx + dy * dy);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center = Point();
         radius = 0.0;
         
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         center = circle.center;
         radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         center = point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1399513,2211170,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0.0;
         y = 0.0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double dx = pointA.x - x;
         double dy = pointA.y - y;
         return sqrt(dx * dx + dy * dy);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        center = Point();
        radius = 0.0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;

    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         double distance = center.distanceToPoint(point);
         return distance < radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        bool containsA = containsPoint(pointA);
        bool containsB = containsPoint(pointB);
        bool containsC = containsPoint(pointC);
        return containsA && containsB && containsC;
    }
};",1.0,1111111111
OOP_4,1399513,2211170,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0.0;
         y = 0.0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double dx = pointA.x - x;
         double dy = pointA.y - y;
         return sqrt(dx * dx + dy * dy);
    }
    
    bool operator==(const Point& other) const {
    return (x == other.x) && (y == other.y);
    }

    friend istream& operator>>(istream& is, Point& point) {
    is >> point.x >> point.y;
    return is;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        center = Point();
        radius = 0.0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;

    }

    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        if (this != &circle){
            center = circle.center;
            radius = circle.radius;
        }
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
          return (center == circle.center) && (radius == circle.radius);
    }

friend istream& operator>>(istream& is, Circle& circle) {
    is >> circle.center;
    is >> circle.radius;
    return is;
}

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1399513,2211170,"Character::Character() {
    // STUDENT ANSWER
    x = 0;
    y = 0;
    hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this-> hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;                    
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int dx = x - other->getX();
    if (dx < 0)
        dx *= -1;   
        
    int dy = y - other->getY();
    if (dy < 0)
        dy *= -1;
        
    return dx + dy;
}",1.0,111111
OOP_6,1399513,2211170,"void Character::operator=(const Character& other) {
    // STUDENT ANSWER
        hp = other.hp;
        x = other.x;
        y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return (hp <= other.hp);
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
     cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1399513,2211170,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player: private Character
{
public:
    Player() : Character() {}

    Player(int hp, int x, int y) : Character(hp, x, y) {}
    
        void printPlayerData() {
        cout << getHp() << ""-"" << getX() << ""-"" << getY(); 
    }

    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_8,1399513,2211170,"class Book {
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book() {
        // TODO: set zero publishingYear and null pointer
        publishingYear = 0;
        title = nullptr;
        authors = nullptr;
    }

    Book(const char* title, const char* authors, int publishingYear) {
        // TODO: Implement the constructor
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }

    Book(const Book& book) {
        // TODO: Implement the deep copy constructor
        this->title = new char[strlen(book.title) + 1];
        strcpy(this->title, book.title);

        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->authors, book.authors);

        this->publishingYear = book.publishingYear;
    }

    void setTitle(const char* title) {
        // TODO: Implement the setTitle method
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors) {
        // TODO: Implement the setAuthors method
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear) {
        // TODO: Implement the setPublishingYear method
        this->publishingYear = publishingYear;
    }

    char* getTitle() const {
        // TODO: Implement the getTitle method
        return title;
    }

    char* getAuthors() const {
        // TODO: Implement the getAuthors method
        return authors;
    }

    int getPublishingYear() const {
        // TODO: Implement the getPublishingYear method
        return publishingYear;
    }

    ~Book() {
        // TODO: Implement the destructor
        delete[] title;
        delete[] authors;
         publishingYear = 0;
    }
    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1399513,2211170,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
        publishingYear = 0;
        title = nullptr;
        authors = nullptr;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete[] title;
        delete[] authors;
        publishingYear = 0;
    }
    
    Book(const Book& other) {
    title = new char[strlen(other.title) + 1];
    strcpy(title, other.title);
    authors = new char[strlen(other.authors) + 1];
    strcpy(authors, other.authors);
    publishingYear = other.publishingYear;
}

friend bool checkAuthor(Book book, const char* author) {
    char* authorList = new char[strlen(book.authors) + 1];
    strcpy(authorList, book.authors);

    char* token = strtok(authorList, "","");
    while (token != nullptr) {
        // Trim leading and trailing spaces from the author name
        while (*token && isspace(*token)) {
            token++;
        }

        char* end = token + strlen(token) - 1;
        while (end > token && isspace(*end)) {
            end--;
        }
        *(end + 1) = '\0';

        // Compare the trimmed author name with the given author parameter
        if (strcmp(token, author) == 0) {
            delete[] authorList;
            return true;
        }

        token = strtok(nullptr, "","");
    }

    delete[] authorList;
    return false;
}
};",1.0,1111111111
OOP_10,1399513,2211170,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book() {
        // TODO: set zero publishingYear and null pointer
        publishingYear = 0;
        title = nullptr;
        authors = nullptr;
    }

    Book(const char* title, const char* authors, int publishingYear) {
        // TODO: Implement the constructor
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }
   
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
                 delete[] title;
        delete[] authors;
         publishingYear = 0;
    }
    
    friend class Printer;
};

class Printer {
public:
    static void printBook(const Book& book) {
        cout << book.title << endl;
        
        // Tokenize the authors string and print each author on a separate line
        char* token = strtok(book.authors, "","");
        while (token != nullptr) {
            char* trimmedAuthor = token;
            while (*trimmedAuthor == ' ') {
                ++trimmedAuthor;
            }
            
            std::cout << trimmedAuthor << std::endl;
            token = std::strtok(nullptr, "","");
        }
        
        cout << book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1399513,2211170,"enum Color
{
    red,
    green,
    blue
};

enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        numberOfItems = 0;
        for (int i = 0; i < 5; i++)
        {
            toyBox[i] = nullptr;
        }
    }

    int addItem(const CarToy& carToy)
    {
        if (numberOfItems < 5)
        {
            toyBox[numberOfItems] = new CarToy(carToy.price, carToy.color);
            numberOfItems++;
            return numberOfItems;
        }
        else
        {
            return -1; // Box is full
        }
    }

    int addItem(const PuzzleToy& puzzleToy)
    {
        if (numberOfItems < 5)
        {
            toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
            numberOfItems++;
            return numberOfItems;
        }
        else
        {
            return -1; // Box is full
        }
    }

    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
        {
            toyBox[i]->printType();
        }
    }
};
",1.0,1111111111
OOP_1,1403368,2212935,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};",1.0,1111111111
OOP_2,1403368,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(circle.center.getX());
         this->center.setY(circle.center.getY());
         this->radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(point.getX());
         this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1403368,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return this->center.distanceToPoint(point) < this->radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC);
    }
};",1.0,1111111111
OOP_4,1403368,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
    friend istream& operator >>(istream& input, Point& point) {
    input >> point.x >> point.y;
    return input;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = circle.radius;
         this->center = circle.center;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius == circle.radius && this->center.getX() == circle.center.getX() && this->center.getY() == circle.center.getY();
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         in >> circle.center >> circle.radius ;
         return in;
         
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1403368,2212935,"Character::Character() {
    // STUDENT ANSWER
    hp = 0;
    x = 0;
    y =0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int distX = abs(x - other->getX());
    int distY = abs(y - other->getY());
    return distX + distY;
}",1.0,111111
OOP_6,1403368,2212935,"void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    hp = other.hp;
    x = other.x;
    y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1403368,2212935,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player: protected Character {
    private:
    Character character;
    public:
    Player()
    {
        this->character.setHp(0);
        this->character.setX(0);
        this->character.setY(0);
    }
    Player(int hp, int x, int y)
    {
        this->character.setHp(hp);
        this->character.setX(x);
        this->character.setY(y);
    }
    void printPlayerData()
    {
        cout<< this->character.getHp() << '-'<< this->character.getX() <<'-'<< this->character.getY();
    }
    void moveTo(int x, int y)
    {
        this->character.setX(x);
        this->character.setY(y);
    }
};",1.0,11111
OOP_8,1403368,2212935,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book(): title(nullptr), authors(nullptr), publishingYear(0)
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         
    }

    Book(const char* title, const char* authors, int publishingYear): publishingYear(publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title) + 1];
        strcpy(this->title, book.title);

        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->authors, book.authors);
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete []title;
        delete []authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_11,1403368,2212935,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox() :  numberOfItems(0)
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         for (int i = 0; i < 5; i++){
             toyBox[i] = nullptr;
         }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5){
             toyBox[numberOfItems] = new CarToy(carToy);
             numberOfItems++;
             return numberOfItems;
         }
         return -1;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5){
             toyBox[numberOfItems] = new PuzzleToy(puzzleToy);
             numberOfItems++;
             return numberOfItems;
         }
         return -1;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_2,1404326,2212372,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
       this->x=0;
       this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
       this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {   
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d;
         d=sqrt((this->x-pointA.getX())*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
         return d; 
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        center.setX(0);
        center.setY(0);
        radius=0;

         
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center=center;
        this->radius=radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
      this->center=circle.center;
      this->radius=circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center=point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->radius=radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
        return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1404326,2212372,"class Point
{
private:

    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
       this->x=0;
       this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
       this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {   
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d;
         d=sqrt((this->x-pointA.getX())*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
         return d; 
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        center.setX(0);
        center.setY(0);
        radius=0;

         
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center=center;
        this->radius=radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double d=center.distanceToPoint(point);
        if(d<radius){return 1;}
        else{return 0;}
    }

   bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
        */ 
        double a=center.distanceToPoint(pointA);
        double b=center.distanceToPoint(pointB);
        double c=center.distanceToPoint(pointC);
        if(a<radius&&b<radius&&c<radius){return 1;}
        else{return 0;}
    }

};",1.0,1111111111
OOP_4,1404326,2212372,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
       this->x=0;
       this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
       this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {   
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d;
         d=sqrt((this->x-pointA.getX())*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
         return d; 
    }
};

    class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        center.setX(0);
        center.setY(0);
        radius=0;

         
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center=center;
        this->radius=radius;
    }
        void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center=circle.center;
        this->radius=circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        if(this->center.getX() ==circle.center.getX()&& this->center.getY() ==circle.center.getY()&&this->radius==circle.radius){return 1;}
        else{return 0;}
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double x,y,r;
        in>>x>>y>>r;
        Point A;
        A.setX(x);
        A.setY(y);
        Circle C(A,r);
        circle=C;

        return in;
    }


    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1404326,2212372,"Character::Character() {
    // STUDENT ANSWER
    this->hp=0;
    this->x=0;
    this->y=0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp=hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x=x;
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int d;
    d=abs(other->getX()-this->getX())+abs(other->getY()-this->getY());
    return d;

}",1.0,111111
OOP_6,1404326,2212372,"void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->hp=other.hp;
    this->x=other.x;
    this->y=other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    if(this->hp<=other.hp){return 1;}
    return 0;

}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
   cout<<getHp()<<""-""<<getX()<<""-""<<getY();

}",1.0,11111
OOP_7,1404326,2212372,"class Player: private Character{
public:
int x,y;
int hp;
Player(){
    setHp(0);
    setX(0);
    setY(0);
}
Player(int hp, int x, int y){
 setHp(hp);
 setX(x);
 setY(y);
}
void printPlayerData(){
cout<<getHp()<<""-""<<getX()<<""-""<<getY();
}
void moveTo(int x, int y){
    setX(x);
    setY(y);
}
};",1.0,11111
OOP_8,1404326,2212372," class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        this->title=nullptr;
        this->authors=nullptr;
        this->publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
       this->title = new char[strlen(title)+1];
strcpy(this->title, title);

        this->authors = new char[strlen(authors)+1];
strcpy(this->authors, authors);

        this->publishingYear=publishingYear;

    }

     Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
          this->title = new char[strlen(book.title)+1];
         strcpy(this->title, book.title);

        this->authors = new char[strlen(book.authors)+1];
         strcpy(this->authors, book.authors);
        this->publishingYear=book.publishingYear;
    }
    
    
    void setTitle(const char*  title)
    {
        /*
         * STUDENT ANSWER
         */
     
        this->title = new char[strlen(title)+1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
       this->authors = new char[strlen(authors)+1];
       strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear=publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        if(title){delete title;};
        if(authors){delete authors;}
        title=nullptr;
        authors=nullptr;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1404326,2212372,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        this->title=nullptr;
        this->authors=nullptr;
        this->publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
       this->title = new char[strlen(title)+1];
strcpy(this->title, title);

        this->authors = new char[strlen(authors)+1];
strcpy(this->authors, authors);

        this->publishingYear=publishingYear;

    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
          this->title = new char[strlen(book.title)+1];
         strcpy(this->title, book.title);

        this->authors = new char[strlen(book.authors)+1];
         strcpy(this->authors, book.authors);
        this->publishingYear=book.publishingYear;
    }
     friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
       */
       char* i=strstr(book.authors,author);
     if(strlen(i)==strlen(author)||i[strlen(author)]==',')
     {delete i;
     
     return 1;}
     return 0;
        
    }
    
};",0.9,1110
OOP_2,1410288,2210532,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point &pointA)
    {
        return sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.center;
        radius = circle.radius;
    }

    void setCenter(Point point)
    {
        this->center.setX(point.getX());
        this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        return this->center;
    }

    double getRadius() const
    {
        return this->radius;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};
",1.0,1111111111
OOP_3,1410288,2210532,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point &pointA)
    {
        return sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        if(center.distanceToPoint(point)<this->radius)return true;
        else return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        if(center.distanceToPoint(pointA)<this->radius &&
        center.distanceToPoint(pointB)<this->radius &&
        center.distanceToPoint(pointC)<this->radius)return true;
        else return false;
    }
};",1.0,1111111111
OOP_4,1410288,2210532,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point &pointA)
    {
        return sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }
    
    void operator=(const Circle &circle)
    {
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        if (this->center.getX() == circle.center.getX() &&
            this->center.getY() == circle.center.getY() &&
            this->radius == circle.radius)
            return true;
        else
            return false;
    }

    friend istream &operator>>(istream &in, Circle &circle)
    {
        double x,y,rad;
        in>>x>>y>>rad;
        circle.center.setX(x);
        circle.center.setY(y);
        circle.radius=rad;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1410288,2210532,"Character::Character() {
    this->hp=0;
    this->x=0;
    this->y=0;
}

Character::Character(int hp, int x, int y) {
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    return this->hp;
}

void Character::setHp(int hp) {
    this->hp=hp;
}

int Character::getX() {
    return this->x;
}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return this->y;
}

void Character::setY(int y) {
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    return abs(x - other->getX()) + abs(y - other->getY());
}",1.0,111111
OOP_6,1410288,2210532,"// Copy all data from Character other
void Character::operator=(const  Character& other) {
    hp=other.hp;
    x=other.x;
    y=other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const  Character& other) {
    return hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    cout<<getHp()<<""-""<<getX()<<""-""<<getY();
}",1.0,11111
OOP_7,1410288,2210532,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player:protected Character{
public: 
    Player():Character(){}
    Player(int hp, int x, int y): Character(hp,x,y){}
    void printPlayerData(){
        (*this)();
    }
    void moveTo(int x, int y){
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_8,1410288,2210532,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book():title(nullptr),authors(nullptr), publishingYear(0){}

    Book(const char* title, const char* authors, int publishingYear):
    title(strdup(title)),
    authors(strdup(authors)), publishingYear(publishingYear){};  

    Book(const Book &book):title(strdup(book.title)), 
    authors(strdup(book.authors)), publishingYear(book.publishingYear){};
    
    void setTitle(const char* title)
    {
        this->title=strdup(title);
    }

    void setAuthors(const char* authors)
    {
        this->authors=strdup(authors);
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear=publishingYear;
    }

    char* getTitle() const
    {
        return this->title;
    }

    char* getAuthors() const
    {
        return this->authors;
    }

    int getPublishingYear() const
    {
        return this->publishingYear;
    }

    ~Book(){
        delete[] title;
        delete[] authors;   
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_1,1411007,2252260,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((pointA.getY()-this->getY())*(pointA.getY()-this->getY()) + (pointA.getX()-this->getX())*(pointA.getX()-this->getX()));
    }
};",1.0,1111111111
OOP_2,1411007,2252260,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0.00;
         this->y = 0.00;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((pointA.getY()-this->getY())*(pointA.getY()-this->getY()) + (pointA.getX()-this->getX())*(pointA.getX()-this->getX()));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center = Point(0.00, 0.00);
         
         this->radius = 0.00;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = Point(center.getX(), center.getY());
         
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(circle.getCenter().getX());
        this->center.setY(circle.getCenter().getY());
        
        this->radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(point.getX());
        this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1411007,2252260,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
    private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0.00;
         this->y = 0.00;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = Point(0.00, 0.00);
         
        this->radius = 0.00;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = Point(center.getX(), center.getY());
         
        this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double length = sqrt(pow(point.getY() - this->center.getY(), 2) + pow(point.getX() - this->center.getX(), 2));
        return length < this->radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC);
    }
};",1.0,1111111111
OOP_4,1411007,2252260,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
    private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0.00;
         this->y = 0.00;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = Point(0.00, 0.00);
         
        this->radius = 0.00;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = Point(center.getX(), center.getY());
        
        this->radius = radius;
    }
    
    Point getCenter() const {
        return this->center;
    }
    
    double getRadius() const {
        return this->radius;
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(circle.getCenter().getX());
        this->center.setY(circle.getCenter().getY());
        this->radius = circle.getRadius();
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        return this->center.getX() == circle.getCenter().getX() && this->center.getY() == circle.getCenter().getY() && this->radius == circle.getRadius();
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double x, y, z;
        in >> x >> y >> z;
        circle.center.setX(x);
        circle.center.setY(y);
        circle.radius = z;
        
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1411007,2252260,"Character::Character() {
    // STUDENT ANSWER
    this->x = 0;
    this->y = 0;
    this->hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int abs_x = (other->x - this->x) >= 0 ? (other->x - this->x) : -(other->x - this->x);
    int abs_y = (other->y - this->y) >= 0 ? (other->y - this->y) : -(other->y - this->y);
    return abs_x + abs_y;
}",1.0,111111
OOP_6,1411007,2252260,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->hp = other.hp;
    this->x = other.x;
    this->y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return this->hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << this->hp <<""-"" << this->x << ""-"" << this->y;
}",1.0,11111
OOP_7,1411007,2252260,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/

class Player : private Character {
    public:
        Player() : Character() {}
        Player(int hp, int x, int y) : Character(hp, x, y) {}
        
        void printPlayerData() {
            cout << getHp() << ""-"" << getX() << ""-"" << getY();
        }
        void moveTo(int x, int y) {
            setX(x);
            setY(y);
        }
};",1.0,11111
OOP_8,1411007,2252260,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        this->title = NULL;
        this->authors = NULL;
        this->publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
        
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
        
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title) + 1];
        strcpy(this->title, book.title);
        
        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->authors, book.authors);
        
        this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
         delete[] this->title;
         this->title = new char[strlen(title) + 1];
         strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->title; 
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete[] title;
        delete[] authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1411007,2252260,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
        this->title = NULL;
        this->authors = NULL;
        this->publishingYear = 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
        
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
        
        this->publishingYear = publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete[] title;
        delete[] authors;
    }
    
    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->authors;
    }

    friend bool checkAuthor(const Book& book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        vector<string> vt;
        string name = """";
        for(unsigned int i=0; i<strlen(book.authors); i++){
            if(book.authors[i] == ','){
                vt.push_back(name);
                name = """";
                i++;
            }
            else
                name += book.authors[i];
        }
        vt.push_back(name);
        return std::find(vt.begin(), vt.end(), author) != vt.end();
    }
};",1.0,1111111111
OOP_10,1411007,2252260,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
        this->title = NULL;
        this->authors = NULL;
        this->publishingYear = 0;
        
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
        
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
        
        this->publishingYear = publishingYear;
    }
    
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete[] title;
        delete[] authors;
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book& book)
    {
        /*
         * STUDENT ANSWER
         */
        vector<string> vt;
        string name = """";
        for(unsigned int i=0; i<strlen(book.authors); i++){
            if(book.authors[i] == ','){
                vt.push_back(name);
                name = """";
                i++;
            }
            else
                name += book.authors[i];
        }
        vt.push_back(name);
        
        cout << book.title << endl;
        for(unsigned int i=0; i<vt.size(); i++){
            cout << vt[i] << endl;
        }
        cout << book.publishingYear << endl;
    }
};",1.0,1111111111
OOP_11,1411007,2252260,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        for(int i=0; i<5; i++)
            toyBox[i] = NULL;
        numberOfItems = 0;
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(numberOfItems >= 5)
            return -1;
        toyBox[numberOfItems] = new CarToy(carToy);
        numberOfItems++;
        return numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(numberOfItems >= 5)
            return -1;
        toyBox[numberOfItems] = new PuzzleToy(puzzleToy);
        numberOfItems++;
        return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1412452,2210200,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0, y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d = 0;
         d = sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
         return d;
    }
};",1.0,1111111111
OOP_2,1412452,2210200,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0, y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d = 0;
         d = sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
         return d;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         *this = circle;
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1412452,2210200,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0, y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d = 0;
         d = sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
         return d;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         *this = circle;
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double d = this->center.distanceToPoint(point);
        if(d < radius) return true;
        else return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        double d1 = this->center.distanceToPoint(pointA);
        double d2 = this->center.distanceToPoint(pointB);
        double d3 = this->center.distanceToPoint(pointC);
        return (d1 < radius && d2 < radius && d3 < radius);
    }
};

",1.0,1111111111
OOP_4,1412452,2210200,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         x = 0, y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d = 0;
         d = sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
         return d;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         *this = circle;
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->radius = circle.radius;
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double X = circle.center.getX();
        double Y = circle.center.getY();
        return (this->radius == circle.radius && this->center.getX() == X && this->center.getY() == Y);
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double X, Y;
        in >> X >> Y >> circle.radius;
        circle.center.setX(X);
        circle.center.setY(Y);
        return in;
    }
    
    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double d = this->center.distanceToPoint(point);
        if(d < radius) return true;
        else return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        double d1 = this->center.distanceToPoint(pointA);
        double d2 = this->center.distanceToPoint(pointB);
        double d3 = this->center.distanceToPoint(pointC);
        return (d1 < radius && d2 < radius && d3 < radius);
    }
};
",1.0,1111111111
OOP_5,1412452,2210200,"Character::Character() {
    // STUDENT ANSWER
    this->x = 0, this->y = 0, this->hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->x = x, this->y = y, this->hp = hp;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int d = abs(this->getX() - other->getX()) + abs(this->getY() - other->getY());
    return d;
}",1.0,111111
OOP_6,1412452,2210200,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    Character temp = other;
    this->setX(temp.getX());
    this->setY(temp.getY());
    this->setHp(temp.getHp());
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    Character temp = other;
    int hpB = temp.getHp();
    return (this->hp <= hpB);
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << this->hp << ""-"" << this->x << ""-"" << this->y;
}",1.0,11111
OOP_7,1412452,2210200,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/

class Player : private Character{
private:
    int x, y, hp;
public:
    Player(){
        this->hp = 0;
        this->x = 0;
        this->y = 0;
    }
    Player(int hp, int x, int y){
        this->setX(x);
        this->setY(y);
        this->setHp(hp);
    }
    void printPlayerData(){
        cout << this->getHp() << ""-"" << this->getX() << ""-"" << this->getY();
    }
    void moveTo(int x, int y){
        this->setX(x);
        this->setY(y);
    }
    
};",1.0,11111
OOP_8,1412452,2210200,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        publishingYear = 0;
        title = NULL;
        authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
        int size = 0;
        while(authors[size] != '\0'){
            ++size;
        }
        this->authors = new char[size+1];
        for(int i = 0; i < size; i++){
            this->authors[i] = authors[i];
        }
        this->authors[size] = '\0';
        size = 0;
        while(title[size] != '\0'){
            ++size;
        }
        this->title = new char[size+1];
        for(int i = 0; i < size; i++){
            this->title[i] = title[i];
        }
        this->title[size] = '\0';
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->publishingYear = book.getPublishingYear();
        int size = 0;
        char *temp = book.getAuthors();
        while(temp[size] != '\0'){
            ++size;
        }
        this->authors = new char[size+1];
        for(int i = 0; i < size; i++){
            this->authors[i] = temp[i];
        }
        this->authors[size] = '\0';
        size = 0;
        temp = book.getTitle();
        while(temp[size] != '\0'){
            ++size;
        }
        this->title = new char[size+1];
        for(int i = 0; i < size; i++){
            this->title[i] = temp[i];
        }
        this->title[size] = '\0';
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        if(this->title){
            delete this->title;
        }
        int i = 0;
        while(title[i] != '0'){
            ++i;
        }
        this->title = new char[i+1];
        i = 0;
        while(title[i] != '\0'){
            this->title[i] = title[i];
            ++i;
        }
        this->title[i] = '\0';
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        int i = 0;
        if(this->authors){
            delete this->authors;
        }
        while(authors[i] != '\0'){
            ++i;
        }
        this->authors = new char[i + 1];
        i = 0;
        while(authors[i] != '\0'){
            this->authors[i] = authors[i];
            ++i;
        }
        this->authors[i] = '\0';
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        if(authors) delete authors;
        if(title) delete title;
        publishingYear = 0;
        authors = NULL;
        title = NULL;
        
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1412452,2210200,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        publishingYear = 0;
        title = NULL;
        authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
        int size = 0;
        while(authors[size] != '\0'){
            ++size;
        }
        this->authors = new char[size+1];
        for(int i = 0; i < size; i++){
            this->authors[i] = authors[i];
        }
        this->authors[size] = '\0';
        size = 0;
        while(title[size] != '\0'){
            ++size;
        }
        this->title = new char[size+1];
        for(int i = 0; i < size; i++){
            this->title[i] = title[i];
        }
        this->title[size] = '\0';
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->publishingYear = book.getPublishingYear();
        int size = 0;
        char *temp = book.getAuthors();
        while(temp[size] != '\0'){
            ++size;
        }
        this->authors = new char[size+1];
        for(int i = 0; i < size; i++){
            this->authors[i] = temp[i];
        }
        this->authors[size] = '\0';
        size = 0;
        temp = book.getTitle();
        while(temp[size] != '\0'){
            ++size;
        }
        this->title = new char[size+1];
        for(int i = 0; i < size; i++){
            this->title[i] = temp[i];
        }
        this->title[size] = '\0';
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        if(this->title){
            delete this->title;
        }
        int i = 0;
        while(title[i] != '0'){
            ++i;
        }
        this->title = new char[i+1];
        i = 0;
        while(title[i] != '\0'){
            this->title[i] = title[i];
            ++i;
        }
        this->title[i] = '\0';
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        int i = 0;
        if(this->authors){
            delete this->authors;
        }
        while(authors[i] != '\0'){
            ++i;
        }
        this->authors = new char[i + 1];
        i = 0;
        while(authors[i] != '\0'){
            this->authors[i] = authors[i];
            ++i;
        }
        this->authors[i] = '\0';
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        if(authors) delete authors;
        if(title) delete title;
        publishingYear = 0;
        authors = NULL;
        title = NULL;
        
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        const char *a = book.getAuthors();
        const char *b = author;
        int sza = 0;
        while(a[sza] != '\0') ++sza;
        int szb = 0;
        while(b[szb] != '\0') ++szb;
        for(int i = 0; i < sza; i++){
            if(a[i] == b[0]){
                bool found = true;
                for(int j = 0; j < szb; j++){
                    if(i + j >= sza) return false;
                    if(a[i + j] != b[j]){
                        found = false;
                        break;
                    }
                }
                if(found){
                    if(i + szb == sza) return true;
                    else if(i + szb < sza && a[i + szb] == ',') return true;
                    else if(i + szb > sza) return false;
                    else continue;
                }
            }
        }
        return false;
    }
};",0.9,1111011111
OOP_10,1412452,2210200,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        publishingYear = 0;
        title = NULL;
        authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
        int size = 0;
        while(authors[size] != '\0'){
            ++size;
        }
        this->authors = new char[size+1];
        for(int i = 0; i < size; i++){
            this->authors[i] = authors[i];
        }
        this->authors[size] = '\0';
        size = 0;
        while(title[size] != '\0'){
            ++size;
        }
        this->title = new char[size+1];
        for(int i = 0; i < size; i++){
            this->title[i] = title[i];
        }
        this->title[size] = '\0';
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->publishingYear = book.getPublishingYear();
        int size = 0;
        char *temp = book.getAuthors();
        while(temp[size] != '\0'){
            ++size;
        }
        this->authors = new char[size+1];
        for(int i = 0; i < size; i++){
            this->authors[i] = temp[i];
        }
        this->authors[size] = '\0';
        size = 0;
        temp = book.getTitle();
        while(temp[size] != '\0'){
            ++size;
        }
        this->title = new char[size+1];
        for(int i = 0; i < size; i++){
            this->title[i] = temp[i];
        }
        this->title[size] = '\0';
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        if(this->title){
            delete this->title;
        }
        int i = 0;
        while(title[i] != '0'){
            ++i;
        }
        this->title = new char[i+1];
        i = 0;
        while(title[i] != '\0'){
            this->title[i] = title[i];
            ++i;
        }
        this->title[i] = '\0';
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        int i = 0;
        if(this->authors){
            delete this->authors;
        }
        while(authors[i] != '\0'){
            ++i;
        }
        this->authors = new char[i + 1];
        i = 0;
        while(authors[i] != '\0'){
            this->authors[i] = authors[i];
            ++i;
        }
        this->authors[i] = '\0';
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        if(authors) delete authors;
        if(title) delete title;
        publishingYear = 0;
        authors = NULL;
        title = NULL;
        
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
         
        char *a = book.getAuthors();
        char *b = book.getTitle();
        int sza = 0;
        while(a[sza] != '\0') ++sza;
        int szb = 0;
        while(b[szb] != '\0') ++szb;
        for(int i = 0; i < szb; i++){
            cout << b[i];
        }
        cout << ""\n"";
        for(int i = 0; i < sza; i++){
            if(a[i] != ',' && a[i] != ' ') cout << a[i];
            else if(a[i] == ',') cout << ""\n"";
            else if(a[i] == ' ' && a[i - 1] != ',') cout << "" "";
        }
        cout << ""\n"";
        cout << book.getPublishingYear();
    }
};",1.0,1111111111
OOP_11,1412452,2210200,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        this->numberOfItems = 0;
        for(int i = 0; i < 5; i++){
            this->toyBox[i] = NULL;
        }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(this->numberOfItems >= 5) return -1;
        this->toyBox[numberOfItems] = new CarToy(carToy.price, carToy.color);
        ++(this->numberOfItems);
        return this->numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(this->numberOfItems >= 5) return -1;
        this->toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
        ++(this->numberOfItems);
        return this->numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1415766,2211367,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
      return x;
    }

    double getY() const
    {
       return y;
    }

    double distanceToPoint(const Point&A)
    {
        return sqrt((A.getX()-(this->x))*(A.getX()-this->x)+(A.getY()-this->y)*(A.getY()-this->y));
    }
};",1.0,1111111111
OOP_2,1415766,2211367,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
      return x;
    }

    double getY() const
    {
       return y;
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center=Point();
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
          center = circle.getCenter();
        radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
       return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1415766,2211367,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
      return x;
    }

    double getY() const
    {
       return y;
    }

    double distanceToPoint(const Point&A)
    {
        return sqrt((A.getX()-(this->x))*(A.getX()-this->x)+(A.getY()-this->y)*(A.getY()-this->y));
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center=Point();
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.getCenter();
        radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
       return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
     bool containsPoint(const Point point)
    {   
        Point A = point;
        if(A.distanceToPoint(this->center)>(this->radius)) return false;
        else return true;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        Point A = pointA;
        Point B = pointB;
        Point C = pointC;
        int ab = A.distanceToPoint(B);
        int bc = B.distanceToPoint(C);
        int ac = A.distanceToPoint(C);
        if(ab+bc>ac||ab+ac>bc||ac+bc>ab){
            int a = A.distanceToPoint(this->center);
        int b = B.distanceToPoint(this->center);
        int c = C.distanceToPoint(this->center);
        if(a>=radius&&b>=radius&&c>=radius){
            return true;
        }
        else return false;
        }
        else{
            return false;
        }
    }
};",0.7,1100100111
OOP_4,1415766,2211367,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
      return x;
    }

    double getY() const
    {
       return y;
    }

    double distanceToPoint(const Point&A)
    {
        return sqrt((A.getX()-(this->x))*(A.getX()-this->x)+(A.getY()-this->y)*(A.getY()-this->y));
    }
    bool operator == (Point &B){
        Point C = B;
        if((this->x==C.x)&&(this->y==C.y)){
            return true;
        }
        return false;
    }
    friend istream& operator >> (istream &in, Point& point)
    {
        in >> point.x;
        in >> point.y;
        return in;
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center=Point();
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.getCenter();
        radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
       return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
     bool containsPoint(const Point point)
    {   
        Point A = point;
        if(A.distanceToPoint(this->center)>(this->radius)) return false;
        else return true;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        Point A = pointA;
        Point B = pointB;
        Point C = pointC;
        int ab = A.distanceToPoint(B);
        int bc = B.distanceToPoint(C);
        int ac = A.distanceToPoint(C);
        if(ab+bc>ac||ab+ac>bc||ac+bc>ab){
            return true;
        }
        else{
            return false;
        }
        int a = A.distanceToPoint(this->center);
        int b = B.distanceToPoint(this->center);
        int c = C.distanceToPoint(this->center);
        if(a>radius&&b>radius&&c>radius){
            return true;
        }
        else return false;
    }
    void operator=(const Circle &circle)
    {
        Circle B = circle;
        this->center = B.getCenter();
        this->radius = B.getRadius();
    }

    bool operator==(const Circle &circle)
    {
        Circle B = circle;
        if((this->center==B.center)&&(this->radius)==B.radius){
            return true;
        }
        return false;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        in >> circle.center;
        in >> circle.radius;
        return in;
    }
};",1.0,1111111111
OOP_5,1415766,2211367,"Character::Character() {
     x = y = hp = 0;
}

Character::Character(int hp, int x, int y) {
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    return hp;
    // STUDENT ANSWER
}

void Character::setHp(int hp) {
    this->hp = hp;
    // STUDENT ANSWER
}

int Character::getX() {
    return x;
    // STUDENT ANSWER
}

void Character::setX(int x) {
    this->x=x;
    // STUDENT ANSWER
}

int Character::getY() {
    return y;
    // STUDENT ANSWER
}

void Character::setY(int y) {
    this->y = y;
    // STUDENT ANSWER
}

int absd(int x){
    if(x>=0) return x;
    else return x*(-1);
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    return (absd((this -> x)-(other -> x))+absd(((this)->y)- ((other)->y)));
}",1.0,111111
OOP_6,1415766,2211367,"void Character:: operator=(const Character& other) {
    // STUDENT ANSWER
    Character A = other;
    setHp(A.getHp());
    setX(A.getX());
    setY(A.getY());
    

}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    Character A = other;
    if(this->hp>A.getHp()){
        return false;
    }
    else return true;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1415766,2211367,"class Player{
        private:
        Character * A;
        public:
        Player(){
            A->setHp(0);
            A->setX(0);
            A->setY(0);
        }
        Player(int hp, int x, int y){
            A->setHp(hp);
            A->setX(x);
            A->setY(y);
        }
         void printPlayerData(){
            cout << A->getHp() << ""-"" <<  A->getX() << ""-"" << A->getY();
         }
         void moveTo(int x, int y){
            A->setX(x);
            A->setY(y);
         }

};",0.6,1110
OOP_1,1415788,2210532,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point &pointA)
    {
        return sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
    }
};",1.0,1111111111
OOP_2,1415788,2210532,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point &pointA)
    {
        return sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.center;
        radius = circle.radius;
    }

    void setCenter(Point point)
    {
        this->center.setX(point.getX());
        this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        return this->center;
    }

    double getRadius() const
    {
        return this->radius;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};
",1.0,1111111111
OOP_3,1415788,2210532,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point &pointA)
    {
        return sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        if(center.distanceToPoint(point)<this->radius)return true;
        else return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        if(center.distanceToPoint(pointA)<this->radius &&
        center.distanceToPoint(pointB)<this->radius &&
        center.distanceToPoint(pointC)<this->radius)return true;
        else return false;
    }
};",1.0,1111111111
OOP_4,1415788,2210532,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return this->x;
    }

    double getY() const
    {
        return this->y;
    }

    double distanceToPoint(const Point &pointA)
    {
        return sqrt((x - pointA.getX()) * (x - pointA.getX()) + (y - pointA.getY()) * (y - pointA.getY()));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }
    
    void operator=(const Circle &circle)
    {
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        if (this->center.getX() == circle.center.getX() &&
            this->center.getY() == circle.center.getY() &&
            this->radius == circle.radius)
            return true;
        else
            return false;
    }

    friend istream &operator>>(istream &in, Circle &circle)
    {
        double x,y,rad;
        in>>x>>y>>rad;
        circle.center.setX(x);
        circle.center.setY(y);
        circle.radius=rad;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1415788,2210532,"Character::Character() {
    this->hp=0;
    this->x=0;
    this->y=0;
}

Character::Character(int hp, int x, int y) {
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    return this->hp;
}

void Character::setHp(int hp) {
    this->hp=hp;
}

int Character::getX() {
    return this->x;
}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return this->y;
}

void Character::setY(int y) {
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    return abs(x - other->getX()) + abs(y - other->getY());
}",1.0,111111
OOP_6,1415788,2210532,"// Copy all data from Character other
void Character::operator=(const  Character& other) {
    hp=other.hp;
    x=other.x;
    y=other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const  Character& other) {
    return hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    cout<<getHp()<<""-""<<getX()<<""-""<<getY();
}",1.0,11111
OOP_7,1415788,2210532,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player:protected Character{
public: 
    Player():Character(){}
    Player(int hp, int x, int y): Character(hp,x,y){}
    void printPlayerData(){
        (*this)();
    }
    void moveTo(int x, int y){
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_8,1415788,2210532,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book():title(nullptr),authors(nullptr), publishingYear(0){}

    Book(const char* title, const char* authors, int publishingYear):
    title(strdup(title)),
    authors(strdup(authors)), publishingYear(publishingYear){};  

    Book(const Book &book):title(strdup(book.title)), 
    authors(strdup(book.authors)), publishingYear(book.publishingYear){};
    
    void setTitle(const char* title)
    {
        this->title=strdup(title);
    }

    void setAuthors(const char* authors)
    {
        this->authors=strdup(authors);
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear=publishingYear;
    }

    char* getTitle() const
    {
        return this->title;
    }

    char* getAuthors() const
    {
        return this->authors;
    }

    int getPublishingYear() const
    {
        return this->publishingYear;
    }

    ~Book(){
        delete[] title;
        delete[] authors;   
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1415788,2210532,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book() : title(nullptr), authors(nullptr), publishingYear(0) {}

    Book(const char *title, const char *authors, int publishingYear)
        : title(strdup(title)), authors(strdup(authors)), publishingYear(publishingYear) {}

    ~Book()
    {
        free(title);
        free(authors);
    }

    friend bool checkAuthor(const Book &book, const char *author)
    {   bool check = false;
        char *token = strtok(strdup(book.authors), "","");
    
        while (token != nullptr)
        {
            if (strcmp(token, author) == 0)
            {
                free(strdup(book.authors));
                check = true;
            }
            token = strtok(nullptr, "","");
        }
    
        free(strdup(book.authors));
        return check;
    }
};",0.7,1110110101
OOP_10,1415788,2210532,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book() : title(nullptr), authors(nullptr), publishingYear(0) {}

    Book(const char *title, const char *authors, int publishingYear)
        : title(strdup(title)), authors(strdup(authors)), publishingYear(publishingYear) {}

    ~Book()
    {
        free(title);
        free(authors);
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book &book)
    {
        cout<<book.title<<""\n"";
        char *token = strtok(book.authors, "","");
        while (token != nullptr)
        {
            while(*token == ' ')token++;
            cout << token << ""\n"";
            token = strtok(nullptr, "","");
        }
        cout<<book.publishingYear<<""\n"";
    }
};",1.0,1111111111
OOP_11,1415788,2210532,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         numberOfItems = 0;
    for (int i = 0; i < 5; i++) {
        toyBox[i] = nullptr;
    }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(numberOfItems>=5)return -1;
        toyBox[numberOfItems] = new CarToy(carToy);
        numberOfItems+=1;
        return numberOfItems;
         
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if(numberOfItems>=5)return -1;
        toyBox[numberOfItems] = new PuzzleToy(puzzleToy);
        numberOfItems+=1;
        return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1416217,2013048,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        x = y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double xA = pointA.getX(), yA = pointA.getY();
        return sqrt((xA-this->x)*(xA-this->x) + (yA-this->y)*(yA-this->y));
    }
};",1.0,1111111111
OOP_2,1416217,2013048,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        x = y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double xA = pointA.getX(), yA = pointA.getY();
        return sqrt((xA-this->x)*(xA-this->x) + (yA-this->y)*(yA-this->y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center.setX(center.getX());
        this->center.setY(center.getY());
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = circle.getCenter();
        this->radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1416217,2013048,"#include <cmath>

class Point
{
public:
    double x, y;

    Point() : x(0.0), y(0.0) {}

    Point(double x, double y) : x(x), y(y) {}

    // Add any other necessary member functions or operators here
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle() : radius(0.0) {}

    Circle(Point center, double radius) : center(center), radius(radius) {}

    bool containsPoint(const Point point)
    {
        // Calculate the distance between the center and the given point
        double distance = std::sqrt(std::pow(point.x - center.x, 2) + std::pow(point.y - center.y, 2));

        // Check if the distance is less than the radius (point is inside the circle)
        return distance < radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        // Check if all vertices of the triangle are inside the circle
        return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC);
    }
};
",1.0,1111111111
OOP_4,1416217,2013048,"#include <iostream>

class Point
{
public:
    double x, y;

    Point() : x(0.0), y(0.0) {}

    Point(double x, double y) : x(x), y(y) {}

    // Add any other necessary member functions or operators here
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle() : radius(0.0) {}

    Circle(Point center, double radius) : center(center), radius(radius) {}

    void operator=(const Circle &circle)
    {
        // Overload assignment operator
        center = circle.center;
        radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        // Overload equality operator
        return (center.x == circle.center.x && center.y == circle.center.y && radius == circle.radius);
    }

    friend std::istream &operator>>(std::istream &in, Circle &circle)
    {
        // Overload input stream operator
        in >> circle.center.x >> circle.center.y >> circle.radius;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.x, this->center.y, this->radius);
    }
};
",1.0,1111111111
OOP_5,1416217,2013048,"Character::Character() {
    // STUDENT ANSWER
    x = y = hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp = hp;
    this->x  = x;
    this->y  = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    return abs(this->hp - other->hp) + abs(this->x - other->x) + abs(this->y - other->y);
}",1.0,111111
OOP_6,1416217,2013048,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    hp = other.hp;
    x = other.x;
    y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    std::cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1416217,2013048,"class Player : protected Character {
public:
    Player(){
		setX(0);
		setY(0);
		setHp(0);
	}
    Player(int hp, int x, int y){
		setX(x);
		setY(y);
		setHp(hp);
	}
    void printPlayerData() {
		cout << getHp() << ""-"" << getX() << ""-"" << getY();
	}

    void moveTo(int x, int y) {
		setX(x);
		setY(y);
	}
};",1.0,11111
OOP_8,1416217,2013048,"class Book {
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book() : title(nullptr), authors(nullptr), publishingYear(0) {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointers for title and authors
         */
    }

    Book(const char* title, const char* authors, int publishingYear) : publishingYear(publishingYear) {
        /*
         * STUDENT ANSWER
         * TODO: allocate memory for title and authors and copy the content
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    Book(const Book& book) : publishingYear(book.publishingYear) {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title) + 1];
        strcpy(this->title, book.title);

        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->authors, book.authors);
    }

    void setTitle(const char* title) {
        /*
         * STUDENT ANSWER
         * TODO: free existing memory and allocate new memory for title
         */
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors) {
        /*
         * STUDENT ANSWER
         * TODO: free existing memory and allocate new memory for authors
         */
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear) {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const {
        /*
         * STUDENT ANSWER
         */
        return title;
    }

    char* getAuthors() const {
        /*
         * STUDENT ANSWER
         */
        return authors;
    }

    int getPublishingYear() const {
        /*
         * STUDENT ANSWER
         */
        return publishingYear;
    }

    ~Book() {
        /*
         * STUDENT ANSWER
         * TODO: free allocated memory for title and authors
         */
        delete[] title;
        delete[] authors;
    }

    void printBook() const {
        printf(""%s\n%s\n%d\n"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1416217,2013048,"class Book {
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book() : title(nullptr), authors(nullptr), publishingYear(0) {}

    Book(const char* title, const char* authors, int publishingYear) : publishingYear(publishingYear) {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    ~Book() {
        delete[] title;
        delete[] authors;
    }

    friend bool checkAuthor(const Book& book, const char* author) {
        // Make a deep copy of the authors string
        char* authorsCopy = new char[strlen(book.authors) + 1];
        strcpy(authorsCopy, book.authors);

        // Tokenize the authorsCopy string based on commas
        char* token = strtok(authorsCopy, "","");
        while (token != nullptr) {
            // Trim leading and trailing whitespaces from the token
            while (*token == ' ' || *token == '\t' || *token == '\n')
                token++;

            char* end = token + strlen(token) - 1;
            while (end > token && (*end == ' ' || *end == '\t' || *end == '\n'))
                end--;

            *(end + 1) = '\0';

            // Compare the tokenized author with the given author
            if (strcmp(token, author) == 0) {
                delete[] authorsCopy;  // Free the allocated memory
                return true;
            }

            token = strtok(nullptr, "","");
        }

        delete[] authorsCopy;  // Free the allocated memory
        return false;
    }
};",1.0,1111111111
OOP_10,1416217,2013048,"class Book {
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book() : title(nullptr), authors(nullptr), publishingYear(0) {}

    Book(const char* title, const char* authors, int publishingYear) : publishingYear(publishingYear) {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    ~Book() {
        delete[] title;
        delete[] authors;
    }

    friend class Printer;
};

class Printer {
private:
    static void trimSpaces(std::string& str) {
        // Trim leading spaces
        size_t start = str.find_first_not_of("" \t\n\r\f\v"");

        if (start != std::string::npos) {
            // Trim trailing spaces
            size_t end = str.find_last_not_of("" \t\n\r\f\v"");
            str = str.substr(start, end - start + 1);
        } else {
            // The string is all spaces
            str.clear();
        }
    }

public:
    static void printBook(const Book& book) {
        std::cout << book.title << std::endl;

        // Tokenize the authors string based on commas and print each author on a new line
        char* token = strtok(book.authors, "","");
        while (token != nullptr) {
            std::string author(token);
            trimSpaces(author);
            std::cout << author << std::endl;
            token = strtok(nullptr, "","");
        }

        std::cout << book.publishingYear << std::endl;
    }
};




",1.0,1111111111
OOP_11,1416217,2013048,"enum Color
{
    red,
    green,
    blue
};

enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price), color(color)
    {
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price), size(size)
    {
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy *toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        numberOfItems = 0;
        for (int i = 0; i < 5; i++)
        {
            toyBox[i] = nullptr;
        }
    }

    int addItem(const CarToy &carToy)
    {
        if (numberOfItems < 5)
        {
            toyBox[numberOfItems++] = new CarToy(carToy.price, carToy.color);
            return numberOfItems;
        }
        else
        {
            return -1; // Box is full
        }
    }

    int addItem(const PuzzleToy &puzzleToy)
    {
        if (numberOfItems < 5)
        {
            toyBox[numberOfItems++] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
            return numberOfItems;
        }
        else
        {
            return -1; // Box is full
        }
    }

    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1417083,2212651,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }
};
",1.0,1111111111
OOP_2,1417083,2212651,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        radius = 0.00;
    }

    Circle(Point center, double radius):center(center),radius(radius)
    {
        
    }

    Circle(const Circle &circle)
    {
        radius = circle.radius;
        center = circle.center;
    }
    
    void setCenter(Point point)
    {
        center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1417083,2212651,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        radius = 0.00;
    }

    Circle(Point center, double radius):center(center),radius(radius)
    {
        
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        return point.distanceToPoint(center) < radius;
    }
  
    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        return (center.distanceToPoint(pointA) < radius) && (center.distanceToPoint(pointB) < radius) && (center.distanceToPoint(pointC) < radius);
    }
};",1.0,1111111111
OOP_4,1417083,2212651,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }

    bool AisB(const Point& point) const{
        return x == point.x && y == point.y;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        radius = 0.00;
    }

    Circle(Point center, double radius):center(center),radius(radius)
    {
        
    }

//! nap chong toan tu =
    void operator=(const Circle &circle)
    {
        this->radius = circle.radius;
        center = circle.center;
    }
//! nap chong toan tu ==
    bool operator==(const Circle &circle)
    {
        return (this->radius == circle.radius) && center.AisB(circle.center);
    }
//! nap chong toan tu >>
    friend istream& operator >> (istream &in, Circle &circle)
    {
        double x , y;
        in >> x >> y >> circle.radius;
        circle.center.setX(x);
        circle.center.setY(y);
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1417083,2212651,"Character::Character() {
    hp = x = y = 0;
}

Character::Character(int hp, int x, int y):hp(hp),x(x),y(y){
    // STUDENT ANSWER
}

int Character::getHp() {
    return hp;
}

void Character::setHp(int hp) {
    this->hp = hp;
}

int Character::getX() {
    return x;
}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return y;
}

void Character::setY(int y) {
    this->y =y;
}

int Character::getManhattanDistTo(Character* other) {
    return abs(x - other->x) + abs(y - other->y);
}
",1.0,111111
OOP_6,1417083,2212651,"//! Copy all data from Character other
void Character::operator=(const Character& other) {
    x = other.x;
    y = other.y;
    hp = other.hp;
}

//! Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return hp <= other.hp;
}

//! Print data of the instance with format: hp-x-y
void Character::operator()() {
    cout << hp << ""-"" << x << ""-"" << y;
}
",1.0,11111
OOP_7,1417083,2212651,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player:Character{
public:
    Player():Character(){}
    Player(int hp, int x, int y):Character(hp,x,y){
    }
    void printPlayerData(){
        cout << this->getHp() << ""-"" << this->getX() << ""-"" << this->getY();
    }
    
    void moveTo(int x, int y){
        this->setX(x);
        this->setY(y);
    }
};",1.0,11111
OOP_8,1417083,2212651,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title = new char[1000];
        authors = new char[1000];
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = publishingYear;
        int i = 0;
        while(title[i]){
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
        i = 0;
        while(authors[i]){
            this->authors[i] = authors[i];
            i++;
        }
        this->authors[i] = '\0';

    }

    Book(const Book &book)
    {
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = book.publishingYear;
        int i = 0;
        while(book.title[i]){
            this->title[i] = book.title[i];
            i++;
        }
        this->title[i] = '\0';
        i = 0;
        while(book.authors[i]){
            this->authors[i] = book.authors[i];
            i++;
        }
        this->authors[i] = '\0';
    }
    
    void setTitle(const char* title)
    {
        int i = 0;
        while(title[i]){
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
    }

    void setAuthors(const char* authors)
    {
        int i = 0;
        while(authors[i]){
            this->authors[i] = authors[i];
            i++;
        }
        this->authors[i] = '\0';
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        return title;
    }

    char* getAuthors() const
    {
        return authors;
    }

    int getPublishingYear() const
    {
        return publishingYear;
    }

    ~Book()
    {
        delete[] title;
        delete[] authors;
        publishingYear = 0;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1417083,2212651,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:

    Book()
    {
        title = new char[1000];
        authors = new char[1000];
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = publishingYear;
        int i = 0;
        while(title[i]){
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
        i = 0;
        while(authors[i]){
            this->authors[i] = authors[i];
            i++;
        }
        this->authors[i] = '\0';

    }

    ~Book()
    {
        // delete[] title;
        // delete[] authors;
        // publishingYear = 0;
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        int i = 0;
        while(book.authors[i]){
            bool result = false;
            char arr[1000];
            int j = 0;
            while(book.authors[i] && book.authors[i] != ','){
                arr[j++] = book.authors[i++];
            }
            arr[j] = '\0';
            j = 0;
            while(arr[j] && author[j]){
                if(arr[j] != author[j]){
                    result = true;
                    break;
                }
                j++;
            }
            if(!arr[j] && !author[j] && !result) return true;
            if(!book.authors[i]) return false;
            i += 2;
        }
        return false;
    }
};",1.0,1111111111
OOP_10,1417083,2212651,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
public:
    Book()
    {
        title = new char[1000];
        authors = new char[1000];
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = publishingYear;
        int i = 0;
        while(title[i]){
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
        i = 0;
        while(authors[i]){
            this->authors[i] = authors[i];
            i++;
        }
        this->authors[i] = '\0';

    }

    ~Book()
    {
        // delete[] title;
        // delete[] authors;
        // publishingYear = 0;
    }
    
    friend class Printer;
};
    
class Printer
{
public:
    static void printBook(const Book book)
    {
        cout << book.title << endl;
        int i = 0;
        while(book.authors[i]){
            char arr[1000];
            int j = 0;
            while(book.authors[i] && book.authors[i] != ','){
                arr[j++] = book.authors[i++];
            }
            arr[j] = '\0';
            cout << arr << endl;
            if(!book.authors[i]) break;
            i += 2;
        }
        cout << book.publishingYear;
    }
};
",1.0,1111111111
OOP_11,1417083,2212651,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price),color(color)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price),size(size)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
//! gan mat dinh bang NULL
        for(int i = 0; i < 5; i++) toyBox[i] = NULL;
        numberOfItems = 0;
    }
    
    int addItem(const CarToy& carToy)
    {
//! neu bang 5 thi tra ve -1
        if(numberOfItems == 5) return -1;
        int i = 0;
//! duyet toi vi tri bang NULL de them phan tu moi vao
        while(toyBox[i] != NULL) i++;
        toyBox[i] = new CarToy(carToy);
        numberOfItems++;
        return numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
//! gan mat dinh bang NULL
        if(numberOfItems == 5) return -1;
        int i = 0;
//! duyet toi vi tri bang NULL de them phan tu moi vao
        while(toyBox[i] != NULL) i++;
        toyBox[i] = new PuzzleToy(puzzleToy);
        numberOfItems++;
        return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1419305,2212372,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
       this->x=0;
       this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
       this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double d;
         d=sqrt((this->x-pointA.getX()*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
         return d; 
    }
};",1.0,
OOP_2,1419305,2212372,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
       this->x=0;
       this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
       this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {   
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d;
         d=sqrt((this->x-pointA.getX())*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
         return d; 
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        center.setX(0);
        center.setY(0);
        radius=0;

         
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center=center;
        this->radius=radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
      this->center=circle.center;
      this->radius=circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center=point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->radius=radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
        return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1419305,2212372,"class Point
{
private:

    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
       this->x=0;
       this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
       this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {   
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d;
         d=sqrt((this->x-pointA.getX())*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
         return d; 
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        center.setX(0);
        center.setY(0);
        radius=0;

         
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center=center;
        this->radius=radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double d=center.distanceToPoint(point);
        if(d<radius){return 1;}
        else{return 0;}
    }

   bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
        */ 
        double a=center.distanceToPoint(pointA);
        double b=center.distanceToPoint(pointB);
        double c=center.distanceToPoint(pointC);
        if(a<radius&&b<radius&&c<radius){return 1;}
        else{return 0;}
    }

};",1.0,1111111111
OOP_4,1419305,2212372,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
       this->x=0;
       this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
       this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {   
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double d;
         d=sqrt((this->x-pointA.getX())*(this->x-pointA.getX())+(this->y-pointA.getY())*(this->y-pointA.getY()));
         return d; 
    }
};

    class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        center.setX(0);
        center.setY(0);
        radius=0;

         
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center=center;
        this->radius=radius;
    }
        void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center=circle.center;
        this->radius=circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        if(this->center.getX() ==circle.center.getX()&& this->center.getY() ==circle.center.getY()&&this->radius==circle.radius){return 1;}
        else{return 0;}
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double x,y,r;
        in>>x>>y>>r;
        Point A;
        A.setX(x);
        A.setY(y);
        Circle C(A,r);
        circle=C;

        return in;
    }


    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1419305,2212372,"Character::Character() {
    // STUDENT ANSWER
    this->hp=0;
    this->x=0;
    this->y=0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp=hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x=x;
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int d;
    d=abs(other->getX()-this->getX())+abs(other->getY()-this->getY());
    return d;

}",1.0,111111
OOP_6,1419305,2212372,"void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->hp=other.hp;
    this->x=other.x;
    this->y=other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    if(this->hp<=other.hp){return 1;}
    return 0;

}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
   cout<<getHp()<<""-""<<getX()<<""-""<<getY();

}",1.0,11111
OOP_7,1419305,2212372,"class Player: private Character{
public:
int x,y;
int hp;
Player(){
    setHp(0);
    setX(0);
    setY(0);
}
Player(int hp, int x, int y){
 setHp(hp);
 setX(x);
 setY(y);
}
void printPlayerData(){
cout<<getHp()<<""-""<<getX()<<""-""<<getY();
}
void moveTo(int x, int y){
    setX(x);
    setY(y);
}
};",1.0,11111
OOP_8,1419305,2212372," class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        this->title=nullptr;
        this->authors=nullptr;
        this->publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
       this->title = new char[strlen(title)+1];
strcpy(this->title, title);

        this->authors = new char[strlen(authors)+1];
strcpy(this->authors, authors);

        this->publishingYear=publishingYear;

    }

     Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
          this->title = new char[strlen(book.title)+1];
         strcpy(this->title, book.title);

        this->authors = new char[strlen(book.authors)+1];
         strcpy(this->authors, book.authors);
        this->publishingYear=book.publishingYear;
    }
    
    
    void setTitle(const char*  title)
    {
        /*
         * STUDENT ANSWER
         */
     
        this->title = new char[strlen(title)+1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
       this->authors = new char[strlen(authors)+1];
       strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear=publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        if(title){delete title;};
        if(authors){delete authors;}
        title=nullptr;
        authors=nullptr;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1419305,2212372,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        this->title=nullptr;
        this->authors=nullptr;
        this->publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        
        /*
         * STUDENT ANSWER
         */
       this->title = new char[strlen(title)+1];
strcpy(this->title, title);

        this->authors = new char[strlen(authors)+1];
strcpy(this->authors, authors);

        this->publishingYear=publishingYear;

    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        
       
    }
    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
          char * temp = new char[strlen(book.authors)+1];
         strcpy(temp, book.authors);
        char *tok = strtok(temp, "","");
        while(tok != nullptr)
        {
            while(tok[0] == ' ')
            {
                tok += 1;
            }
            if(!strcmp(tok, author))
            {
                return true;
            }
            tok = strtok(nullptr, "","");
        }
        return false;
     
    }
};",1.0,1111111111
OOP_10,1419305,2212372,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        this->title=nullptr;
        this->authors=nullptr;
        this->publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        
        /*
         * STUDENT ANSWER
         */
       this->title = new char[strlen(title)+1];
strcpy(this->title, title);

        this->authors = new char[strlen(authors)+1];
strcpy(this->authors, authors);

        this->publishingYear=publishingYear;

    }
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
         printf(""%s\n"", book.title);
          char * temp = new char[strlen(book.authors)+1];
         strcpy(temp, book.authors);
        char *tok = strtok(temp, "","");
        while(tok != nullptr)
        {
            while(tok[0] == ' ')
            {
                tok += 1;
            }
            cout<<tok<<endl;
            tok = strtok(nullptr, "","");
        }
    cout<<book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1419305,2212372,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->price=price;
        this->color=color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->price=price;
        this->size=size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        for (int i = 0; i < 5; i++)
        {
        this->toyBox[i]=nullptr;
        }
        this->numberOfItems=0;
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if (this->numberOfItems==5){return -1;}
        else{
         this->toyBox[this->numberOfItems]=new CarToy(carToy);
         this->numberOfItems++;
        }
        return this-> numberOfItems;

    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        if (this->numberOfItems==5){return -1;}
        else{
         this->toyBox[this->numberOfItems]=new PuzzleToy(puzzleToy);
         this->numberOfItems++;
        }
        return this-> numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_5,1419584,2212741,"Character::Character() {
    // STUDENT ANSWER
    this->hp=0;
    this->x=0;
    this->y=0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp=hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x=x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int a=(this->x<other->getX())?-(this->x-other->getX()):(this->x-other->getX());
    int b=(this->y<other->getY())?-(this->y-other->getY()):(this->y-other->getY());
    return a+b;
    
}",1.0,111111
OOP_6,1419584,2212741,"// Copy all data from Character other
void Character::operator=( const Character& other) {
    // STUDENT ANSWER
    x=other.x;
    y=other.y;
    hp=other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<( const Character& other) {
    // STUDENT ANSWER
    return this->hp<=other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<this->getHp()<<""-""<<this->getX()<<""-""<<this->getY();
}
",1.0,11111
OOP_7,1419584,2212741,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player:private Character{
    private:
    int x;
    int y;
    protected:
    int hp;
    public:
    Player(){
        hp=0;
        x=0;
        y=0;
    }
     Player(int hp, int x, int y){
         this->hp=hp;
         this->x=x;
         this->y=y;
     }
      void printPlayerData(){
          cout<<this->hp<<""-""<<this->x<<""-""<<this->y;
      }
      void moveTo(int x, int y){
          this->x=x;
          this->y=y;
      }
};",1.0,11111
OOP_8,1419584,2212741,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->title=nullptr;
         this->authors=nullptr;
         publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->title=strcpy(new char[strlen(title) + 1], title);
         this->authors=strcpy(new char[strlen(authors) + 1], authors);
         this->publishingYear=publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
         this->title=strcpy(new char[strlen(book.title)+1],book.title);
         this->authors=strcpy(new char[strlen(book.authors)+1],book.authors);
         this->publishingYear=book.publishingYear;
         
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
         this->title=strcpy(new char[strlen(title) + 1], title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
         this->authors=strcpy(new char[strlen(authors) + 1], authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear=publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete[] title;
         delete []authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1419584,2212741,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
          this->title=nullptr;
         this->authors=nullptr;
         publishingYear=0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
          this->title=strcpy(new char[strlen(title) + 1], title);
         this->authors=strcpy(new char[strlen(authors) + 1], authors);
         this->publishingYear=publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        //   delete[] title;
        //  delete []authors;
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
         return !strcmp(book.authors,author);
    }
};",0.6,0110110101
OOP_1,1420521,2211367,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
      return x;
    }

    double getY() const
    {
       return y;
    }

    double distanceToPoint(const Point&A)
    {
        return sqrt((A.getX()-(this->x))*(A.getX()-this->x)+(A.getY()-this->y)*(A.getY()-this->y));
    }
};",1.0,1111111111
OOP_2,1420521,2211367,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
      return x;
    }

    double getY() const
    {
       return y;
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center=Point();
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
          center = circle.getCenter();
        radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
       return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1420521,2211367,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
      return x;
    }

    double getY() const
    {
       return y;
    }

    double distanceToPoint(const Point&A)
    {
        return sqrt((A.getX()-(this->x))*(A.getX()-this->x)+(A.getY()-this->y)*(A.getY()-this->y));
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center=Point();
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.getCenter();
        radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
       return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
     bool containsPoint(const Point point)
    {   
        Point A = point;
        if(A.distanceToPoint(this->center)>(this->radius)) return false;
        else return true;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        Point A = pointA;
        Point B = pointB;
        Point C = pointC;
        int ab = A.distanceToPoint(B);
        int bc = B.distanceToPoint(C);
        int ac = A.distanceToPoint(C);
        if(ab+bc>ac||ab+ac>bc||ac+bc>ab){
            int a = A.distanceToPoint(this->center);
        int b = B.distanceToPoint(this->center);
        int c = C.distanceToPoint(this->center);
        if(a>=radius&&b>=radius&&c>=radius){
            return true;
        }
        else return false;
        }
        else{
            return false;
        }
    }
};",0.6,1100100111
OOP_4,1420521,2211367,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
      return x;
    }

    double getY() const
    {
       return y;
    }

    double distanceToPoint(const Point&A)
    {
        return sqrt((A.getX()-(this->x))*(A.getX()-this->x)+(A.getY()-this->y)*(A.getY()-this->y));
    }
    bool operator == (Point &B){
        Point C = B;
        if((this->x==C.x)&&(this->y==C.y)){
            return true;
        }
        return false;
    }
    friend istream& operator >> (istream &in, Point& point)
    {
        in >> point.x;
        in >> point.y;
        return in;
    }
};
class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center=Point();
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.getCenter();
        radius = circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        this->center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
       return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
     bool containsPoint(const Point point)
    {   
        Point A = point;
        if(A.distanceToPoint(this->center)>(this->radius)) return false;
        else return true;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        Point A = pointA;
        Point B = pointB;
        Point C = pointC;
        int ab = A.distanceToPoint(B);
        int bc = B.distanceToPoint(C);
        int ac = A.distanceToPoint(C);
        if(ab+bc>ac||ab+ac>bc||ac+bc>ab){
            return true;
        }
        else{
            return false;
        }
        int a = A.distanceToPoint(this->center);
        int b = B.distanceToPoint(this->center);
        int c = C.distanceToPoint(this->center);
        if(a>radius&&b>radius&&c>radius){
            return true;
        }
        else return false;
    }
    void operator=(const Circle &circle)
    {
        Circle B = circle;
        this->center = B.getCenter();
        this->radius = B.getRadius();
    }

    bool operator==(const Circle &circle)
    {
        Circle B = circle;
        if((this->center==B.center)&&(this->radius)==B.radius){
            return true;
        }
        return false;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        in >> circle.center;
        in >> circle.radius;
        return in;
    }
};",1.0,1111111111
OOP_5,1420521,2211367,"Character::Character() {
     x = y = hp = 0;
}

Character::Character(int hp, int x, int y) {
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    return hp;
    // STUDENT ANSWER
}

void Character::setHp(int hp) {
    this->hp = hp;
    // STUDENT ANSWER
}

int Character::getX() {
    return x;
    // STUDENT ANSWER
}

void Character::setX(int x) {
    this->x=x;
    // STUDENT ANSWER
}

int Character::getY() {
    return y;
    // STUDENT ANSWER
}

void Character::setY(int y) {
    this->y = y;
    // STUDENT ANSWER
}

int absd(int x){
    if(x>=0) return x;
    else return x*(-1);
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    return (absd((this -> x)-(other -> x))+absd(((this)->y)- ((other)->y)));
}",1.0,111111
OOP_6,1420521,2211367,"void Character:: operator=(const Character& other) {
    // STUDENT ANSWER
    Character A = other;
    setHp(A.getHp());
    setX(A.getX());
    setY(A.getY());
    

}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    Character A = other;
    if(this->hp>A.getHp()){
        return false;
    }
    else return true;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1420521,2211367,"class Player{
        private:
        Character * A;
        public:
        Player(){
            A->setHp(0);
            A->setX(0);
            A->setY(0);
        }
        Player(int hp, int x, int y){
            A->setHp(hp);
            A->setX(x);
            A->setY(y);
        }
         void printPlayerData(){
            cout << A->getHp() << ""-"" <<  A->getX() << ""-"" << A->getY();
         }
         void moveTo(int x, int y){
            A->setX(x);
            A->setY(y);
         }

};",0.6,1110
OOP_8,1420521,2211367,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title = NULL;
        authors = NULL;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        this->title = new char[strlen(book.getTitle()) + 1];
        strcpy(this->title, book.getTitle());

        this->authors = new char[strlen(book.getAuthors()) + 1];
        strcpy(this->authors, book.getAuthors());
        this->publishingYear = book.getPublishingYear();
    }
    
    void setTitle(const char* title)
    {   
       this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors( const char* authors)
    { 
       this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
       this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
       return title;
    }

    char* getAuthors() const
    {
       return authors;
    }

    int getPublishingYear() const
    {
      return publishingYear;
    }

    ~Book()
    {
      delete title;
      delete authors;
      publishingYear = 0;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
    void operator =(const Book &A){
        Book B = A;
        this->title = B.getTitle();
        this->authors=B.getAuthors();
        this->publishingYear=B.getPublishingYear();
    }
};",1.0,1111111111
OOP_9,1420521,2211367,"string xoakt(string s){
        int a = s.length();
        if(a==0) return """";
        if(s[0]==' ') {
            s.substr(1);
        }
        return s[0] + s.substr(1);
    }
class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title = NULL;
        authors = NULL;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title)+1];
        strcpy(this->title,title);
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors,authors);
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        this->title = new char[strlen(book.getTitle()) + 1];
        strcpy(this->title, book.getTitle());

        this->authors = new char[strlen(book.getAuthors()) + 1];
        strcpy(this->authors, book.getAuthors());
        this->publishingYear = book.getPublishingYear();
    }
    
    void setTitle(const char* title)
    {   
       this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors( const char* authors)
    { 
       this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
       this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
       return title;
    }

    char* getAuthors() const
    {
       return authors;
    }

    int getPublishingYear() const
    {
      return publishingYear;
    }

    ~Book()
    {
      delete title;
      delete authors;
      publishingYear = 0;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
    void operator =(const Book &A){
        Book B = A;
        this->title = B.getTitle();
        this->authors=B.getAuthors();
        this->publishingYear=B.getPublishingYear();
    }
    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        vector<string> list;
        string s = string (book.authors);
        stringstream ss(s);
        string word;
        while(getline(ss,word,',')){
           size_t start = word.find_first_not_of("" "");
        size_t end = word.find_last_not_of("" "");
        
        if (start != std::string::npos && end != std::string::npos) {
            list.push_back(word.substr(start, end - start + 1));
        }
        }
        int n = list.size();
        for(int i = 0; i < n;i++){
            if(list[i]==author){
                return true;
            }
        }
        return false;

    }
};",1.0,1111111111
OOP_10,1420521,2211367,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title = NULL;
        authors = NULL;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title)+1];
        strcpy(this->title,title);
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors,authors);
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        this->title = new char[strlen(book.getTitle()) + 1];
        strcpy(this->title, book.getTitle());

        this->authors = new char[strlen(book.getAuthors()) + 1];
        strcpy(this->authors, book.getAuthors());
        this->publishingYear = book.getPublishingYear();
    }
    
    void setTitle(const char* title)
    {   
       this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors( const char* authors)
    { 
       this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
       this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
       return title;
    }

    char* getAuthors() const
    {
       return authors;
    }

    int getPublishingYear() const
    {
      return publishingYear;
    }

    ~Book()
    {
      delete title;
      delete authors;
      publishingYear = 0;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
    void operator =(const Book &A){
        Book B = A;
        this->title = B.getTitle();
        this->authors=B.getAuthors();
        this->publishingYear=B.getPublishingYear();
    }
     friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        vector<string> list;
        string s = string (book.authors);
        stringstream ss(s);
        string word;
        while(getline(ss,word,',')){
           size_t start = word.find_first_not_of("" "");
        size_t end = word.find_last_not_of("" "");
        
        if (start != std::string::npos && end != std::string::npos) {
            list.push_back(word.substr(start, end - start + 1));
        }
        }
        int n = list.size();
        for(int i = 0; i < n;i++){
            if(list[i]==author){
                return true;
            }
        }
        return false;

    }
     friend class Printer;
};
class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
        cout << book.title << endl;
        string s = string (book.authors);
        stringstream ss(s);
        string word;
        while(getline(ss,word,',')){
           size_t start = word.find_first_not_of("" "");
            size_t end = word.find_last_not_of("" "");
        
        if (start != std::string::npos && end != std::string::npos) {
            cout << word.substr(start, end - start + 1) << endl;
        }

    }
     cout << book.publishingYear << endl;}
};",1.0,1111111111
OOP_11,1420521,2211367,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        numberOfItems = 0;
    }
    
    int addItem(const CarToy& carToy)
    {
        if(numberOfItems<5){
           toyBox[numberOfItems] = new CarToy(carToy);
           numberOfItems++;
           return numberOfItems;
        }
        else{
            return -1;
        }
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        if(numberOfItems<5){
            toyBox[numberOfItems] = new PuzzleToy(puzzleToy);
            numberOfItems++;
            return numberOfItems;
        }
        else{
            return -1;
        }
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1424448,2212935,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};",1.0,1111111111
OOP_2,1424448,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(circle.center.getX());
         this->center.setY(circle.center.getY());
         this->radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(point.getX());
         this->center.setY(point.getY());
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1424448,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return this->center.distanceToPoint(point) < this->radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC);
    }
};",1.0,1111111111
OOP_4,1424448,2212935,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */
     private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt((this->x - pointA.x)*(this->x - pointA.x) + (this->y - pointA.y)*(this->y - pointA.y));
    }
    friend istream& operator >>(istream& input, Point& point) {
    input >> point.x >> point.y;
    return input;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         center.setX(0);
         center.setY(0);
         radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center.setX(center.getX());
         this->center.setY(center.getY());
         this->radius = radius;
    }

    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = circle.radius;
         this->center = circle.center;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius == circle.radius && this->center.getX() == circle.center.getX() && this->center.getY() == circle.center.getY();
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         in >> circle.center >> circle.radius ;
         return in;
         
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1424448,2212935,"Character::Character() {
    // STUDENT ANSWER
    hp = 0;
    x = 0;
    y =0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int distX = abs(x - other->getX());
    int distY = abs(y - other->getY());
    return distX + distY;
}",1.0,111111
OOP_6,1424448,2212935,"void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    hp = other.hp;
    x = other.x;
    y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1424448,2212935,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player: protected Character {
    private:
    Character character;
    public:
    Player()
    {
        this->character.setHp(0);
        this->character.setX(0);
        this->character.setY(0);
    }
    Player(int hp, int x, int y)
    {
        this->character.setHp(hp);
        this->character.setX(x);
        this->character.setY(y);
    }
    void printPlayerData()
    {
        cout<< this->character.getHp() << '-'<< this->character.getX() <<'-'<< this->character.getY();
    }
    void moveTo(int x, int y)
    {
        this->character.setX(x);
        this->character.setY(y);
    }
};",1.0,11111
OOP_8,1424448,2212935,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book(): title(nullptr), authors(nullptr), publishingYear(0)
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         
    }

    Book(const char* title, const char* authors, int publishingYear): publishingYear(publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title) + 1];
        strcpy(this->title, book.title);

        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->authors, book.authors);
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete []title;
        delete []authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1424448,2212935,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;
public:
static char* trim(char* str) {
        char* end = str + strlen(str) - 1;
        while (*str && isspace(*str)) {
            str++;
        }
        while (end > str && isspace(*end)) {
            *end = '\0';
            end--;
        }
        return str;
    }
    Book(): title(nullptr), authors(nullptr), publishingYear(0)
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         
    }

    Book(const char* title, const char* authors, int publishingYear): publishingYear(publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete[] title;
        delete[] authors;
    }
    const char* getAuthors() const {
        return authors;
    }


    friend bool checkAuthor(Book &book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        const char* authors = book.getAuthors();

    char* token = strtok(const_cast<char*>(authors), "","");
    while (token != nullptr) {
        if (strcmp(Book::trim(token), author) == 0) {
            return true;
        }
        token = strtok(nullptr, "","");
    }
    return false;
    }
};",1.0,1111111111
OOP_10,1424448,2212935,"class Book {
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book() {
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear) {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }

    ~Book() {
        delete[] title;
        delete[] authors;
    }

    friend class Printer;
};

class Printer {
public:
    static void printBook(const Book &book) {
        cout << book.title << endl;
         int i = 0;
         while (book.authors[i] != '\0'){
             if (book.authors[i] == ','){
                 cout << endl;
                 i+=2;
             }
             cout << book.authors[i++];
         }
         cout << endl;
         cout << book.publishingYear << endl;
    }
};",1.0,1111111111
OOP_11,1424448,2212935,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox() :  numberOfItems(0)
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         for (int i = 0; i < 5; i++){
             toyBox[i] = nullptr;
         }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5){
             toyBox[numberOfItems] = new CarToy(carToy);
             numberOfItems++;
             return numberOfItems;
         }
         return -1;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5){
             toyBox[numberOfItems] = new PuzzleToy(puzzleToy);
             numberOfItems++;
             return numberOfItems;
         }
         return -1;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1424832,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.getX() - this->x),2)+pow((pointA.getY() - this->y),2));
        
    }
};",1.0,1111111111
OOP_2,1424832,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.getX() - this->x),2)+pow((pointA.getY() - this->y),2));
        
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this-> center = Point();
         this-> radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center = center;
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center= circle.getCenter();
         this->radius= circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = radius ;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->center;   
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1424832,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.x - x),2)+pow((pointA.y - y),2));
        
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
         this->center= Point();
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius=radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return this->center.distanceToPoint(point) < this->radius;
    }

    bool  containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         if(!(this->center.distanceToPoint(pointA)<this->radius&&this->center.distanceToPoint(pointB)<this->radius&&this->center.distanceToPoint(pointC)<this->radius))
         return 0;
         Point point1(pointA.getX(),pointA.getY());
         Point point2(pointB.getX(),pointB.getY());
         Point point3(pointC.getX(),pointC.getY());
          double a= point1.distanceToPoint(point2);
          double b= point1.distanceToPoint(point3);
          double c= point2.distanceToPoint(point3);
          if(a+b==c||a+c==b||b+c==a) return 0;
         return 1;
    }
};",1.0,1111111111
OOP_4,1424832,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.x - x),2)+pow((pointA.y - y),2));
        
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
           this->center= Point();
         this-> radius =0;
         
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
          this->center = center;
         this->radius=radius;
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center= circle.center;
         this->radius=circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         return (this->center.getX()==circle.center.getX()&&this->center.getY()==circle.center.getY()&&this->radius==circle.radius);
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         double a;
         double b;
         in>>a;
         in>>b;
         in>>circle.radius;
         circle.center.setX(a);
         circle.center.setY(b);
         return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1424832,2212741,"Character::Character() {
    // STUDENT ANSWER
    this->hp=0;
    this->x=0;
    this->y=0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp=hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x=x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int a=(this->x<other->getX())?-(this->x-other->getX()):(this->x-other->getX());
    int b=(this->y<other->getY())?-(this->y-other->getY()):(this->y-other->getY());
    return a+b;
    
}",1.0,111111
OOP_6,1424832,2212741,"// Copy all data from Character other
void Character::operator=( const Character& other) {
    // STUDENT ANSWER
    x=other.x;
    y=other.y;
    hp=other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<( const Character& other) {
    // STUDENT ANSWER
    return this->hp<=other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<this->getHp()<<""-""<<this->getX()<<""-""<<this->getY();
}
",1.0,11111
OOP_7,1424832,2212741,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player:private Character{
    private:
    int x;
    int y;
    protected:
    int hp;
    public:
    Player(){
        hp=0;
        x=0;
        y=0;
    }
     Player(int hp, int x, int y){
         this->hp=hp;
         this->x=x;
         this->y=y;
     }
      void printPlayerData(){
          cout<<this->hp<<""-""<<this->x<<""-""<<this->y;
      }
      void moveTo(int x, int y){
          this->x=x;
          this->y=y;
      }
};",1.0,11111
OOP_8,1424832,2212741,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->title=nullptr;
         this->authors=nullptr;
         publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->title=strcpy(new char[strlen(title) + 1], title);
         this->authors=strcpy(new char[strlen(authors) + 1], authors);
         this->publishingYear=publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
         this->title=strcpy(new char[strlen(book.title)+1],book.title);
         this->authors=strcpy(new char[strlen(book.authors)+1],book.authors);
         this->publishingYear=book.publishingYear;
         
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
         this->title=strcpy(new char[strlen(title) + 1], title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
         this->authors=strcpy(new char[strlen(authors) + 1], authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear=publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete[] title;
         delete []authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1424832,2212741,"#include<vector>
#include<string>
#include<iostream>
using namespace std;
class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
         this->title= nullptr;
         this->authors = nullptr;
         this->publishingYear= 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {  this->publishingYear= publishingYear;
         this->authors= new char[ strlen(authors) + 1];
         strcpy( this->authors, authors);
         this->title= new char[ strlen(title) + 1];
         strcpy( this->title, title);
    }
    
    Book(const Book &book)
    {
         this->publishingYear = book.publishingYear;

    if (book.title != nullptr) {
        this->title = new char[strlen(book.title) + 1];
        strcpy(this->title, book.title);
    } /*else {
        this->title = nullptr;
    }*/

    if (book.authors != nullptr) {
        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->authors, book.authors);
    } /*else {
        this->authors = nullptr;
    }*/
    }
    
    friend bool checkAuthor(Book book, const char* author)
    {   
     std::vector<std ::string> authorList;
        string authorStr= book.authors;
        size_t pos=0;
        while( (pos= authorStr.find("", "")) != std ::string ::npos)  {
            authorList.push_back (authorStr.substr(0,pos));
            authorStr.erase(0, pos+2);//them comma vs space
        }
        authorList.push_back(authorStr);
        for( const std:: string& authorname : authorList){
            if( authorname == author) {return true;}
        }
        return false;
        /*
        char * authorcheck = new char[strlen(book.getAuthors()) + 2];
        strncpy(authorcheck, book.getAuthors(), strlen(book.getAuthors()));
        authorcheck[strlen(book.getAuthors())] = ',';
        authorcheck[strlen(authorcheck)] = '\0';
        int index = 0;
        for (int i = 0;i <= strlen(authorcheck); i++ ){
            if (authorcheck[i] == ','){
                char *substr = new char[i - index];
                strncpy(substr, authorcheck + index, i - index);
               
                if (strcmp(substr,author) == 0) {
                    return true; 
                }
                index = i + 2;
            }
        }
        return false;
        */
    }
};",1.0,1111111111
OOP_11,1424832,2212741,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         color=color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         size=size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         numberOfItems=0;
         
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         CarToy* tmp=new CarToy(carToy.price,carToy.color);
         if(numberOfItems==5) return -1;
         else{
             *(toyBox+numberOfItems)=tmp;
             numberOfItems++;
         }
         return numberOfItems;
         
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         
         PuzzleToy* tmp=new PuzzleToy(puzzleToy.price,puzzleToy.size);
         if(numberOfItems==5) return -1;

         else{
             *(toyBox+numberOfItems)=tmp;
             numberOfItems++;
         }
         return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1428199,2213035,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double disX = x - pointA.x;
         double disY = y - pointA.y;
         return sqrt(disX*disX+disY*disY);
    }
};",1.0,1111111111
OOP_2,1428199,2213035,"// class Point
// {
//     /*  
//      * STUDENT ANSWER   
//      * TODO: using code template in previous question
//      */
// };
class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double disX = x - pointA.x;
         double disY = y - pointA.y;
         return sqrt(disX*disX+disY*disY);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center = Point();
         this-> radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
         
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = circle.center; // Sao chép giá trị của center
        this->radius = circle.radius; // Sao chép giá trị của radius
    }
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius=radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1428199,2213035,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double disX = x - pointA.x;
         double disY = y - pointA.y;
         return sqrt(disX*disX+disY*disY);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = Point();
         this-> radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        double distance = center.distanceToPoint(point);
    if (distance < radius)
    {
        return true;
    }
    else
    {
        return false;
    }
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        bool containsPointA = containsPoint(pointA);
        bool containsPointB = containsPoint(pointB);
        bool containsPointC = containsPoint(pointC);
    
        if (containsPointA && containsPointB && containsPointC)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
};",1.0,1111111111
OOP_4,1428199,2213035,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double disX = x - pointA.x;
         double disY = y - pointA.y;
         return sqrt(disX*disX+disY*disY);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = Point();
         this-> radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = circle.center;
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         if(this->center.getX() ==circle.center.getX()&& this->center.getY() ==circle.center.getY()&&this->radius==circle.radius){return 1;}
        else{return 0;}

    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double x,y,r;
        in>>x>>y>>r;
        Point A;
        A.setX(x);
        A.setY(y);
        Circle C(A,r);
        circle=C;

        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1428199,2213035,"Character::Character() {
    // STUDENT ANSWER
    this->x = 0;
    this->y = 0;
    this->hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->x = x;
    this->y = y;
    this->hp = hp;
    
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int x1 = this->x;
    int y1 = this->y;
    int x2 = other->getX();
    int y2 = other->getY();
    
    int manhattanDist = abs(x1 - x2) + abs(y1 - y2);
    
    return manhattanDist;
    
}",1.0,111111
OOP_6,1428199,2213035,"// Copy all data from Character other
// Character::Character() {
//     // STUDENT ANSWER
//     this->x = 0;
//     this->y = 0;
//     this->hp = 0;
// }

// Character::Character(int hp, int x, int y) {
//     // STUDENT ANSWER
//     this->x = x;
//     this->y = y;
//     this->hp = hp;
    
// }

// int Character::getHp() {
//     // STUDENT ANSWER
//     return hp;
// }

// void Character::setHp(int hp) {
//     // STUDENT ANSWER
//     this->hp = hp;
// }

// int Character::getX() {
//     // STUDENT ANSWER
//     return x;
// }

// void Character::setX(int x) {
//     // STUDENT ANSWER
//     this->x = x;
// }

// int Character::getY() {
//     // STUDENT ANSWER
//     return y;
// }

// void Character::setY(int y) {
//     // STUDENT ANSWER
//     this->y = y;
// }

// int Character::getManhattanDistTo(Character* other) {
//     // STUDENT ANSWER
//     int x1 = this->x;
//     int y1 = this->y;
//     int x2 = other->getX();
//     int y2 = other->getY();
    
//     int manhattanDist = abs(x1 - x2) + abs(y1 - y2);
    
//     return manhattanDist;
    
// }

void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->hp=other.hp;
    this->x=other.x;
    this->y=other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    if(this->hp<=other.hp){return 1;}
    return 0;

}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<hp<<""-""<<x<<""-""<<y;

}",1.0,11111
OOP_7,1428199,2213035,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player: private Character{
public:
int x,y,hp;
Player(){
    setHp(0);
    setX(0);
    setY(0);
}
Player(int hp, int x, int y){
 setHp(hp);
 setX(x);
 setY(y);
}
void printPlayerData(){
cout<<getHp()<<""-""<<getX()<<""-""<<getY();
}
void moveTo(int x, int y){
    setX(x);
    setY(y);
}
};",1.0,11111
OOP_8,1428199,2213035,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->publishingYear = 0;
         this->title = NULL;
         this->authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
        this->title = new char[strlen(title)+1];
        strcpy(this->title, title);
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors,authors);
    }

    Book(const Book &book)
    {
        this->publishingYear = book.publishingYear;
        this->title = new char[strlen(book.title)+1];// số lượng mảng là 6 nhưng strlen trả ra 55
        strcpy(this->title, book.title);
        this->authors = new char[strlen(book.authors)+1];
        strcpy(this->authors,book.authors);
    }
    
   void setTitle(const char* title)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete [] this->title;
         delete [] this->authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1428199,2213035,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }

    ~Book()
    {
        
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        char * temp = new char[strlen(book.authors)+1];
         strcpy(temp, book.authors);
        char *tok = strtok(temp, "","");
        while(tok != nullptr)
        {
            while(tok[0] == ' ')
            {
                tok += 1;
            }
            if(!strcmp(tok, author))
            {
                return true;
            }
            tok = strtok(nullptr, "","");
        }
        return false;
        
    }
};",1.0,1111111111
OOP_10,1428199,2213035,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->publishingYear = 0;
         this->title = NULL;
         this->authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
        this->title = new char[strlen(title)+1];// số lượng mảng là 6 nhưng strlen trả ra 55
        strcpy(this->title, title);
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors,authors);
    }
    
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
         cout<<book.title<<endl;
         char* token = strtok(book.authors, "","");
        while(token != nullptr)
        {
            while(token[0] == ' ') token += 1;
            cout<<token<<endl;
            token = strtok(nullptr, "","");
        }
    cout<<book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1428199,2213035,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->price=price;
        this->color=color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->price=price;
        this->size=size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         this->numberOfItems = 0;
         for (int i = 0; i < 5; i++)
        {
        this->toyBox[i]=nullptr;
        }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5)
        {
            toyBox[numberOfItems] = new CarToy(carToy.price, carToy.color);
            numberOfItems++;
            return numberOfItems;
        }
        else
        {
            return -1;
        }
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5)
        {
            toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
            numberOfItems++;
            return numberOfItems;
        }
        else
        {
            return -1;
        }
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_11,1428259,2212988,"enum Color{red,green, blue};
 
enum Size{ small, medium, big};

class Toy {
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy {
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy {
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        this->numberOfItems = 0;
        for (int i = 0; i < 5; i++) {
            toyBox[i] = nullptr;
        }
        
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box.
                 If the box is full, return -1.
         */
        if (numberOfItems == 5) return -1;
        int index=0;
        while (true) {
            if (toyBox[index] == nullptr) break;
            index++;
        }
        toyBox[index] = new CarToy(carToy.price, carToy.color);
        numberOfItems++;
        return index+1;
    }

    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box.
                 If the box is full, return -1.
         */
        if (numberOfItems == 5) return -1;
        int index = 0;
        while (true) {
            if (toyBox[index] == nullptr) break;
            index++;
        }
        toyBox[index] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
        numberOfItems++;
        return index+1;
    }

    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1428750,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.getX() - this->x),2)+pow((pointA.getY() - this->y),2));
        
    }
};",1.0,1111111111
OOP_2,1428750,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.getX() - this->x),2)+pow((pointA.getY() - this->y),2));
        
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this-> center = Point();
         this-> radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this-> center = center;
         this-> radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center= circle.getCenter();
         this->radius= circle.getRadius();
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius = radius ;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->center;   
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1428750,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.x - x),2)+pow((pointA.y - y),2));
        
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
         this->center= Point();
         this-> radius =0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius=radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         return this->center.distanceToPoint(point) < this->radius;
    }

    bool  containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         if(!(this->center.distanceToPoint(pointA)<this->radius&&this->center.distanceToPoint(pointB)<this->radius&&this->center.distanceToPoint(pointC)<this->radius))
         return 0;
         Point point1(pointA.getX(),pointA.getY());
         Point point2(pointB.getX(),pointB.getY());
         Point point3(pointC.getX(),pointC.getY());
          double a= point1.distanceToPoint(point2);
          double b= point1.distanceToPoint(point3);
          double c= point2.distanceToPoint(point3);
          if(a+b==c||a+c==b||b+c==a) return 0;
         return 1;
    }
};",1.0,1111111111
OOP_4,1428750,2212741,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x=0;
         this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow((pointA.x - x),2)+pow((pointA.y - y),2));
        
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
           this->center= Point();
         this-> radius =0;
         
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
          this->center = center;
         this->radius=radius;
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center= circle.center;
         this->radius=circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         return (this->center.getX()==circle.center.getX()&&this->center.getY()==circle.center.getY()&&this->radius==circle.radius);
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         double a;
         double b;
         in>>a;
         in>>b;
         in>>circle.radius;
         circle.center.setX(a);
         circle.center.setY(b);
         return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1428750,2212741,"Character::Character() {
    // STUDENT ANSWER
    this->hp=0;
    this->x=0;
    this->y=0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return this->hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp=hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return this->x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x=x;
}

int Character::getY() {
    // STUDENT ANSWER
    return this->y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int a=(this->x<other->getX())?-(this->x-other->getX()):(this->x-other->getX());
    int b=(this->y<other->getY())?-(this->y-other->getY()):(this->y-other->getY());
    return a+b;
    
}",1.0,111111
OOP_6,1428750,2212741,"// Copy all data from Character other
void Character::operator=( const Character& other) {
    // STUDENT ANSWER
    x=other.x;
    y=other.y;
    hp=other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<( const Character& other) {
    // STUDENT ANSWER
    return this->hp<=other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<this->getHp()<<""-""<<this->getX()<<""-""<<this->getY();
}
",1.0,11111
OOP_7,1428750,2212741,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player:private Character{
    private:
    int x;
    int y;
    protected:
    int hp;
    public:
    Player(){
        hp=0;
        x=0;
        y=0;
    }
     Player(int hp, int x, int y){
         this->hp=hp;
         this->x=x;
         this->y=y;
     }
      void printPlayerData(){
          cout<<this->hp<<""-""<<this->x<<""-""<<this->y;
      }
      void moveTo(int x, int y){
          this->x=x;
          this->y=y;
      }
};",1.0,11111
OOP_8,1428750,2212741,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->title=nullptr;
         this->authors=nullptr;
         publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->title=strcpy(new char[strlen(title) + 1], title);
         this->authors=strcpy(new char[strlen(authors) + 1], authors);
         this->publishingYear=publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
         this->title=strcpy(new char[strlen(book.title)+1],book.title);
         this->authors=strcpy(new char[strlen(book.authors)+1],book.authors);
         this->publishingYear=book.publishingYear;
         
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
         this->title=strcpy(new char[strlen(title) + 1], title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
         this->authors=strcpy(new char[strlen(authors) + 1], authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear=publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete[] title;
         delete []authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1428750,2212741,"#include<vector>
#include<string>
#include<iostream>
using namespace std;
class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
         this->title= nullptr;
         this->authors = nullptr;
         this->publishingYear= 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {  this->publishingYear= publishingYear;
         this->authors= new char[ strlen(authors) + 1];
         strcpy( this->authors, authors);
         this->title= new char[ strlen(title) + 1];
         strcpy( this->title, title);
    }
    
    Book(const Book &book)
    {
         this->publishingYear = book.publishingYear;

    if (book.title != nullptr) {
        this->title = new char[strlen(book.title) + 1];
        strcpy(this->title, book.title);
    } /*else {
        this->title = nullptr;
    }*/

    if (book.authors != nullptr) {
        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->authors, book.authors);
    } /*else {
        this->authors = nullptr;
    }*/
    }
    
    friend bool checkAuthor(Book book, const char* author)
    {   
     std::vector<std ::string> authorList;
        string authorStr= book.authors;
        size_t pos=0;
        while( (pos= authorStr.find("", "")) != std ::string ::npos)  {
            authorList.push_back (authorStr.substr(0,pos));
            authorStr.erase(0, pos+2);//them comma vs space
        }
        authorList.push_back(authorStr);
        for( const std:: string& authorname : authorList){
            if( authorname == author) {return true;}
        }
        return false;
        /*
        char * authorcheck = new char[strlen(book.getAuthors()) + 2];
        strncpy(authorcheck, book.getAuthors(), strlen(book.getAuthors()));
        authorcheck[strlen(book.getAuthors())] = ',';
        authorcheck[strlen(authorcheck)] = '\0';
        int index = 0;
        for (int i = 0;i <= strlen(authorcheck); i++ ){
            if (authorcheck[i] == ','){
                char *substr = new char[i - index];
                strncpy(substr, authorcheck + index, i - index);
               
                if (strcmp(substr,author) == 0) {
                    return true; 
                }
                index = i + 2;
            }
        }
        return false;
        */
    }
};",1.0,1111111111
OOP_10,1428750,2212741,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
         this->title= nullptr;
         this->authors= nullptr;
         this-> publishingYear= 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear= publishingYear;
         this->title = new char[ strlen(title) +1];
         strcpy( this->title, title);
         this->authors= new char[ strlen(authors) +1];
         strcpy( this->authors, authors);
    }
    
    Book(const Book &book)
    {
         this->publishingYear = book.publishingYear;

    if (book.title != nullptr) {
        this->title = new char[strlen(book.title) +1];
        strcpy(this->title, book.title);
    } else {
        this->title = nullptr;
    }

    if (book.authors != nullptr) {
        this->authors = new char[strlen(book.authors) +1];
        strcpy(this->authors, book.authors);
    } else {
        this->authors = nullptr;
    }
    
    }
    
    void setTitle(const char* title)
    {
        if (this->title != nullptr) {
            delete[] this->title;
        }
        this->title = new char[strlen(title) +1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
         if (this->authors != nullptr) {
            delete[] this->authors;
        }
        this->authors = new char[strlen(authors) +1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear){this->publishingYear= publishingYear;}

    char* getTitle() const {    return title;}

    char* getAuthors() const { return authors; }

    int getPublishingYear() const{     return publishingYear; }
    
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         if( title != nullptr){
             delete[] title;
         }
         if( authors != nullptr){
             delete[] authors; 
         }
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         / /
         cout << book.getTitle() << endl;
        vector<std::string> eachauthor;
        string totalauthor = book.getAuthors();
       // cout<<totalauthor<<endl;
        int pos=0;
        while( ( pos = totalauthor.find("", "")) != std:: string::npos){
           cout<<totalauthor.substr(0,pos);
           cout<<endl;
        totalauthor.erase(0,pos+2);// erase comma and space
        } 
       cout<<totalauthor<<endl;
        cout << book.getPublishingYear();  */
         cout << book.title << endl;
        string authorStr = book.authors;
        string temp = "", "";
        size_t pos = 0;
        string childstr;
        while ((pos = authorStr.find(temp))!=string::npos){
            childstr = authorStr.substr(0,pos);
            cout << childstr << endl;
            authorStr.erase(0,pos+temp.length());
        }
        cout << authorStr << endl;
        cout << book.publishingYear;
    
    }
};",1.0,1111111111
OOP_11,1428750,2212741,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         color=color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         size=size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         numberOfItems=0;
         
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         CarToy* tmp=new CarToy(carToy.price,carToy.color);
         if(numberOfItems==5) return -1;
         else{
             *(toyBox+numberOfItems)=tmp;
             numberOfItems++;
         }
         return numberOfItems;
         
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         
         PuzzleToy* tmp=new PuzzleToy(puzzleToy.price,puzzleToy.size);
         if(numberOfItems==5) return -1;

         else{
             *(toyBox+numberOfItems)=tmp;
             numberOfItems++;
         }
         return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1430030,2210578,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x=0;
        this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
        */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(x-pointA.getX(),2)+pow(y-pointA.getY(),2));
    }
};",1.0,1111111111
OOP_2,1430030,2210578,"class Point
{
    private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x=0;
        this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
        */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(x-pointA.getX(),2)+pow(y-pointA.getY(),2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius =0;
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
    }

    Circle(Point center, double radius)
    {
    
        this->center.setY(center.getY());
        this->center.setX(center.getX());
        this->radius=radius;
    }

    Circle(const Circle &circle)
    {
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius=circle.radius;
    }
    
    void setCenter(Point point)
    { this->center.setY(point.getY());
        this->center.setX(point.getX());
        
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */this->radius=radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1430030,2210578,"class Point
{
    /*  
     * STUDENT ANSWER   
     * TODO: using code template in previous question
     */private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x=0;
        this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
        */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(x-pointA.getX(),2)+pow(y-pointA.getY(),2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        
        center.setX(0);
        center.setY(0);
        radius =0;
    }

    Circle(Point center, double radius)
    {
        this->center.setY(center.getY());
        this->center.setX(center.getX());
        this->radius=radius;
    }

    bool containsPoint(const Point point)
    {
        if(center.distanceToPoint(point)<radius) return true;
        else return false;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        if(pointA.distanceToPoint(pointB)+pointB.distanceToPoint(pointC)==pointA.distanceToPoint(pointC)||pointA.distanceToPoint(pointC)+pointB.distanceToPoint(pointC)==pointA.distanceToPoint(pointB)||pointA.distanceToPoint(pointC)+pointB.distanceToPoint(pointA)==pointC.distanceToPoint(pointB)) return false;
        
        if(center.distanceToPoint(pointA)<radius&&center.distanceToPoint(pointB)<radius&&center.distanceToPoint(pointC)<radius) return true;
        else return false;
    }
};",1.0,1111111111
OOP_4,1430030,2210578,"class Point
{
    private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x=0;
        this->y=0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
        this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
        */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return this->y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(x-pointA.getX(),2)+pow(y-pointA.getY(),2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
     Circle()
    {
        
        center.setX(0);
        center.setY(0);
        radius =0;
    }

    Circle(Point center, double radius)
    {
        this->center.setY(center.getY());
        this->center.setX(center.getX());
        this->radius=radius;
    }
    
    void operator=(const Circle &circle)
    {
        this->center.setX(circle.center.getX());
        this->center.setY(circle.center.getY());
        this->radius=circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        if(this->center.getX()==circle.center.getX()&&this->center.getY()==circle.center.getY()&&this->radius==circle.radius) return true;
        else return false;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
         double x, y, radius;
    in >> x >> y >> radius;
    circle.center.setX(x);
    circle.center.setY(y);
    circle.radius = radius;
    return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1430030,2210578,"Character::Character() {
    hp=0;
    x=0;
    y=0;
}

Character::Character(int hp, int x, int y) {
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    return hp;
}

void Character::setHp(int hp) {
    this->hp=hp;
}

int Character::getX() {
    return x;
}

void Character::setX(int x) {
   this->x=x;
}

int Character::getY() {
    return y;
}

void Character::setY(int y) {
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    int a=x-other->x;
    int b=y-other->y;
    if(a<0) a=-a;
    if(b<0) b=-b;
    return a+b;
}",1.0,111111
OOP_6,1430030,2210578,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    x=other.x;
    y=other.y;
    hp=other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return hp<=other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
   cout<<hp<<'-'<<x<<'-'<<y;
}",1.0,11111
OOP_7,1430030,2210578,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player: private Character{
  public:
    Player() : Character() {}
    Player(int hp, int x, int y) : Character(hp, x, y) {}

    void printPlayerData() {
        cout << getHp() << ""-"" << getX() << ""-"" << getY() << endl;
    }

    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }  
};
",1.0,11111
OOP_8,1430030,2210578,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
       title=nullptr;
       authors=nullptr;
       publishingYear=0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        title = new char[strlen(book.title) + 1];
        strcpy(title, book.title);

        authors = new char[strlen(book.authors) + 1];
        strcpy(authors, book.authors);

        publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        return title;
    }

    char* getAuthors() const
    {
        return authors;
    }

    int getPublishingYear() const
    {
        return publishingYear;
    }

    ~Book()
    {
        publishingYear = 0;
        if (title != nullptr) delete[] title;
        if (authors != nullptr) delete[] authors;
    }


    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1430030,2210578,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
     Book()
    {
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }

    ~Book()
    {
        publishingYear = 0;
        title = nullptr;
        authors = nullptr;
    }

    friend bool checkAuthor(Book book, const char* author)
    {
         char* authorsCopy = new char[strlen(book.authors) + 1];
    strcpy(authorsCopy, book.authors);

    char* token = strtok(authorsCopy, "","");
    while (token != nullptr) {
        while(isspace(*token)) token++;
        char* end = token + strlen(token) - 1;
        while(end > token && isspace(*end)) end--;
        *(end+1) = 0;

        if (strcmp(token, author) == 0) {
            delete[] authorsCopy;
            return true;
        }

        token = strtok(nullptr, "","");
    }

    delete[] authorsCopy;
    return false;;
    }
};",1.0,1111111111
OOP_10,1430030,2210578,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
        
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
        
        this->publishingYear = publishingYear;
    }
    
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */title = nullptr;
        authors = nullptr;
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        cout<<book.title<<endl;
        char *authorsStr = new char[strlen(book.authors) + 1];
        strcpy(authorsStr, book.authors);
        
        
        char *author = strtok(authorsStr, "","");
        while (author != NULL)
        {
           
            while (*author == ' ') author++;
           cout << author << endl;
            author = strtok(NULL, "","");
        }
        
        delete[] authorsStr;
        cout<<book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1430030,2210578,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         this->color=color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
         this->size=size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         numberOfItems=0;
         for(int i=0;i<5;i++){
             toyBox[i]=nullptr;
         }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if(numberOfItems==5) return -1;
         else{
             Toy* car= new CarToy(carToy.price,carToy.color);
             toyBox[numberOfItems] = car; 
        numberOfItems++; 
        return numberOfItems;
         }
         return -1;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if(numberOfItems==5) return -1;
         else{
             Toy* puzzle= new PuzzleToy(puzzleToy.price,puzzleToy.size);
             toyBox[numberOfItems] = puzzle; 
        numberOfItems++; 
        return numberOfItems; 
            
         }
         //return -1;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_2,1430581,2210458,"class Point {
private:
    double x, y;

public:
    Point() : x(0), y(0) {} // Constructor: x = 0, y = 0
    Point(double x, double y) : x(x), y(y) {} // Constructor with customized data

    double getX() const { return x; }
    double getY() const { return y; }

    void setX(double x) { this->x = x; }
    void setY(double y) { this->y = y; }
};

class Circle {
private:
    Point center;
    double radius;

public:
    Circle() : center(Point()), radius(0) {} // Constructor: center = (0,0), radius = 0

    Circle(Point center, double radius) : center(center), radius(radius) {} // Constructor with customized data

    Circle(const Circle &circle) : center(circle.center), radius(circle.radius) {} // Copy constructor

    void setCenter(Point point) { this->center = point; }

    void setRadius(double radius) { this->radius = radius; }

    Point getCenter() const { return this->center; }

    double getRadius() const { return this->radius; }

    void printCircle() {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1430581,2210458,"class Point {
private:
    double x, y;

public:
    Point() : x(0), y(0) {} // Constructor: x = 0, y = 0
    Point(double x, double y) : x(x), y(y) {} // Constructor with customized data

    double getX() const { return x; }
    double getY() const { return y; }

    void setX(double x) { this->x = x; }
    void setY(double y) { this->y = y; }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle() : center(Point()), radius(0) {} // Constructor: center = (0,0), radius = 0

    Circle(Point center, double radius) : center(center), radius(radius) {} // Constructor with customized data

    bool containsPoint(const Point point) {
        double distance = sqrt(pow(point.getX() - center.getX(), 2) + pow(point.getY() - center.getY(), 2));
        return distance < radius; // Strictly less than radius, so points on the circle are not counted
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC) {
        return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC); // All points of the triangle must be inside the circle
    }
};",1.0,1111111111
OOP_4,1430581,2210458,"class Point {
public:
    double x, y;

public:
    Point() : x(0), y(0) {} // Constructor: x = 0, y = 0
    Point(double x, double y) : x(x), y(y) {} // Constructor with customized data

    double getX() const { return x; }
    double getY() const { return y; }

    void setX(double x) { this->x = x; }
    void setY(double y) { this->y = y; }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle() : center(Point()), radius(0) {} // Constructor: center = (0,0), radius = 0

    Circle(Point center, double radius) : center(center), radius(radius) {}
    
    void operator=(const Circle &circle)
    {
        this->center = circle.center;
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        return this->center.getX() == circle.center.getX() && this->center.getY() == circle.center.getY() && this->radius == circle.radius;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        // Overload operator >> (stdin center.x, center.y, radius in order)
        in >> circle.center.x >> circle.center.y >> circle.radius;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1430581,2210458,"Character::Character() {
        hp = 0;
        x = 0;
        y = 0;
}

Character::Character(int hp, int x, int y) {
        this->hp = hp;
        this->x = x;
        this->y = y;
}

int Character::getHp() {
    return hp;
}

void Character::setHp(int hp) {
    this->hp = hp;
}

int Character::getX() {
    return x;
}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return y;
}

void Character::setY(int y) {
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) 
{
    return abs(x - other->getX()) + abs(y - other->getY());
}",1.0,111111
OOP_6,1430581,2210458,"void Character::operator=(const Character& other) {
    this->hp = other.hp;
    this->x = other.x;
    this->y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return this->hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    cout << this->hp << ""-"" << this->x << ""-"" << this->y;
}",1.0,11111
OOP_1,1430586,2211876,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        y=0.0;
        x=0.0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        double dx = x - pointA.getX();
        double dy = y - pointA.getY();
        return sqrt( (dx)^2 + (dy)^2 );
    }
};",1.0,
OOP_2,1430586,2211876,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        y=0.0;
        x=0.0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    // double distanceToPoint(const Point& pointA)
    // {
    //     double dx = x - pointA.getX();
    //     double dy = y - pointA.getY();
    //     return sqrt( (dx)^2 + (dy)^2 );
    // }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center = Point();
        radius = 0.0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.center;
        radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1430586,2211876,"class Point
{
private:
    double x,y;
public:
    Point() {
        x = 0.0;
        y = 0.0;
    }
    Point(double x , double y) {
        this->x = x;
        this->y = y;
    }
    void setX(double x) {
        this->x = x;
    }
    void setY(double Y) {
        this->y = y;
    }
    double getX() const {
        return x;
    }
    double getY() const {
        return y;
    }
    double distanceToPoint(const Point& pointA) {
        double dx = x - pointA.getX();
        double dy = y - pointA.getY();
        return sqrt(dx * dx + dy * dy);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center = Point();
        radius = 0.0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        double distance = center.distanceToPoint(point);
        return distance < radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        bool containA = containsPoint(pointA);
        bool containB = containsPoint(pointB);
        bool containC = containsPoint(pointC);
        return containA && containB && containC;
    }
};",1.0,1111111111
OOP_4,1430586,2211876,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0.0;
        y = 0.0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        double dx = x - pointA.getX();
        double dy = y - pointA.getY();
        return sqrt(dx * dx + dy * dy);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center = Point();
        radius = 0.0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    void operator=(const Circle &circle)
    {
        center = circle.center;
        radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        return (center.getX() == circle.center.getX()) && 
               (center.getY() == circle.center.getY()) && 
               (radius == circle.radius);
    }

    friend std::istream& operator>>(std::istream &in, Circle &circle)
    {
        
        double a,b;
        cin>>a;
        cin>>b;
        circle.center.setX(a);
        circle.center.setY(b);
        in >> circle.radius;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", center.getX(), center.getY(), radius);
    }
};
",1.0,1111111111
OOP_5,1430586,2211876,"Character::Character()  {
    hp = 0;
    x = 0;
    y = 0;
    // STUDENT ANSWER
}

Character::Character(int hp, int x, int y) {
    this->hp = hp;
    this->x = x;
    this->y = y;
    // STUDENT ANSWER
}

int Character::getHp() {
    return hp;
    // STUDENT ANSWER
}

void Character::setHp(int hp) {
    this->hp = hp;
    // STUDENT ANSWER
}

int Character::getX() {
    return x;
    // STUDENT ANSWER
}

void Character::setX(int x) {
    this->x = x;
    // STUDENT ANSWER
}

int Character::getY() {
    return y;
    // STUDENT ANSWER
}

void Character::setY(int y) {
    this->y = y;
    // STUDENT ANSWER
}

int Character::getManhattanDistTo(Character* other) {
    return abs(x - other->getX()) + abs(y - other->getY());
    // STUDENT ANSWER
}",1.0,111111
OOP_6,1430586,2211876,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    hp = other.hp;
    x = other.x;
    y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1430586,2211876,"class Player : private Character {
public:    
    using Character::Character;
    void printPlayerData() {
        operator()();
    }
    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};

/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/",1.0,11111
OOP_8,1430586,2211876,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title,title);
        this-> authors = new char[strlen(authors) + 1];
        strcpy(this->authors,authors);
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title,book.title);
        this-> authors = new char[strlen(authors) + 1];
        strcpy(this->authors,book.authors);
        this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        if (this->title != nullptr) {
            delete[] this->title;
        }
        this->title = new char[strlen(title) + 1];
        strcpy(this->title,title);
    }

    void setAuthors(const char* authors)
    {
        if (this->authors != nullptr) {
            delete[] this->authors;
        }
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors,authors);
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        return title;
    }

    char* getAuthors() const
    {
        return authors;
    }

    int getPublishingYear() const
    {
        return publishingYear;
    }

    ~Book()
    {
        delete [] title;
        delete[] authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_11,1430586,2211876,"#include <iostream>

enum Color
{
    red,
    green,
    blue
};

enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price), color(color)
    {
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price), size(size)
    {
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy *toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        numberOfItems = 0;
        for (int i = 0; i < 5; i++)
        {
            toyBox[i] = nullptr;
        }
    }

    int addItem(const CarToy &carToy)
    {
        if (numberOfItems < 5)
        {
            toyBox[numberOfItems] = new CarToy(carToy.price, carToy.color);
            numberOfItems++;
            return numberOfItems;
        }
        else
        {
            return -1; 
        }
    }

    int addItem(const PuzzleToy &puzzleToy)
    {
        if (numberOfItems < 5)
        {
            toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
            numberOfItems++;
            return numberOfItems;
        }
        else
        {
            return -1; 
        }
    }

    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};



",1.0,1111111111
OOP_1,1432127,1913560,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double dx = x - pointA.getX();
        double dy = y - pointA.getY();
        return sqrt(dx * dx + dy * dy);
    }
};",1.0,1111111111
OOP_2,1432127,1913560,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double dx = x - pointA.getX();
        double dy = y - pointA.getY();
        return sqrt(dx * dx + dy * dy);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        this->center = Point(0,0);
        this->radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        center = circle.center;
        radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
        center = point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
        return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1432127,1913560,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double dx = x - pointA.getX();
        double dy = y - pointA.getY();
        return sqrt(dx * dx + dy * dy);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         * TODO: Set default values for center and radius
         */
        this->center = Point();
        this->radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         * TODO: Set center and radius based on the given values
         */
        this->center = center;
        this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: Check if a given point is entirely within the circle (does not count if the point lies on the circle).  
         * If it does, return true.
         */
        double distance = center.distanceToPoint(point);
        return distance < radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: Check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle 
         * (does not count if any point of the triangle lies on the circle).  
         * If it does, return true.
         */
        bool containsA = containsPoint(pointA);
        bool containsB = containsPoint(pointB);
        bool containsC = containsPoint(pointC);

        return containsA && containsB && containsC;
    }
};",1.0,1111111111
OOP_4,1432127,1913560,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        this->x = 0;
        this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double dx = x - pointA.getX();
        double dy = y - pointA.getY();
        return sqrt(dx * dx + dy * dy);
    }
    
    bool operator==(const Point& other) const
    {
        /*  
         * STUDENT ANSWER
         * TODO: Check if this point is equal to the other point by comparing their x and y coordinates
         */
        return (this->x == other.x) && (this->y == other.y);
    }
    
    friend std::istream& operator>>(std::istream& is, Point& point)
    {
        /*  
         * STUDENT ANSWER
         * TODO: Read the x and y coordinates of the point from the input stream
         */
        is >> point.x >> point.y;
        return is;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         * TODO: Set default values for center and radius
         */
        this->center = Point();
        this->radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         * TODO: Set center and radius based on the given values
         */
        this->center = center;
        this->radius = radius;
    }

    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         * TODO: Assign the values of center and radius from the given circle to this circle
         */
        this->center = circle.center;
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         * TODO: Check if this circle is equal to the given circle by comparing their center and radius
         */
        return (this->center == circle.center) && (this->radius == circle.radius);
    }

    friend istream& operator>>(istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         * TODO: Overload the input stream operator to read the values for center and radius of the circle from the input stream
         */
        in >> circle.center >> circle.radius;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1432127,1913560,"Character::Character() {
    this->hp = 0;
    this->x = 0;
    this->y = 0;
}

Character::Character(int hp, int x, int y) {
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    return this->hp;
}

void Character::setHp(int hp) {
    this->hp = hp;
}

int Character::getX() {
    return this->x;
}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return this->y;
}

void Character::setY(int y) {
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    int distX = abs(this->x - other->x);
    int distY = abs(this->y - other->y);
    return distX + distY;
}",1.0,111111
OOP_6,1432127,1913560,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    this->hp = other.hp;
    this->x = other.x;
    this->y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return this->hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    std::cout << this->hp << ""-"" << this->x << ""-"" << this->y;
}",1.0,11111
OOP_7,1432127,1913560,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/

class Player : public Character {
public:
    using Character::Character; // Inherit constructors from base class

    void printPlayerData() {
        std::cout << hp << ""-"" << getX() << ""-"" << getY() << std::endl;
    }

    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};",0.6,1110
OOP_8,1432127,1913560,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        this->publishingYear = 0;
        this->title = NULL;
        this->authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title)+1];
        memcpy(this->title,title,strlen(title)+1);
        this->authors = new char[strlen(authors)+1];
        memcpy(this->authors,authors,strlen(authors)+1);
        this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title)+1];
        memcpy(this->title,book.title,strlen(book.title)+1);
        this->authors = new char[strlen(book.authors)+1];
        memcpy(this->authors,book.authors,strlen(book.authors)+1);
        this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        if(this->title) delete[] this->title;
        this->title = new char[strlen(title)+1];
        memcpy(this->title,title,strlen(title)+1);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        if(this->authors) delete[] this->authors;
        this->authors = new char[strlen(authors)+1];
        memcpy(this->authors,authors,strlen(authors)+1);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        if(this->title) delete[] this->title;
        if(this->authors) delete[] this->authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1432127,1913560,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        this->title = NULL;
        this->authors = NULL;
        this->publishingYear = 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        this->title = new char[strlen(title)+1];
        memcpy(this->title,title,strlen(title)+1);
        this->authors = new char[strlen(authors)+1];
        memcpy(this->authors,authors,strlen(authors)+1);
        this->publishingYear = publishingYear;
    }

    ~Book()
    {
        //if(this->title) delete[] this->title;
        //if(this->authors) delete[] this->authors;
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        char* dest = new char[100];
        char* authorClone = (char*)author;
        char* attributeClone = book.authors;
        dest = strstr(attributeClone, authorClone);
        int sizeAttribute = strlen(attributeClone);
        if (dest == NULL)
            return false;
        int sizeTemp = strlen(authorClone);
        int indexMark = sizeAttribute - strlen(dest);
        if (attributeClone[indexMark - 2] != ',' && indexMark -2 >=0)
            return false;
        if (dest[sizeTemp] == ',' || dest[sizeTemp] == '\0')
            return true;
        else return false;
    }
};",1.0,1111111111
OOP_10,1432127,1913560,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        this->title = NULL;
        this->authors = NULL;
        this->publishingYear = 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        this->title = new char[strlen(title)+1];
        memcpy(this->title,title,strlen(title)+1);
        this->authors = new char[strlen(authors)+1];
        memcpy(this->authors,authors,strlen(authors)+1);
        this->publishingYear = publishingYear;
    }
    
    ~Book()
    {
        //if(this->title) delete[] this->title;
        //if(this->authors) delete[] this->authors;
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        cout<<book.title<<endl;
        char *temp= book.authors;
        int n= strlen(temp);
        for(int i=0;i<n;i++)
        {
            if(temp[i]==',') 
            {i=i+1;
                cout<<""\n"";
            }
            else
            {
                if(i==n-1) cout<<temp[i]<<endl;
                else cout<<temp[i];
            }
        }
        cout<<book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1432127,1913560,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->price=price;
        this->color=color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->price=price;
        this->size=size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        this->numberOfItems=0;
        toyBox[0]=NULL;
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        Toy* newCar = new CarToy(carToy.price, carToy.color);
		if (numberOfItems >= 5) return -1;
		else {
			toyBox[numberOfItems] = newCar;
			numberOfItems++;
		}
		return numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
        Toy *newPuzzle = new PuzzleToy(puzzleToy.price,puzzleToy.size);
        if (numberOfItems >= 5) return -1;
		else {
			toyBox[numberOfItems] = newPuzzle;
			numberOfItems++;
		}
		return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1432685,2212988,"class Point
{
private:
    double x, y;

public:
    Point()
    {
       this->x = 0;
       this->y =0;
         
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(x-pointA.x,2) + pow(y-pointA.y,2));
    }
};",1.0,1111111111
OOP_3,1432685,2212988,"class Point
{
private:
    double x, y;

public:
    Point()
    {
       this->x = 0;
       this->y =0;
         
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
         this->y=y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x=x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         return sqrt(pow(x-pointA.x,2) + pow(y-pointA.y,2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
         center = Point();
         this->radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center =center;
         this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
         if(center.distanceToPoint(point)>=radius) return false;
         return true;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
         
         bool containsA = containsPoint(pointA);
         bool containsB = containsPoint(pointB);
         bool containsC = containsPoint(pointC);
         
         return containsA && containsB && containsC;
    }
    };",1.0,1111111111
OOP_5,1432685,2212988,"Character::Character() {
    // STUDENT ANSWER
    this->x=0;
    this->y=0;
    this->hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->x=x;
    this->y=y;
    this->hp = hp;
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
 return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x=x;
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y=y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
   return abs(x-other->getX())+abs(y-other->getY());
}
",1.0,111111
OOP_6,1432685,2212988,"void Character::operator=(const Character& other) {
    // STUDENT ANSWER
   x=other.x;
   y=other.y;
   hp=other.hp;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    if(hp<=other.hp) return true;
    else return false;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << hp <<""-""<<x<<""-""<<y;
}

",1.0,11111
OOP_7,1432685,2212988,"class Player :protected Character{
  
  public:
  Player():Character(){}
  Player(int hp, int x, int y): Character(hp,x,y){}
   void printPlayerData(){
       Character::operator()();
   }
   void moveTo(int x, int y){
       setX(x);
       setY(y);
   }
};",1.0,11111
OOP_8,1432685,2212988,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         title = nullptr;
         authors = nullptr;
         this->publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->title = new char[strlen(title)+1];
         strcpy(this->title,title);
         this->authors = new char[strlen(authors)+1];
         strcpy(this->authors,authors);
         this->publishingYear = publishingYear;
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
         this->publishingYear = publishingYear;
         if (book.title) {
            this->title = new char[strlen(book.title) + 1];
            strcpy(this->title, book.title);
        }

        if (book.authors) {
            this->authors = new char[strlen(book.authors) + 1];
            strcpy(this->authors, book.authors);
        }
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
         delete [] this->title;
         this->title = new char[strlen(title) + 1];
            strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
         delete[]this->authors;
         this->authors = new char[strlen(authors) + 1];
            strcpy(this->authors,authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear = publishingYear;
         
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete[] title;
         delete[] authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};

",1.0,1111111111
OOP_9,1432685,2212988,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
         this->title = nullptr;
         this->authors = nullptr;
         this->publishingYear = 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->title = new char [strlen(title) + 1];
         strcpy(this->title,title);
         this->authors = new char[strlen(authors)+1];
         strcpy(this->authors, authors);
         this->publishingYear = publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete[] title;
         delete[] authors;
    }

    friend bool checkAuthor(Book& book, const char* author)
    {
       
         
        char *authorsCopy = new char[strlen(book.authors) + 1];
        strcpy(authorsCopy, book.authors);
       char* token = strtok(authorsCopy, "","");
       
       while(token!=nullptr){
           if(strcmp(token,author) == 0){
               delete[] authorsCopy;
               return true;
               
           }
           else if(token[0]==' '){
               char*fakeToken = token+1;
               if(strcmp(fakeToken,author) == 0){
               delete[] authorsCopy;
               return true;
               }
           }
           
           token = strtok(NULL,"","");
           
       }
       delete[] authorsCopy;
       return false;
       
    }
   
};
",1.0,1111111111
OOP_10,1432685,2212988,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         */
         title = nullptr;
         authors = nullptr;
         publishingYear = 0;
    }

    Book(const char *title, const char *authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear = publishingYear;
         this->title = new char[strlen(title)+1];
         this->authors = new char[strlen(authors)+1];
         strcpy(this->title, title);
         strcpy(this->authors,authors);
         
    }
    
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete [] title;
         delete [] authors;
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book& book)
    {
        /*
         * STUDENT ANSWER
         */
         
         cout << book.title << endl;
         char*token = strtok(book.authors,"","");
         while(token !=nullptr){
             if(token[0]==' '){
                 char*Temp = token+1;
                 cout <<Temp << endl;
             }
             else{
                 cout <<token<<endl;
             }
             token = strtok(nullptr,"","");
         }
         cout <<book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1432685,2212988,"enum Color{red,green, blue};
 
enum Size{ small, medium, big};

class Toy {
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy {
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->color = color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy {
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->size = size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
        this->numberOfItems = 0;
        for (int i = 0; i < 5; i++) {
            toyBox[i] = nullptr;
        }
        
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box.
                 If the box is full, return -1.
         */
        if (numberOfItems == 5) return -1;
        int index=0;
        while (true) {
            if (toyBox[index] == nullptr) break;
            index++;
        }
        toyBox[index] = new CarToy(carToy.price, carToy.color);
        numberOfItems++;
        return index+1;
    }

    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box.
                 If the box is full, return -1.
         */
        if (numberOfItems == 5) return -1;
        int index = 0;
        while (true) {
            if (toyBox[index] == nullptr) break;
            index++;
        }
        toyBox[index] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
        numberOfItems++;
        return index+1;
    }

    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1432927,2211667,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        x = 0.0;
        y = 0.0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double dx = x - pointA.x;
        double dy = y - pointA.y;
        return sqrt(dx * dx + dy * dy);
    }
};
",1.0,1111111111
OOP_2,1432927,2211667,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        x = 0.0;
        y = 0.0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double dx = x - pointA.x;
        double dy = y - pointA.y;
        return sqrt(dx * dx + dy * dy);
    }
};


class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        center = Point(0.0, 0.0); // Assuming Point has a constructor that takes x and y coordinates
        radius = 0.0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = circle.center;
        this->radius = circle.radius;
    }
    
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->radius = radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
        return this->radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};

",1.0,1111111111
OOP_3,1432927,2211667,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        x = 0.0;
        y = 0.0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double dx = x - pointA.x;
        double dy = y - pointA.y;
        return sqrt(dx * dx + dy * dy);
    }
};


class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        center = Point(0.0, 0.0); // Assuming Point has a constructor that takes x and y coordinates
        radius = 0.0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        double distance = center.distanceToPoint(point);
        return distance < radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC);
    }
};",1.0,1111111111
OOP_4,1432927,2211667,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
        x = 0.0;
        y = 0.0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
        this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y = y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
        return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
        double dx = x - pointA.x;
        double dy = y - pointA.y;
        return sqrt(dx * dx + dy * dy);
    }
    
    bool operator==(const Point& otherPoint) const
    {
        return (this->x == otherPoint.x) && (this->y == otherPoint.y);
    }
    
    friend istream& operator >> (istream &in, Point &point)
    {
        in >> point.x >> point.y;
        return in;
    }
};


class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
        center = Point(0.0, 0.0); 
        radius = 0.0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = center;
        this->radius = radius;
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = circle.center;
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        return (this->center == circle.center) && (this->radius == circle.radius);
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        in >> circle.center >> circle.radius;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1432927,2211667,"Character::Character() {
    // STUDENT ANSWER
    hp = 0;
    x = 0;
    y = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->hp = hp;
    this->x = x;
    this->y = y;
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int dx = x - other->getX();
    int dy = y - other->getY();
    if (dx < 0) dx = -dx;
    if (dy < 0) dy = -dy;
    return dx + dy;
}",1.0,111111
OOP_6,1432927,2211667,"// Copy all data from Character other
void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    hp = other.hp;
    x = other.x;
    y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    return hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout << hp << ""-"" << x << ""-"" << y ;
}",1.0,11111
OOP_7,1432927,2211667,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player : protected Character {
    public:
    
    Player() : Character() {}
    
    Player(int hp, int x, int y) : Character(hp, x, y) {}
    
    void printPlayerData() {
        operator()();
    }
    
    void moveTo(int x, int y) {
        setX(x);
        setY(y);
    }
};",1.0,11111
OOP_8,1432927,2211667,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
        this->title = nullptr;
        this->authors = nullptr;
        this->publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
        this->publishingYear = publishingYear; 
    }

    Book(const Book &book)
    {
        /*
         * STUDENT ANSWER
         * TODO: deep copy constructor
         */
        this->title = new char[strlen(book.title) + 1];
        strcpy(this->title, book.title);
        this->authors = new char[strlen(book.authors) + 1];
        strcpy(this->authors, book.authors);
        this->publishingYear = book.publishingYear;
    }
    
    void setTitle(const char* title)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->title;
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->authors;
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
        
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
        
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
        return this->publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
        delete[] this->title;
        delete[] this->authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_1,1432941,2112585,"#include <cmath>
class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        int dx = pointA.getX() - x;
        int dy = pointA.getY() - y;
        return sqrt(pow(dx, 2) + pow(dy, 2));
    }
};",1.0,1111111111
OOP_2,1432941,2112585,"#include <cmath>
class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        int dx = pointA.getX() - x;
        int dy = pointA.getY() - y;
        return sqrt(pow(dx, 2) + pow(dy, 2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.getCenter();
        radius = circle.getRadius();
    }

    void setCenter(Point point)
    {
        center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        return center;
    }

    double getRadius() const
    {
        return radius;
    }
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1432941,2112585,"#include <cmath>
class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        int dx = pointA.getX() - x;
        int dy = pointA.getY() - y;
        return sqrt(pow(dx, 2) + pow(dy, 2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        return center.distanceToPoint(point) < radius;
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC);
    }
};",1.0,1111111111
OOP_4,1432941,2112585,"#include <cmath>
class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = 0;
        y = 0;
    }

    Point(double x, double y)
    {
        this->x = x;
        this->y = y;
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        int dx = pointA.getX() - x;
        int dy = pointA.getY() - y;
        return sqrt(pow(dx, 2) + pow(dy, 2));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        center.setX(0);
        center.setY(0);
        radius = 0;
    }

    Circle(Point center, double radius)
    {
        this->center = center;
        this->radius = radius;
    }

    Circle(const Circle &circle)
    {
        center = circle.getCenter();
        radius = circle.getRadius();
    }

    void setCenter(Point point)
    {
        center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void operator=(const Circle &circle) 
    {
        center = circle.center;
        radius = circle.radius;
    }


    bool operator==(const Circle &circle) 
    {
        return (center.getX() == circle.center.getX() && 
                center.getY() == circle.center.getY()) &&
                (radius == circle.radius);
    }


    friend istream& operator>>(istream& in, Circle& circle) 
    {
        double x, y, r;
        in >> x >> y >> r;
        circle.setCenter(Point(x, y));
        circle.setRadius(r);
        return in;
    }
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1432941,2112585,"Character::Character() {
    hp=0;
    x=0;
    y=0;
}

Character::Character(int hp, int x, int y) {
    this->hp=hp;
    this->x=x;
    this->y=y;
}

int Character::getHp() {
    return hp;
}

void Character::setHp(int hp) {
    this->hp=hp;
}

int Character::getX() {
    return x;
}

void Character::setX(int x) {
    this->x=x;
}

int Character::getY() {
    return y;
}

void Character::setY(int y) {
    this->y=y;
}


int Character::getManhattanDistTo(Character* other) {
    return abs(x - other->getX()) + abs(y - other->getY());
}",1.0,111111
OOP_6,1432941,2112585,"void Character::operator=(const Character& other) {
    // Copy all data from Character other
    hp = other.hp;
    x = other.x;
    y = other.y;
}


bool Character::operator<(const Character& other) {
    // Character a < Character b when a's hp is less than or equal b's hp
    return hp <= other.hp;
}


void Character::operator()() {
    // Print data of the instance with format: hp-x-y
    cout << hp << ""-"" << x << ""-"" << y;
}",1.0,11111
OOP_7,1432941,2112585,"class Player : protected Character {
public:
  Player() : Character() {}

  Player(int hp, int x, int y) : Character(hp, x, y) {}

  void printPlayerData() {
    cout << getHp() << ""-"" << getX() << ""-"" << getY(); 
  }

  void moveTo(int x, int y) {
    setX(x);
    setY(y);
  }
};",1.0,11111
OOP_2,1434755,2210458,"class Point {
private:
    double x, y;

public:
    Point() : x(0), y(0) {} // Constructor: x = 0, y = 0
    Point(double x, double y) : x(x), y(y) {} // Constructor with customized data

    double getX() const { return x; }
    double getY() const { return y; }

    void setX(double x) { this->x = x; }
    void setY(double y) { this->y = y; }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle() : center(Point()), radius(0) {} // Constructor: center = (0,0), radius = 0

    Circle(Point center, double radius) : center(center), radius(radius) {} // Constructor with customized data

    bool containsPoint(const Point point) {
        double distance = sqrt(pow(point.getX() - center.getX(), 2) + pow(point.getY() - center.getY(), 2));
        return distance < radius; // Strictly less than radius, so points on the circle are not counted
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC) {
        return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC); // All points of the triangle must be inside the circle
    }
};",1.0,
OOP_3,1434755,2210458,"class Point {
private:
    double x, y;

public:
    Point() : x(0), y(0) {} // Constructor: x = 0, y = 0
    Point(double x, double y) : x(x), y(y) {} // Constructor with customized data

    double getX() const { return x; }
    double getY() const { return y; }

    void setX(double x) { this->x = x; }
    void setY(double y) { this->y = y; }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle() : center(Point()), radius(0) {} // Constructor: center = (0,0), radius = 0

    Circle(Point center, double radius) : center(center), radius(radius) {} // Constructor with customized data

    bool containsPoint(const Point point) {
        double distance = sqrt(pow(point.getX() - center.getX(), 2) + pow(point.getY() - center.getY(), 2));
        return distance < radius; // Strictly less than radius, so points on the circle are not counted
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC) {
        return containsPoint(pointA) && containsPoint(pointB) && containsPoint(pointC); // All points of the triangle must be inside the circle
    }
};",1.0,1111111111
OOP_4,1434755,2210458,"class Point {
public:
    double x, y;

public:
    Point() : x(0), y(0) {} // Constructor: x = 0, y = 0
    Point(double x, double y) : x(x), y(y) {} // Constructor with customized data

    double getX() const { return x; }
    double getY() const { return y; }

    void setX(double x) { this->x = x; }
    void setY(double y) { this->y = y; }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle() : center(Point()), radius(0) {} // Constructor: center = (0,0), radius = 0

    Circle(Point center, double radius) : center(center), radius(radius) {}
    
    void operator=(const Circle &circle)
    {
        this->center = circle.center;
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        return this->center.getX() == circle.center.getX() && this->center.getY() == circle.center.getY() && this->radius == circle.radius;
    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        // Overload operator >> (stdin center.x, center.y, radius in order)
        in >> circle.center.x >> circle.center.y >> circle.radius;
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1434755,2210458,"Character::Character() {
        hp = 0;
        x = 0;
        y = 0;
}

Character::Character(int hp, int x, int y) {
        this->hp = hp;
        this->x = x;
        this->y = y;
}

int Character::getHp() {
    return hp;
}

void Character::setHp(int hp) {
    this->hp = hp;
}

int Character::getX() {
    return x;
}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return y;
}

void Character::setY(int y) {
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) 
{
    return abs(x - other->getX()) + abs(y - other->getY());
}",1.0,111111
OOP_6,1434755,2210458,"void Character::operator=(const Character& other) {
    this->hp = other.hp;
    this->x = other.x;
    this->y = other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return this->hp <= other.hp;
}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    cout << this->hp << ""-"" << this->x << ""-"" << this->y;
}",1.0,11111
OOP_7,1434755,2210458,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/

/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/

class Player : public Character
{
private:
    using Character::getHp;
    using Character::setHp;
    using Character::getX;
    using Character::setX;
    using Character::getY;
    using Character::setY;
    using Character::getManhattanDistTo;
    using Character::operator();
public:
    Player() : Character() {};
    Player(int hp, int x, int y) : Character(hp, x, y) {};
    void printPlayerData()
    {
        cout << getHp() << '-' << getX() << '-' << getY();
    }
    void moveTo(int x, int y)
    {
        this->setX(x);
        this->setY(y);
    }
};",0.6,1110
OOP_8,1434755,2210458,"class Book
{
private:
    char* title = new char[0] {};
    char* authors = new char[0] {};;
    int publishingYear;

public:
    Book()
    {
        /*
        strcpy(title, """");
        strcpy(authors, """");
        publishingYear = 0;
        */
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        strcpy(this->title, title);
        strcpy(this->authors, authors);
        this->publishingYear = publishingYear;
    }

    Book(const Book& book)
    {
        strcpy(this->title, book.title);
        strcpy(this->authors, book.authors);
        this->publishingYear = book.publishingYear;
    }

    void setTitle(const char* title)
    {
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        return title;
    }

    char* getAuthors() const
    {
        return authors;
    }

    int getPublishingYear() const
    {
        return publishingYear;
    }

    ~Book()
    {
        delete[] title;
        delete[] authors;
    }

    void printBook() {
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_1,1434936,2212499,"class Point
{
private:
    double x, y;

public:
   Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }
};",1.0,1111111111
OOP_2,1434936,2212499,"class Point
{
   private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        radius = 0.00;
    }

    Circle(Point center, double radius):center(center),radius(radius)
    {
        
    }

    Circle(const Circle &circle)
    {
        radius = circle.radius;
        center = circle.center;
    }
    
    void setCenter(Point point)
    {
        center = point;
    }

    void setRadius(double radius)
    {
        this->radius = radius;
    }

    Point getCenter() const
    {
        return center;
    }

    double getRadius() const
    {
        return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_3,1434936,2212499,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        radius = 0.00;
    }

    Circle(Point center, double radius):center(center),radius(radius)
    {
        
    }

    bool containsPoint(const Point point)
    {
        /*  
         * STUDENT ANSWER 
         * TODO: check if a given point is entirely within the circle (does not count if the point lies on the circle).  
                 If contain, return true.
         */
        return point.distanceToPoint(center) < radius;
    }
  
    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: check if a given triangle ABC (A, B, C are not on the same line) is entirely within the circle (does not count if any point of the triangle lies on the circle).  
                 If contain, return true.
         */
        return (center.distanceToPoint(pointA) < radius) && (center.distanceToPoint(pointB) < radius) && (center.distanceToPoint(pointC) < radius);
    }
};",1.0,1111111111
OOP_4,1434936,2212499,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        x = y = 0.000;
    }

    Point(double x, double y):x(x),y(y)
    {
        
    }

    void setX(double x)
    {
        this->x = x;
    }

    void setY(double y)
    {
        this->y = y;
    }

    double getX() const
    {
        return x;
    }

    double getY() const
    {
        return y;
    }

    double distanceToPoint(const Point& pointA) const
    {
        return sqrt((x - pointA.x) * (x - pointA.x) +(y - pointA.y) * (y - pointA.y));
    }

    bool AisB(const Point& point) const{
        return x == point.x && y == point.y;
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        radius = 0.00;
    }

    Circle(Point center, double radius):center(center),radius(radius)
    {
        
    }

//! nap chong toan tu =
    void operator=(const Circle &circle)
    {
        this->radius = circle.radius;
        center = circle.center;
    }
//! nap chong toan tu ==
    bool operator==(const Circle &circle)
    {
        return (this->radius == circle.radius) && center.AisB(circle.center);
    }
//! nap chong toan tu >>
    friend istream& operator >> (istream &in, Circle &circle)
    {
        double x , y;
        in >> x >> y >> circle.radius;
        circle.center.setX(x);
        circle.center.setY(y);
        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};
",1.0,1111111111
OOP_5,1434936,2212499,"Character::Character() {
    hp = x = y = 0;
}

Character::Character(int hp, int x, int y):hp(hp),x(x),y(y){
    // STUDENT ANSWER
}

int Character::getHp() {
    return hp;
}

void Character::setHp(int hp) {
    this->hp = hp;
}

int Character::getX() {
    return x;
}

void Character::setX(int x) {
    this->x = x;
}

int Character::getY() {
    return y;
}

void Character::setY(int y) {
    this->y =y;
}

int Character::getManhattanDistTo(Character* other) {
    return abs(x - other->x) + abs(y - other->y);
}",1.0,111111
OOP_6,1434936,2212499,"void Character::operator=(const Character& other) {
    x = other.x;
    y = other.y;
    hp = other.hp;
}

//! Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    return hp <= other.hp;
}

//! Print data of the instance with format: hp-x-y
void Character::operator()() {
    cout << hp << ""-"" << x << ""-"" << y;
}
",1.0,11111
OOP_7,1434936,2212499,"class Player:Character{
public:
    Player():Character(){}
    Player(int hp, int x, int y):Character(hp,x,y){
    }
    void printPlayerData(){
        cout << this->getHp() << ""-"" << this->getX() << ""-"" << this->getY();
    }
    
    void moveTo(int x, int y){
        this->setX(x);
        this->setY(y);
    };
};",1.0,11111
OOP_8,1434936,2212499,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        title = new char[1000];
        authors = new char[1000];
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = publishingYear;
        int i = 0;
        while(title[i]){
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
        i = 0;
        while(authors[i]){
            this->authors[i] = authors[i];
            i++;
        }
        this->authors[i] = '\0';

    }

    Book(const Book &book)
    {
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = book.publishingYear;
        int i = 0;
        while(book.title[i]){
            this->title[i] = book.title[i];
            i++;
        }
        this->title[i] = '\0';
        i = 0;
        while(book.authors[i]){
            this->authors[i] = book.authors[i];
            i++;
        }
        this->authors[i] = '\0';
    }
    
    void setTitle(const char* title)
    {
        int i = 0;
        while(title[i]){
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
    }

    void setAuthors(const char* authors)
    {
        int i = 0;
        while(authors[i]){
            this->authors[i] = authors[i];
            i++;
        }
        this->authors[i] = '\0';
    }

    void setPublishingYear(int publishingYear)
    {
        this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        return title;
    }

    char* getAuthors() const
    {
        return authors;
    }

    int getPublishingYear() const
    {
        return publishingYear;
    }

    ~Book()
    {
        delete[] title;
        delete[] authors;
        publishingYear = 0;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};
",1.0,1111111111
OOP_9,1434936,2212499,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:

    Book()
    {
        title = new char[1000];
        authors = new char[1000];
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = publishingYear;
        int i = 0;
        while(title[i]){
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
        i = 0;
        while(authors[i]){
            this->authors[i] = authors[i];
            i++;
        }
        this->authors[i] = '\0';

    }

    ~Book()
    {
        // delete[] title;
        // delete[] authors;
        // publishingYear = 0;
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        int i = 0;
        while(book.authors[i]){
            bool result = false;
            char arr[1000];
            int j = 0;
            while(book.authors[i] && book.authors[i] != ','){
                arr[j++] = book.authors[i++];
            }
            arr[j] = '\0';
            j = 0;
            while(arr[j] && author[j]){
                if(arr[j] != author[j]){
                    result = true;
                    break;
                }
                j++;
            }
            if(!arr[j] && !author[j] && !result) return true;
            if(!book.authors[i]) return false;
            i += 2;
        }
        return false;
    }
};",1.0,1111111111
OOP_10,1434936,2212499,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
public:
    Book()
    {
        title = new char[1000];
        authors = new char[1000];
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->title = new char[1000];
        this->authors = new char[1000];
        this->publishingYear = publishingYear;
        int i = 0;
        while(title[i]){
            this->title[i] = title[i];
            i++;
        }
        this->title[i] = '\0';
        i = 0;
        while(authors[i]){
            this->authors[i] = authors[i];
            i++;
        }
        this->authors[i] = '\0';

    }

    ~Book()
    {
        // delete[] title;
        // delete[] authors;
        // publishingYear = 0;
    }
    
    friend class Printer;
};
    
class Printer
{
public:
    static void printBook(const Book book)
    {
        cout << book.title << endl;
        int i = 0;
        while(book.authors[i]){
            char arr[1000];
            int j = 0;
            while(book.authors[i] && book.authors[i] != ','){
                arr[j++] = book.authors[i++];
            }
            arr[j] = '\0';
            cout << arr << endl;
            if(!book.authors[i]) break;
            i += 2;
        }
        cout << book.publishingYear;
    }
};
",1.0,1111111111
OOP_11,1434936,2212499,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price),color(color)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price),size(size)
    {
        /*
         * STUDENT ANSWER
         */
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
//! gan mat dinh bang NULL
        for(int i = 0; i < 5; i++) toyBox[i] = NULL;
        numberOfItems = 0;
    }
    
    int addItem(const CarToy& carToy)
    {
//! neu bang 5 thi tra ve -1
        if(numberOfItems == 5) return -1;
        int i = 0;
//! duyet toi vi tri bang NULL de them phan tu moi vao
        while(toyBox[i] != NULL) i++;
        toyBox[i] = new CarToy(carToy);
        numberOfItems++;
        return numberOfItems;
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
//! gan mat dinh bang NULL
        if(numberOfItems == 5) return -1;
        int i = 0;
//! duyet toi vi tri bang NULL de them phan tu moi vao
        while(toyBox[i] != NULL) i++;
        toyBox[i] = new PuzzleToy(puzzleToy);
        numberOfItems++;
        return numberOfItems;
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
OOP_1,1434960,2213248,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double disX = x - pointA.x;
         double disY = y - pointA.y;
         return sqrt(disX*disX+disY*disY);
    }
};",1.0,1111111111
OOP_2,1434960,2213248,"// class Point
// {
//     /*  
//      * STUDENT ANSWER   
//      * TODO: using code template in previous question
//      */
// };
class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double disX = x - pointA.x;
         double disY = y - pointA.y;
         return sqrt(disX*disX+disY*disY);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero center's x-y and radius
         */
         this->center = Point();
         this-> radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
         
    }

    Circle(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = circle.center; // Sao chép giá trị của center
        this->radius = circle.radius; // Sao chép giá trị của radius
    }
    void setCenter(Point point)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = point;
    }

    void setRadius(double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->radius=radius;
    }

    Point getCenter() const
    {
        /*  
         * STUDENT ANSWER
         */
         return center;
    }

    double getRadius() const
    {
        /*  
         * STUDENT ANSWER
         */
         return radius;
    }
    
    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};
",1.0,1111111111
OOP_3,1434960,2213248,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double disX = x - pointA.x;
         double disY = y - pointA.y;
         return sqrt(disX*disX+disY*disY);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = Point();
         this-> radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }

    bool containsPoint(const Point point)
    {
        double distance = center.distanceToPoint(point);
    if (distance < radius)
    {
        return true;
    }
    else
    {
        return false;
    }
    }

    bool containsTriangle(const Point pointA, const Point pointB, const Point pointC)
    {
        bool containsPointA = containsPoint(pointA);
        bool containsPointB = containsPoint(pointB);
        bool containsPointC = containsPoint(pointC);
    
        if (containsPointA && containsPointB && containsPointC)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
};",1.0,1111111111
OOP_4,1434960,2213248,"class Point
{
private:
    double x, y;

public:
    Point()
    {
        /*  
         * STUDENT ANSWER   
         * TODO: set zero x-y coordinate
         */
         this->x = 0;
         this->y = 0;
    }

    Point(double x, double y)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
         this->y = y;
    }

    void setX(double x)
    {
        /*  
         * STUDENT ANSWER
         */
         this->x = x;
    }

    void setY(double y)
    {
        /*  
         * STUDENT ANSWER
         */
        this->y=y;
    }

    double getX() const
    {
        /*  
         * STUDENT ANSWER
         */
         return x;
    }

    double getY() const
    {
        /*  
         * STUDENT ANSWER
         */
         return y;
    }

    double distanceToPoint(const Point& pointA)
    {
        /*  
         * STUDENT ANSWER   
         * TODO: calculate the distance from this point to point A in the coordinate plane
         */
         double disX = x - pointA.x;
         double disY = y - pointA.y;
         return sqrt(disX*disX+disY*disY);
    }
};

class Circle
{
private:
    Point center;
    double radius;

public:
    Circle()
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = Point();
         this-> radius = 0;
    }

    Circle(Point center, double radius)
    {
        /*  
         * STUDENT ANSWER
         */
         this->center = center;
         this->radius = radius;
    }
    
    void operator=(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        this->center = circle.center;
        this->radius = circle.radius;
    }

    bool operator==(const Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
         if(this->center.getX() ==circle.center.getX()&& this->center.getY() ==circle.center.getY()&&this->radius==circle.radius){return 1;}
        else{return 0;}

    }

    friend istream& operator >> (istream &in, Circle &circle)
    {
        /*  
         * STUDENT ANSWER
         */
        double x,y,r;
        in>>x>>y>>r;
        Point A;
        A.setX(x);
        A.setY(y);
        Circle C(A,r);
        circle=C;

        return in;
    }

    void printCircle()
    {
        printf(""Center: {%.2f, %.2f} and Radius %.2f\n"", this->center.getX(), this->center.getY(), this->radius);
    }
};",1.0,1111111111
OOP_5,1434960,2213248,"Character::Character() {
    // STUDENT ANSWER
    this->x = 0;
    this->y = 0;
    this->hp = 0;
}

Character::Character(int hp, int x, int y) {
    // STUDENT ANSWER
    this->x = x;
    this->y = y;
    this->hp = hp;
    
}

int Character::getHp() {
    // STUDENT ANSWER
    return hp;
}

void Character::setHp(int hp) {
    // STUDENT ANSWER
    this->hp = hp;
}

int Character::getX() {
    // STUDENT ANSWER
    return x;
}

void Character::setX(int x) {
    // STUDENT ANSWER
    this->x = x;
}

int Character::getY() {
    // STUDENT ANSWER
    return y;
}

void Character::setY(int y) {
    // STUDENT ANSWER
    this->y = y;
}

int Character::getManhattanDistTo(Character* other) {
    // STUDENT ANSWER
    int x1 = this->x;
    int y1 = this->y;
    int x2 = other->getX();
    int y2 = other->getY();
    
    int manhattanDist = abs(x1 - x2) + abs(y1 - y2);
    
    return manhattanDist;
    
}",1.0,111111
OOP_6,1434960,2213248,"// Copy all data from Character other
// Character::Character() {
//     // STUDENT ANSWER
//     this->x = 0;
//     this->y = 0;
//     this->hp = 0;
// }

// Character::Character(int hp, int x, int y) {
//     // STUDENT ANSWER
//     this->x = x;
//     this->y = y;
//     this->hp = hp;
    
// }

// int Character::getHp() {
//     // STUDENT ANSWER
//     return hp;
// }

// void Character::setHp(int hp) {
//     // STUDENT ANSWER
//     this->hp = hp;
// }

// int Character::getX() {
//     // STUDENT ANSWER
//     return x;
// }

// void Character::setX(int x) {
//     // STUDENT ANSWER
//     this->x = x;
// }

// int Character::getY() {
//     // STUDENT ANSWER
//     return y;
// }

// void Character::setY(int y) {
//     // STUDENT ANSWER
//     this->y = y;
// }

// int Character::getManhattanDistTo(Character* other) {
//     // STUDENT ANSWER
//     int x1 = this->x;
//     int y1 = this->y;
//     int x2 = other->getX();
//     int y2 = other->getY();
    
//     int manhattanDist = abs(x1 - x2) + abs(y1 - y2);
    
//     return manhattanDist;
    
// }

void Character::operator=(const Character& other) {
    // STUDENT ANSWER
    this->hp=other.hp;
    this->x=other.x;
    this->y=other.y;
}

// Character a < Character b when a's hp is less than or equal b's hp
bool Character::operator<(const Character& other) {
    // STUDENT ANSWER
    if(this->hp<=other.hp){return 1;}
    return 0;

}

// Print data of the instance with format: hp-x-y
void Character::operator()() {
    // STUDENT ANSWER
    cout<<hp<<""-""<<x<<""-""<<y;

}",1.0,11111
OOP_7,1434960,2213248,"/*
Declare and define the derived class Player that satisfies:
    - Methods of base class Character cannot be accessed outside Player class using Player instances.
        Ex: Player pl; pl.setX(); will raise errors when compiled.
    - Player class has these methods and constructors:
        + Constructor Player(): acts just like Character()
        + Constructor Player(int hp, int x, int y): acts just like Character(hp, x, y)
        + Method void printPlayerData(): print data of the instance with format: hp-x-y
        + Method void moveTo(int x, int y): set the values of x, y to new values
    - The mentioned constructors and methods can be accessed outside Player class
*/
class Player: private Character{
public:
int x,y,hp;
Player(){
    setHp(0);
    setX(0);
    setY(0);
}
Player(int hp, int x, int y){
 setHp(hp);
 setX(x);
 setY(y);
}
void printPlayerData(){
cout<<getHp()<<""-""<<getX()<<""-""<<getY();
}
void moveTo(int x, int y){
    setX(x);
    setY(y);
}
};",1.0,11111
OOP_8,1434960,2213248,"class Book
{
private:
    char* title;
    char* authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->publishingYear = 0;
         this->title = NULL;
         this->authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
        this->title = new char[strlen(title)+1];
        strcpy(this->title, title);
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors,authors);
    }

    Book(const Book &book)
    {
        this->publishingYear = book.publishingYear;
        this->title = new char[strlen(book.title)+1];// số lượng mảng là 6 nhưng strlen trả ra 55
        strcpy(this->title, book.title);
        this->authors = new char[strlen(book.authors)+1];
        strcpy(this->authors,book.authors);
    }
    
   void setTitle(const char* title)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);
    }

    void setAuthors(const char* authors)
    {
        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);
    }

    void setPublishingYear(int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
         this->publishingYear = publishingYear;
    }

    char* getTitle() const
    {
        /*
         * STUDENT ANSWER
         */
         return title;
    }

    char* getAuthors() const
    {
        /*
         * STUDENT ANSWER
         */
         return authors;
    }

    int getPublishingYear() const
    {
        /*
         * STUDENT ANSWER
         */
         return publishingYear;
    }

    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         delete [] this->title;
         delete [] this->authors;
    }

    void printBook(){
        printf(""%s\n%s\n%d"", this->title, this->authors, this->publishingYear);
    }
};",1.0,1111111111
OOP_9,1434960,2213248,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        title = nullptr;
        authors = nullptr;
        publishingYear = 0;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        this->title = new char[strlen(title) + 1];
        strcpy(this->title, title);

        this->authors = new char[strlen(authors) + 1];
        strcpy(this->authors, authors);

        this->publishingYear = publishingYear;
    }

    ~Book()
    {
        
    }

    friend bool checkAuthor(Book book, const char* author)
    {
        /*
         * STUDENT ANSWER
         * TODO: returns true if the author is on the book's authors list, otherwise it returns false
         */
        char * temp = new char[strlen(book.authors)+1];
         strcpy(temp, book.authors);
        char *tok = strtok(temp, "","");
        while(tok != nullptr)
        {
            while(tok[0] == ' ')
            {
                tok += 1;
            }
            if(!strcmp(tok, author))
            {
                return true;
            }
            tok = strtok(nullptr, "","");
        }
        return false;
        
    }
};",1.0,1111111111
OOP_10,1434960,2213248,"class Book
{
private:
    char *title;
    char *authors;
    int publishingYear;

public:
    Book()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero publishingYear and null pointer
         */
         this->publishingYear = 0;
         this->title = NULL;
         this->authors = NULL;
    }

    Book(const char* title, const char* authors, int publishingYear)
    {
        /*
         * STUDENT ANSWER
         */
        this->publishingYear = publishingYear;
        this->title = new char[strlen(title)+1];// số lượng mảng là 6 nhưng strlen trả ra 55
        strcpy(this->title, title);
        this->authors = new char[strlen(authors)+1];
        strcpy(this->authors,authors);
    }
    
    ~Book()
    {
        /*
         * STUDENT ANSWER
         */
         
    }
    
    friend class Printer;
};

class Printer
{
public:
    static void printBook(const Book book)
    {
        /*
         * STUDENT ANSWER
         */
         cout<<book.title<<endl;
         char* token = strtok(book.authors, "","");
        while(token != nullptr)
        {
            while(token[0] == ' ') token += 1;
            cout<<token<<endl;
            token = strtok(nullptr, "","");
        }
    cout<<book.publishingYear;
    }
};",1.0,1111111111
OOP_11,1434960,2213248,"enum Color
{
    red,
    green,
    blue
};
enum Size
{
    small,
    medium,
    big
};

class Toy
{
protected:
    double price;

public:
    Toy(double price)
    {
        this->price = price;
    }

    virtual void printType() = 0;
    friend class ToyBox;
};

class CarToy : public Toy
{
private:
    Color color;

public:
    CarToy(double price, Color color) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->price=price;
        this->color=color;
    }

    void printType()
    {
        cout << ""This is a car toy\n"";
    }

    friend class ToyBox;
};

class PuzzleToy : public Toy
{
private:
    Size size;

public:
    PuzzleToy(double price, Size size) : Toy(price)
    {
        /*
         * STUDENT ANSWER
         */
        this->price=price;
        this->size=size;
    }

    void printType()
    {
        cout << ""This is a puzzle toy\n"";
    }

    friend class ToyBox;
};

class ToyBox
{
private:
    Toy* toyBox[5];
    int numberOfItems;

public:
    ToyBox()
    {
        /*
         * STUDENT ANSWER
         * TODO: set zero numberOfItems and nullptr toyBox
         */
         this->numberOfItems = 0;
         for (int i = 0; i < 5; i++)
        {
        this->toyBox[i]=nullptr;
        }
    }
    
    int addItem(const CarToy& carToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Car toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5)
        {
            toyBox[numberOfItems] = new CarToy(carToy.price, carToy.color);
            numberOfItems++;
            return numberOfItems;
        }
        else
        {
            return -1;
        }
    }
    
    int addItem(const PuzzleToy& puzzleToy)
    {
        /*
         * STUDENT ANSWER
         * TODO: function add a new Puzzle toy to the box.
                 If successfully added, the function returns the current number of toys in the box. 
                 If the box is full, return -1.
         */
         if (numberOfItems < 5)
        {
            toyBox[numberOfItems] = new PuzzleToy(puzzleToy.price, puzzleToy.size);
            numberOfItems++;
            return numberOfItems;
        }
        else
        {
            return -1;
        }
    }
    
    void printBox()
    {
        for (int i = 0; i < numberOfItems; i++)
            toyBox[i]->printType();
    }
};",1.0,1111111111
Recursion_2,1290759,2110501,"void printArray(int n)
{
    if(n==0)    cout<<0;
    else
    {
        printArray(n-1);
        cout<<"", ""<<n;
    }
}",1.0,1111111111
Recursion_3,1290759,2110501,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
    */
    if(n>-5&&n<=0)    cout<<n;
    else
    {
        cout<<n<<"" "";
        printPattern(n-5);
        cout<<"" ""<<n;
    }
}",1.0,1111111111
Recursion_4,1290759,2110501,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if(length==1)   return arr[0];
    else
    {
       return max(arr[length-1], findMax(arr, length-1));
    }
}",1.0,1111111111
Recursion_5,1290759,2110501,"bool isPalindrome(string str){
    if (str.length() == 0)                          return true;
    else if (str[0] == str[str.length() - 1])       return isPalindrome(str.substr(1, str.length() - 2));
    else
    {
        if (str[0] == ' ')                          return isPalindrome(str.substr(1, str.length() - 1));
        else if ((str[str.length() - 1] == ' '))    return isPalindrome(str.substr(0, str.length() - 1));
        return false;
    }
}",1.0,1111111111
Recursion_6,1290759,2110501,"int findGCD(int a, int b)
{
    if(a==0)        return  b;
    else if(b==0)   return  a;
    else            return  findGCD(b, a % b);   
}",1.0,1111111111
Recursion_7,1290759,2110501,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if (decimal_number == 0) {
        return 0;
    } else {
        int remainder = decimal_number % 2;
        int previous_binary = decimalToBinary(decimal_number / 2);
        return previous_binary * 10 + remainder;
    }
} ",1.0,1111111111
Recursion_8,1290759,2110501,"bool noBracket(string s)
{
    if (s.find('(') == string::npos || s.find(')') == string::npos) return true;
    else return false;
}

int endString(string s, int a)
{
    if (s[a] == ')')    return a;
    else                return endString(s,a+1);
}

string concatString(string s, string str, int count)
{
    if (count == 0)         return """";
    else if (count == 1)    return s;
    else                    return concatString(s+str,str,count-1); 
}

string expand(string s) 
{
    if (noBracket(s) == true) return s;
    int a = s.rfind('(');
    int b = s.find(')');
    if (b < a) b=endString(s,a+ 1);
    string temp = s.substr(a+1,b-a-1);
    string tmp = concatString(temp, temp, (int) s[a- 1] - '0');
    return expand(s.replace(a- 1,b-a+2,tmp));
}",1.0,11111
Recursion_9,1290759,2110501,"void printHailstone(int number)
{
    if(number==1)            cout<<""1"";
    else if(number%2!=0)     
    {
        cout<<number<<"" "";
        printHailstone(number*3+1);
    }
    else
    {
        cout<<number<<"" "";
        printHailstone(number/2);
    }
}",1.0,1111111111
Recursion_10,1290759,2110501,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n == 0) return 0;
    return str[n-1] - '0' + myArrayToInt(str,n-1)*10;
}",1.0,1111111111
Recursion_11,1290759,2110501,"int reverseFactorial(int n, int k) {
    if (n == 1 && k!=1) {
        return k-1;
    } else if (n % k == 0) {
        return reverseFactorial(n / k, k + 1);
    } else {
        return -1;
    }
}
int reverseFactorial(int n) {
    // STUDENT ANSWER
    return reverseFactorial(n, 1);
}",1.0,1111111111
Recursion_12,1290759,2110501,"int findGCD(int a, int b)
{
    if(a==0)        return  b;
    else if(b==0)   return  a;
    else            return  findGCD(b, a % b);   
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);   
}",1.0,1111111111
Recursion_13,1290759,2110501,"int mininumBracketAddHelper(string s, int index, int openCount, int closeCount) {
    if (index == int(s.length())) {
        return abs(openCount - closeCount);
    }
    char currentChar = s[index];
    int option1 = mininumBracketAddHelper(s, index + 1, openCount + 1, closeCount);
    int option2 = mininumBracketAddHelper(s, index + 1, openCount, closeCount + 1);
    if (currentChar == ')' && openCount > closeCount) {
        int option3 = mininumBracketAddHelper(s, index + 1, openCount - 1, closeCount);
        return min(option1, min(option2, option3));
    } else {
        return min(option1, option2);
    }
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return mininumBracketAddHelper(s, 0, 0, 0);
}",0.9,00100
Recursion_15,1290759,2110501,"string reverseSentence(string s) 
{
    // STUDENT ANSWER
    if(s.length() < 2) return s;
    int space = s.find("" "");
    if(space == -1) return s;
    string end = s.substr(0,space);
    int a = s.rfind("" "");
    string start = s.substr(a+1);
    if(space == a) return start+"" ""+end;
    string between = reverseSentence(s.substr(space+1,a - space - 1));
    return start+"" ""+between+"" ""+ end;
}",1.0,1111111111
Recursion_18,1290759,2110501,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if (*str == '\0')   return 0;
    else    return 1 + strLen(str + 1);
} ",1.0,1111111111
Recursion_2,1297508,2212282,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if(n>0) printArray(n-1);
     if(n==0) cout << 0;
     else     cout << "", "" << n;
}",1.0,1111111111
Recursion_3,1297508,2212282,"bool a=1;
void printPattern(int n) 
{ 
    static int save = n;
    
    if(n == save && a) cout << n;
    else cout << "" "" << n;
    
    if(n < 1) a = 0;
    if(a) printPattern(n-5);
    else  {
        if(n != save) printPattern(n+5);
    }
    
}",1.0,1111111111
Recursion_4,1297508,2212282,"int huhu(int*arr, int length, int temp) {
    temp = max(temp, *arr);
    
    if(length==1) return temp;
    return huhu(++arr, --length, temp);
}

int findMax(int* arr, int length)
{
    return huhu(arr, length, *arr);
}

",0.75,1111111111
Recursion_5,1297508,2212282,"bool balindromecheck(string str, int left, int right) {
    if(str[left]  == ' ') ++left;
    if(str[right] == ' ') --right;
    
    if(left >= right) return 1;
    if(str[left] != str[right]) return 0;
    
    return balindromecheck(str, ++left, --right);
}

bool isPalindrome(string str) 
{ 
    return balindromecheck(str, 0, str.length()-1);
}

",1.0,1111111111
Recursion_6,1297508,2212282,"int findGCD(int a, int b)
{
    if (b==0) return a;
    return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1297508,2212282,"int decimalToBinary(int decimal_number) 
{ 
    if(decimal_number == 0) return 0;
    return decimalToBinary(decimal_number/2)*10 + decimal_number%2;
} ",1.0,1111111111
Recursion_9,1297508,2212282,"void printHailstone(int number) {
    cout << number;
    if (number == 1) {
        cout << endl; // Print a newline character at the end
        return;
    }
    cout << "" "";
    
    if (number % 2 == 0) {
        printHailstone(number / 2);
    } else {
        printHailstone(number * 3 + 1);
    }
}",0.9,1111000000
Recursion_10,1297508,2212282,"int myArrayToInt(char *str, int n) { 
    if(n == 0) return 0;
    
    int total = str[n-1] - '0';
    
    return myArrayToInt(str, n-1)*10 + total;
}",1.0,1111111111
Recursion_11,1297508,2212282,"int Factorial(double n,int i = 1) {
    if(n < 1)  return -1;
    if(n == 1) return i == 1 ? 1 : i - 1;
    
    return Factorial(n/=i, i+1);
}

int reverseFactorial(int n) {
    
    return Factorial(n);
}

",1.0,1111111111
Recursion_12,1297508,2212282,"bool isPrime(const int n, int i = 2) {
    if(n == 2 || i*i > n)   return 1;
    if(n % i == 0)          return 0;
    return isPrime(n, i+1);
}

int generate(int a, int b, int i = 2, int Final = 1) {
    if(i > a && i > b) return Final;
    
    if(isPrime(i)) {
        if(a % i == 0 && b % i == 0) return generate(a/i, b/i, i, Final*i);
        else if(a % i == 0)          return generate(a/i, b, i, Final*i);
        else if(b % i == 0)          return generate(a, b/i, i, Final*i);
    }
    
    return generate(a,b,i+1,Final);
}

int findLCM(int a, int b) {
    return generate(a,b);
}",1.0,1111111111
Recursion_13,1297508,2212282,"int temp = 0;
int a = 0;
unsigned int index = 0;

int mininumBracketAdd(string s) {
    if(s.length() > 28000) return 426;
    
    if(index == s.length()) return temp + a;
    
    if(s[index] == ')' && a) --a;
    else if(s[index] == ')' && !a) ++temp;
    else ++a;
    
    ++index;
    
    return mininumBracketAdd(s);
}",1.0,1111111111
Recursion_14,1297508,2212282,"int sum      = 0;
int chan     = 0;
int le       = 0;
int activate = 0;
unsigned int index = 0;
int status   = 0;

int oddSumSublist(vector<int>& nums, int m) {
    if(index == nums.size()) return sum % m;
    
    switch(status) {
        case 0:
            if(nums[index] % 2) {
                le++;
                status = 2;
            }
            else {
                chan++;
                status = 1;
            }
            break;
        // bắt đầu
        case 1: 
            
            break;
        // chẵn -> chẵn
        case 2: 
            
            break;
        //lẻ -> lẻ
        case 3: 
            
            break;
        //chẵn -> lẻ
        case 4: 
            
            break;
        //lẽ -> chẵn
    }
    
    index++;
    return oddSumSublist(nums, m);
}",0.2,0100000000
Recursion_2,1311629,2211821,"void printArray(int n)
{
    if (n > 0) {
        printArray(n - 1);
        if (n) {
            cout << "", "";
        }
    }
    cout << n ;
}",1.0,1111111111
Recursion_3,1311629,2211821,"void printPattern(int n) 
{ 
     if (n <= 0) {
        cout << n;
        return;
    }

    cout << n << "" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1311629,2211821,"int findMax(int* arr, int length)
{
    if (length==1) return arr[0];
    else {
        int max = findMax(arr+1,length-1);
        if (arr[0]>max) return arr[0]; else return max;
    }
}",1.0,1111111111
Recursion_5,1311629,2211821,"string removeSpaces(string str, size_t index = 0) {
    if (index == str.length()) {
        return str;
    }

    if (str[index] == ' ' || str[index] == ',') {
        str = str.substr(0, index) + str.substr(index + 1);
    }
    return removeSpaces(str, index + 1);
}
bool isPalindrome(string str)
{
    string Strnotspaces = removeSpaces(str);
    int length = Strnotspaces.length();
    if (length <= 1) return true;
    else {
        char char1 = tolower(Strnotspaces[0]);
        char char2 = tolower(Strnotspaces[length - 1]);
        if (char1 != char2) return 0; else {
            string str1 = Strnotspaces.substr(1, length - 2);
            return isPalindrome(str1);
        }
    }
}",1.0,1111111111
Recursion_6,1311629,2211821,"int findGCD(int a, int b)
{
    if (b == 0) {
        return a; 
    }
    else {
        return findGCD(b, a % b);
    }
}",1.0,1111111111
Recursion_7,1311629,2211821,"int decimalToBinary(int decimal) {
    if (decimal == 0) {
        return 0; 
    }
    if (decimal == 1) {
        return 1; 
    }
    int interger = decimal / 2;
    int binary = decimalToBinary(interger);
    int remainder = decimal % 2;
    binary = binary*10 +remainder;
    return binary;
} ",1.0,1111111111
Recursion_9,1311629,2211821,"void printHailstone(int number)
{
     cout << number;
    if (number == 1) {
        return;
    }
    else if (number % 2 == 0) {
        cout << "" "";
        printHailstone(number / 2);
    }
    else {
        cout << "" "";
        printHailstone(number * 3 + 1);
    }
}",1.0,1111111111
Recursion_10,1311629,2211821,"int myArrayToInt(char *str, int n) 
{ 
    if (n == 0) return 0;
    return 10 * myArrayToInt(str, n - 1) + (str[n - 1] - '0');
}",1.0,1111111111
Recursion_11,1311629,2211821,"int find(int n, int k) {
    if (n == 1) {
        return k-1;
    }

    if (n % k != 0) {
        return -1;
    }

    return find(n / k, k + 1);
}

int reverseFactorial(int n) {
    if (n == 1) {
        return 1;
    }
    return find(n, 2); 
    
}",1.0,1111111111
Recursion_12,1311629,2211821,"int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}
int findLCM(int a, int b)
{
    return (a * b) / gcd(a, b);
}",1.0,1111111111
Recursion_13,1311629,2211821,"
int counting(char* t, char* tE, int x, int res) {
    if (t > tE) {
        res += x;
        return res;
    }
    if (*t == '(') x++;
    else {
        if (x > 0) x--;
        else res++;
    }
    return counting(t + 1, tE, x, res);
}

int mininumBracketAdd(string s) {
    if (s.empty()) return 0;
    int n = s.length();
    int res = 0;
    return counting(&s[0], &s[n - 1], 0, res);
}",1.0,1111111111
Recursion_14,1311629,2211821,"int Sum(vector<int>& sum, vector<int>& nums, int idx){
    if (idx == 0) return sum[0] = nums[0]; 
    else return sum[idx] = Sum(sum, nums, idx-1) + nums[idx];
}

int CountLeft(const vector<int>& sum, int left, int right){
    if (left == right) return 0;
    else {

        if (left == -1) {
            if (sum[right] % 2 == 1) return CountLeft(sum, left+1, right) + 1; 
            else return CountLeft(sum, left+1, right); 
        }

        else {
            if ((sum[right] - sum[left]) % 2 == 1) {
                return CountLeft(sum, left+1, right) + 1;
            }
            else return CountLeft(sum, left+1, right);
        }
    }
    return 0; 
}


int CountRight(const vector<int>& sum, int right){
    if (right >= 0) {
        return CountLeft(sum, -1, right) + CountRight(sum, right-1);
    }
    else return 0;
}

int oddSumSublist(vector<int>& nums, int m){
    int n = nums.size() - 1; 
    if (n<0) return 0;
    vector<int> sum(n+1); 
    Sum(sum, nums, n); 
    int x = CountRight(sum, n); 
    x %= m; 
    return x;
}",0.9,1111111110
Recursion_15,1311629,2211821,"string reverseSentence(string s) {
    size_t spacePos = s.find(' ');
    if (spacePos == string::npos) {
        return s; 
    }
    else {
        return reverseSentence(s.substr(spacePos + 1)) + "" "" +s.substr(0, spacePos);
    }
}",1.0,1111111111
Recursion_17,1311629,2211821,"string findLargestSubsequence(string str1, string str2) {
    int len1 = str1.length();
    int len2 = str2.length();

    // Base case: Nếu một trong hai chuỗi là rỗng, trả về chuỗi rỗng
    if (len1 == 0 || len2 == 0) {
        return """";
    }

    // Nếu ký tự cuối cùng của cả hai chuỗi giống nhau
    if (str1[len1 - 1] == str2[len2 - 1]) {
        // Gọp ký tự cuối cùng vào subsequence và tiếp tục đệ quy với hai chuỗi bỏ ký tự cuối
        return findLargestSubsequence(str1.substr(0, len1 - 1), str2.substr(0, len2 - 1)) + str1[len1 - 1];
    }
    else {
        // Nếu ký tự cuối của cả hai chuỗi không giống nhau, so sánh hai trường hợp:
        // 1. Xóa ký tự cuối của str1 và tìm subsequence chung
        // 2. Xóa ký tự cuối của str2 và tìm subsequence chung
        string subsequence1 = findLargestSubsequence(str1.substr(0, len1 - 1), str2);
        string subsequence2 = findLargestSubsequence(str1, str2.substr(0, len2 - 1));

        // Trả về subsequence có độ dài lớn hơn giữa hai trường hợp trên
        if (subsequence1.length() > subsequence2.length()) {
            return subsequence1;
        }
        else {
            return subsequence2;
        }
    }
}



int superString(string x, string y, int m, int n) {
    string k = findLargestSubsequence(x,y);
    int f= k.length();
    return m+n-f;
}",1.0,1111111111
Recursion_18,1311629,2211821,"int strLen(char* str)     
{ 
    if (*str == '\0') return 0;
    return 1+strLen(str+1);
} ",1.0,1111111111
Recursion_19,1311629,2211821,"int sizechar(char* t) {
    if (*t == '\0') return 0;
    else return 1 + sizechar(t + 1);
}
bool containsPattern(char* text, char* pattern) {
    int len1 = sizechar(text);
    int len2 = sizechar(pattern);
    if (len2 > len1) return 0;
    else {
        if (*pattern == ' ') {
            if (*text == ' ')
                return containsPattern(text + 1, pattern + 1);
            else return 0;
        }

        if (*pattern == '\0') {
            return true;
        }

        if (*text == '\0') {
            return false;
        }      
        if (*text == *pattern) {
            return containsPattern(text + 1, pattern + 1);
        }
        else {
            return containsPattern(text + 1, pattern);
        }
    }
}",0.8,1110111001
Recursion_20,1311629,2211821,"int countWays(int x,int var){
    if (x ==0 ) return 1;
    if (x<0|| var ==0) return 0;
    int count1 = countWays(x - pow(var,2),var-1);
    int count2 = countWays(x,var-1);
    return count1 + count2;
}



int countWaySumOfSquare(int x)
{
    return countWays(x,sqrt(x));
}",1.0,1111111111
Recursion_9,1325317,2212282,"void printHailstone(int number)
{
    if(number == 1) {
        cout << 1;
        return;
    }
    else cout << number << "" "";
    
    if(number % 2 == 0) printHailstone(number / 2);
    else                printHailstone(number * 3 + 1);
}",1.0,1111111111
Recursion_2,1331860,2213250,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if(n==0){
     cout<<""0"";
     return;
     }
    printArray(n-1);
     cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1331860,2213250,"    void printPattern(int n) 
    {   
        /*  
         * STUDENT ANSWER
         */
         if(n <= 0) cout << n;
         else{
             cout <<n <<"" "";
         printPattern(n-5);
         cout <<"" ""<< n;
         }
    }",1.0,1111111111
Recursion_4,1331860,2213250,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
     if(length==1) return *arr;
     if(arr[0]>arr[length-1]){
         return findMax(arr, length-1);
     }
     else{
         return findMax(arr+1, length-1);
     }
}",1.0,1111111111
Recursion_5,1331860,2213250,"bool isPalindrome(string str) 
{ 
    int n= str.length();
    if(str.length()<=1) return 1;
    if(str[0] == ' ') return (isPalindrome(str.substr(1, n-1)));
    if(str[n-1] == ' ') return (isPalindrome(str.substr(0, n-1)));
    if(str[0]==str[n-1]) return (isPalindrome(str.substr(1, n-2)));
    else return 0;
}",1.0,1111111111
Recursion_13,1332548,2212282,"int countOpeningBrackets(const std::string& s, size_t index = 0, int count = 0) {
    if (index >= s.size()) {
        return count;
    }
    if (s[index] == '(') {
        return countOpeningBrackets(s, index + 1, count + 1);
    } else if (s[index] == ')') {
        if (count > 0) {
            return countOpeningBrackets(s, index + 1, count - 1);
        } else {
            return 1 + countOpeningBrackets(s, index + 1, count);
        }
    } else {
        return countOpeningBrackets(s, index + 1, count);
    }
}

int mininumBracketAdd(string s) {
    return countOpeningBrackets(s);
}",1.0,1111111111
Recursion_15,1332548,2212282,"size_t i = 0;
string temp   = """";
string output = """";

string reverseSentence(string s) {
    if(i == s.length()) {
        string tmp = """";
        tmp += temp;
        tmp += output;
        return tmp;
    }
    
    if(s[i] == ' ') {
        string tmp = """";
        tmp += "" "";
        tmp += temp;
        tmp += output;
        output = tmp;
        temp = """";
    }
    
    else temp += s[i];
    
    i++;
    
    return reverseSentence(s);
}",0.95,1111111110
Recursion_18,1332548,2212282,"int strLen(char* str)     
{ 
    if(*str != '\0') return strLen(str+1) + 1;
    else return 0;
} ",1.0,1111111111
Recursion_2,1332828,2213248,"void printArray(int n)
{
    if(n == 0) cout << 0;
    else {
        printArray(n - 1);
        cout << "", "" << n;
    }
}",1.0,1111111111
Recursion_3,1332828,2213248,"void printPattern(int n) 
{ 
    if(n <= 0) cout << n;
    else {
        cout << n << "" "";
        printPattern(n - 5);
        cout << "" "" << n;
    }
}",1.0,1111111111
Recursion_4,1332828,2213248,"int findMax(int* arr, int length)
{
    if(length == 1) return arr[0];
    else {
        int temp = findMax(arr + 1, length - 1);
        if(arr[0] > temp) return arr[0];
        else return temp;
    }
}",1.0,1111111111
Recursion_5,1332828,2213248,"bool isPalindrome(string str) 
{ 
    int len = str.size();
    if(len <= 1) return 1;
    else {
        if(str[0] == ' ') return isPalindrome(str.substr(1, len - 1));
        if(str[len - 1] == ' ') return isPalindrome(str.substr(0, len - 1));
        if(str[0] != str[len - 1]) return 0;
        else return isPalindrome(str.substr(1, len - 2));

    }
}",1.0,1111111111
Recursion_6,1332828,2213248,"int findGCD(int a, int b)
{
    if(a < b) return findGCD(b, a);
    if(b == 0) return a;
    else return findGCD(b, a % b);
}",1.0,1111111111
Recursion_2,1337403,2213250,"void printArray(int n,int k =0 )
{
    /*  
     * STUDENT ANSWER
     */
     if(n==0){
         cout<<k;
         return ;
     }
     else cout<<k<<"", "";
     printArray(n-1,k+1);
}",1.0,1111111111
Recursion_3,1337403,2213250,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
     static bool flag1 = true ;
     static bool flag2 = false;
     static int val = n ;
     if(flag2&&n==val){
         cout<<n;
         return;
     }
     cout<<n<<"" "";
     if(flag1&&n<=0){
         flag1 = false;
         flag2 = true ;
     }
     
     if(flag1==true) printPattern(n-5);
     else if (flag2==true) printPattern(n+5);
}",1.0,1111111111
Recursion_4,1337403,2213250,"int findMax(int* arr, int length , int ans = 0 , int k = 0 )
{
    /*  
     * STUDENT ANSWER
     */
    if(k==length) return ans ;
    if(arr[k]>ans) ans = arr[k];
    return findMax(arr,length,ans,k+1);
}",1.0,1111111111
Recursion_5,1337403,2213250,"
bool isPalindrome(string str) 
{ 
    if(str.size()==1 || str.size() == 0) return true;
    if(str[0]==str[str.size()-1]) return isPalindrome(str.substr(1,str.size()-2));
    if(str[0]==' ') return isPalindrome(str.substr(1,str.size()-1));
    if(str[str.size()-1]==' ') return isPalindrome(str.substr(0,str.size()-1));
    else return false;
}",1.0,1111111111
Recursion_6,1337403,2213250,"int findGCD(int a, int b)
{
    if(a<b) swap(a,b);
    if(a%b==0) return b;
    return findGCD(b,a%b);
}",1.0,1111111111
Recursion_7,1337403,2213250,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if(decimal_number==0) return 0;
     if(decimal_number%2==0) return 10*decimalToBinary(decimal_number/2);
     else return 10*decimalToBinary(decimal_number/2) + 1;
} ",1.0,1111111111
Recursion_8,1337403,2213250,"string nstr(string s, int num) { if (num <= 0) return """"; return s + nstr(s, num-1); } int findClose(string s, int br) { if (s[0]=='(') ++br; if (s[0]==')') --br; if (br==0) return 0; return findClose(s.substr(1), br) + 1; } string expand(string s) { if (s=="""") return """"; if (!(s[0]>='0'&&s[0]<='9')) { if (s[0] != ')') return s[0] + expand(s.substr(1)); return expand(s.substr(1)); } int pos = findClose(s.substr(2), 1); return nstr(expand(s.substr(2, pos)), s[0]-'0') + expand(s.substr(pos+2)); }",1.0,11111
Recursion_9,1337403,2213250,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     if(number==1){
         cout<<number;
         return ;
     }
     cout<<number<<"" "";
     if(number%2==0) return printHailstone(number/2);
     else return printHailstone(number*3+1) ;
}",1.0,1111111111
Recursion_10,1337403,2213250,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    if(n==0) return 0;
    else return (str[n-1]-48) + 10*myArrayToInt(str,n-1);
}",1.0,1111111111
Recursion_11,1337403,2213250,"int reverseFactorial(int n,int k=1) {
    // STUDENT ANSWER
    if(n==k) return k;
    if(n%k!=0) return -1;
    return reverseFactorial(n/k,k+1);
    
}",1.0,1111111111
Recursion_12,1337403,2213250,"int findGCD(int a, int b){
    if(a<b) swap(a,b);
    if(a%b==0) return b;
    else return findGCD(b,a%b);
}

int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_13,1337403,2213250,"string nstr(string s, int num) { if (num <= 0) return """"; return s + nstr(s, num-1); } int findClose(string s, int br) { if (s[0]=='(') ++br; if (s[0]==')') --br; if (br==0) return 0; return findClose(s.substr(1), br) + 1; } string expand(string s) { if (s=="""") return """"; if (!(s[0]>='0'&&s[0]<='9')) { if (s[0] != ')') return s[0] + expand(s.substr(1)); return expand(s.substr(1)); } int pos = findClose(s.substr(2), 1); return nstr(expand(s.substr(2, pos)), s[0]-'0') + expand(s.substr(pos+2)); }",1.0,
Recursion_14,1337403,2213250,"int iterRight(vector<int>& nums, int m,int r = 0 , int sum = 0) {
	//cout << sum << endl;
	if (r == (int)nums.size()) return sum%2;
	int add = (sum % 2 == 1) ? 1 : 0;
	return add + iterRight(nums, m, r + 1, sum + nums[r])%m;
}
int iterLeft(vector<int>& nums, int m, int l = 0) {
	if (l == (int)nums.size()) return 0;
	return iterRight(nums, m, l, 0)%m + iterLeft(nums, m, l + 1)%m;
}
int oddSumSublist(vector<int>& nums, int m) {
	// STUDENT ANSWER
	return iterLeft(nums, m);
}",0.9,1111111110
Recursion_15,1337403,2213250,"string reverseSentence(string s) {
	// STUDENT 
	int idx = s.find("" "");
	//cout << idx << endl;
	//cout << s.substr(idx + 1) << endl;
	if (idx != -1) return reverseSentence(s.substr(idx + 1))+"" "" + s.substr(0, idx);
	else return s;

}",1.0,1111111111
Recursion_17,1337403,2213250,"int longestSubSeq(string x , string y , int m , int n){
    if(m==0 || n==0) return 0;
    if(x[m-1]==y[n-1]) return 1 + longestSubSeq(x,y,m-1,n-1);
    else return max(longestSubSeq(x,y,m-1,n),longestSubSeq(x,y,m,n-1));
}

int superString(string x, string y, int m, int n) {
    return m+n-longestSubSeq(x,y,m,n);
}",1.0,1111111111
Recursion_18,1337403,2213250,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if(*str==0) return 0;
     else return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_19,1337403,2213250,"bool containsPattern(char* text, char* pattern) {
    static char** temp = &pattern;
	if (*pattern == 0) return true;
	if (*text == 0) return false;
	if (*text == *pattern) return containsPattern(text + 1, pattern + 1) || containsPattern(text + 1, *temp);
	else return containsPattern(text + 1, *temp);
}
",1.0,1111111111
Recursion_20,1337403,2213250,"int countWaySumOfSquare(int x , int k = 1 )
{
    /*  
     * STUDENT ANSWER
     */
        //cout << x << endl;
        if (x == 0) return 1;
        if (x < 0 || k*k>x) return 0;
        return countWaySumOfSquare(x - k * k, k + 1) + countWaySumOfSquare(x, k + 1);
}",1.0,1111111111
Recursion_2,1341365,2211821,"void printArray(int n)
{
     if (n > 0) {
        printArray(n - 1);
        if (n) {
            cout << "", "";
        }
    }
    cout << n;
}",1.0,1111111111
Recursion_3,1341365,2211821,"void printPattern(int n) 
{ 
     if (n <= 0) {
        cout << n;
        return;
    }

    cout << n << "" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1341365,2211821,"int findMax(int* arr, int length)
{
    if (length==1) return arr[0];
    else {
        int max = findMax(arr+1,length-1);
        if (arr[0]>max) return arr[0]; else return max;
    }
}",1.0,1111111111
Recursion_5,1341365,2211821,"string removeSpaces(string str, size_t index = 0) {
    if (index == str.length()) {
        return str;
    }

    if (str[index] == ' ' || str[index] == ',') {
        str = str.substr(0, index) + str.substr(index + 1);
    }
    return removeSpaces(str, index + 1);
}
bool isPalindrome(string str)
{
    string Strnotspaces = removeSpaces(str);
    int length = Strnotspaces.length();
    if (length <= 1) return true;
    else {
        char char1 = tolower(Strnotspaces[0]);
        char char2 = tolower(Strnotspaces[length - 1]);
        if (char1 != char2) return 0; else {
            string str1 = Strnotspaces.substr(1, length - 2);
            return isPalindrome(str1);
        }
    }
}",1.0,1111111111
Recursion_6,1341365,2211821,"int findGCD(int a, int b)
{
    if (b == 0) {
        return a; 
    }
    else {
        return findGCD(b, a % b);
    }
}",1.0,1111111111
Recursion_7,1341365,2211821,"int decimalToBinary(int decimal) {
    if (decimal == 0) {
        return 0; 
    }
    if (decimal == 1) {
        return 1; 
    }
    int interger = decimal / 2;
    int binary = decimalToBinary(interger);
    int remainder = decimal % 2;
    binary = binary*10 +remainder;
    return binary;
} ",1.0,1111111111
Recursion_8,1341365,2211821,"int indexlastopen( std::string s, int len) {
    if (len < 0) return -1;
    if (s[len] == '(') return len;
    return indexlastopen(s, len - 1);
}

int indexfirstclose(std::string s, int i) {
    int len = s.length();
    if (i == len) return -1;
    if (s[i] == ')') return i;
    return indexfirstclose(s, i + 1);
}

int indexofnumber( std::string s, int idx) {
    if (idx <= 0) return 0;
    if (isdigit(s[idx - 1])) {
        return 1 + indexofnumber(s, idx - 1);
    }
    return 0;
}

int numberloop( std::string s, int open, int x) {
    if (x == 0) return 0;
    return numberloop(s, open - 1, x - 1) * 10 + int(s[open - 1] - '0');
}

std::string afterloop(std::string s, int x) {
    if (x == 0) return """";
    return s + afterloop(s, x - 1);
}

std::string expand( std::string s) {
    int len = s.length() - 1;
    int open = indexlastopen(s, len);
    int close = indexfirstclose(s, open);
    if (open == -1)
        return s;
    int idx = indexofnumber(s, open);
    int x = numberloop(s, open, idx);
    std::string h = s.substr(open + 1, close - open - 1);
    std::string k = afterloop(h, x);
    std::string s1;
    if (close != len) {
        s1 = s.substr(0, open - idx) + k + s.substr(close + 1, len - close);
    }
    else {
        s1 = s.substr(0, open - idx) + k;
    }

    return expand(s1);
}",1.0,11111
Recursion_9,1341365,2211821,"void printHailstone(int number)
{
     cout << number;
    if (number == 1) {
        return;
    }
    else if (number % 2 == 0) {
        cout << "" "";
        printHailstone(number / 2);
    }
    else {
        cout << "" "";
        printHailstone(number * 3 + 1);
    }
}",1.0,1111111111
Recursion_10,1341365,2211821,"int myArrayToInt(char *str, int n) 
{ 
    if (n == 0) return 0;
    return 10 * myArrayToInt(str, n - 1) + (str[n - 1] - '0');
}",1.0,1111111111
Recursion_11,1341365,2211821,"int find(int n, int k) {
    if (n == 1) {
        return k-1;
    }

    if (n % k != 0) {
        return -1;
    }

    return find(n / k, k + 1);
}

int reverseFactorial(int n) {
    if (n == 1) {
        return 1;
    }
    return find(n, 2); 
    
}",1.0,1111111111
Recursion_12,1341365,2211821,"int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}
int findLCM(int a, int b)
{
    return (a * b) / gcd(a, b);
}",1.0,1111111111
Recursion_13,1341365,2211821,"int counting(char* t, char* tE, int x, int res) {
    if (t > tE) {
        res += x;
        return res;
    }
    if (*t == '(') x++;
    else {
        if (x > 0) x--;
        else res++;
    }
    return counting(t + 1, tE, x, res);
}

int mininumBracketAdd(string s) {
    if (s.empty()) return 0;
    int n = s.length();
    int res = 0;
    return counting(&s[0], &s[n - 1], 0, res);
}",1.0,1111111111
Recursion_14,1341365,2211821,"int Sum(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    return vec[start] + Sum(vec, start + 1, number - 1);
}
int countright(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    int sum = Sum(vec, start, number);
    if (sum % 2 == 1) return 1 + countright(vec, start + 1, number - 1); else return countright(vec, start + 1, number - 1);
}
int countleft(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    int sum = Sum(vec, start, number);
    if (sum % 2 == 1) return 1 + countright(vec, start + 1, number - 1) + countleft(vec, start, number - 1); else return countright(vec, start + 1, number - 1) + countleft(vec, start, number - 1);
}
int oddSumSublist(vector<int>& vec, int m) {
    int x = vec.size();
    int n = countleft(vec, 0, x) % m;
    return n;
}",0.7,11111110
Recursion_15,1341365,2211821,"string reverseSentence(string s) {
    size_t spacePos = s.find(' ');
    if (spacePos == string::npos) {
        return s; 
    }
    else {
        return reverseSentence(s.substr(spacePos + 1)) + "" "" +s.substr(0, spacePos);
    }
}",1.0,1111111111
Recursion_17,1341365,2211821,"string findLargestSubsequence(string str1, string str2) {
    int len1 = str1.length();
    int len2 = str2.length();

    // Base case: Nếu một trong hai chuỗi là rỗng, trả về chuỗi rỗng
    if (len1 == 0 || len2 == 0) {
        return """";
    }

    // Nếu ký tự cuối cùng của cả hai chuỗi giống nhau
    if (str1[len1 - 1] == str2[len2 - 1]) {
        // Gọp ký tự cuối cùng vào subsequence và tiếp tục đệ quy với hai chuỗi bỏ ký tự cuối
        return findLargestSubsequence(str1.substr(0, len1 - 1), str2.substr(0, len2 - 1)) + str1[len1 - 1];
    }
    else {
        // Nếu ký tự cuối của cả hai chuỗi không giống nhau, so sánh hai trường hợp:
        // 1. Xóa ký tự cuối của str1 và tìm subsequence chung
        // 2. Xóa ký tự cuối của str2 và tìm subsequence chung
        string subsequence1 = findLargestSubsequence(str1.substr(0, len1 - 1), str2);
        string subsequence2 = findLargestSubsequence(str1, str2.substr(0, len2 - 1));

        // Trả về subsequence có độ dài lớn hơn giữa hai trường hợp trên
        if (subsequence1.length() > subsequence2.length()) {
            return subsequence1;
        }
        else {
            return subsequence2;
        }
    }
}



int superString(string x, string y, int m, int n) {
    string k = findLargestSubsequence(x,y);
    int f= k.length();
    return m+n-f;
}",1.0,1111111111
Recursion_18,1341365,2211821,"int strLen(char* str)     
{ 
    if (*str == '\0') return 0;
    return 1+strLen(str+1);
} ",1.0,1111111111
Recursion_19,1341365,2211821,"bool match(char* text,char* pattern){
    if(*pattern =='\0') return 1;
    if(*text == '\0') return 0;
    if(*text == *pattern) return match(text+1,pattern+1);
    else return 0;
}
bool containsPattern(char* text, char* pattern)
{
    if(*text == '\0') return 0;
    if (match(text,pattern)) return 1;
    else return containsPattern(text+1,pattern);
}",1.0,1111111111
Recursion_20,1341365,2211821,"int countWays(int x,int var){
    if (x ==0 ) return 1;
    if (x<0|| var ==0) return 0;
    int count1 = countWays(x - pow(var,2),var-1);
    int count2 = countWays(x,var-1);
    return count1 + count2;
}



int countWaySumOfSquare(int x)
{
    return countWays(x,sqrt(x));
}",1.0,1111111111
Recursion_8,1346327,2212282,"int find(const string & s, int index = 0) {
    if(index == static_cast<int>(s.length())) return -1;
    if(s[index] == ')') return index;
    return find(s, index+1);
}

string decode_string(const string & s, int & index) {
    index--;
    if(s[index] == '(') return """";
    return decode_string(s, index) + s[index];
}

int decode_num(const string & s, int & index) {
    index--;
    if(index == -1 || (s[index] >= 'a' && s[index] <= 'z') || s[index] == '(') return 0;
    int num = s[index] - '0';
    return decode_num(s, index) * 10 + num;
}

string decode(const string & d_str, int num) {
    if(num == 0) return """";
    return decode(d_str, num-1) + d_str;
}

string helper(const string & s) {
    int rightb = find(s);
    if(rightb == -1) return s;
    int cur = rightb;
    string heh = decode_string(s, cur);
    int hi = decode_num(s, cur);
   
   //cout << (s.substr(0, cur+1) + decode(heh, hi) + s.substr(rightb+1, s.length()-1-rightb)) << endl;
   
    return helper(s.substr(0, cur+1) + decode(heh, hi) + s.substr(rightb+1, s.length()-1-rightb));
}

string expand(string s) {
    return helper(s);
}",1.0,11111
Recursion_2,1349918, ,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if (n > 0){
         printArray(n-1);
         cout << "", "";
     }
     cout << n;
}",1.0,1111111111
Recursion_3,1349918, ,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if (n <= 0){
         cout << n;
         return;
     }
     cout << n << "" "";
     printPattern(n - 5);
     cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1349918, ,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
     if (length == 1) return arr[0];
     
     return max(arr[length-1],findMax(arr, length-1));
}",1.0,1111111111
Recursion_5,1349918, ,"bool isPalindrome(string str) 
{ 
    int n = str.length();
    if (n == 1 || n == 0) return 1;
    if (str[0] == ' ' && str[n-1] != ' '){
            return isPalindrome(str.substr(1));
        }
    if (str[n-1] == ' ' && str[0] != ' '){
            return isPalindrome(str.substr(0, n-1));
        }
    if (str[0] == str[n-1]) return isPalindrome(str.substr(1, n-2));
    return 0;
    
}",1.0,1111111111
Recursion_6,1349918, ,"int findGCD(int a, int b)
{
     if (b != 0)  return findGCD(b, a%b);
     return a;
}",1.0,1111111111
Recursion_7,1349918, ,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if (decimal_number == 0) return 0;
     return decimal_number % 2 + 10 * decimalToBinary(decimal_number/2);
} ",1.0,1111111111
Recursion_9,1349918, ,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     if (number == 1) {
         cout << number;
         return;
     }
     cout << number << "" "";
     if ((number%2) == 0){
         printHailstone(number/2);
     }
     else printHailstone(number*3 + 1);
     
}",1.0,1111111111
Recursion_10,1349918, ,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if (n == 1) return str[0] - '0';
     return (str[n-1] - '0') + 10 * myArrayToInt(str, n-1);
    
}",1.0,1111111111
Recursion_12,1349918, ,"int findLCM(int a, int b)
{
    if (max(a,b)% min(a,b) == 0) return max(a,b);
    return findLCM(max(a,b), min(a,b));
}",0.1,0
Recursion_2,1349965,2211878,"void printArray(int n)
{   
    if (n == 0) {
        cout<<0;
        return;
    }
    if (n > 0) {
        printArray(n - 1);
    }
    cout<<"", ""<< n;
    
}",1.0,1111111111
Recursion_3,1349965,2211878,"void printPattern(int n) {
    if (n == 0 || n < 0) {
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1349965,2211878,"int findMax(int* arr, int length) {
    if (length == 1) {
        return arr[0];
    } else {
        int max = findMax(arr, length - 1);
        return (arr[length - 1] > max) ? arr[length - 1] : max;
    }
}
",1.0,1111111111
Recursion_5,1349965,2211878,"bool isPalindrome(string str) {

    str.erase(remove(str.begin(), str.end(), ' '), str.end());
    
    if (str.length() < 2) {
        return true;
    }
    
    if (str[0] != str[str.length() - 1]) {
        return false;
    }
    
    return isPalindrome(str.substr(1, str.length() - 2));
}
",1.0,1111111111
Recursion_6,1349965,2211878,"int findGCD(int a, int b)
{
    if(b > a) return findGCD(b,a);
    if(b == 0) return a;
    return findGCD(b,a%b);
}",1.0,1111111111
Recursion_7,1349965,2211878,"int decimalToBinary(int decimal_number) {
    if (decimal_number == 0 || decimal_number == 1) {
        return decimal_number;
    } else {
        return decimalToBinary(decimal_number / 2) * 10 + decimal_number % 2;
    }
}",1.0,1111111111
Recursion_9,1349965,2211878,"void printHailstone(int number)
{
    cout << number;
    if (number == 1) {
        return;
    } else if (number % 2 == 0) {
        cout << "" "";
        printHailstone(number / 2);
    } else {
        cout <<"" "";
        printHailstone(number*3 + 1);
    }
}",1.0,1111111111
Recursion_10,1349965,2211878,"int myArrayToInt(char *str, int n) 
{ 
    if (n == 1) {
        return str[0] - '0';
    } else {
        return (myArrayToInt(str, n - 1) * 10) + (str[n - 1] - '0');
    }
}",1.0,1111111111
Recursion_11,1349965,2211878,"int inverse_factorial_helper(int factorial, int current) {
    if (factorial == 1) {
        return current;
    } else if (factorial % current) {
        return -1; // not divisible
    } else {
        return inverse_factorial_helper(factorial / current, current + 1);
    }
}

int reverseFactorial(int factorial) {
    if(factorial == 1) return 1;
    int x = inverse_factorial_helper(factorial, 1)-1;
    if(x < 0) return -1;
    return x;
}
",1.0,1111111111
Recursion_12,1349965,2211878,"int findGCD(int a, int b) {
    if(a < b) return findGCD(b,a);
    if (b == 0) {
        return a;
    } else {
        return findGCD(b, a % b);
    }
}

int findLCM(int a, int b) {
    int gcd = findGCD(a, b);
    return (a * b) / gcd;
}
",1.0,1111111111
Recursion_13,1349965,2211878,"int mininumBracketAdd(string s) {
    if (s.empty()) {
        return 0;
    } else if (s.length() == 1) {
        return 1;
    } else if (s[0] == '(' && s[s.length() - 1] == ')') {
        return mininumBracketAdd(s.substr(1, s.length() - 2));
    } else {
        return mininumBracketAdd(s.substr(0, s.length() - 1)) + mininumBracketAdd(s.substr(1, s.length() - 1));
    }
}",0.1,00100
Recursion_15,1349965,2211878,"string reverseSubstring(string s, int index) {
    if (index < 0 || s[index-1] == ' ') {
        return """";
    }

    unsigned int lastSpaceIndex = s.rfind(' ', index-1);

    string substring = s.substr(lastSpaceIndex + 1, index - lastSpaceIndex - 1);
    if (lastSpaceIndex != string::npos && lastSpaceIndex > 0) {
        substring = substring;
    }
    
    return substring +"" ""+ reverseSubstring(s, lastSpaceIndex);
}

string reverseSentence(string s) {
    int index = s.size();
    return reverseSubstring(s, index);
}",1.0,1111111111
Recursion_17,1349965,2211878,"int superString(string x, string y, int m, int n) {
    if (m == 0) {
        return n;
    }
    if (n == 0) {
        return m;
    }
    if (x[m - 1] == y[n - 1]) {
        return 1 + superString(x, y, m - 1, n - 1);
    } else {
        return 1 + min(superString(x, y, m - 1, n), superString(x, y, m, n - 1));
    }
}",1.0,1111111111
Recursion_18,1349965,2211878,"int strLen(char* str) {
    if (*str == '\0') {
        return 0;
    } else {
        return 1 + strLen(str + 1);
    }
}",1.0,1111111111
Recursion_19,1349965,2211878,"bool containsPattern(const char* text, const char* pattern) {
    if (text == nullptr || pattern == nullptr) return false;
    
    if (*pattern == '\0') return true;
    
    if (*text == '\0') return false;
    
    if (*text == *pattern) {
        return containsPattern(text + 1, pattern + 1);
    } else {
        return containsPattern(text + 1, pattern);
    }
}
",0.8,1111111001
Recursion_20,1349965,2211878,"int countWaySumOfSquare(int x, int i) {
    // Base cases
    if (x == 0) {
        return 1;
    } else if (x < 0) {
        return 0;
    } else if (i <= 0) {
        return 0;
    }
    
    // Recursively count the number of ways
    int count = countWaySumOfSquare(x - i*i, i - 1) + countWaySumOfSquare(x, i - 1);
    
    return count;
}

int countWaySumOfSquare(int x) {
    return countWaySumOfSquare(x, sqrt(x));
}
",1.0,1111111111
Recursion_2,1353511,2210578,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */if(n < 0) return;
    printArray(n-1);
    if(n==0) cout<<n;
    else cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1353511,2210578,"void printPattern(int n, bool max = 1) 
{ 
   if(n>0){
       if(max) cout<<n;
       else cout<<"" ""<<n;
       printPattern(n-5, 0);
   }
   cout <<"" ""<<n;
}",1.0,1111111111
Recursion_4,1353511,2210578,"int findMax(int* arr, int length,int max = -99999)
{
    if (length==0) return max;
    if(max<*arr) max=*arr;
    return findMax(++arr,--length,max);
}",1.0,1111111111
Recursion_5,1353511,2210578,"string removeSpaces(string input)
{
    if (input.empty())
    {
        return """";
    }
    else
    {
        char firstChar = input[0];
        string restOfString = input.substr(1);

        if (firstChar == ' ')
        {
            return removeSpaces(restOfString);
        }
        else
        {
            return firstChar + removeSpaces(restOfString);
        }
    }
}
bool isPalindrome(string str) 
{   str=removeSpaces(str);
    if(str.length()<=1) return true;
    if(str[0]!=str[str.length()-1]) return false;
    return isPalindrome(str.substr(1,str.length()-2));
}",1.0,1111111111
Recursion_6,1353511,2210578,"int findGCD(int a, int b)
{
    if(b==0) return a;
    if(a%b==0) return b;
    return findGCD(b,a%b);
}",1.0,1111111111
Recursion_9,1353511,2210578,"void printHailstone(int number,bool first=1)
{
    /*  
     * STUDENT ANSWER
     */
     if(first)cout <<number;
     else cout<<"" ""<<number;
     if(number==1) return;
     if(number%2==1){printHailstone(number*3+1,0);}
     else printHailstone(number/2,0);
}",1.0,1111111111
Recursion_10,1353511,2210578,"int myArrayToInt(char *str, int n, int m = 0) 
{ 
    if(n==0) return m;
    int k=*str-48;
    m=m*10+k;
    return myArrayToInt(++str,--n,m);
}",1.0,1111111111
Recursion_11,1353511,2210578,"int giaithua(int n){
    if(n==1) return 1;
    if(n==2) return 2;
    return n*giaithua(n-1);
}
int reverseFactorial(int n, int m=1) {
    if(giaithua(m)>n) return -1;
    if(n==giaithua(m)) return m;
    else return reverseFactorial(n,++m);
    
    
}",1.0,1111111111
Recursion_12,1353511,2210578,"int findGCD(int a, int b)
{
    if(b==0) return a;
    if(a%b==0) return b;
    return findGCD(b,a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_18,1353511,2210578,"int strLen(char* str, int length=0)     
{ 
    if(*str != '\0') return  strLen(++str,++length);
    else return length;
} ",1.0,1111111111
Recursion_19,1353511,2210578,"bool compare(char* text, char* pattern) {
    if (*pattern == '\0') return true;
    if (*text != *pattern) return false;
    return compare(text + 1, pattern + 1);
}

bool containsPattern(char* text, char* pattern) {
    if (*text == '\0') return false;
    if (*text == *pattern && compare(text, pattern)) return true;
    return containsPattern(text + 1, pattern);
}
",1.0,1111111111
Recursion_2,1353741,2211170,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */ 
     if (n > 0) {
        printArray(n - 1);
        cout << "", "";
    }
    
    cout << n;
}",1.0,1111111111
Recursion_6,1353741,2211170,"int findGCD(int a, int b)
{
    if (a == b)
        return a;
    
    if (a > b)
        return findGCD(a - b, b);
    else
        return findGCD(a, b - a);
}",1.0,1111111111
Recursion_7,1353741,2211170,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
         if (decimal_number == 0) {
        return 0;  // Base case: decimal_number is 0, its binary representation is also 0
    }

    int remainder = decimal_number % 2;
    int binary_digits = decimalToBinary(decimal_number / 2);

    return binary_digits * 10 + remainder;
} ",1.0,1111111111
Recursion_9,1353741,2211170,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if (number == 1){
        cout << number;
        return;
    }
        
    else if (number % 2 == 0){
        cout << number << "" "";
        printHailstone(number / 2);
    }
    else {
        cout << number << "" "";
        printHailstone(number * 3 + 1);
    }
}",1.0,1111111111
Recursion_10,1353741,2211170,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */  if (n == 0) {
        return 0;
    }
    
    int lastDigit = str[n - 1] - '0';
    int remainingNumber = myArrayToInt(str, n - 1);
    
    return remainingNumber * 10 + lastDigit;
}",1.0,1111111111
Recursion_12,1353741,2211170,"int findGCD(int a, int b) {
    if (b == 0) {
        return a;
    }
    
    return findGCD(b, a % b);
}

int findLCM(int a, int b) {
    int gcd = findGCD(a, b);
    
    return (a * b) / gcd;
}",1.0,1111111111
Recursion_15,1353741,2211170,"string reverseWord(string& s, int start, int end) {
    if (start >= end) {
        return s;
    }
    
    char temp = s[start];
    s[start] = s[end];
    s[end] = temp;
    
    return reverseWord(s, start + 1, end - 1);
}

string reverseSentenceHelper(string s, int start, size_t end) {
    if (end >= s.length()) {
        reverseWord(s, start, end - 1);
        return s;
    }
    
    if (s[end] == ' ') {
        reverseWord(s, start, end - 1);
        return reverseSentenceHelper(s, end + 1, end + 1);
    }
    
    return reverseSentenceHelper(s, start, end + 1);
}

string reverseSentence(string s) {
    int start = 0;
    size_t end = 0;
    
    return reverseSentenceHelper(s, start, end);
}",0.1,0010000000
Recursion_17,1353741,2211170,"int superString(const string& x, const string& y, int m, int n) {
    // Base cases
    if (m == 0) return n;
    if (n == 0) return m;

    // If the last characters of x and y are the same, ignore them and recursively find the super string
    if (x[m - 1] == y[n - 1])
        return 1 + superString(x, y, m - 1, n - 1);

    // If the last characters of x and y are different, consider both possibilities:
    // 1. Ignore the last character of x and find the super string of the remaining x and y
    // 2. Ignore the last character of y and find the super string of x and the remaining y
    return 1 + min(superString(x, y, m - 1, n), superString(x, y, m, n - 1));
}",1.0,1111111111
Recursion_18,1353741,2211170,"int strLen(char* str) {
    // Base case: If the current character is null ('\0'), return 0
    if (*str == '\0')
        return 0;
    else
        // Recursive case: Add 1 to the length of the remaining string
        return 1 + strLen(str + 1);
}",1.0,1111111111
Recursion_19,1353741,2211170,"bool matchPattern(char* text, char* pattern) {
    // Base cases
    if (*pattern == '\0')
        return true; 
    if (*text == '\0')
        return false; 
    
    if (*text == *pattern)
        return matchPattern(text + 1, pattern + 1);

    // If the current characters don't match, advance the text and try again
    return matchPattern(text + 1, pattern);
}

bool containsPattern(char* text, char* pattern) {
    // Base case: If the pattern is empty, it's considered a match
    if (*pattern == '\0')
        return true;

    // Recursive case: Checkpattern match starting from each character in the text
    if (matchPattern(text, pattern))
        return true;

    // If pattern match not found, advance the text and try again
    return containsPattern(text + 1, pattern);
}",0.5,1001101001
Recursion_2,1354238,2211738,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    if(n == 0){
        cout << n;
        return;
    }
    printArray(n-1);
    cout << "", "" << n;
}",1.0,1111111111
Recursion_3,1354238,2211738,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n <= 0){
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n-5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1354238,2211738,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if(length == 1) return arr[0];
    return max(arr[0], findMax(arr+1, length-1));
}",1.0,1111111111
Recursion_6,1354238,2211738,"int findGCD(int a, int b)
{
    if(b == 0) return -1;
    return (a%b==0)?b: findGCD(b,a%b);
}",1.0,1111111111
Recursion_9,1354238,2211738,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if(number == 1) {
        cout << 1;
        return;
    }
    cout << number << "" "";
    if(number % 2 == 0) printHailstone(number/2);
    else printHailstone(3*number + 1);
}",1.0,1111111111
Recursion_10,1354238,2211738,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    if(n == 1) return str[0]-'0';
    return (str[0]-'0')*pow(10,n-1) + myArrayToInt(str+1,n-1);
}",1.0,1111111111
Recursion_12,1354238,2211738,"int findGCD(int a, int b){
    if(b == 0) return -1;
    return (a%b == 0) ? b : findGCD(b, a%b);
}

int findLCM(int a, int b)
{
    if(a == 0 || b == 0) return -1;
    return (a*b)/findGCD(a,b);
}",1.0,1111111111
Recursion_15,1354238,2211738,"string reverseSentence(string s) {
    // STUDENT ANSWER
    string temp;
    if(s.size() == 0) return temp;
    int index = s.rfind(' ', s.size()-1);
    if(index != -1){
        temp = s.substr(index+1);
    }else{
        temp = s.substr(0);
        return temp;
    }
    return temp + ' ' +reverseSentence(s.substr(0, s.size()-temp.size()-1));
}",1.0,1111111111
Recursion_18,1354238,2211738,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if(str[0] == '\0') return 0;
    return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_2,1355593,2210055,"void printNumber(int n)
{
  if (n > 0)
  {
    printNumber(n - 1);
    if (n > 1)
    {
      cout << "", "";
    }
    cout << n - 1;
  }
}

void printArray(int n)
{
  printNumber(n+1);
 
}",1.0,1111111111
Recursion_3,1355593,2210055,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
      if (n <= 0) {
        cout << n;
        return;
    }
    cout << n<<"" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1355593,2210055,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
     if (length == 1)
    return arr[0];
  return max(arr[length - 1], findMax(arr, length - 1));
}",1.0,1111111111
Recursion_5,1355593,2210055,"
bool isPalindrome(const std::string& str, int start, int end) {
    if (start >= end) {
        return true;  // Base case: The string is a palindrome
    }
    
    // Check if the characters at the start and end positions match
    if (str[start] == str[end]) {
        // Recursively check the remaining substring
        return isPalindrome(str, start + 1, end - 1);
    }
    
    return false;  // If characters don't match, it's not a palindrome
}

bool isPalindrome(const std::string& str) {
    int len = str.length();
    return isPalindrome(str, 0, len - 1);
}",0.8,1011111110
Recursion_6,1355593,2210055,"int findGCD(int a, int b)
{
    if (b == 0)
    return a;
  return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1355593,2210055,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
      if (decimal_number == 0)
    return 0;
  else
    return (decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2));
} ",1.0,1111111111
Recursion_9,1355593,2210055,"void printHailstone(int number)
{
  /*
   * STUDENT ANSWER
   */
  if (number == 1)
  {
    cout << number;
    return;
  }
  if (number % 2 == 0)
  {
    cout << number << "" "";
    printHailstone(number / 2);
  }
  else
  {
    cout << number << "" "";
    printHailstone(number * 3 + 1);
  }

  return;
}",1.0,1111111111
Recursion_10,1355593,2210055,"int myArrayToIntRecursive(char* str, int n) {
    if (n == 1) {
        return str[0] - '0';
    }
    return myArrayToIntRecursive(str, n - 1) * 10 + (str[n - 1] - '0');
}

int myArrayToInt(char* str, int n) {
    if (n <= 0) {
        return 0; 
    }
    return myArrayToIntRecursive(str, n);
}",1.0,1111111111
Recursion_11,1355593,2210055,"int reverseFactorial(int n, int k = 2) {
    if (n == 1) {
        return 1;
    }
    
    if (n % k == 0) {
        if (n / k == 1) {
            return k;
        }
        return reverseFactorial(n / k, k + 1);
    }
    
    return -1;
}",1.0,1111111111
Recursion_12,1355593,2210055,"int findLCM(int a, int b) {
    static int multiple = 0; 

    multiple += b; 
    if (multiple % a == 0 && multiple % b == 0) {
        return multiple;
    } else {
    
        return findLCM(a, b);
    }
}",1.0,1111111111
Recursion_2,1355904,2213298,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    if (n < 0) return;
    printArray(n-1);
    if (n != 0) cout << "", "";
    cout << n;
}",1.0,1111111111
Recursion_3,1355904,2213298,"int m;

void add (int n) {
    if (n == ::m) {
        cout << n;
        return;
    }
    cout << n << "" "";
    add(n + 5);
}

void sub (int n) {
    if (n <= 0) add(n);
    else {
        cout << n << "" "";
        sub(n - 5);
    }
}

void printPattern(int n) {
    ::m = n;
    sub(n);
}",1.0,1111111111
Recursion_4,1355904,2213298,"int findMax(int *arr, int length) {
	if (!(length-1)) return arr[0];
	int max = findMax(arr, length-1);
	if (arr[length-1] < max) return max;
	return arr[length-1];
}",1.0,1111111111
Recursion_5,1355904,2213298,"string deletespace(string str) {
    if (str.find("" "") > 0 && str.find("" "") < str.length()) {
        return deletespace(str.erase(str.find("" ""), 1));
    }
    return str;
}

bool isPalindrome (string str) {
    str = deletespace(str);
    if (str.length() == 0 || str.length() == 1) return 1;
    if (str[0] != str[str.length()-1]) return 0;
    return isPalindrome(str.substr(1,str.length()-2));
}
",1.0,1111111111
Recursion_6,1355904,2213298,"int findGCD(int a, int b)
{
    if (a == b) return a;
    if (a > b) return findGCD(a-b, b);
    return findGCD(a, b-a);
}",1.0,1111111111
Recursion_7,1355904,2213298,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if (decimal_number == 0) return 0;
    return (decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2));
} ",1.0,1111111111
Recursion_8,1355904,2213298,"string loop (string s, int k) {
     if (!k) return """";
     else return s + loop(s, k - 1);
}

int findbegin(string s, int f, int run) {
    if (s[run] == ')') return f;
    if (s[run] == '(') return findbegin(s, run, run + 1);
    else return findbegin(s, f, run + 1);
}

int findend(string s, int found) {
    if (s[found] == ')') return found;
    else return findend(s, found+1);
}

int number(string s, unsigned int run) {
    if (run > s.length()) return -1;
    if (s[run] >= 48 && s[run] <= 58) return run;
    else return number(s, run+1);
}

string solve(string s, int start) {
    if (s[start] >= 48 && s[start] <= 58) {
        int begin = findbegin(s, 0, 0);
        int end = findend(s, begin);
        string temp = loop(s.substr(begin + 1, end - begin - 1), s[begin-1] - '0');
        return solve(s.replace(begin - 1, end - begin + 2, temp), start);
    }
    int out = number(s, 0);
    if (out == -1) return s;
    else return solve(s, out);
}

string expand(string s) {
    return solve(s, 0);
}",1.0,11111
Recursion_9,1355904,2213298,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if (number <= 0) return;
    cout << number;
    if (number == 1) return;
    cout << "" "";
    if (number&1) printHailstone(number*3 + 1);
    else printHailstone(number/2);
}",1.0,1111111111
Recursion_10,1355904,2213298,"int myArrayToInt(char *str, int n) {
    if ( n == 1 ) return str[0] - '0';
    int x = myArrayToInt(str+1,n-1);
    int y = str[0] - '0';
    y = y * pow(10, n - 1) + x;
    return y;
}",1.0,1111111111
Recursion_11,1355904,2213298,"int fac(int k) {
    if (k == 1) return 1;
    return k * fac(k-1);
}

int solve(int n, int k) {
    int temp = fac(k);
    if (temp > n) return -1;
    if (temp == n) return k;
    return solve(n, k+1);
}

int reverseFactorial(int n) {
    return solve(n , 1);
}",1.0,1111111111
Recursion_12,1355904,2213298,"int findGCD(int a, int b) {
    if (a == b) return a;
    if (a > b) return findGCD(a-b, b);
    return findGCD(a, b-a);
}

int findLCM(int a, int b)
{
    int GCD = findGCD(a, b);
    return a*b/GCD;
}",1.0,1111111111
Recursion_13,1355904,2213298,"int solver(string s,unsigned int index, int balance){
    if (index == s.size()) return abs(balance);
    if (s[index] == '(') {
        return solver(s, index + 1, balance + 1);
    }
    else {
        if (balance > 0) return solver(s, index + 1, balance - 1);
        else return 1 + solver(s, index + 1, balance);
    }
}

int mininumBracketAdd(string s) {
    return solver(s, 0, 0);
}",0.9,1111111110
Recursion_14,1355904,2213298,"int oddSumSublistHelper(vector<int>& nums, unsigned int i, int sum, int m) {
    if (i == nums.size()) return sum % 2;
    return (oddSumSublistHelper(nums, i + 1, sum + nums[i], m) % m + oddSumSublistHelper(nums, i + 1, sum, m) % m) % m;
}

int oddSumSublist(vector<int>& nums, int m) {
    return oddSumSublistHelper(nums, 0, 0, m);
}",0.1,01000
Recursion_15,1355904,2213298,"string reverseSentence(string s) {
    if (s.find(' ') == string::npos) return s;
    else {
        string s1 = s.substr(0, s.find(' '));
        string s2 = s.substr(s.find(' ') + 1);
        return reverseSentence(s2) + ' ' + s1;
    }
}",1.0,1111111111
Recursion_17,1355904,2213298,"int max(int x, int y) {
    return (x>y) ? x : y;
}

int lcs(string X, string Y, int m, int n)
{
    if (m == 0 || n == 0) return 0;
    if (X[m - 1] == Y[n - 1]) return lcs(X, Y, m - 1, n - 1) + 1;
    else return max(lcs(X, Y, m, n - 1), lcs(X, Y, m - 1, n));
}

int superString(string X, string Y, int m, int n)
{
    int lcs_length = lcs(X, Y, m, n);
    return m + n - lcs_length;
}",1.0,1111111111
Recursion_18,1355904,2213298,"int dequy(char *str, int lens) {
    if (str[0] == '\0') return lens;
    return dequy(str+1, lens+1);
}

int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     return dequy(str, 0);
} ",1.0,1111111111
Recursion_19,1355904,2213298,"bool solve(char *test, char *pattern, bool k, int head) {
    if (*pattern == '\0' && k) return 1;
    if (*test == '\0') return 0;
    if (*pattern != *test) {
        if (!head) return solve(test + 1, pattern, 0, head);
        return solve(test, pattern - 1, 0, head - 1);
    }
    if (*pattern == *test) return solve(test + 1, pattern + 1, 1, head + 1);
    return 0;
}

bool containsPattern(char *test, char *pattern) {
    return solve(test, pattern, 1, 0);
}",1.0,1111111111
Recursion_20,1355904,2213298,"int countWaysUtil(int x, int n)
{
    if (x == 0) return 1;
    if (n <= 0) return 0;
    int res = countWaysUtil(x, n - 1);
    if (x >= n * n) res += countWaysUtil(x - n * n, n - 1);
    return res;
}

int countWaySumOfSquare(int x)
{
    return countWaysUtil(x, sqrt(x));
}",1.0,1111111111
Recursion_2,1356513,2211738,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    if(n == 0){
        cout << n;
        return;
    }
    printArray(n-1);
    cout << "", "" << n;
}",1.0,1111111111
Recursion_3,1356513,2211738,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n <= 0){
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n-5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1356513,2211738,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if(length == 1) return arr[0];
    return max(arr[0], findMax(arr+1, length-1));
}",1.0,1111111111
Recursion_5,1356513,2211738,"bool isPalindrome(string str) 
{ 
    if(str.size() == 0 || str.size() == 1) return true;
    if(str[0] == str[str.size()-1]){
        if(str[1] == ' ' && str[str.size()-2] == ' '){
            return isPalindrome(str.substr(2, str.size()-4));
        }else if(str[1] == ' '){
            return isPalindrome(str.substr(2, str.size()-3));
        }else if (str[str.size()-2] == ' '){
            return isPalindrome(str.substr(1, str.size()-3));
        }else{
            return isPalindrome(str.substr(1,str.size()-2));
        }
    }
    return false;
}",1.0,1111111111
Recursion_6,1356513,2211738,"int findGCD(int a, int b)
{
    if(b == 0) return -1;
    return (a%b==0)? b : findGCD(b, a%b);
}",1.0,1111111111
Recursion_7,1356513,2211738,"int decimalToBinary(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n == 0) return 0;
    return (n%2) + decimalToBinary(n/2)*10;
} ",1.0,1111111111
Recursion_9,1356513,2211738,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if(number == 1) {
        cout << 1;
        return;
    }
    cout << number << "" "";
    if(number % 2 == 0) printHailstone(number/2);
    else printHailstone(3*number + 1);
}",1.0,1111111111
Recursion_10,1356513,2211738,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    if(n == 1) return str[0]-'0';
    return (str[0]-'0')*pow(10,n-1) + myArrayToInt(str+1,n-1);
}",1.0,1111111111
Recursion_11,1356513,2211738,"int k = 1;

int reverseFactorial(int n) {
    // STUDENT ANSWER
        if (n == 1) {
        int x = k;
        k = 1;
        return x;
    }
    if (n < 1) {
        k = 1;
        return -1;
    }
    k++;
    if (n % k != 0) {
        k = 1;
        return -1;
    }
    return reverseFactorial(n / k);
}",1.0,1111111111
Recursion_12,1356513,2211738,"int findGCD(int a, int b){
    if(b == 0) return -1;
    return (a%b == 0) ? b : findGCD(b, a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_15,1356513,2211738,"string reverseSentence(string s) {
    // STUDENT ANSWER
    string temp;
    if(s.size() == 0) return temp;
    int index = s.rfind(' ', s.size()-1);
    if(index != -1){
        temp = s.substr(index+1);
    }else{
        temp = s.substr(0);
        return temp;
    }
    return temp + ' ' +reverseSentence(s.substr(0, s.size()-temp.size()-1));
}",1.0,1111111111
Recursion_18,1356513,2211738,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if(str[0] == '\0') return 0;
    return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_19,1356513,2211738,"bool match(char* text, char* pattern) {
    if (*text == '\0' && *pattern != '\0') return false;
    if (*pattern == '\0') return true;
    if (*text == *pattern) return match(text + 1, pattern + 1);
    return false;
}

bool containsPattern(char* text, char* pattern) {
    if (*text == '\0') return false;
    if (*text == *pattern)
        if (match(text, pattern)) return true;
    return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_2,1358011,2210200,"void printArray(int n)
{
    if(n == 0){
        cout << 0;
        return;
    }
    printArray(n - 1);
    cout << "", "" << n;
    return;
}",1.0,1111111111
Recursion_3,1358011,2210200,"void printPattern(int n) 
{ 
    if(n <= 0){
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1358011,2210200,"int findMax(int* arr, int length)
{
    if(length == 0) return 0;
    int t = arr[length-1];
    int x = findMax(arr, length - 1);
    if(x >= t) return x;
    else return t;
}",1.0,1111111111
Recursion_5,1358011,2210200,"bool isPalindrome(string str) 
{
    if(str.size() == 1) return 1;
    if(str.size() == 0) return 1;
    if(str[0] == ' ') return isPalindrome(str.substr(1, str.size()-1));
    if(str[str.size()-1] == ' ') return isPalindrome(str.substr(0, str.size()-1));
    if(str[0] == str[str.size()-1]) return isPalindrome(str.substr(1, str.size()-2));
    else return false;
}",1.0,1111111111
Recursion_6,1358011,2210200,"int findGCD(int a, int b)
{
    if(b == 0) return a;
    else return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1358011,2210200,"int decimalToBinary(int decimal_number) 
{ 
    if(decimal_number == 0) return 0;
    if(decimal_number == 1){
        return 1;
    }
    int r = decimal_number % 2;
    return 10 * decimalToBinary(decimal_number/2) + r;
} ",1.0,1111111111
Recursion_9,1358011,2210200,"void printHailstone(int number)
{
    
    if(number == 1){
        cout << 1;
        return;
    }
    cout << number << "" "";
    if(number % 2 == 0) printHailstone(number/2);
    else printHailstone(3 * number + 1);
}",1.0,1111111111
Recursion_10,1358011,2210200,"int myArrayToInt(char *str, int n) 
{
    if(n == 0) return 0;
    int r = str[n-1] - '0';
    return myArrayToInt(str, n - 1) * 10 + r;
}",1.0,1111111111
Recursion_11,1358011,2210200,"int fact(int n, int x, int &ans){
    if(n == 0){
        return 1;
    }
    int t = n * fact(n - 1, x, ans);
    if(t == x) ans = n;
    return t;
}


int reverseFactorial(int n) {
    int ans = -1;
    fact(10, n, ans);
    return ans;
}",1.0,1111111111
Recursion_12,1358011,2210200,"int findGCD(int a, int b){
    if(b == 0) return a;
    return findGCD(b, a % b);
}

int findLCM(int a, int b)
{
    return a * b / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1358011,2210200,"void Stack(string s, int &cnt, int &ans){
    if(s.size() == 0) return;
    if(s[0] == '('){
        string t = s.substr(1, s.size()-1);
        ++cnt;
        Stack(t, cnt, ans);
        return;
    }
    if(s[0] == ')'){
        if(cnt == 0){
            ++ans;
            string t = s.substr(1, s.size()-1);
            Stack(t, cnt, ans);
        }
        else{
            --cnt;
            string t = s.substr(1, s.size()-1);
            Stack(t, cnt, ans);
        }
        return;
    }
}


int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int ans = 0;
    int cnt = 0;
    Stack(s, cnt, ans);
    return ans + cnt;
}",1.0,1111111110
Recursion_18,1358011,2210200,"int strLen(char* str)     
{
    if(str[0] == '\0') return 0;
    return (1 + strLen(str + 1));
} ",1.0,1111111111
Recursion_2,1358414,2212935,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if (n > 0){
         printArray(n-1);
         cout << "", "";
     }
     cout << n;
}",1.0,1111111111
Recursion_3,1358414,2212935,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if (n <= 0){
         cout << n;
         return;
     }
     cout << n << "" "";
     printPattern(n - 5);
     cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1358414,2212935,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
     if (length == 1) return arr[0];
     return max(arr[length-1],findMax(arr, length-1));
}",1.0,1111111111
Recursion_5,1358414,2212935,"bool isPalindrome(string str) 
{ 
    int n = str.length();
    if (n == 1 || n == 0) return 1;
    if (str[0] == ' ' && str[n-1] != ' '){
            return isPalindrome(str.substr(1));
        }
    if (str[n-1] == ' ' && str[0] != ' '){
            return isPalindrome(str.substr(0, n-1));
        }
    if (str[0] == str[n-1]) return isPalindrome(str.substr(1, n-2));
    return 0;
}",1.0,1111111111
Recursion_6,1358414,2212935,"int findGCD(int a, int b)
{
    if (b != 0)  return findGCD(b, a%b);
     return a;
}",1.0,1111111111
Recursion_7,1358414,2212935,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if (decimal_number == 0) return 0;
     return decimal_number % 2 + 10 * decimalToBinary(decimal_number/2);
} ",1.0,1111111111
Recursion_9,1358414,2212935,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     if (number == 1) {
         cout << number;
         return;
     }
     cout << number << "" "";
     if ((number%2) == 0){
         printHailstone(number/2);
     }
     else printHailstone(number*3 + 1);
}",1.0,1111111111
Recursion_10,1358414,2212935,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
     if (n == 1) return str[0] - '0';
     return (str[n-1] - '0') + 10 * myArrayToInt(str, n-1);
}",1.0,1111111111
Recursion_11,1358414,2212935,"int reverseFactorial(int n, int k) {
    if (n % k != 0) {
        return -1;
    }
    if (n / k == 1) {
        return k;
    }
    return reverseFactorial(n / k, k + 1);
}
int reverseFactorial(int n) {
    // STUDENT ANSWER
    if (n == 1) return 1;
    return reverseFactorial(n, 2);
}",1.0,1111111111
Recursion_12,1358414,2212935,"int findGCD(int a, int b)
{
     if (b != 0)  return findGCD(b, a%b);
     return a;
}
int findLCM(int a, int b)
{
    return (a*b)/findGCD( a, b);
}",1.0,1111111111
Recursion_18,1358414,2212935,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if (str[0] == '\0') return 0;
     return 1 + strLen(str + 1);
} ",1.0,1111111111
Recursion_19,1358414,2212935,"bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
     if (*pattern == '\0') return 1;
     if (*text == '\0' && *pattern != '\0') return 0;
     if (*text == *pattern) return containsPattern(text+1, pattern+1);
     return containsPattern(text+1, pattern);
}",0.8,1111111001
Recursion_20,1358414,2212935,"int countWaySumOfSquare(int x, int n){
    int val = x - pow(n, 2);
    if (val == 0) return 1;
    if (val < 0) return 0;
    return countWaySumOfSquare (val,n+1) + countWaySumOfSquare(x, n+1);
}
int countWaySumOfSquare(int x)
{
    /*  
     * STUDENT ANSWER
     */
     return countWaySumOfSquare(x, 1);
}",1.0,1111111111
Recursion_14,1361209,2212282,"int index = 0;
int ans   = 0;
int odd   = 0;
int even  = 0;
int sum   = 0;

int oddSumSublist(const vector<int>& nums,const int & m) {
    if(index == static_cast<int>(nums.size())) return ans%m;
    
    sum += nums[index++];
    if(sum % 2 == 0) {
        ans += odd;
        even++;
    }
    else {
        ans += 1 + even;
        odd ++;
    }
    
    return oddSumSublist(nums, m);
}",1.0,1111111111
Recursion_2,1366413,2210055,"void printNumber(int n)
{
  if (n > 0)
  {
    printNumber(n - 1);
    if (n > 1)
    {
      cout << "", "";
    }
    cout << n - 1;
  }
}

void printArray(int n)
{
  printNumber(n+1);
 
}",1.0,1111111111
Recursion_3,1366413,2210055,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
      if (n <= 0) {
        cout << n;
        return;
    }
    cout << n<<"" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1366413,2210055,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
     if (length == 1)
    return arr[0];
  return max(arr[length - 1], findMax(arr, length - 1));
}",1.0,1111111111
Recursion_5,1366413,2210055,"
bool isPalindrome(const std::string& str, int start, int end) {
    if (start >= end) {
        return true;  
    }
    
    
    if (str[start] == str[end]) {
     
        return isPalindrome(str, start + 1, end - 1);
    }
    
    return false;  
}

bool isPalindrome(const std::string& str) {
    int len = str.length();
    return isPalindrome(str, 0, len - 1);
}",0.8,1011111110
Recursion_6,1366413,2210055,"int findGCD(int a, int b)
{
    if (b == 0)
    return a;
  return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1366413,2210055,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
      if (decimal_number == 0)
    return 0;
  else
    return (decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2));
} ",1.0,1111111111
Recursion_9,1366413,2210055,"void printHailstone(int number)
{
  /*
   * STUDENT ANSWER
   */
  if (number == 1)
  {
    cout << number;
    return;
  }
  if (number % 2 == 0)
  {
    cout << number << "" "";
    printHailstone(number / 2);
  }
  else
  {
    cout << number << "" "";
    printHailstone(number * 3 + 1);
  }

  return;
}",1.0,1111111111
Recursion_10,1366413,2210055,"int myArrayToIntRecursive(char* str, int n) {
    if (n == 1) {
        return str[0] - '0';
    }
    return myArrayToIntRecursive(str, n - 1) * 10 + (str[n - 1] - '0');
}

int myArrayToInt(char* str, int n) {
    if (n <= 0) {
        return 0; 
    }
    return myArrayToIntRecursive(str, n);
}",1.0,1111111111
Recursion_11,1366413,2210055,"int reverseFactorial(int n, int k = 2) {
    if (n == 1) {
        return 1;
    }
    
    if (n % k == 0) {
        if (n / k == 1) {
            return k;
        }
        return reverseFactorial(n / k, k + 1);
    }
    
    return -1;
}",1.0,1111111111
Recursion_12,1366413,2210055,"int findLCM(int a, int b) {
    static int multiple = 0; 

    multiple += b; 
    if (multiple % a == 0 && multiple % b == 0) {
        return multiple;
    } else {
    
        return findLCM(a, b);
    }
}",1.0,1111111111
Recursion_17,1366413,2210055,"int superString(string x, string y, int m, int n) {
    if (m == 0)
        return n;
    if (n == 0)
        return m;
    if (x[m - 1] == y[n - 1])
        return 1 + superString(x, y, m - 1, n - 1);
    return 1 + min(superString(x, y, m - 1, n), superString(x, y, m, n - 1));
}",1.0,1111111111
Recursion_18,1366413,2210055,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if (*str == '\0') {
        return 0;
    } else {
        return 1 + strLen(str + 1);
    }
} ",1.0,1111111111
Recursion_19,1366413,2210055,"bool matchPattern(char* text, char* pattern, int textIndex, int patternIndex) {
    // If the pattern is fully matched, return true
    if (pattern[patternIndex] == '\0') {
        return true;
    }

    // If the text ends before pattern is fully matched, return false
    if (text[textIndex] == '\0') {
        return false;
    }

    // If the current characters match, move to the next character in both text and pattern
    if (text[textIndex] == pattern[patternIndex]) {
        return matchPattern(text, pattern, textIndex + 1, patternIndex + 1);
    }

    // If the current characters do not match, start over from the next character in text
    return matchPattern(text, pattern, textIndex - patternIndex + 1, 0);
}

bool containsPattern(char* text, char* pattern) {
    return matchPattern(text, pattern, 0, 0);
}",0.5,0000000000
Recursion_20,1366413,2210055,"int countWaySumOfSquare(int x, int num = 1) {
    if (x == 0) {
        return 1;
    }
    if (x < 0 || num * num > x) {
        return 0;
    }

    // Include the current square (num * num) in the sum
    int count_with_current = countWaySumOfSquare(x - num * num, num + 1);

    // Exclude the current square and move to the next number
    int count_without_current = countWaySumOfSquare(x, num + 1);

    return count_with_current + count_without_current;
}",1.0,1111111111
Recursion_13,1366859,2210200,"void Stack(const string &s, int &cnt, int &ans, int &i){
    if(i == int(s.size())) return;
    if(s[i] == '('){
        ++i;
        ++cnt;
        Stack(s, cnt, ans, i);
        return;
    }
    if(s[i] == ')'){
        if(cnt == 0){
            ++ans;
            ++i;
            Stack(s, cnt, ans, i);
        }
        else{
            --cnt;
            ++i;
            Stack(s, cnt, ans, i);
        }
        return;
    }
}

int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int ans = 0;
    int cnt = 0;
    int i = 0;
    Stack(s, cnt, ans, i);
    return ans + cnt;
}",1.0,1111111111
Recursion_14,1366859,2210200,"void check(vector<int> &nums, int &i, int &odd, int &even, int &ans, int &m){
    if(i == int(nums.size())) return;
    if(nums[i] % 2 == 0){
        even += 1;
    }
    else{
        int temp = odd;
        odd = even + 1;  
        even = temp;
    }
    ans = ((ans % m) + (odd % m)) % m;
    ++i;
    check(nums, i, odd, even, ans, m);
}

int oddSumSublist(vector<int>& nums, int m) {
    int ans = 0, odd = 0, even = 0, i = 0;
    check(nums, i, odd, even, ans, m);
    return ans;
}",1.0,1111111111
Recursion_15,1366859,2210200,"void traverse(const string &s, string &word, string &sentence, int &i){
    if(int(s.size()) == i) return;
    if(s[i] == ' '){
        reverse(word.begin(), word.end());
        sentence += (word + "" "");
        word = """";
        ++i;
        traverse(s, word, sentence, i);
    }
    else{
        word += string(1, s[i]);
        ++i;
        traverse(s, word, sentence, i);
    }
}

string reverseSentence(string s){
    s += "" "";
    string t = """";
    string word = """";
    int i = 0;
    traverse(s, word, t, i);
    t.pop_back();
    i = 0;
    reverse(t.begin(), t.end());
    return t;
}",0.9,1111111111
Recursion_17,1366859,2210200,"int findMin(int a, int b){
    if(a <= b) return a;
    else return b;
}

int superString(string x, string y, int m, int n){
    if(m == 0) return n;
    if(n == 0) return m;
    if(x[m - 1] == y[n - 1]) return 1 + superString(x, y, m - 1, n - 1);
    else return 1 + findMin(superString(x, y, m, n - 1), superString(x, y, m - 1, n));
}",1.0,1111111111
Recursion_2,1367267,2210997,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if (n == 0)
     {
         cout << n;
         return;
     }
     printArray (n-1);
     cout << "", "" <<n;
}",1.0,1111111111
Recursion_3,1367267,2210997,"void printPattern(int n) {
    if (n <= 0) 
    {
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1367267,2210997,"int findMax(int* arr, int length)
{
    if (length == 1) return arr[0];
    int Max = findMax(arr + 1, length - 1);
    
    return (arr[0] > Max) ? arr[0] : Max;
}",1.0,1111111111
Recursion_5,1367267,2210997,"bool isPalindrome(string str) {
    str.erase(remove(str.begin(), str.end(), ' '), str.end());
    if (str.length() <= 1)    return true;
    if (str[0] != str[str.length() - 1])  return false;

    
    return isPalindrome(str.substr(1, str.length() - 2));
}",1.0,1111111111
Recursion_6,1367267,2210997,"int findGCD(int a, int b)
{
    if (b == 0) return a;
    return findGCD (b, a % b);
}",1.0,1111111111
Recursion_7,1367267,2210997,"int decimalToBinary(int decimal_number) {
    if (decimal_number == 0)  return 0;
    int temp = decimal_number % 2;
    int binary_part = decimalToBinary(decimal_number / 2);

    return binary_part * 10 + temp;
}
",1.0,1111111111
Recursion_8,1367267,2210997,"string repeatString(string s, int x) {
    if (x == 0) return """";
    else return (s + repeatString(s, x - 1));
}

int findNumber(string s, int index) {
    int lenS = s.length();
    if (index == lenS) return -1;
    if (s[index] >= '0' && s[index] <= '9') return index;
    return findNumber(s, index + 1);
}

int findRepeatS(string s, int indexS, int numS, int numE) {
    if (numS == numE) return indexS - 1;
    if (s[indexS] == '(') return findRepeatS(s, indexS + 1, numS + 1, numE);
    if(s[indexS]==')') return findRepeatS(s, indexS + 1, numS , numE+1);
    return findRepeatS(s, indexS + 1, numS, numE);
}

string expandRecursion(string s) {
    if (findNumber(s, 0) == -1) return s;
    int indexS = s.find(""("");
    int lenS = s.length();
    int numRe = s[indexS - 1] - '0';
    int indexE = findRepeatS(s, indexS+1,1,0);
    string sub = s.substr(indexS + 1, indexE - indexS - 1);
    if (indexS == 1 && indexE < lenS - 1) {
        return repeatString(expandRecursion(sub), numRe) + expandRecursion(s.substr(indexE + 1, lenS - indexE));
    }
    if (indexS > 1 && indexE < lenS - 1) {
        return s.substr(0, indexS - 1) +
            repeatString(expandRecursion(sub), numRe) +
            expandRecursion(s.substr(indexE + 1, lenS - indexE - 1));
    }
    if (indexS > 1 && indexE == lenS - 1)
        return s.substr(0, indexS - 1) +
            repeatString(expandRecursion(sub), numRe);
    return repeatString(expandRecursion(sub), numRe);
}

string expand(string s) {
    return expandRecursion(s);
}
",1.0,11111
Recursion_9,1367267,2210997,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     cout<<number;
    if(number == 1) return;
    cout<<"" "";
    if(number%2) printHailstone(number*3+1);
    else printHailstone(number/2);
}",1.0,1111111111
Recursion_10,1367267,2210997,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
     if(n==1) return str[0]-48;
     return myArrayToInt(str,n-1)*10 + (str[n-1]-48);
}",1.0,1111111111
Recursion_11,1367267,2210997,"int reverseFactorial(int n, int k) {
    if (n == k)    return k;
    if (n % k != 0 || n < 1)  return -1;
    return reverseFactorial(n / k, k + 1);
}

int reverseFactorial(int n) {
    if (n == 1) {
        return 1;
    }
    return reverseFactorial(n, 2);
}",1.0,1111111111
Recursion_12,1367267,2210997,"int findGCD(int a, int b) {
    if (b == 0) return a;

    return findGCD(b, a % b);
}

int findLCM(int a, int b) {
    if (a == 0 || b == 0)   return 0;
    int gcd = findGCD(a, b);
    return (a * b) / gcd;
}",1.0,1111111111
Recursion_13,1367267,2210997,"int minimumBracketAddRe(string* s, int numberOfStart, int addition, int index) {
    if ((*s)[index] == '(')  return minimumBracketAddRe(s, numberOfStart + 1, addition, index + 1);
    if ((*s)[index] == ')')
    {
        if (numberOfStart > 0) 
        {
            return minimumBracketAddRe(s, numberOfStart - 1, addition, index + 1);
        }
        else 
        {
            return minimumBracketAddRe(s, numberOfStart, addition + 1, index + 1);
        }
    }
    if ((*s)[index] == '\0')  return numberOfStart + addition;
    return minimumBracketAddRe(s, numberOfStart, addition, index + 1);
}

int mininumBracketAdd(string s) {
    string* refS = &s;
    return minimumBracketAddRe(refS, 0, 0, 0);
}",1.0,1111111111
Recursion_14,1367267,2210997,"void findOdd(vector<int> &nums, int &cnt, int &even, int &odd, int index) {
    int n = nums.size();
    if (index == n) return;

    if (nums[index] % 2 == 1) {
        swap(even, odd);
        odd++;
    } else {
        even++;
    }

    cnt += odd;
    index++;
    findOdd(nums, cnt, even, odd, index);
}
int oddSumSublist(vector<int>& nums, int m) {
    if (nums.empty()) return 0;
    int cnt = 0, even = 0, odd = 0, index = 0;
    findOdd(nums, cnt, even, odd, index);
    return cnt % m;
}",1.0,1111111111
Recursion_15,1367267,2210997,"string reverseSentence(string s) 
{
    size_t spacePos = s.find(' ');
    if (spacePos == string::npos)   return s;
    string firstWord = s.substr(0, spacePos);
    string lastWord = s.substr(spacePos + 1);
    return reverseSentence(lastWord) + "" "" + firstWord;
}",1.0,1111111111
Recursion_17,1367267,2210997,"int superString(string x, string y, int m, int n) {
    if (m == 0) return n;
    if (n == 0) return m;
    if (x[m - 1] == y[n - 1])    return 1 + superString(x, y, m - 1, n - 1);
    return 1 + min(superString(x, y, m - 1, n), superString(x, y, m, n - 1));
}
",1.0,1111111111
Recursion_18,1367267,2210997,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if(*str == '\0') return 0;
    else return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_19,1367267,2210997,"bool match(char* text, char* pattern, int textIndex, int patternIndex) {

    if (pattern[patternIndex] == '\0') {
        return true;
    }
    if (text[textIndex] == '\0') {
        return false;
    }
 
    if (text[textIndex] == pattern[patternIndex]) {
        return match(text, pattern, textIndex + 1, patternIndex + 1);
    }
    return match(text, pattern, textIndex - patternIndex + 1, 0);
}

bool containsPattern(char* text, char* pattern) {
    return match(text, pattern, 0, 0);
}





",1.0,1111111111
Recursion_20,1367267,2210997,"int countWays(int x, int n) {
    if (x == 0) return 1;
    if (n == 0) return 0;
    int square = n * n;
    if (square > x) return countWays(x, n - 1);
    return countWays(x - square, n - 1) + countWays(x, n - 1);
}

int countWaySumOfSquare(int x) {
    return countWays(x, floor(sqrt(x)));
}






",1.0,1111111111
Recursion_2,1368016,2210535,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if (n == 0) {
		cout << n;
	}
	else {
		printArray(n - 1);
		cout << "", "" << n;
	}
}",1.0,1111111111
Recursion_3,1368016,2210535,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if (n <= 0)
	    {
			cout << n;
		}
		else
		{
			cout << n << "" "";
			printPattern(n - 5);
			cout << "" "" << n;
		}
}",1.0,1111111111
Recursion_4,1368016,2210535,"int max(int a, int b)   {
    if (a > b)  {
        return a;
    }
    else return b;
}
int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if (length == 1)   {
        return arr[0];
    }
    return max(arr[length-1],findMax(arr,length-1));
}",1.0,1111111111
Recursion_5,1368016,2210535,"string deleteSpace(string str, int index=0) {
	int n = str.length();
	if (index >= n) {
		return """";
	}
	if (str[index] != ' ') {
		return str[index] + deleteSpace(str, index + 1);
	}
	else {
		return deleteSpace(str, index + 1);
	}
}
bool isPalin(string str, int l, int r) {
	if (l == r) {
		return true;
	}
	if (str[l] != str[r]) {
		return false;
	}
	if (l < r ) {
		return isPalin(str, l + 1, r - 1);
	}
	return true;
}
bool isPalindrome(string str) {
	string str1 = deleteSpace(str);
	int n = str1.length();
	if (n == 0) {
		return true;
	} // string is empty ==> It is palindrome
	return isPalin(str1, 0, n-1);
}",1.0,1111111111
Recursion_6,1368016,2210535,"int findGCD(int a, int b)
{
    if (b == 0) {
        return a;
    }
    else {
        return findGCD(b,a%b);
    }
}",1.0,1111111111
Recursion_7,1368016,2210535,"int decimalToBinary(int decimal_number) 
{ 
    //Base case
	if (decimal_number == 0) {
		return 0;
	}
	else {
		return (decimal_number % 2 + 10 * (decimalToBinary(decimal_number / 2)));
	}
} ",1.0,1111111111
Recursion_8,1368016,2210535,"string nstr(string s, int num) { if (num <= 0) return """"; return s + nstr(s, num-1); } int findClose(string s, int br) { if (s[0]=='(') ++br; if (s[0]==')') --br; if (br==0) return 0; return findClose(s.substr(1), br) + 1; } string expand(string s) { if (s=="""") return """"; if (!(s[0]>='0'&&s[0]<='9')) { if (s[0] != ')') return s[0] + expand(s.substr(1)); return expand(s.substr(1)); } int pos = findClose(s.substr(2), 1); return nstr(expand(s.substr(2, pos)), s[0]-'0') + expand(s.substr(pos+2)); }",1.0,11111
Recursion_9,1368016,2210535,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    cout << number;
    if (number == 1)    {
        return;
    }
    if (number % 2 == 0)    {
        cout <<"" "";
        number = number / 2;
        printHailstone(number);
    }
    else {
        cout <<"" "";
        number = number * 3 + 1;
        printHailstone(number);
    }
}",1.0,1111111111
Recursion_10,1368016,2210535,"int myArrayToInt1(char *str, int n, int index=0, int result=0)    {
    if (index == n) {
        return result;
    }
    if (str[index] >= '0' && str[index] <= '9') {
        result = result*10 + (str[index] - '0');
        return myArrayToInt1(str,n,index+1,result);
    }
    else {
        return -1;
    }
}
int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    return myArrayToInt1(str,n);
}",1.0,1111111111
Recursion_11,1368016,2210535,"int reverseFactorial1(int n, int k = 2) {
	if (n == 1) {
		return k-1;
	}
	else if (n % k == 0) {
		return reverseFactorial1(n / k, k + 1);
	}
	else return -1;
}
int reverseFactorial(int n) {
	return reverseFactorial1(n);
}",1.0,1111111111
Recursion_12,1368016,2210535,"int findGCD(int a, int b)   {
    if (b == 0) {
        return a;
    }
    return findGCD(b, a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_13,1368016,2210535,"int mininumBracketAdd1(string &s, int length, int index, int &openC, int &closeC) {
	if (index == length) return openC + closeC;
	else {
		if (s[index] == '(') {
			openC++;
		}
		else if (s[index] == ')') {
			if (openC > 0) openC--;
			else closeC++;
		}
		index++;
		return mininumBracketAdd1(s, length, index, openC, closeC);
	}
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int n = s.length();
    int a = 0;
    int b = 0;
    return mininumBracketAdd1(s,n,0,a,b);
    
}",1.0,1111111111
Recursion_14,1368016,2210535,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111
Recursion_15,1368016,2210535,"#include <string>
string reverseSentence1(string s) {
	// STUDENT ANSWER
	if (s.find("" "") == string::npos) {
		return s + "" "";
	}
	else {
		return reverseSentence1(s.substr(s.find("" "") + 1)) + s.substr(0, s.find("" "")) + "" "";
	}
}
string reverseSentence(string s) {
	string str = reverseSentence1(s);
	return str.substr(0,str.length() - 1);
}",1.0,1111111111
Recursion_18,1368016,2210535,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if (*str == '\0')   {
        return 0;
    }
    return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_19,1368016,2210535,"bool check(char* text, char* patt) {
	if (*text == '\0' && *patt != '\0') {
		return false;
	}
	if (*patt == '\0') {
		return true;
	}
	if (*text == *patt) {
		return check(text + 1, patt + 1);
	}
	return false;
}
bool containsPattern(char* text, char* pattern) {
	if (*text == '\0') {
		return false;
	}
	if (*text == *pattern) {
		if (check(text, pattern)) {
			return true;
		}
		else return containsPattern(text + 1, pattern);
	}
	return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1368016,2210535,"int countWaySumOfSquare1(int x, int num) {
	if (x == 0) {
		return 1;
	}
	if (x < 0 || num < 0) {
		return 0;
	}
	int result1 = countWaySumOfSquare1(x - num * num, num - 1);
	int result2 = countWaySumOfSquare1(x, num - 1);
	return result1 + result2;

}
int countWaySumOfSquare(int x) {
    
	return countWaySumOfSquare1(x, static_cast<int>(sqrt(x)));
}",1.0,1111111111
Recursion_2,1368533,2212935,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if (n > 0){
         printArray(n-1);
         cout << "", "";
     }
     cout << n;
}",1.0,1111111111
Recursion_3,1368533,2212935,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if (n <= 0){
         cout << n;
         return;
     }
     cout << n << "" "";
     printPattern(n - 5);
     cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1368533,2212935,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
     if (length == 1) return arr[0];
     return max(arr[length-1],findMax(arr, length-1));
}",1.0,1111111111
Recursion_5,1368533,2212935,"bool isPalindrome(string str) 
{ 
    int n = str.length();
    if (n == 1 || n == 0) return 1;
    if (str[0] == ' ' && str[n-1] != ' '){
            return isPalindrome(str.substr(1));
        }
    if (str[n-1] == ' ' && str[0] != ' '){
            return isPalindrome(str.substr(0, n-1));
        }
    if (str[0] == str[n-1]) return isPalindrome(str.substr(1, n-2));
    return 0;
}",1.0,1111111111
Recursion_6,1368533,2212935,"int findGCD(int a, int b)
{
    if (b != 0)  return findGCD(b, a%b);
     return a;
}",1.0,1111111111
Recursion_7,1368533,2212935,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if (decimal_number == 0) return 0;
     return decimal_number % 2 + 10 * decimalToBinary(decimal_number/2);
} ",1.0,1111111111
Recursion_9,1368533,2212935,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     if (number == 1) {
         cout << number;
         return;
     }
     cout << number << "" "";
     if ((number%2) == 0){
         printHailstone(number/2);
     }
     else printHailstone(number*3 + 1);
}",1.0,1111111111
Recursion_10,1368533,2212935,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
     if (n == 1) return str[0] - '0';
     return (str[n-1] - '0') + 10 * myArrayToInt(str, n-1);
}",1.0,1111111111
Recursion_11,1368533,2212935,"int reverseFactorial(int n, int k) {
    if (n % k != 0) {
        return -1;
    }
    if (n / k == 1) {
        return k;
    }
    return reverseFactorial(n / k, k + 1);
}
int reverseFactorial(int n) {
    // STUDENT ANSWER
    if (n == 1) return 1;
    return reverseFactorial(n, 2);
}",1.0,1111111111
Recursion_12,1368533,2212935,"int findGCD(int a, int b)
{
     if (b != 0)  return findGCD(b, a%b);
     return a;
}
int findLCM(int a, int b)
{
    return (a*b)/findGCD( a, b);
}",1.0,1111111111
Recursion_13,1368533,2212935,"int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    if (s.length() == 0) return 0;
    if (s[0] == ')') return 1 + mininumBracketAdd(s.substr(1));
    else {
        size_t i = s.find(')');
        if (i != string::npos) {
            if(i-0 > 1) return mininumBracketAdd(s.substr(0, i-1) + s.substr(i+1));
            else return mininumBracketAdd(s.substr(i+1));
        }
        else return 1 + mininumBracketAdd(s.substr(1));
    }
}",0.9,1111111110
Recursion_15,1368533,2212935,"string reverseSentence(string s) {
    // STUDENT ANSWER
    if (s.empty()) return """";
    string word;
    size_t spaceidx = s.find(' ');
    if (spaceidx == string::npos) return s;
    else {
        word = s.substr(0, spaceidx);
        string rest = s.substr(spaceidx+1);
        return reverseSentence(rest) + "" "" + word;
    }
}",1.0,1111111111
Recursion_18,1368533,2212935,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if (str[0] == '\0') return 0;
     return 1 + strLen(str + 1);
} ",1.0,1111111111
Recursion_19,1368533,2212935,"bool precheck(char* text, char* pattern){
    if (*pattern == '\0') return 1;
    if (*text == '\0') return 0;
    if (*text == *pattern) return precheck(text+1, pattern+1);
    else return precheck(text+1, pattern);
}
bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
     if (*text == '\0') return 0;
     if (precheck(text, pattern)) return 1;
     else return containsPattern(text+1, pattern);
     
}",0.8,1111111001
Recursion_20,1368533,2212935,"int countWaySumOfSquare(int x, int n){
    int val = x - pow(n, 2);
    if (val == 0) return 1;
    if (val < 0) return 0;
    return countWaySumOfSquare (val,n+1) + countWaySumOfSquare(x, n+1);
}
int countWaySumOfSquare(int x)
{
    /*  
     * STUDENT ANSWER
     */
     return countWaySumOfSquare(x, 1);
}",1.0,1111111111
Recursion_2,1373400,2210535,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if (n == 0) {
		cout << n;
	}
	else {
		printArray(n - 1);
		cout << "", "" << n;
	}
}",1.0,1111111111
Recursion_3,1373400,2210535,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if (n <= 0)
	    {
			cout << n;
		}
		else
		{
			cout << n << "" "";
			printPattern(n - 5);
			cout << "" "" << n;
		}
}",1.0,1111111111
Recursion_4,1373400,2210535,"int max(int a, int b)   {
    if (a > b)  {
        return a;
    }
    else return b;
}
int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if (length == 1)   {
        return arr[0];
    }
    return max(arr[length-1],findMax(arr,length-1));
}",1.0,1111111111
Recursion_5,1373400,2210535,"string deleteSpace(string str, int index=0) {
	int n = str.length();
	if (index >= n) {
		return """";
	}
	if (str[index] != ' ') {
		return str[index] + deleteSpace(str, index + 1);
	}
	else {
		return deleteSpace(str, index + 1);
	}
}
bool isPalin(string str, int l, int r) {
	if (l == r) {
		return true;
	}
	if (str[l] != str[r]) {
		return false;
	}
	if (l < r ) {
		return isPalin(str, l + 1, r - 1);
	}
	return true;
}
bool isPalindrome(string str) {
	string str1 = deleteSpace(str);
	int n = str1.length();
	if (n == 0) {
		return true;
	} // string is empty ==> It is palindrome
	return isPalin(str1, 0, n-1);
}",1.0,1111111111
Recursion_6,1373400,2210535,"int findGCD(int a, int b)
{
    if (b == 0) {
        return a;
    }
    else {
        return findGCD(b,a%b);
    }
}",1.0,1111111111
Recursion_7,1373400,2210535,"int decimalToBinary(int decimal_number) 
{ 
    //Base case
	if (decimal_number == 0) {
		return 0;
	}
	else {
		return (decimal_number % 2 + 10 * (decimalToBinary(decimal_number / 2)));
	}
} ",1.0,1111111111
Recursion_8,1373400,2210535,"string nstr(string s, int num) { if (num <= 0) return """"; return s + nstr(s, num-1); } int findClose(string s, int br) { if (s[0]=='(') ++br; if (s[0]==')') --br; if (br==0) return 0; return findClose(s.substr(1), br) + 1; } string expand(string s) { if (s=="""") return """"; if (!(s[0]>='0'&&s[0]<='9')) { if (s[0] != ')') return s[0] + expand(s.substr(1)); return expand(s.substr(1)); } int pos = findClose(s.substr(2), 1); return nstr(expand(s.substr(2, pos)), s[0]-'0') + expand(s.substr(pos+2)); }",1.0,11111
Recursion_9,1373400,2210535,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    cout << number;
    if (number == 1)    {
        return;
    }
    if (number % 2 == 0)    {
        cout <<"" "";
        number = number / 2;
        printHailstone(number);
    }
    else {
        cout <<"" "";
        number = number * 3 + 1;
        printHailstone(number);
    }
}",1.0,1111111111
Recursion_10,1373400,2210535,"int myArrayToInt1(char *str, int n, int index=0, int result=0)    {
    if (index == n) {
        return result;
    }
    if (str[index] >= '0' && str[index] <= '9') {
        result = result*10 + (str[index] - '0');
        return myArrayToInt1(str,n,index+1,result);
    }
    else {
        return -1;
    }
}
int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    return myArrayToInt1(str,n);
}",1.0,1111111111
Recursion_11,1373400,2210535,"int reverseFactorial1(int n, int k = 2) {
	if (n == 1) {
		return k-1;
	}
	else if (n % k == 0) {
		return reverseFactorial1(n / k, k + 1);
	}
	else return -1;
}
int reverseFactorial(int n) {
	return reverseFactorial1(n);
}",1.0,1111111111
Recursion_12,1373400,2210535,"int findGCD(int a, int b)   {
    if (b == 0) {
        return a;
    }
    return findGCD(b, a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_13,1373400,2210535,"int mininumBracketAdd1(string &s, int length, int index, int &openC, int &closeC) {
	if (index == length) return openC + closeC;
	else {
		if (s[index] == '(') {
			openC++;
		}
		else if (s[index] == ')') {
			if (openC > 0) openC--;
			else closeC++;
		}
		index++;
		return mininumBracketAdd1(s, length, index, openC, closeC);
	}
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int n = s.length();
    int a = 0;
    int b = 0;
    return mininumBracketAdd1(s,n,0,a,b);
    
}",1.0,1111111111
Recursion_14,1373400,2210535,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111
Recursion_15,1373400,2210535,"#include <string>
string reverseSentence1(string s) {
	// STUDENT ANSWER
	if (s.find("" "") == string::npos) {
		return s + "" "";
	}
	else {
		return reverseSentence1(s.substr(s.find("" "") + 1)) + s.substr(0, s.find("" "")) + "" "";
	}
}
string reverseSentence(string s) {
	string str = reverseSentence1(s);
	return str.substr(0,str.length() - 1);
}",1.0,1111111111
Recursion_17,1373400,2210535,"int superString(string x, string y, int m, int n) {

    if (m == 0) return n;
    if (n == 0) return m;


    if (x[m - 1] == y[n - 1]) {
        return superString(x, y, m - 1, n - 1) + 1;
    } else {

        return min(
            superString(x, y, m - 1, n) + 1,
            superString(x, y, m, n - 1) + 1
        );
    }
}",1.0,1111111111
Recursion_18,1373400,2210535,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if (*str == '\0')   {
        return 0;
    }
    return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_19,1373400,2210535,"bool check(char* text, char* patt) {
	if (*text == '\0' && *patt != '\0') {
		return false;
	}
	if (*patt == '\0') {
		return true;
	}
	if (*text == *patt) {
		return check(text + 1, patt + 1);
	}
	return false;
}
bool containsPattern(char* text, char* pattern) {
	if (*text == '\0') {
		return false;
	}
	if (*text == *pattern) {
		if (check(text, pattern)) {
			return true;
		}
		else return containsPattern(text + 1, pattern);
	}
	return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1373400,2210535,"int countWaySumOfSquare1(int x, int num) {
	if (x == 0) {
		return 1;
	}
	if (x < 0 || num < 0) {
		return 0;
	}
	int result1 = countWaySumOfSquare1(x - num * num, num - 1);
	int result2 = countWaySumOfSquare1(x, num - 1);
	return result1 + result2;

}
int countWaySumOfSquare(int x) {
    
	return countWaySumOfSquare1(x, static_cast<int>(sqrt(x)));
}",1.0,1111111111
Recursion_15,1377761,2212282,"string temp   = """";
string output = """";
unsigned int i = 0;

string helper(const string & s) {
    if(i == s.length()) return output;
    
    if(s[i] == ' ' || i == s.length()-1) {
        if(output == """") output = temp;
        else output = temp + "" "" + output;
        
        temp = """";
    }
    else temp += s[i];
    
    ++i;
    
    return helper(s);
}

string reverseSentence(string s) {
    return helper(s);
}",0.1,0010000000
Recursion_19,1377761,2212282,"bool inProgress = 0;

bool containsPattern(char* text, char* pattern) {
    if(inProgress) {
        if(*pattern == '\0')  return 1;
        
        if(*text != *pattern) return 0;
        
        return containsPattern(text+1, pattern+1);
    }
    else {
        if(*text == *pattern) {
            inProgress = 1;
            return containsPattern(text+1, pattern+1);
        }
        if(*text == '\0')   return *pattern == '\0';
        
        return containsPattern(text+1, pattern);
    }
}",0.8,1110010110
Recursion_2,1379046,2213836,"void printArray(int n) {
    if (n >= 0) {
        if (n > 0) {
            printArray(n - 1);
            cout << "", "";
        }
        cout << n;
    }
}",1.0,1111111111
Recursion_2,1379936,2211667,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    if (n > 0) {
        printArray(n - 1);
        cout<<"", "";
    }
    cout << n ;
    
}",0.95,1111111111
Recursion_3,1379936,2211667,"void printPattern(int n) 
{ 
    cout<<n<<"" "";
    if(n<=0) return;
    printPattern(n-5);
    cout<<n<<"" "";
}",0.2,1100000000
Recursion_4,1379936,2211667,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if (length == 1) {
        return arr[0];
    }
    else {
        int max = findMax(arr + 1, length - 1);
        return (*arr > max) ? *arr : max;
    }
}",1.0,1111111111
Recursion_5,1379936,2211667,"string removeSpaces(std::string str) {
    if (str.empty()) {
        return str;
    } else if (str[0] == ' ') {
        return removeSpaces(str.substr(1));
    } else {
        return str[0] + removeSpaces(str.substr(1));
    }
}
bool isPalindrome(string str) 
{ 
    string str1=removeSpaces(str);
    
    if(str1.length()<=1) return true;
    else return(str1[0]==str1[str1.length()-1]) && isPalindrome(str1.substr(1, str1.length()-2));
}",1.0,1111111111
Recursion_6,1379936,2211667,"int findGCD(int a, int b)
{
    if(b==0) return a;
    else return findGCD(b, a%b);
}",1.0,1111111111
Recursion_7,1379936,2211667,"#include <cmath>
int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    
    if(decimal_number==0) return 0;
    else return (decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2));
     
} ",0.8,1111111111
Recursion_9,1379936,2211667,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     if (number == 1) {
        cout << number << "" "";
        return;
    }
    cout << number << "" "";
    if (number % 2 == 0)
        printHailstone(number / 2);
    else
        printHailstone(3 * number + 1);
}",0.4,1111000000
Recursion_10,1379936,2211667,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
     if (n == 0) {
        return 0;
    } else {
        return (str[n-1] - '0') + 10 * myArrayToInt(str, n-1);
    }
}",1.0,1111111111
Recursion_11,1379936,2211667,"int reverseFactorialHelper(int n, int i = 1) {
    if (n == 1) return (i == 1) ? 1 : i - 1;
    if (n < 1 || n % i != 0) return -1;
    return reverseFactorialHelper(n / i, i + 1);
}
int reverseFactorial(int n) {
    return reverseFactorialHelper(n);
}",1.0,1111111111
Recursion_12,1379936,2211667,"int gcd(int a, int b){
    if(b==0) return a;
    return gcd(b, a%b);
}
int findLCM(int a, int b)
{
    return (a*b)/gcd(a,b);
}",1.0,1111111111
Recursion_13,1379936,2211667,"int mininumBracketAdd(string s, unsigned int i=0, int open=0, int close=0) {
    // STUDENT ANSWER
    if(i==s.length()) {
        return open + close;
    }
    if(s[i]=='(') {
        return mininumBracketAdd(s, i+1, open+1, close);
    } else {
        if(open>0) {
            return mininumBracketAdd(s, i+1, open-1, close);
        } else {
            return mininumBracketAdd(s, i+1, open, close+1);
        }
    }
}",0.9,1111111110
Recursion_14,1379936,2211667,"int helper(vector<int>& nums, int m, size_t i, int odd, int even) {
    if (i==nums.size()) {
        return 0;
    }

    int newOdd, newEven;
    if (nums[i]%2==0) {
        newOdd=odd;
        newEven=even+1;
    } else {
        newOdd=even+1;
        newEven=odd;
    }
    return (newOdd+helper(nums, m, i + 1, newOdd, newEven))%m;
}

int oddSumSublist(vector<int>& nums, int m) {
    return helper(nums, m, 0, 0, 0);
}",1.0,1111111111
Recursion_15,1379936,2211667,"string reverseSentence(string s) {
    if (s.empty()) {
        return """";
    }
    string word;
    size_t spaceIndex=s.find(' ');
    if (spaceIndex!=std::string::npos) {
        word=s.substr(0, spaceIndex);
        s=s.substr(spaceIndex + 1);
    } else {
        word=s;
        s="""";
    }
    string reversed=reverseSentence(s);
    if (!reversed.empty()) {
        reversed+="" "";
    }
    reversed+=word;
    return reversed;
}",1.0,1111111111
Recursion_17,1379936,2211667,"int superString(string x, string y, int m, int n) {
    if (m==0) return n;
    if (n==0) return m;
    if (x[m-1] == y[n-1])
        return 1 + superString(x, y, m-1, n-1);
    else
        return 1 + min(superString(x, y, m-1, n), superString(x, y, m, n-1));
}",1.0,1111111111
Recursion_18,1379936,2211667,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if (*str=='\0') return 0 ;
     else return 1 + strLen(str+1);
     
} ",1.0,1111111111
Recursion_19,1379936,2211667,"bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
    if (*pattern == '\0') return true;
    if (*text == '\0') return false;
    if (*text == *pattern) return containsPattern(text + 1, pattern + 1);
    return containsPattern(text + 1, pattern);
}",0.8,1111111001
Recursion_20,1379936,2211667,"int helper(int x, int n, int num) {
    int val = (x - pow(num, n));
    if (val == 0)
        return 1;
    if (val < 0)
        return 0;
    return helper(val, n, num + 1) + helper(x, n, num + 1);
}
int countWaySumOfSquare(int x)
{
    /*  
     * STUDENT ANSWER
     */
     return helper(x, 2, 1);
}",1.0,1111111111
Recursion_2,1380103,2213836,"void printArray(int n) {
    if (n >= 0) {
        if (n > 0) {
            printArray(n - 1);
            cout << "", "";
        }
        cout << n;
    }
}",1.0,1111111111
Recursion_3,1380103,2213836,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n <= 0) {
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1380103,2213836,"int findMax(int* arr, int length) {
    if (length == 1) {
        return *arr;
    }
    int max = findMax(arr + 1, length - 1);
    return (*arr > max) ? *arr : max;
}
",0.9,1111111111
Recursion_5,1380103,2213836,"bool isPalindromeHelper(string s, int l, int r) {
    if(l > r) return true;
    if(s[l] == ' ') l++;
    if(s[r] == ' ') r--;
    if(s[l] != s[r]) return false;
    return isPalindromeHelper(s, l + 1, r - 1);
}

bool isPalindrome(string str) 
{ 
    return isPalindromeHelper(str, 0, str.length() - 1);
}",1.0,1111111111
Recursion_6,1380103,2213836,"int findGCD(int a, int b) {
    //* nếu b =  0 thì a là ước chung lớn nhất
    if (b == 0) {
        return a;
    }
    
    //* đệ quy để gọi lại b mới
    return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1380103,2213836,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(decimal_number == 0) return 0;
    int binary_digit = decimal_number % 2; //* chia lấy phần dư
    int binary_result = decimalToBinary(decimal_number / 2); //* đệ quy gọi hàm chia tới lúc bằng 0
    return binary_result * 10 + binary_digit;
} ",1.0,1111111111
Recursion_8,1380103,2213836,"//! hàm lặp chuỗi theo số trước đó
string mulString(string s, int number) {
    //* number bằng 0 thì hết lặp
    if(number == 0) return """";
    return s + mulString(s, number - 1);
}

//! hàm lấy số trước chuỗi
string numString(string s) {
    //* nếu chuỗi rỗng hoặc không phải số thì trả về rỗng
    if(s == """" || s[0] < '0' || s[0] > '9') return """";
    return s[0] + numString(s.substr(1));
}

//! hàm mở rộng chuỗi
string expand(string s) {
    //* nếu chuỗi rỗng
    if(s == """") return """";

    else if(s[0] >= '0' && s[0] <= '9') {
        string number = numString(s); //* lấy số trước chuỗi
        string temp = expand(s.substr(number.length() + 1)); //* đệ quy sau số để tiếp tục
        int bracket = temp.find(')'); //* tìm vị trí dấu đóng ngoặc

        //* lặp chuỗi đến dấu đóng ngoặc number lần && đệ quy tiếp sau dấu ngoặc
        return mulString(temp.substr(0, bracket), stoi(number)) + expand(temp.substr(bracket + 1)); 
    }

    //* nếu không phải số thì ghép vào chuỗi xét tiếp
    return s[0] + expand(s.substr(1));
}",1.0,11111
Recursion_9,1380103,2213836,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    cout << number;
    if(number == 1) return; //* nếu là 1 thì kết thúc vòng lặp
    if(number%2 == 0) { //* TH là số chẵn
        cout << "" "";
        printHailstone(number / 2);
    }

    else {
        cout << "" ""; //* TH là số lẻ
        printHailstone(number*3 + 1);
    }
}",1.0,1111111111
Recursion_10,1380103,2213836,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    //* nếu duyệt tới số lượng n = 1 thì trả về kí tự đầu trong chuỗi
    if(n == 1) return str[0] - '0';
    //* nếu không thì đệ quy xét n giảm dần
    return myArrayToInt(str, n - 1)*10 + (str[n-1] - '0');
}",1.0,1111111111
Recursion_11,1380103,2213836,"int helper(int n, int k, int result) {
    if(n == 1) return 1; //* nếu n = 1 thì trả về 1
    result *= k;
    if(result == n) return k; //* nếu result bằng n thì trả về k
    else if(result > n) return -1; //* result lớn hơn thì không có giá trị nào
    return helper(n, k + 1, result);
}

int reverseFactorial(int n) {
    // STUDENT ANSWER
    return helper(n, 1, 1);
}",1.0,1111111111
Recursion_12,1380103,2213836,"//! hàm tìm GCD (ước số chung lớn nhất)
int GCD(int a, int b) {
    if(b == 0) return a;
    return GCD(b, a % b);
}
//! hàm tìm LCM (bội số chung nhỏ nhất)
int findLCM(int a, int b)
{
    if(a == 0 || b == 0) return 0;
    int gcd = GCD(a, b);
    return (a * b) / gcd;
}",1.0,1111111111
Recursion_2,1384903,2210200,"void printArray(int n)
{
    if(n == 0){
        cout << 0;
        return;
    }
    printArray(n - 1);
    cout << "", "" << n;
    return;
}",1.0,1111111111
Recursion_3,1384903,2210200,"void printPattern(int n) 
{ 
    if(n <= 0){
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1384903,2210200,"int findMax(int* arr, int length)
{
    if(length == 0) return 0;
    int t = arr[length-1];
    int x = findMax(arr, length - 1);
    if(x >= t) return x;
    else return t;
}",1.0,1111111111
Recursion_5,1384903,2210200,"bool isPalindrome(string str) 
{
    if(str.size() == 1) return 1;
    if(str.size() == 0) return 1;
    if(str[0] == ' ') return isPalindrome(str.substr(1, str.size()-1));
    if(str[str.size()-1] == ' ') return isPalindrome(str.substr(0, str.size()-1));
    if(str[0] == str[str.size()-1]) return isPalindrome(str.substr(1, str.size()-2));
    else return false;
}",1.0,1111111111
Recursion_6,1384903,2210200,"int findGCD(int a, int b)
{
    if(b == 0) return a;
    else return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1384903,2210200,"int decimalToBinary(int decimal_number) 
{ 
    if(decimal_number == 0) return 0;
    if(decimal_number == 1){
        return 1;
    }
    int r = decimal_number % 2;
    return 10 * decimalToBinary(decimal_number/2) + r;
} ",1.0,1111111111
Recursion_8,1384903,2210200,"#include <algorithm>

void travelback(string &st, string &take){
    if(st.empty()) return;
    if(isdigit(st.back())) return; 
    else{
        take.push_back(st.back());
        st.pop_back();
    }
    travelback(st, take);   
}

void multiple(string &ans, int &i, const string &start){
    if(i == 0) return;
    ans = ans + start;
    --i;
    multiple(ans, i, start);
}

void insert(string &st, string &take, int &i){
    if(i == int(take.size())) return;
    st.push_back(take[i]);
    ++i;
    insert(st, take, i);
}

void solve(const string &s, int &i, string &st){
    if(i == int(s.size())) return;
    if(isdigit(s[i]) || isalpha(s[i])){
        st.push_back(s[i]);
    }
    else if(s[i] == ')'){
        string take = """";
        travelback(st, take);
        reverse(take.begin(), take.end());
        int repeat = 1;
        if(!st.empty()){
            repeat = st.back() - '0';
            st.pop_back();  
        }
        string finalans = """";
        multiple(finalans, repeat, take);
        take = finalans;  
        int cnt = 0;
        insert(st, take, cnt);
    }
    ++i;
    solve(s, i, st);
}

string expand(string s) {
    string st = """";
    int i = 0;
    solve(s, i, st);
    string take = """";
    travelback(st, take);
    reverse(take.begin(), take.end());
    int repeat = 1;
    if(!st.empty()){
        repeat = st.back() - '0';
        st.pop_back(); 
    }
    string finalans = """";
    multiple(finalans, repeat, take);
    take = finalans;  
    return take;
}",1.0,11111
Recursion_9,1384903,2210200,"void printHailstone(int number)
{
    
    if(number == 1){
        cout << 1;
        return;
    }
    cout << number << "" "";
    if(number % 2 == 0) printHailstone(number/2);
    else printHailstone(3 * number + 1);
}",1.0,1111111111
Recursion_10,1384903,2210200,"int myArrayToInt(char *str, int n) 
{
    if(n == 0) return 0;
    int r = str[n-1] - '0';
    return myArrayToInt(str, n - 1) * 10 + r;
}",1.0,1111111111
Recursion_11,1384903,2210200,"int fact(int n, int x, int &ans){
    if(n == 0){
        return 1;
    }
    int t = n * fact(n - 1, x, ans);
    if(t == x) ans = n;
    return t;
}


int reverseFactorial(int n) {
    int ans = -1;
    fact(10, n, ans);
    return ans;
}",1.0,1111111111
Recursion_12,1384903,2210200,"int findGCD(int a, int b){
    if(b == 0) return a;
    return findGCD(b, a % b);
}

int findLCM(int a, int b)
{
    return a * b / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1384903,2210200,"void Stack(const string &s, int &cnt, int &ans, int &i){
    if(i == int(s.size())) return;
    if(s[i] == '('){
        ++i;
        ++cnt;
        Stack(s, cnt, ans, i);
        return;
    }
    if(s[i] == ')'){
        if(cnt == 0){
            ++ans;
            ++i;
            Stack(s, cnt, ans, i);
        }
        else{
            --cnt;
            ++i;
            Stack(s, cnt, ans, i);
        }
        return;
    }
}

int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int ans = 0;
    int cnt = 0;
    int i = 0;
    Stack(s, cnt, ans, i);
    return ans + cnt;
}",1.0,1111111111
Recursion_14,1384903,2210200,"void check(vector<int> &nums, int &i, int &odd, int &even, int &ans, int &m){
    if(i == int(nums.size())) return;
    if(nums[i] % 2 == 0){
        even += 1;
    }
    else{
        int temp = odd;
        odd = even + 1;  
        even = temp;
    }
    ans = ((ans % m) + (odd % m)) % m;
    ++i;
    check(nums, i, odd, even, ans, m);
}

int oddSumSublist(vector<int>& nums, int m) {
    int ans = 0, odd = 0, even = 0, i = 0;
    check(nums, i, odd, even, ans, m);
    return ans;
}",1.0,1111111111
Recursion_15,1384903,2210200,"void traverse(const string &s, string &word, string &sentence, int &i){
    if(int(s.size()) == i) return;
    if(s[i] == ' '){
        reverse(word.begin(), word.end());
        sentence += (word + "" "");
        word = """";
        ++i;
        traverse(s, word, sentence, i);
    }
    else{
        word += string(1, s[i]);
        ++i;
        traverse(s, word, sentence, i);
    }
}

string reverseSentence(string s){
    s += "" "";
    string t = """";
    string word = """";
    int i = 0;
    traverse(s, word, t, i);
    t.pop_back();
    i = 0;
    reverse(t.begin(), t.end());
    return t;
}",1.0,1111111111
Recursion_17,1384903,2210200,"int findMin(int a, int b){
    if(a <= b) return a;
    else return b;
}

int superString(string x, string y, int m, int n){
    if(m == 0) return n;
    if(n == 0) return m;
    if(x[m - 1] == y[n - 1]) return 1 + superString(x, y, m - 1, n - 1);
    else return 1 + findMin(superString(x, y, m, n - 1), superString(x, y, m - 1, n));
}",1.0,1111111111
Recursion_18,1384903,2210200,"int strLen(char* str)     
{
    if(str[0] == '\0') return 0;
    return (1 + strLen(str + 1));
} ",1.0,1111111111
Recursion_19,1384903,2210200,"bool matching(char *text, char *pattern, int &i){
    if(pattern[i] == '\0') return true;
    if(text[i] == '\0' && pattern[i] != '\0'){
        return false;
    }
    if(text[i] == pattern[i]){
        ++i;
        return matching(text, pattern, i);
    }
    else return false;
}


bool containsPattern(char *text, char *pattern){
    int i = 0;
    if(matching(text, pattern, i)) return true;
    if(text[0] == '\0') return false;
    return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1384903,2210200,"int countWaySumOfSquare(int x, int i){
    int res = x - i * i;
    if(res == 0) return 1;
    if(res < 0) return 0;
    return countWaySumOfSquare(res, i + 1) + countWaySumOfSquare(x, i + 1);
}

int countWaySumOfSquare(int x)
{
    return countWaySumOfSquare(x, 1);
}",1.0,1111111111
Recursion_2,1386432,2110501,"void printArray(int n)
{
    if(n==0)    cout<<0;
    else
    {
        printArray(n-1);
        cout<<"", ""<<n;
    }
}",1.0,1111111111
Recursion_3,1386432,2110501,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
    */
    if(n>-5&&n<=0)    cout<<n;
    else
    {
        cout<<n<<"" "";
        printPattern(n-5);
        cout<<"" ""<<n;
    }
}",1.0,1111111111
Recursion_4,1386432,2110501,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if(length==1)   return arr[0];
    else
    {
       return max(arr[length-1], findMax(arr, length-1));
    }
}",1.0,1111111111
Recursion_5,1386432,2110501,"bool isPalindrome(string str){
    if (str.length() == 0)                          return true;
    else if (str[0] == str[str.length() - 1])       return isPalindrome(str.substr(1, str.length() - 2));
    else
    {
        if (str[0] == ' ')                          return isPalindrome(str.substr(1, str.length() - 1));
        else if ((str[str.length() - 1] == ' '))    return isPalindrome(str.substr(0, str.length() - 1));
        return false;
    }
}",1.0,1111111111
Recursion_6,1386432,2110501,"int findGCD(int a, int b)
{
    if(a==0)        return  b;
    else if(b==0)   return  a;
    else            return  findGCD(b, a % b);   
}",1.0,1111111111
Recursion_7,1386432,2110501,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if (decimal_number == 0) {
        return 0;
    } else {
        int remainder = decimal_number % 2;
        int previous_binary = decimalToBinary(decimal_number / 2);
        return previous_binary * 10 + remainder;
    }
} ",1.0,1111111111
Recursion_8,1386432,2110501,"bool noBracket(string s)
{
    if (s.find('(') == string::npos || s.find(')') == string::npos) return true;
    else return false;
}

int endString(string s, int a)
{
    if (s[a] == ')')    return a;
    else                return endString(s,a+1);
}

string concatString(string s, string str, int count)
{
    if (count == 0)         return """";
    else if (count == 1)    return s;
    else                    return concatString(s+str,str,count-1); 
}

string expand(string s) 
{
    if (noBracket(s) == true) return s;
    int a = s.rfind('(');
    int b = s.find(')');
    if (b < a) b=endString(s,a+ 1);
    string temp = s.substr(a+1,b-a-1);
    string tmp = concatString(temp, temp, (int) s[a- 1] - '0');
    return expand(s.replace(a- 1,b-a+2,tmp));
}",1.0,11111
Recursion_9,1386432,2110501,"void printHailstone(int number)
{
    if(number==1)            cout<<""1"";
    else if(number%2!=0)     
    {
        cout<<number<<"" "";
        printHailstone(number*3+1);
    }
    else
    {
        cout<<number<<"" "";
        printHailstone(number/2);
    }
}",1.0,1111111111
Recursion_10,1386432,2110501,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n == 0) return 0;
    return str[n-1] - '0' + myArrayToInt(str,n-1)*10;
}",1.0,1111111111
Recursion_11,1386432,2110501,"int reverseFactorial(int n, int k) {
    if (n == 1 && k!=1) {
        return k-1;
    } else if (n % k == 0) {
        return reverseFactorial(n / k, k + 1);
    } else {
        return -1;
    }
}
int reverseFactorial(int n) {
    // STUDENT ANSWER
    return reverseFactorial(n, 1);
}",1.0,1111111111
Recursion_12,1386432,2110501,"int findGCD(int a, int b)
{
    if(a==0)        return  b;
    else if(b==0)   return  a;
    else            return  findGCD(b, a % b);   
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);   
}",1.0,1111111111
Recursion_13,1386432,2110501,"int mininumBracketAdd(string s) {
    if (s.length() == 0) return 0;
    if (s[0] == ')') {
        return 1 + mininumBracketAdd(s.substr(1));
    } else if (s[0] == '(' && s.find(')') != string::npos) {
        s.erase(s.begin() + s.find(')'));
        return mininumBracketAdd(s.substr(1));
    } else {
        return 1 + mininumBracketAdd(s.substr(1));
    }
}",0.9,1111111110
Recursion_14,1386432,2110501,"int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
}",0.1,
Recursion_15,1386432,2110501,"string reverseSentence(string s) 
{
    // STUDENT ANSWER
    if(s.length() < 2) return s;
    int space = s.find("" "");
    if(space == -1) return s;
    string end = s.substr(0,space);
    int a = s.rfind("" "");
    string start = s.substr(a+1);
    if(space == a) return start+"" ""+end;
    string between = reverseSentence(s.substr(space+1,a - space - 1));
    return start+"" ""+between+"" ""+ end;
}",1.0,1111111111
Recursion_18,1386432,2110501,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if (*str == '\0')   return 0;
    else    return 1 + strLen(str + 1);
} ",1.0,1111111111
Recursion_19,1386432,2110501,"bool isPatternAt(char* text, char* pattern, int textIndex, int patternIndex) {
    if (pattern[patternIndex] == '\0') {
        return true;  
    }

    if (text[textIndex] == '\0') {
        return false;  
    }

    if (text[textIndex] == pattern[patternIndex]) {
        return isPatternAt(text, pattern, textIndex + 1, patternIndex + 1);
    }

    return false;
}

bool containsPattern(char* text, char* pattern) {
    if (*text == '\0') {
        return false;
    }

    if (isPatternAt(text, pattern, 0, 0)) {
        return true;
    }

    return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1386432,2110501,"int countWaysRecursive(int x, int current)
{
    // Base case: successfully found a sum of squares
    if (x == 0)
        return 1;

    // If x becomes negative or we've exhausted all possible squares
    if (x < 0 || current <= 0)
        return 0;

    // Recursive call considering the current square
    int withCurrent = countWaysRecursive(x - current * current, current - 1);

    // Recursive call without considering the current square
    int withoutCurrent = countWaysRecursive(x, current - 1);

    // Total ways is the sum of ways with and without the current square
    return withCurrent + withoutCurrent;
}

int countWaySumOfSquare(int x)
{
    return countWaysRecursive(x, (int)std::sqrt(x));
}",1.0,1111111111
Recursion_13,1388525,2213836,"int Helper(string& s, int l, int r, int index = 0) {
    // STUDENT ANSWER
    //* l là biến đếm ngoặc đang mở
    //* r là biến đếm ngoặc đang đóng
    int n = s.length();
    if(index >= n) return l + r;
    if(s[index] == '(') l++;
    if(s[index] == ')') {
        if(l > 0) {
            l--;
        }
        else r++;
    }
    return Helper(s, l, r, index + 1);
}

int mininumBracketAdd(string s) {
    return Helper(s,0,0,0);
}",1.0,1111111111
Recursion_14,1388525,2213836,"#include <vector>
using namespace std;

int countOddSublists(vector<int>& nums, int left, int right, int prefixSum, int m) {
    if (left > right) {
        return 0;
    }

    int result = 0;

    // Kiểm tra nếu tổng của các phần tử từ left đến right là số lẻ
    if (prefixSum % 2 == 1) {
        result = (result + 1) % m;
    }

    // Đệ quy tính số lượng sublist với tổng lẻ
    result = (result + countOddSublists(nums, left + 1, right, prefixSum + nums[left], m)) % m;
    result = (result + countOddSublists(nums, left, right - 1, prefixSum + nums[right], m)) % m;

    return result;
}

int oddSumSublist(vector<int>& nums, int m) {
    int n = nums.size();
    return countOddSublists(nums, 0, n - 1, 0, m);
}
",0.2,11000
Recursion_15,1388525,2213836,"string reverseSentence(string s) {
    // STUDENT ANSWER
    if(s.find(' ') == string::npos) return s;
    return reverseSentence(s.substr(s.find(' ') + 1)) + ' ' + s.substr(0, s.find(' '));
}",1.0,1111111111
Recursion_18,1388525,2213836,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if(*str == '\0') return 0;
    return 1 + strLen(str + 1);
}",1.0,1111111111
Recursion_2,1389198,2212282,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if(n>0) printArray(n-1);
     if(n==0) cout << 0;
     else     cout << "", "" << n;
}",1.0,1111111111
Recursion_3,1389198,2212282,"bool a=1;
void printPattern(int n) 
{ 
    static int save = n;
    
    if(n == save && a) cout << n;
    else cout << "" "" << n;
    
    if(n < 1) a = 0;
    if(a) printPattern(n-5);
    else  {
        if(n != save) printPattern(n+5);
    }
    
}",1.0,1111111111
Recursion_4,1389198,2212282,"int huhu(int*arr, int length, int temp) {
    temp = max(temp, *arr);
    
    if(length==1) return temp;
    return huhu(++arr, --length, temp);
}

int findMax(int* arr, int length)
{
    return huhu(arr, length, *arr);
}
",1.0,1111111111
Recursion_5,1389198,2212282,"bool balindromecheck(string str, int left, int right) {
    if(str[left]  == ' ') ++left;
    if(str[right] == ' ') --right;
    
    if(left >= right) return 1;
    if(str[left] != str[right]) return 0;
    
    return balindromecheck(str, ++left, --right);
}

bool isPalindrome(string str) 
{ 
    return balindromecheck(str, 0, str.length()-1);
}",1.0,1111111111
Recursion_6,1389198,2212282,"int findGCD(int a, int b)
{
    if (b==0) return a;
    return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1389198,2212282,"int decimalToBinary(int decimal_number) 
{ 
    if(decimal_number == 0) return 0;
    return decimalToBinary(decimal_number/2)*10 + decimal_number%2;
} ",1.0,1111111111
Recursion_8,1389198,2212282,"int find(const string & s, int index = 0) {
    if(index == static_cast<int>(s.length())) return -1;
    if(s[index] == ')') return index;
    return find(s, index+1);
}

string decode_string(const string & s, int & index) {
    index--;
    if(s[index] == '(') return """";
    return decode_string(s, index) + s[index];
}

int decode_num(const string & s, int & index) {
    index--;
    if(index == -1 || (s[index] >= 'a' && s[index] <= 'z') || s[index] == '(') return 0;
    int num = s[index] - '0';
    return decode_num(s, index) * 10 + num;
}

string decode(const string & d_str, int num) {
    if(num == 0) return """";
    return decode(d_str, num-1) + d_str;
}

string helper(const string & s) {
    int rightb = find(s);
    if(rightb == -1) return s;
    int cur = rightb;
    string heh = decode_string(s, cur);
    int hi = decode_num(s, cur);
   
   //cout << (s.substr(0, cur+1) + decode(heh, hi) + s.substr(rightb+1, s.length()-1-rightb)) << endl;
   
    return helper(s.substr(0, cur+1) + decode(heh, hi) + s.substr(rightb+1, s.length()-1-rightb));
}

string expand(string s) {
    return helper(s);
}",1.0,11111
Recursion_9,1389198,2212282,"void printHailstone(int number)
{
    if(number == 1) {
        cout << 1;
        return;
    }
    else cout << number << "" "";
    
    if(number % 2 == 0) printHailstone(number / 2);
    else                printHailstone(number * 3 + 1);
}",1.0,1111111111
Recursion_10,1389198,2212282,"int myArrayToInt(char *str, int n) { 
    if(n == 0) return 0;
    
    int total = str[n-1] - '0';
    
    return myArrayToInt(str, n-1)*10 + total;
}",1.0,1111111111
Recursion_11,1389198,2212282,"int Factorial(double n,int i = 1) {
    if(n < 1)  return -1;
    if(n == 1) return i == 1 ? 1 : i - 1;
    
    return Factorial(n/=i, i+1);
}

int reverseFactorial(int n) {
    
    return Factorial(n);
}
",1.0,1111111111
Recursion_12,1389198,2212282,"int findGCD(int a, int b)
{
    if (b==0) return a;
    return findGCD(b, a % b);
}
int findLCM(int a, int b)
{
    int c=findGCD(a,b);
    return (a*b)/c;
}",1.0,1111111111
Recursion_13,1389198,2212282,"int temp = 0;
int a = 0;
unsigned int index = 0;

int mininumBracketAdd(string s) {
    if(s.length() > 28000) return 426;
    
    if(index == s.length()) return temp + a;
    
    if(s[index] == ')' && a) --a;
    else if(s[index] == ')' && !a) ++temp;
    else ++a;
    
    ++index;
    
    return mininumBracketAdd(s);
}",1.0,1111111111
Recursion_14,1389198,2212282,"int index = 0;
int ans   = 0;
int odd   = 0;
int even  = 0;
int sum   = 0;

int oddSumSublist(const vector<int>& nums,const int & m) {
    if(index == static_cast<int>(nums.size())) return ans%m;
    
    sum += nums[index++];
    if(sum % 2 == 0) {
        ans += odd;
        even++;
    }
    else {
        ans += 1 + even;
        odd ++;
    }
    
    return oddSumSublist(nums, m);
}
",1.0,1111111111
Recursion_15,1389198,2212282,"size_t i = 0;
string temp   = """";
string output = """";

string reverseSentence(string s) {
    if(i == s.length()) {
        string tmp = """";
        tmp += temp;
        tmp += output;
        return tmp;
    }
    
    if(s[i] == ' ') {
        string tmp = """";
        tmp += "" "";
        tmp += temp;
        tmp += output;
        output = tmp;
        temp = """";
    }
    
    else temp += s[i];
    
    i++;
    
    return reverseSentence(s);
}",0.9,1111111110
Recursion_18,1389198,2212282,"int strLen(char* str)     
{ 
    if(*str != '\0') return strLen(str+1) + 1;
    else return 0;
} ",1.0,1111111111
Recursion_20,1389198,2212282,"int countWaySumOfSquare(int x, int n) {
    if(x==0) return 1;
    if(x < 0 || n == 0) return 0;
    
    int case1 = countWaySumOfSquare(x - n*n, n-1);
    int case2 = countWaySumOfSquare(x, n-1);
    
    return case1 + case2;
}

int countWaySumOfSquare(int x) {
    return countWaySumOfSquare(x, int(sqrt(x)));
}",1.0,1111111111
Recursion_2,1389618,2213248,"void printArray(int n)
{
    if(n == 0) cout << 0;
    else {
        printArray(n - 1);
        cout << "", "" << n;
    }
}",1.0,1111111111
Recursion_3,1389618,2213248,"void printPattern(int n) 
{ 
    if(n <= 0) cout << n;
    else {
        cout << n << "" "";
        printPattern(n - 5);
        cout << "" "" << n;
    }
}",1.0,1111111111
Recursion_4,1389618,2213248,"int findMax(int* arr, int length)
{
    if(length == 1) return arr[0];
    else {
        int temp = findMax(arr + 1, length - 1);
        if(arr[0] > temp) return arr[0];
        else return temp;
    }
}",1.0,1111111111
Recursion_5,1389618,2213248,"bool isPalindrome(string str) 
{ 
    int len = str.size();
    if(len <= 1) return 1;
    else {
        if(str[0] == ' ') return isPalindrome(str.substr(1, len - 1));
        if(str[len - 1] == ' ') return isPalindrome(str.substr(0, len - 1));
        if(str[0] != str[len - 1]) return 0;
        else return isPalindrome(str.substr(1, len - 2));

    }
}",1.0,1111111111
Recursion_6,1389618,2213248,"int findGCD(int a, int b)
{
    if(a < b) return findGCD(b, a);
    if(b == 0) return a;
    else return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1389618,2213248,"int decimalToBinary(int decimal_number) 
{ 
    if(decimal_number == 0) return 0;
    else return decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2);
} ",1.0,1111111111
Recursion_8,1389618,2213248,"bool have_open(string s) {
    if(s[0] == '\0') return 0;
    else if(s[0] == '(') return 1;
    else return have_open(s.substr(1));
}

string inside(string s, int open){
    if(open == 0) return """";
    if(s[0] == '(') return s[0] + inside(s.substr(1), open + 1);
    else if(s[0] == ')') {
        if(open == 1) return inside(s.substr(1), open - 1);
        else return s[0] + inside(s.substr(1), open - 1);
    }
    else return s[0] + inside(s.substr(1), open);
}

string combine(string element, int times) {
    if(times == 0) return """";
    else return element + combine(element, times - 1);
}

string scan(string s) {
    if(s[0] == '\0') return """";
    if(s[0] >= '0' && s[0] <= '9') {
        int times = s[0] - '0';
        string temp = inside(s.substr(2), 1);
        return combine(temp, times) + scan(s.substr(temp.size() + 3));
    }
    else return s[0] + scan(s.substr(1));
}

string expand(string s) {
    if(!have_open(s)) return scan(s);
    else return expand(scan(s));
}
",1.0,11111
Recursion_9,1389618,2213248,"void printHailstone(int number)
{
    if(number == 1) cout << 1;
    else if(number % 2 == 0) {
        cout << number << "" "";
        printHailstone(number / 2);
    }
    else {
        cout << number << "" "";
        printHailstone(number * 3 + 1);
    }
}
",1.0,1111111111
Recursion_10,1389618,2213248,"int myArrayToInt(char *str, int n) 
{ 
    if(n == 1) return str[0] - 48;
    else return (str[n - 1]  - 48)+ myArrayToInt(str, n - 1) * 10;
}
",1.0,1111111111
Recursion_11,1389618,2213248,"int reverse(int n, int current) {
    if(n / current == 1 && n % current == 0) return current;
    else if(n % current != 0) return - 1;
    else return reverse(n / current, current + 1);
}

int reverseFactorial(int n) {
    return reverse(n, 1);
}",1.0,1111111111
Recursion_12,1389618,2213248,"int findGCD(int a, int b)
{
    if(a < b) return findGCD(b, a);
    if(b == 0) return a;
    else return findGCD(b, a % b);
}

int findLCM(int a, int b) {
    return a * b / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1389618,2213248,"int count(string & s, int index = 0, int count1 = 0, int count2 = 0) {
    if(s[index] == '\0') return count1 + count2;
    if(s[index] == '(') return count(s, index + 1, count1 + 1, count2);
    if(s[index] == ')' && count1 > 0) return count(s, index + 1, count1 - 1, count2);
    else return count(s, index + 1, count1, count2 + 1);
}
int mininumBracketAdd(string s){
    return count(s);
}",1.0,1111111111
Recursion_14,1389618,2213248,"int sumOfElement(vector<int>& nums, int number) {
    if(number == 0) return 0;
    return nums.at(nums.size() - number) + sumOfElement(nums, number - 1);

}

int oddSumlist_backElement(vector<int>& nums, int number) {
    int size = nums.size();
    if(size < number) return 0;
    else {
        int sum = sumOfElement(nums, number);
        if(sum % 2 == 1) return 1 + oddSumlist_backElement(nums, number + 1);
        else return oddSumlist_backElement(nums, number + 1);
    }
}

int oddSumSublist(vector<int>& nums, int m) {
    if(nums.empty()) return 0;
    else {
        int list = oddSumlist_backElement(nums, 1);
        nums.pop_back();
        return (list % m + oddSumSublist(nums, m) % m) % m;
    }
}",0.7,11111110
Recursion_15,1389618,2213248,"int index(string s, bool &end) {
    if(s[0] == '\0') {
        end = 1;
        return 0;
    }
    else if(s[0] == ' ') return 0;
    else return 1 + index(s.substr(1), end);
}

string word(string s) {
    if(s[0] == '\0' || s[0] == ' ') return """";
    else return s[0] + word(s.substr(1));
}

string reverseSentence(string s) {
    if(s[0] == '\0') return """";
    else {
        bool end = 0;
        int val = index(s, end);
        if(!end) return reverseSentence(s.substr(val + 1)) + "" "" + word(s);
        else return word(s);
        
    }
}",1.0,1111111111
Recursion_17,1389618,2213248,"int superString(string x, string y, int m, int n) {
    if(m == 0) return n;
    if(n == 0) return m;
    if(x[0] == y[0]) return 1 + superString(x.substr(1), y.substr(1), m - 1, n - 1);
    else {
        int temp1 = superString(x.substr(1), y, m - 1, n);
        int temp2 = superString(x, y.substr(1), m, n - 1);
        if(temp1 > temp2) return 1 + temp2;
        else return 1 + temp1;
    }
}",1.0,1111111111
Recursion_18,1389618,2213248,"int strLen(char* str)     
{ 
    if(str[0] == '\0') return 0;
    else return 1 + strLen(str + 1);
} 
 ",1.0,1111111111
Recursion_19,1389618,2213248,"int length(char* text) {
    if(text[0] == '\0') return 0;
    else return 1 + length(text + 1);
}

bool IsEqual(char* text, char* pattern) {
    if(pattern[0] == '\0') return 1;
    else {
        if(text[0] != pattern[0]) return 0;
        else return IsEqual(text + 1, pattern + 1);
    }
}

bool containsPattern(char* text, char* pattern)
{
    if(length(text) < length(pattern)) return 0;
    else {
        if(IsEqual(text, pattern)) return 1;
        else return containsPattern(text + 1, pattern);
    }
}",1.0,1111111111
Recursion_20,1389618,2213248,"int countWays(int x, int current) {
    if (x == 0) {
        return 1;
    }
    if (x < 0 || pow(current, 2) > x) {
        return 0;
    }

    // Count ways with current number squared
    int withCurrent = countWays(x - pow(current, 2), current + 1);

    // Count ways without current number squared
    int withoutCurrent = countWays(x, current + 1);

    return withCurrent + withoutCurrent;
}

int countWaySumOfSquare(int x) {
    return countWays(x, 1);
}",1.0,1111111111
Recursion_2,1390238,2211876,"void printNumber(int n, int current) {
    if (current <= n) {
        cout << current;
        if (current < n) {
            cout << "", "";
        }
        printNumber(n, current + 1);
    }
}

void printArray(int n) {
    printNumber(n, 0);
}",1.0,1111111111
Recursion_4,1390238,2211876,"int findMaxRecursively(int* arr, int length, int currentIndex, int currentMax) {
    if (currentIndex == length) {
        return currentMax;
    } else {
        if (arr[currentIndex] > currentMax) {
            return findMaxRecursively(arr, length, currentIndex + 1, arr[currentIndex]);
        } else {
            return findMaxRecursively(arr, length, currentIndex + 1, currentMax);
        }
    }
}

int findMax(int* arr, int length) {
    if (length <= 0) {
        
        return 0; 
    }

    return findMaxRecursively(arr, length, 0, arr[0]);
}",1.0,1111111111
Recursion_5,1390238,2211876,"bool isPalindromeHelper( string str, int start, int end) {
    if (start >= end) {
        return true;
    }
    if (str[start] == ' ') start++;
    if (str[end] == ' ') end--;
    if (str[start] != str[end]) {
        return false;
    }
    return isPalindromeHelper(str, start + 1, end - 1);
}
bool isPalindrome( string str) {
    int length = str.length();
    if (length == 0) return true;
    return isPalindromeHelper(str, 0, length - 1);
}
",1.0,1111111111
Recursion_6,1390238,2211876,"int findGCD(int a, int b)
{
    if (b == 0) {
        return a;
    }
     return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1390238,2211876,"int decimalToBinary(int decimal_number) 
{ 
    if (decimal_number == 0 || decimal_number == 1) {
        return decimal_number;
    }
    return (decimalToBinary(decimal_number / 2) * 10) + (decimal_number % 2);
    /*  
     * STUDENT ANSWER
     */
} ",1.0,1111111111
Recursion_9,1390238,2211876,"void printHailstone(int number)
{
    cout << number;

    if (number == 1) {
        
        return;
    }

    if (number % 2 == 0) {
        
        cout << "" "";
        printHailstone(number / 2);
    } else {
        
        cout << "" "";
        printHailstone(number * 3 + 1);
    }
    /*  
     * STUDENT ANSWER
     */
}",1.0,1111111111
Recursion_10,1390238,2211876,"int myArrayToInt(char *str, int n) 
{ 
    if (n == 1) {
        return str[0] - '0';
    }
    int partialResult = myArrayToInt(str, n - 1);
     return partialResult * 10 + (str[n - 1] - '0');
    /*  
     * STUDENT ANSWER
     */ 
}",1.0,1111111111
Recursion_11,1390238,2211876,"int findK(int n, int k) {
    
    // if (n == 1) && (k == 0 ) return k+1;
    if ( n == 1 )  return k-1;  
    if (n % k != 0) {
        
        return -1;
    }
    return findK(n / k, k + 1);
}
int reverseFactorial(int n) {
    
    return findK(n, 1);}",0.9,1011111111
Recursion_12,1390238,2211876,"int gcd(int a, int b) {
   
    if (b == 0) {
        return a;
    }

    
    return gcd(b, a % b);
}
int findLCM(int a, int b)
{
 return (a * b) / gcd(a, b);   
    
}",1.0,1111111111
Recursion_13,1390238,2211876,"int balanceParentheses(string s,unsigned int index, int openCount) {
    if (index == s.length()) {
        return openCount;
    }

    if (s[index] == '(') {
        return balanceParentheses(s, index + 1, openCount + 1);
    } else if (s[index] == ')' && openCount > 0) {
        return balanceParentheses(s, index + 1, openCount - 1);
    } else {
        return balanceParentheses(s, index + 1, openCount + 1) + 1;
    }
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return balanceParentheses(s, 0, 0);
}",0.2,1010000000
Recursion_18,1390238,2211876,"int strLen(char* str)     
{ 
    if (*str == '\0') {
        return 0;
    }
    return 1 + strLen(str + 1);
    /*  
     * STUDENT ANSWER
     */
} ",1.0,1111111111
Recursion_19,1390238,2211876,"bool containsPattern(char* text, char* pattern)
{
    if (*pattern == '\0') {
        
        return true;
    }

    if (*text == '\0') {
        
        return false;
    }

    if (*text == *pattern || *pattern == '.') {
        
        return containsPattern(text + 1, pattern + 1);
    }

    return false;
    /*  
     * STUDENT ANSWER
     */
}",0.5,0110010110
Recursion_20,1390238,2211876,"int countWays(int x, int current) {
    if (x == 0) {
         
        return 1;
    }
    if (x < 0 || current <= 0) {
        
        return 0;
    }

    
    
    int includeCurrent = countWays(x - (current * current), current - 1);
    int excludeCurrent = countWays(x, current - 1);


    return includeCurrent + excludeCurrent;
}
int countWaySumOfSquare(int x)
{
    return countWays(x, static_cast<int>(sqrt(x)));
    /*  
     * STUDENT ANSWER
     */
}",1.0,1111111111
Recursion_2,1390919,2210532,"void printArray(int n)
{
    if(n==0){cout<<n;return;}
    printArray(n-1);
    cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1390919,2210532,"void printPattern(int n){
    if(n<=0){
        cout<<n;return;
    }
    cout<<n<<"" "";
    printPattern(n-5);
    cout<<"" ""<<n;
    
}",1.0,1111111111
Recursion_4,1390919,2210532,"int findMax(int* arr, int length)
{
    if(length == 1)return arr[0];
    else return max(arr[length-1],findMax(arr, length-1));
}",1.0,1111111111
Recursion_5,1390919,2210532,"string removeSpaces(string str)
{
    str.erase(remove(str.begin(), str.end(), ' '), str.end());
    return str;
}
bool isPalindromeHelper(const string& str, int start, int end) {
    // Base case: If the start index is greater than or equal to the end index, it's a palindrome.
    if (start >= end) {
        return true;
    }

    // Compare characters at the start and end positions.
    if (str[start] != str[end]) {
        return false; // If they are not equal, it's not a palindrome.
    }

    // Recursively check the substring between start and end.
    return isPalindromeHelper(str, start + 1, end - 1);
}

bool isPalindrome(const string& str) {
    string newstr=removeSpaces(str);
    int length = newstr.length();
    
    // Call the helper function with the start and end indices.
    return isPalindromeHelper(newstr, 0, length - 1);
}",1.0,1111111111
Recursion_6,1390919,2210532,"int findGCD(int a, int b)
{
    if(b != 0)return findGCD(b,a%b);
    else return a;
}",1.0,1111111111
Recursion_7,1390919,2210532,"int decimalToBinary(int decimal_number) 
{ 
   if(decimal_number == 0)return 0;
   else return (decimal_number%2 + 10 * decimalToBinary(decimal_number / 2));
} ",0.85,1111111111
Recursion_9,1390919,2210532,"void printHailstone(int number) {
    cout << number;

    if (number == 1) {
        return; 
    }

    if (number % 2 == 0) {
        cout<<"" "";
        printHailstone(number / 2);
    } else{
        cout<<"" "";
        printHailstone(number * 3 + 1);
    }
}",1.0,1111111111
Recursion_2,1390945,2213250,"void printArray(int n,int k =0 )
{
    /*  
     * STUDENT ANSWER
     */
     if(n==0){
         cout<<k;
         return ;
     }
     else cout<<k<<"", "";
     printArray(n-1,k+1);
}",1.0,1111111111
Recursion_3,1390945,2213250,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
     static bool flag1 = true ;
     static bool flag2 = false;
     static int val = n ;
     if(flag2&&n==val){
         cout<<n;
         return;
     }
     cout<<n<<"" "";
     if(flag1&&n<=0){
         flag1 = false;
         flag2 = true ;
     }
     
     if(flag1==true) printPattern(n-5);
     else if (flag2==true) printPattern(n+5);
}",1.0,1111111111
Recursion_4,1390945,2213250,"int findMax(int* arr, int length , int ans = 0 , int k = 0 )
{
    /*  
     * STUDENT ANSWER
     */
    if(k==length) return ans ;
    if(arr[k]>ans) ans = arr[k];
    return findMax(arr,length,ans,k+1);
}",1.0,1111111111
Recursion_5,1390945,2213250,"
bool isPalindrome(string str) 
{ 
    if(str.size()==1 || str.size() == 0) return true;
    if(str[0]==str[str.size()-1]) return isPalindrome(str.substr(1,str.size()-2));
    if(str[0]==' ') return isPalindrome(str.substr(1,str.size()-1));
    if(str[str.size()-1]==' ') return isPalindrome(str.substr(0,str.size()-1));
    else return false;
}",1.0,1111111111
Recursion_6,1390945,2213250,"int findGCD(int a, int b)
{
    if(a<b) swap(a,b);
    if(a%b==0) return b;
    return findGCD(b,a%b);
}",1.0,1111111111
Recursion_7,1390945,2213250,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if(decimal_number==0) return 0;
     if(decimal_number%2==0) return 10*decimalToBinary(decimal_number/2);
     else return 10*decimalToBinary(decimal_number/2) + 1;
} ",1.0,1111111111
Recursion_8,1390945,2213250,"string nstr(string s, int num) { if (num <= 0) return """"; return s + nstr(s, num-1); } int findClose(string s, int br) { if (s[0]=='(') ++br; if (s[0]==')') --br; if (br==0) return 0; return findClose(s.substr(1), br) + 1; } string expand(string s) { if (s=="""") return """"; if (!(s[0]>='0'&&s[0]<='9')) { if (s[0] != ')') return s[0] + expand(s.substr(1)); return expand(s.substr(1)); } int pos = findClose(s.substr(2), 1); return nstr(expand(s.substr(2, pos)), s[0]-'0') + expand(s.substr(pos+2)); }",1.0,11111
Recursion_9,1390945,2213250,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     if(number==1){
         cout<<number;
         return ;
     }
     cout<<number<<"" "";
     if(number%2==0) return printHailstone(number/2);
     else return printHailstone(number*3+1) ;
}",1.0,1111111111
Recursion_10,1390945,2213250,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    if(n==0) return 0;
    else return (str[n-1]-48) + 10*myArrayToInt(str,n-1);
}",1.0,1111111111
Recursion_11,1390945,2213250,"int reverseFactorial(int n,int k=1) {
    // STUDENT ANSWER
    if(n==k) return k;
    if(n%k!=0) return -1;
    return reverseFactorial(n/k,k+1);
    
}",1.0,1111111111
Recursion_12,1390945,2213250,"int findGCD(int a, int b){
    if(a<b) swap(a,b);
    if(a%b==0) return b;
    else return findGCD(b,a%b);
}

int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_13,1390945,2213250,"int mininumBracket(string& s, int& k, int& n, int& count, int& size)
{
	if (count == size) return n + k;
	else
	{
		if (s[count] == '(') k++;
		else if (s[count] == ')')
		{
			if (k > 0) k--;
			else n++;
		}
		count++;
		return mininumBracket(s, k, n, count, size);
	}
}
int mininumBracketAdd(string s)
{
    // STUDENT ANSWER
	int n = 0, k = 0, count = 0, size = s.length();
	return mininumBracket(s, k, n, count, size);
}",1.0,1111111111
Recursion_14,1390945,2213250,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111
Recursion_15,1390945,2213250,"string reverseSentence(string s) {
	// STUDENT 
	int idx = s.find("" "");
	//cout << idx << endl;
	//cout << s.substr(idx + 1) << endl;
	if (idx != -1) return reverseSentence(s.substr(idx + 1))+"" "" + s.substr(0, idx);
	else return s;

}",1.0,1111111111
Recursion_17,1390945,2213250,"int longestSubSeq(string x , string y , int m , int n){
    if(m==0 || n==0) return 0;
    if(x[m-1]==y[n-1]) return 1 + longestSubSeq(x,y,m-1,n-1);
    else return max(longestSubSeq(x,y,m-1,n),longestSubSeq(x,y,m,n-1));
}

int superString(string x, string y, int m, int n) {
    return m+n-longestSubSeq(x,y,m,n);
}",1.0,1111111111
Recursion_18,1390945,2213250,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if(*str==0) return 0;
     else return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_19,1390945,2213250,"bool containsPattern(char* text, char* pattern) {
    static char** temp = &pattern;
	if (*pattern == 0) return true;
	if (*text == 0) return false;
	if (*text == *pattern) return containsPattern(text + 1, pattern + 1) || containsPattern(text + 1, *temp);
	else return containsPattern(text + 1, *temp);
}
",1.0,1111111111
Recursion_20,1390945,2213250,"int countWaySumOfSquare(int x , int k = 1 )
{
    /*  
     * STUDENT ANSWER
     */
        //cout << x << endl;
        if (x == 0) return 1;
        if (x < 0 || k*k>x) return 0;
        return countWaySumOfSquare(x - k * k, k + 1) + countWaySumOfSquare(x, k + 1);
}",1.0,1111111111
Recursion_2,1390981,2211367,"void printArray(int n){
    if(n==0) {cout << ""0"";
    return;}
    else{ printArray(n-1);
    cout << "",""<< "" ""<< n;}
}
",1.0,1111111111
Recursion_3,1390981,2211367,"void printPattern(int n) 
{ 
    if(n<=0) {cout << n;
    return;}
    cout << n << "" "";
    printPattern(n-5);
    cout << "" "" << n;

}",1.0,1111111111
Recursion_4,1390981,2211367,"int findMax(int *arr, int length){
    if(length==1) return arr[0];
    int n = findMax(arr+1,length-1);
    return (arr[0]>n) ? arr[0] : n;
}
",1.0,1111111111
Recursion_5,1390981,2211367,"string xoakt(string s){
    if(s.length()==0) return"""";
    if(s[0]==' ') return xoakt(s.substr(1));
    return s[0] + xoakt(s.substr(1));
}
bool isPalindrome(string str){
    string s = xoakt(str);
    if(str.length()<=1) return 1;
    if(s[0]!=s[s.length()-1]){
        return 0;
    }
    else{
        return isPalindrome(s.substr(1,s.length()-2));
    }
}",1.0,1111111111
Recursion_6,1390981,2211367,"int findGCD(int a, int b){
    if(b==0) return a;
    return findGCD(b,a%b);
}
",1.0,1111111111
Recursion_7,1390981,2211367,"int decimalToBinary(int n) 
{ 
   return (n<=1) ? n : n % 2 + decimalToBinary(n/2)*10;
} ",1.0,1111111111
Recursion_8,1390981,2211367,"string mulString(const string& s, int number){
    if(number == 0) return """";
    return s + mulString(s,number-1);
}
string IntInString(string s){
    if(s==""""||s[0]<'0'||s[0]>'9'){
        return """";
    }
    return s[0] + IntInString(s.substr(1));
}
string expand(string s){
    if(s=="""") return """";
    else if(s[0]>='0'&&s[0]<='9'){
        string number = IntInString(s);
        string tmp = expand(s.substr(number.length()+1));
        int close = tmp.find(')');
        return mulString(tmp.substr(0,close),stoi(number)) + tmp.substr(close+1);
    }
    return s[0] + expand(s.substr(1));
    }",1.0,11111
Recursion_9,1390981,2211367,"void printHailstone(int n)
{
   
    cout<<n;
    if(n==1) return;
    cout<<"" "";
    if(n%2==0) printHailstone(n/2);
    else printHailstone(3*n+1);
}
",1.0,1111111111
Recursion_10,1390981,2211367,"int myArrayToInt(char* str, int n){
    if(n==1) return str[0]-48;
    return (str[0]-48)*pow(10,n-1) + myArrayToInt(str+1,n-1);

}",1.0,1111111111
Recursion_11,1390981,2211367,"int reverseFactorial(int n) {
    
}",0.1,
Recursion_12,1390981,2211367,"int findGCD(int a,int b)
{
    if(b==0) return a;
    return findGCD(b,a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}
",1.0,1111111111
Recursion_2,1391170,2212988,"void printArray(int n)
{
    if (n > -1)
    {
        printArray(n - 1);
        if (n == 0) { cout << n; }
        else { cout << "","" << "" ""<<n; }
        
    }
    return;
    /*  
     * STUDENT ANSWER
     */
}",1.0,1111111111
Recursion_4,1391170,2212988,"

int findMax(int* arr, int length)
{
    if (length == 1) return arr[0];
    return min(arr[length], findMax(arr, length - 1));
}
",0.7,0100000000
Recursion_2,1391248,2212372,"void printArray(int n)
{
    if(n==0){cout<<0;}
    else {
        printArray(n-1);
        cout<<"", ""<<n;
    }
}",1.0,1111111111
Recursion_3,1391248,2212372,"void printPattern(int n) 
{ 
  if(n<=0){cout<<n;}
  else{
      cout<<n<<"" "";
      printPattern(n-5);
      cout<<"" ""<<n;
  }
    
}",1.0,1111111111
Recursion_4,1391248,2212372,"int findMax(int* arr, int length)
{   
     if(length>0)
        {arr[0]= max(arr[0],arr[length-1]);
        findMax(arr,length-1);}
     return arr[0];
}
",1.0,1111111111
Recursion_5,1391248,2212372,"bool isPalindrome(string str) 
{  int n=str.length();
    if(n<=1){return 1;}
    if(str[0]==' '){
       return isPalindrome(str.substr(1,n-1));
    }
    else if(str[n-1]==' '){
        return isPalindrome(str.substr(0,n-1));
    } 
    else if(str[0]==str[n-1]){
        return isPalindrome(str.substr(1,n-2));
    }
    else {return 0;}
}",1.0,1111111111
Recursion_6,1391248,2212372,"int findGCD(int a, int b)
{if(a>=b){
 if(a%b==0){return b;}else{return findGCD(a%b,b);}
}else{
 if(b%a==0){return a;}
else{return findGCD(a,b%a);}
    
}}",1.0,1111111111
Recursion_7,1391248,2212372,"int decimalToBinary(int decimal_number) 
{ if(decimal_number/2!=0){
    return decimal_number%2+10*decimalToBinary(decimal_number/2);
}
if(decimal_number==0){ return 0; }
return 1;
} 
",1.0,1111111111
Recursion_9,1391248,2212372,"void printHailstone(int number)
{
    if(number%2==0){cout<<number<<"" "";
    printHailstone(number/2);}
    else if (number==1){cout<<1;}
    else {cout<<number<<"" "";
     printHailstone(number*3+1);
}
}",1.0,1111111111
Recursion_10,1391248,2212372,"int myArrayToInt(char *str, int n) 
{ 
    if(n<=0){
        return 0;
    }
    int a=str[n-1]-'0';
    return a+ myArrayToInt(str, n-1)*10;
}",1.0,1111111111
Recursion_11,1391248,2212372,"int reverseFactorial(int n) {
    // STUDENT ANSWER
    if(n==1){return 1;}
    if(n>1){
    return 1+reverseFactorial(n/1+reverseFactorial(n));}
    return -1;

}",0.6,0
Recursion_12,1391248,2212372,"int GND(int a, int b){
    int c=a%b;
    if(c==0)
    return b;
    else return GND(b,c);
   
}
int findLCM(int a, int b)
{    if(a==b) return a;
    return a*b/GND(a,b);
}",1.0,1111111111
Recursion_2,1391249,2213035,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    if(n==0){
        cout<<0;
        return;
    }
    else{
        printArray(n-1);
        cout<<"", ""<<n;
        
    }
}",1.0,1111111111
Recursion_3,1391249,2213035,"void printPattern(int n) 
{ 
    if(n <= 0){
        cout<<n;
    }
    else if(n > 0){
        cout<<n<<"" "";
        printPattern(n -= 5);
        cout<<"" ""<<n+5;
    }
}",1.0,1111111111
Recursion_4,1391249,2213035,"int findMax(int* arr, int length)
{
    int max = arr[length-1];
    if(length == 1) return max;
    if(max >= arr[0]){
        arr[0] = max;
        return findMax(arr, length-1);
    }
    else{
        return findMax(arr, length-1);
    }
    
}
",1.0,1111111111
Recursion_5,1391249,2213035,"bool isPalindrome(string str) {
    if(str.length() <= 1) return true;
    else if(str[0] == str[str.length()-1]){
        return isPalindrome(str.substr(1, str.length()-2));
    }
    else if (str[0] == ' ')
        return isPalindrome(str.substr(1, str.length() - 1));
    else if (str[str.length() - 1] == ' ')
        return isPalindrome(str.substr(0, str.length() - 1));
    return false;
}",1.0,1111111111
Recursion_6,1391249,2213035,"int findGCD(int a, int b)
{
    if(a == 0) return b;
    if(b == 0) return a;
    return findGCD(b, a%b);
}",1.0,1111111111
Recursion_7,1391249,2213035,"int decimalToBinary(int decimal_number) 
{
    if(decimal_number/2 != 0) 
        return decimal_number%2 + 10*decimalToBinary(decimal_number/2);
    if(decimal_number == 0) 
        return 0;
    return 1;
} ",1.0,1111111111
Recursion_8,1391249,2213035,"int findIndex(string s,unsigned int i=0,int index=-1,int count=0){
    // static int a=0;
    // if(a++==0) {cout<<s;}
    if(s[i]==')') {index=i;count--;}
    if(s[i]=='(') {count++;}
    if(!count) return index;
    if(i==s.length()-1){
        return index;
    }
    else return findIndex(s,i+1,index,count);
}

void expand2(string s,string &ans,int n=1,unsigned int i=0){
    //base case
    if(!n||s=="""") return;
    if(i>=s.length()) {expand2(s,ans,n-1);return ;}
    if(s[i]>='0'&&s[i]<='9') {
        expand2(s.substr(i+1,findIndex(s.substr(i+1))+1),ans,s[i]-'0');
        i+=findIndex(s.substr(i+1))+1;
        expand2(s,ans,n,i);                                                                
    }else {
    if(s[i]!=')'&&s[i]!='(')
    ans+=s[i];
    expand2(s,ans,n,i+1); 
    }
}

string expand(string s){
    string ans="""";
    expand2(s,ans);
    return ans;
}",1.0,11111
Recursion_9,1391249,2213035,"void printHailstone(int number)
{   if(number == 1){
        cout<<1; 
        return; 
    } 
    if(number % 2 == 0){
        cout<<number<<"" "";
        return printHailstone(number/2);
    } 
    if(number % 2 != 0){
        cout<<number<<"" "";
        return printHailstone(number*3+1);
    } 
}",1.0,1111111111
Recursion_10,1391249,2213035,"int myArrayToInt(char *str, int n) 
{
    if(n == 0) return 0;
    int a = str[n-1]-'0';
    return a + myArrayToInt(str, n-1)*10;
}",1.0,1111111111
Recursion_11,1391249,2213035,"int giaithua(int n, int k) {
    if (n == 1) {
        return k-1;
    }
    if (n % k != 0) {
        return -1;
    }
    return giaithua(n / k, k + 1);
}

int reverseFactorial(int n) {
    if (n == 1) {
        return 1;
    }
    return giaithua(n, 1);
}",1.0,1111111111
Recursion_12,1391249,2213035,"int UCLN (int a, int b)
{
    if(a==0) return b;
    if(b==0) return a;
    return UCLN(b, a%b);
}
int findLCM(int a, int b)
{
   return (a*b)/UCLN(a,b);
}",1.0,1111111111
Recursion_13,1391249,2213035,"int balanceBrackets(const string& s, size_t i = 0, int openCount = 0, int addCount = 0) {
    if (i == s.size()) {
        return openCount + addCount;
    }
    if (s[i] == '(') {
        return balanceBrackets(s, i + 1, openCount + 1, addCount);
    } else if (s[i] == ')' && openCount > 0) {
        return balanceBrackets(s, i + 1, openCount - 1, addCount);
    } else if (s[i] == ')' && openCount == 0) {
        return balanceBrackets(s, i + 1, openCount, addCount + 1);
    } else {
        return balanceBrackets(s, i + 1, openCount, addCount);
    }
}

int mininumBracketAdd(string s) {
    // STUDENT ANSWER
      return balanceBrackets(s);
}",1.0,1111111111
Recursion_14,1391249,2213035,"int oddSumSublist(vector<int>& nums, int m){
    if(nums.empty()) return 0;
    else {
        int x = 0;
        if(nums[nums.size()-1]&1) x = nums[nums.size()-1];
        nums.pop_back();
        return (x + oddSumSublist(nums, m))%m;
    }
}",0.1,0100000000
Recursion_15,1391249,2213035,"string reverseSentence(string s) {
    // STUDENT ANSWER
    if( s.find(' ') == string::npos) return s;
    size_t index = s.find(' ');
    string firstWord = s.substr(0,index);
    string lastWord = s.substr(index + 1);
    string reverseString = reverseSentence(lastWord);
    return reverseString + ' ' + firstWord;
}",1.0,1111111111
Recursion_17,1391249,2213035,"int shortestSuperStringUtil(string x, string y, int m, int n){
    if (m == 0) return n;
    if (n == 0) return m;

    if (x[m - 1] == y[n - 1])   return 1 + shortestSuperStringUtil(x, y, m - 1, n - 1);
    else    return 1 + min(shortestSuperStringUtil(x, y, m - 1, n), shortestSuperStringUtil(x, y, m, n - 1));
}

int superString(string x, string y, int m, int n){
    return shortestSuperStringUtil(x, y, m, n);
}
",1.0,1111111111
Recursion_18,1391249,2213035,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if(str[0]=='\0') return 0;
     else{
         return 1 + strLen(str + 1);
     }
} ",1.0,1111111111
Recursion_19,1391249,2213035,"bool isMatch(char* text, char* pattern) {
    if (*text == '\0' && *pattern == '\0') {
        return true;
    }

    if (*text == '\0' || *pattern == '\0') {
        return false;
    }

    if (*text == *pattern) {
        return isMatch(text + 1, pattern + 1);
    }

    return false;
}

bool containsPatternHelper(char* text, char* pattern) {
    if (*pattern == '\0') {
        return true;
    }

    if (*text == '\0') {
        return false;
    }

    if (isMatch(text, pattern)) {
        return true;
    }

    return containsPatternHelper(text + 1, pattern);
}

bool containsPattern(char* text, char* pattern) {
    return containsPatternHelper(text, pattern);
}
",0.8,1111110110
Recursion_20,1391249,2213035,"int count(int x, int num)
{
    int val = (x - pow(num, 2));
    if (val == 0)
        return 1;
    if (val < 0)
        return 0;
 
    return count(val, num + 1) +
           count(x, num + 1);
}

int countWaySumOfSquare(int x)
{
    return count(x, 1);
}",1.0,1111111111
Recursion_2,1391254,2212741,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if(n==0){
         cout<<n;
     }
     else{
         printArray(n-1);
         cout<<"",""<<"" ""<<n;
     }
     }
",0.65,1111111111
Recursion_3,1391254,2212741,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if(n<=0) cout<<n;
     else{
         cout<<n<<"" "";
         printPattern(n-5);
         cout<<"" ""<<n;
     }
}",1.0,1111111111
Recursion_4,1391254,2212741,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
     if(length==1) return arr[0];
     else{
         if(arr[length-1]>=arr[length-2]) arr[length-2]=arr[length-1];
         return findMax(arr,length-1);
     }
}",1.0,1111111111
Recursion_5,1391254,2212741,"bool isPalindrome(string str) 
{   
    int length=str.length();
    if(str.length()==0||str.length()==1) return 1;
    if(str[0]==' ') {
        str.erase(str.begin());
        return isPalindrome(str);
    }
    if(str[length-1]==' ') {
        str.pop_back();
        return isPalindrome(str);
    }
    if(str[0]==str[length-1]){
        str.erase(str.begin());
        str.pop_back();
        return isPalindrome(str);
    }
    else{
        return 0;
    }
}",1.0,1111111111
Recursion_6,1391254,2212741,"int findGCD(int a, int b)
{
    if(a>=b){
        if(a%b==0) return b;
        else{
            return findGCD(b,a%b);
        }
    }
    else{
        if(b%a==0) return a;
        else{
            return findGCD(a,b%a);
        }
    }
}",1.0,1111111111
Recursion_7,1391254,2212741,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if(decimal_number/2==0) return (decimal_number%2);
     else{
     return decimal_number%2+10*decimalToBinary(decimal_number/2);
    //  cout<<(decimal_number%2);
     }
} ",1.0,1111111111
Recursion_2,1391269,1912532,"void printArray(int n)
{
    
   if(n>0)
   
    {printArray(n-1);}
    if(n>0)
   cout << "", "" << n;
   else
   cout << n;
}",0.85,1111111111
Recursion_3,1391269,1912532,"void printPattern(int n) {
    if (n <= 0) {
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n - 5);
    if (n != 0) {
        cout << "" "" << n;
    }
}
",1.0,1111111111
Recursion_4,1391269,1912532,"int findMaxRecursive(int* arr, int length, int currentIndex, int currentMax) {
    if (currentIndex == length) {
        return currentMax;
    }

    if (arr[currentIndex] > currentMax) {
        return findMaxRecursive(arr, length, currentIndex + 1, arr[currentIndex]);
    } else {
        return findMaxRecursive(arr, length, currentIndex + 1, currentMax);
    }
}

int findMax(int* arr, int length) {

    return findMaxRecursive(arr, length, 0, arr[0]);
}",1.0,1111111111
Recursion_2,1391279,2210578,"void printArray(int n)
{
    if(n < 0) return;
    printArray(n-1);
    if(n==0) cout<<n;
    else cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1391279,2210578,"void printPattern(int n, bool max = 1) 
{ 
   if(n>0){
       if(max) cout<<n;
       else cout<<"" ""<<n;
       printPattern(n-5, 0);
   }
   cout <<"" ""<<n;
}",1.0,1111111111
Recursion_4,1391279,2210578,"int findMax(int* arr, int length,int max = -99999)
{
    if (length==0) return max;
    if(max<*arr) max=*arr;
    return findMax(++arr,--length,max);
}",1.0,1111111111
Recursion_5,1391279,2210578,"string removeSpaces(string input)
{
    if (input.empty())
    {
        return """";
    }
    else
    {
        char firstChar = input[0];
        string restOfString = input.substr(1);

        if (firstChar == ' ')
        {
            return removeSpaces(restOfString);
        }
        else
        {
            return firstChar + removeSpaces(restOfString);
        }
    }
}
bool isPalindrome(string str) 
{   str=removeSpaces(str);
    if(str.length()<=1) return true;
    if(str[0]!=str[str.length()-1]) return false;
    return isPalindrome(str.substr(1,str.length()-2));
}",1.0,1111111111
Recursion_6,1391279,2210578,"int findGCD(int a, int b)
{
    if(b==0) return a;
    if(a%b==0) return b;
    return findGCD(b,a%b);
}",1.0,1111111111
Recursion_7,1391279,2210578,"int decimalToBinary(int decimal_number) 
{ 
   if( decimal_number==1) return 1;
   
   if( decimal_number==0) return 0;
   return decimalToBinary(decimal_number/2)*10+decimal_number%2;
} ",1.0,1111111111
Recursion_9,1391279,2210578,"void printHailstone(int number,bool first=1)
{
    /*  
     * STUDENT ANSWER
     */
     if(first)cout <<number;
     else cout<<"" ""<<number;
     if(number==1) return;
     if(number%2==1){printHailstone(number*3+1,0);}
     else printHailstone(number/2,0);
}",1.0,1111111111
Recursion_10,1391279,2210578,"int myArrayToInt(char *str, int n, int m = 0) 
{ 
    if(n==0) return m;
    int k=*str-48;
    m=m*10+k;
    return myArrayToInt(++str,--n,m);
}",1.0,1111111111
Recursion_11,1391279,2210578,"int giaithua(int n){
    if(n==1) return 1;
    if(n==2) return 2;
    return n*giaithua(n-1);
}
int reverseFactorial(int n, int m=1) {
    if(giaithua(m)>n) return -1;
    if(n==giaithua(m)) return m;
    else return reverseFactorial(n,++m);
    
    
}",1.0,1111111111
Recursion_12,1391279,2210578,"int findGCD(int a, int b)
{
    if(b==0) return a;
    if(a%b==0) return b;
    return findGCD(b,a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_14,1391279,2210578,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111
Recursion_15,1391279,2210578,"string reverseSentence(string s) {
    int i=s.find("" "");
    if(i!=-1) return reverseSentence(s.substr(i+1))+"" ""+s.substr(0,i);
    else return s;
}",1.0,1111111111
Recursion_17,1391279,2210578,"int longestSubSeq(string x , string y , int m , int n){
    if(m==0 || n==0) return 0;
    if(x[m-1]==y[n-1]) return 1 + longestSubSeq(x,y,m-1,n-1);
    else return max(longestSubSeq(x,y,m-1,n),longestSubSeq(x,y,m,n-1));
}

int superString(string x, string y, int m, int n) {
    return m+n-longestSubSeq(x,y,m,n);
}",1.0,1111111111
Recursion_18,1391279,2210578,"
int strLen(char* str, int length=0)     
{ 
    if(*str != '\0') return  strLen(++str,++length);
    else return length;
} 
 ",1.0,1111111111
Recursion_19,1391279,2210578,"bool compare(char* text, char* pattern) {
    if (*pattern == '\0') return true;
    if (*text != *pattern) return false;
    return compare(text + 1, pattern + 1);
}

bool containsPattern(char* text, char* pattern) {
    if (*text == '\0') return false;
    if (*text == *pattern && compare(text, pattern)) return true;
    return containsPattern(text + 1, pattern);
}
",1.0,1111111111
Recursion_2,1391311,2211667,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    if (n > 0) {
        printArray(n - 1);
        cout<<"", "";
    }
    cout << n ;
    
}",1.0,1111111111
Recursion_3,1391311,2211667,"void printPattern(int n) 
{ 
    if(n<=0){
        cout<<n;
        return;
    }
    cout<<n<<"" "";
    printPattern(n-5);
    cout<<"" ""<<n;
}",1.0,1111111111
Recursion_4,1391311,2211667,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if (length == 1) {
        return arr[0];
    }
    else {
        int max = findMax(arr + 1, length - 1);
        return (*arr > max) ? *arr : max;
    }
}",1.0,1111111111
Recursion_5,1391311,2211667,"string removeSpaces(std::string str) {
    if (str.empty()) {
        return str;
    } else if (str[0] == ' ') {
        return removeSpaces(str.substr(1));
    } else {
        return str[0] + removeSpaces(str.substr(1));
    }
}
bool isPalindrome(string str) 
{ 
    string str1=removeSpaces(str);
    
    if(str1.length()<=1) return true;
    else return(str1[0]==str1[str1.length()-1]) && isPalindrome(str1.substr(1, str1.length()-2));
}",1.0,1111111111
Recursion_6,1391311,2211667,"int findGCD(int a, int b)
{
    if(b==0) return a;
    else return findGCD(b, a%b);
}",1.0,1111111111
Recursion_7,1391311,2211667,"#include <cmath>
int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    
    if(decimal_number==0) return 0;
    else return (decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2));
     
} ",1.0,1111111111
Recursion_9,1391311,2211667,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     if (number == 1) {
        cout << number;
        return;
    }
    cout << number << "" "";
    if (number % 2 == 0)
        printHailstone(number / 2);
    else
        printHailstone(3 * number + 1);
}",1.0,1111111111
Recursion_10,1391311,2211667,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
     if (n == 0) {
        return 0;
    } else {
        return (str[n-1] - '0') + 10 * myArrayToInt(str, n-1);
    }
}",1.0,1111111111
Recursion_11,1391311,2211667,"int reverseFactorialHelper(int n, int i = 1) {
    if (n == 1) return (i == 1) ? 1 : i - 1;
    if (n < 1 || n % i != 0) return -1;
    return reverseFactorialHelper(n / i, i + 1);
}
int reverseFactorial(int n) {
    return reverseFactorialHelper(n);
}",1.0,1111111111
Recursion_12,1391311,2211667,"int gcd(int a, int b){
    if(b==0) return a;
    return gcd(b, a%b);
}
int findLCM(int a, int b)
{
    return (a*b)/gcd(a,b);
}",1.0,1111111111
Recursion_13,1391311,2211667,"int mininumBracketAdd(string s, unsigned int i=0, int open=0, int close=0) {
    // STUDENT ANSWER
    if(i==s.length()) {
        return open + close;
    }
    if(s[i]=='(') {
        return mininumBracketAdd(s, i+1, open+1, close);
    } else {
        if(open>0) {
            return mininumBracketAdd(s, i+1, open-1, close);
        } else {
            return mininumBracketAdd(s, i+1, open, close+1);
        }
    }
}",0.9,1111111110
Recursion_2,1391529,2211738,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    if(n == 0) {
        cout << n;
        return;
    }
    printArray(n-1);
    cout << "", "" << n;
}",1.0,1111111111
Recursion_3,1391529,2211738,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n <= 0){
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n-5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1391529,2211738,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if(length == 1) return arr[0];
    return max(arr[0], findMax(arr+1, length-1));
}",1.0,1111111111
Recursion_5,1391529,2211738,"bool isPalindrome(string str) 
{ 
    if(str.length() <= 1) return true;
    if(str[0] == str[str.length()-1]){
        if(str[1] == ' ' && str[str.length()-2] == ' '){
            return isPalindrome(str.substr(2, str.length()-4));
        }else if(str[1] == ' '){
            return isPalindrome(str.substr(2, str.length()-3));
        }else if(str[str.length()-2] == ' '){
            return isPalindrome(str.substr(1, str.length()-3));
        }else {
            return isPalindrome(str.substr(1, str.length()-2));
        }
    }
    return false;
}",1.0,1111111111
Recursion_6,1391529,2211738,"int findGCD(int a, int b)
{
    if(b == 0) return -1;
    return (a%b == 0)? b : findGCD(b, a%b);
}",1.0,1111111111
Recursion_7,1391529,2211738,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(decimal_number == 0){
        return 0;
    }
    return (decimal_number%2) + decimalToBinary(decimal_number/2)*10;
} ",1.0,1111111111
Recursion_9,1391529,2211738,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if(number == 1) {
        cout << number;
        return;
    }
    cout << number << "" "";
    if(number%2==0){
        printHailstone(number/2);
    }else {
        printHailstone(3*number+1);
    }
}",1.0,1111111111
Recursion_10,1391529,2211738,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    if(n == 0) return 0;
    return (str[0] - '0')*pow(10,n-1) + myArrayToInt(str+1, n-1);
}",1.0,1111111111
Recursion_11,1391529,2211738,"int k = 1;

int reverseFactorial(int n) {
    // STUDENT ANSWER
        if (n == 1) {
        int x = k;
        k = 1;
        return x;
    }
    if (n < 1) {
        k = 1;
        return -1;
    }
    k++;
    if (n % k != 0) {
        k = 1;
        return -1;
    }
    return reverseFactorial(n / k);
}",1.0,1111111111
Recursion_12,1391529,2211738,"int findGCD(int a, int b){
    if(b == 0) return -1;
    return (a%b==0)?b:findGCD(b,a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_15,1391529,2211738,"string reverseSentence(string s) {
    // STUDENT ANSWER
    string temp;
    if(s.length() == 0) return temp;
    int index = s.rfind(' ', s.size()-1);
    if(index != -1){
        temp = s.substr(index+1);
    }else{
        temp = s.substr(0);
        return temp;
    }
    return temp + ' ' +reverseSentence(s.substr(0, s.size()-temp.size()-1));
}",1.0,1111111111
Recursion_18,1391529,2211738,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if(str[0] == '\0') return 0;
    return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_19,1391529,2211738,"bool match(char* text, char* pattern) {
    if (*text == '\0' && *pattern != '\0') return false;
    if (*pattern == '\0') return true;
    if (*text == *pattern) return match(text + 1, pattern + 1);
    return false;
}

bool containsPattern(char* text, char* pattern) {
    if (*text == '\0') return false;
    if (*text == *pattern)
        if (match(text, pattern)) return true;
    return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1391529,2211738,"int helper(int x, int n, int num){
    int val = x - pow(num,n);
    if(val < 0) return 0;
    if(val == 0) return 1;
    return helper(val,n,num+1) + helper(x,n,num+1);
}
int countWaySumOfSquare(int x)
{
    /*  
     * STUDENT ANSWER
     */
    return helper(x,2,1);
}",1.0,1111111111
Recursion_2,1391687,1913560,"void printArray(int n)
{
    if (n >= 0) {
        printArray(n - 1);
        if (n == 0) std::cout << n;
        else std::cout << "", "" << n;
    }
}",1.0,1111111111
Recursion_3,1391687,1913560,"void printPattern(int n) 
{ 
    static int count1 = 0;
    static int count2 = 0;
    if (n <= 0) {
        if (count1 == count2) cout << n;
        else cout << n << "" "";
        return;
    }

    cout << n << "" "";
    count1 += 1;
    printPattern(n - 5);
    count2 += 1;
    if (count1 == count2) cout << n;
    else cout << n << "" "";
}",1.0,1111111111
Recursion_4,1391687,1913560,"int findMax(int* arr, int length)
{
    if (length == 1)
        return arr[0];
    return max(arr[length - 1], findMax(arr, length - 1));
}",1.0,1111111111
Recursion_5,1391687,1913560,"bool isPalindromeRecursive(string str, int start, int end) {
    if (start >= end) {
        return true;
    }

    if (str[start] == ' ') return isPalindromeRecursive(str, start + 1, end);
    else if (str[end] == ' ') return isPalindromeRecursive(str, start, end - 1);
    else if (str[start] == str[end]) return isPalindromeRecursive(str, start + 1, end - 1);
    
    return false;
}

bool isPalindrome(string str) 
{ 
    int length = str.length();
    return isPalindromeRecursive(str, 0, length - 1);
}",1.0,1111111111
Recursion_6,1391687,1913560,"int findGCD(int a, int b)
{
    if (b == 0) {
        return a;
    } else {
        return findGCD(b, a % b);
    }
}",1.0,1111111111
Recursion_7,1391687,1913560,"int decimalToBinary(int decimal_number) 
{ 
    if (decimal_number == 0) {
        return 0;
    } else {
        return (decimal_number % 2) + 10 * decimalToBinary(decimal_number / 2);
    }
} ",1.0,1111111111
Recursion_2,1391957,2210103,"void printArrayAToB(int& a, int b)
{
    if (a == b)
    {
        cout << a;
        return;
    }
    cout << a << "", "";
    a = a + 1;
    printArrayAToB(a, b);
}

void printArray(int n)
{
    int pos = 0;
    printArrayAToB(pos, n);
}",1.0,1111111111
Recursion_2,1392194,2212499,"void printArray(int n)
{ if(n == 0){
        cout << ""0"";
        return;
    }
//! loi goi de quy
    printArray(n - 1);
//!phan tra nguoc lai cua de quy
    cout << "", ""<<n;
}",1.0,1111111111
Recursion_3,1392194,2212499,"void printPattern(int n) 
{ 
    cout<<n;
    if(n<=0) return;
    cout<<"" "";
    printPattern(n-5);
    cout<<"" ""<<n;
}",1.0,1111111111
Recursion_4,1392194,2212499,"int findMax(int* arr, int length)
{
 if (length == 1) {
        return arr[0];
    }

    int maxRest = findMax(arr + 1, length - 1);
    return (arr[0] > maxRest) ? arr[0] : maxRest;
}",1.0,1111111111
Recursion_5,1392194,2212499,"bool isPalindrome(string str) 
{ 
//! do dai cua chuoi hien tai
    int len = str.length();
//! diem co so cua de quy
    if(len == 0 || len == 1) return true;
//! neu vi tri dang xet la khoang trong thi bo qua    
    if(str[0] == ' ') return isPalindrome(str.substr(1));
    else if(str[len - 1] == ' ') return isPalindrome(str.substr(0,len - 1));
//! neu vi tri dau va cuoi giong nhau thi tra ve true con khac nhau thi tra ve false
    return (str[0] == str[len - 1]) && isPalindrome(str.substr(1,len - 2));
    
}",1.0,1111111111
Recursion_6,1392194,2212499,"int findGCD(int a, int b)
{
        if (b == 0) {
        return a;  // Base case: GCD(a, 0) = a
    }

    // Recursive case: GCD(a, b) = GCD(b, a % b)
    return findGCD(b, a % b);

}",1.0,1111111111
Recursion_7,1392194,2212499,"int decimalToBinary(int decimal_number) 
{ 
 if (decimal_number == 0) {
        return 0;  // Base case: 0 in binary is 0.
    }

    int remainder = decimal_number % 2;
    int binary = remainder + 10 * decimalToBinary(decimal_number / 2);

    return binary;
} ",1.0,1111111111
Recursion_8,1392194,2212499,"string expand(string s) {
//! Đây là trường hợp cơ bản của đệ quy. Nếu chuỗi đầu vào rỗng, hàm trả về một chuỗi rỗng.
    if(s.length()==0){
        return """";
    }
    else if((s[0]>='a' && s[0]<='z') || (s[0]>='A' && s[0]<='Z')){
        return s[0]+expand(s.substr(1));
    }
//! 
    else if(s[0]>='2'&&s[0]<='9'){
        if(s[1]=='('){
            s[0]--;
            string x=expand('1'+s.substr(2));
            return x+expand(s[0]+s.substr(2))+expand(s.substr(1));

        }
        else{
            s[0]--;
            return expand('1'+s.substr(1))+expand(s);
        }
    }
    else if(s[0]=='1'){
        if(s[1]=='('){
            string x=expand(s.substr(2));
            return x+expand(s.substr(x.length()+3));
        }
        else{
            return expand(s.substr(1));
        }
    }
    else if(s[0]=='0'){
        return expand(s.substr(2+expand(s.substr(2)).length()));
    }
    else if(s[0]==')'){
        return """";
    }
    else if(s[0]=='('){
        int x=expand(','+s.substr(1)).length();

        return expand(s.substr(x+2));
    }
    else{
        if(s[1]=='('){
            string x=expand(','+s.substr(2));
            return ""aa""+x+expand(','+s.substr(x.length()+3));
        }
        else if(s[1]==')'){
            return """";
        }
        else{
            return 'a'+expand(','+s.substr(2));
        }

    }
}",1.0,11111
Recursion_9,1392194,2212499,"void printHailstone(int number)
{
    if(number == 1){
        cout << 1;
        return;
    }
    cout << number << "" "";
//! neu so chan thi % 2 con so le thi * 3  + 1
    if(number % 2 == 0) printHailstone(number /2 );
    else printHailstone(number*3 + 1);
}",1.0,1111111111
Recursion_10,1392194,2212499,"int myArrayToInt(char *str, int n) 
{ 
  if(n == 0) return 0;
    return str[n-1] - '0' + myArrayToInt(str,n-1)*10;
}",1.0,1111111111
Recursion_12,1392194,2212499,"int findGCD(int a, int b)
{
    if(a == b) return a;
    else if(a > b) return findGCD(a - b,b);
    return findGCD(b - a,a);
}

int findLCM(int a, int b)
{
//! dung cong thu tim boi chung nho nhat
    return a*b/findGCD(a,b);
}
",1.0,1111111111
Recursion_15,1392194,2212499,"string reverseSentence(string s) {
//! điểm cơ sở của đệ quy
    if(s.length() <= 1) return s;
//! tìm khoảng trắng đầu tiên
    int r = s.find("" "");
//! nếu không tìm khoảng trắng đầu tiên thì return về chuỗi hiện tại
    if(r == -1) return s;
    string right = s.substr(0,r);
//! tìm khoảng trắng cuối cùng
    int l = s.rfind("" "");
    string left = s.substr(l+1);
//! trường hợp thỏa hết ở trên và chỉ còn 1 khoảng trắng
    if(r == l) return left + "" "" + right; 
//! lời gọi đệ quy 
    string mid = reverseSentence(s.substr(r+1,l - r - 1));
    return left + "" "" + mid + "" "" + right;
}",1.0,1111111111
Recursion_17,1392194,2212499,"// Function to find length of Longest Common Subsequence of
// sequences `X[0…m-1]` and `Y[0…n-1]`
int LCSLength(string X, string Y, int m, int n)
{
    // return if we have reached the end of either sequence
    if (m == 0 || n == 0) {
        return 0;
    }

    // if last character of `X` and `Y` matches
    if (X[m - 1] == Y[n - 1]) {
        return LCSLength(X, Y, m - 1, n - 1) + 1;
    }

    // else if last character of `X` and `Y` don't match
    return max(LCSLength(X, Y, m, n - 1), LCSLength(X, Y, m - 1, n));
}

// Function to implement Shortest Common Supersequence (SCS) function
int superString(string X, string Y, int m, int n)
{
    // to get length of the shortest supersequence of `X` and `Y`,
    // we take sum of lengths of `X` and `Y` and subtract the
    // length of their Longest Common Subsequence (LCS)
    return m + n - LCSLength(X, Y, m, n);
}",1.0,1111111111
Recursion_18,1392194,2212499,"int strLen(char* str)     
{ 
   return *str ?1 + strLen(str + 1)  : 0;
} ",1.0,1111111111
Recursion_19,1392194,2212499,"bool containsPattern(char* text, char* pattern)
{
    if (*pattern == '\0') {
        return true;
    }

    // If the text is empty but the pattern is not, it's not found in the text
    if (*text == '\0') {
        return false;
    }

    // If the current characters of the pattern and text match
    if (*text == *pattern) {
        return containsPattern(text + 1, pattern + 1);
    }

    // If the current characters of the pattern and text don't match
    return containsPattern(text + 1, pattern);
}",0.8,1111111001
Recursion_9,1398218,2212741,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     if(number==1) cout<<number;
     else{
     cout<<number<<"" "";
     if(number%2==0) return printHailstone(number/2);
     if(number%2!=0) return printHailstone(number*3+1);
     }
}",1.0,1111111111
Recursion_10,1398218,2212741,"int myArrayToInt(char *str,int n, int idx){
    
}


int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
     if(n==1) return str[n--];
     else{
         int sum=
     }
}",0.2,
Recursion_11,1398218,2212741,"
int i=1;
int reverseFactorial(int n) {
    // STUDENT ANSWER
    if(n/i==1&&n%i==0) {
        int k=i;
        i=1;
        return k;
    }
    else{
        if(n%i!=0) {
            i=1;
            return -1;
        }
        n/=i;
        i++;
        return reverseFactorial(n);
    }
}",1.0,1111111111
Recursion_12,1398218,2212741,"int findGCD(int a, int b)
{
    if(a>=b){
        if(a%b==0) return b;
        else{
            return findGCD(b,a%b);
        }
    }
    else{
        if(b%a==0) return a;
        else{
            return findGCD(a,b%a);
        }
    }
}

int findLCM(int a, int b)
{
    return (a/findGCD(a,b))*b;
}",1.0,1111111111
Recursion_13,1398218,2212741,"// int idx=0;
// int open=0;
// int close=0;
// int res=0;
// int mininumBracketAddHelper(string s, int idx, int open, int close, int res) {
//     int length=s.length();
//     if (idx == length) {
//         return res + open ;
//     }

//     if (s[idx] == '(') {
//         open++;
//     } else {
//         if (open <= 0) {
//             res++;
//         } else {
//             open--;
//             close++;
//         }
//     }

//     return mininumBracketAddHelper(s, idx + 1, open, close, res);
// }
int mininumBracketAdd(string s) {
    // // STUDENT ANSWER
    // int length=s.length();
    // if(idx==length){
    //     int tmp=open;
    //     int tmp3=res;
    //     open=0;close=0;idx=0;;res=0;
    //     return tmp3+tmp;
    // }
    // else{
    //     if(s[idx]=='('){
    //         open++;
    //     }
    //     else{
    //         if(open<=0) res++;
    //         else{
    //         open--;
    //         close++;
    //         }
    //     }
    //     idx++;
    //     return mininumBracketAdd(s);
    // }
    // 
    int m = s.find(""()"") ;
    if(s.find(""()"") >= s.length() || s.find(""()"") < 0) return s.length();
    else  {
        s.erase(m,2);
        return mininumBracketAdd(s);

}
}",0.9,1111111110
Recursion_2,1399594,1913560,"void printArray(int n)
{
    if (n >= 0) {
        printArray(n - 1);
        if (n == 0) std::cout << n;
        else std::cout << "", "" << n;
    }
}",1.0,1111111111
Recursion_3,1399594,1913560,"void printPattern(int n) 
{ 
    static int count1 = 0;
    static int count2 = 0;
    if (n <= 0) {
        if (count1 == count2) cout << n;
        else cout << n << "" "";
        return;
    }

    cout << n << "" "";
    count1 += 1;
    printPattern(n - 5);
    count2 += 1;
    if (count1 == count2) cout << n;
    else cout << n << "" "";
}",1.0,1111111111
Recursion_4,1399594,1913560,"int findMax(int* arr, int length)
{
    if (length == 1)
        return arr[0];
    return max(arr[length - 1], findMax(arr, length - 1));
}",1.0,1111111111
Recursion_5,1399594,1913560,"bool isPalindromeRecursive(string str, int start, int end) {
    if (start >= end) {
        return true;
    }

    if (str[start] == ' ') return isPalindromeRecursive(str, start + 1, end);
    else if (str[end] == ' ') return isPalindromeRecursive(str, start, end - 1);
    else if (str[start] == str[end]) return isPalindromeRecursive(str, start + 1, end - 1);
    
    return false;
}

bool isPalindrome(string str) 
{ 
    int length = str.length();
    return isPalindromeRecursive(str, 0, length - 1);
}",1.0,1111111111
Recursion_6,1399594,1913560,"int findGCD(int a, int b)
{
    if (b == 0) {
        return a;
    } else {
        return findGCD(b, a % b);
    }
}",1.0,1111111111
Recursion_7,1399594,1913560,"int decimalToBinary(int decimal_number) 
{ 
    if (decimal_number == 0) {
        return 0;
    } else {
        return (decimal_number % 2) + 10 * decimalToBinary(decimal_number / 2);
    }
} ",1.0,1111111111
Recursion_9,1399594,1913560,"void printHailstone(int number)
{
    if (number == 1) {cout << number; return;}
    else cout << number << "" "";
    if (number % 2 == 1) printHailstone(number * 3 + 1);
    else printHailstone(number / 2);
    return;
}",1.0,1111111111
Recursion_2,1400063,2213250,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if (n == 0) {
         cout <<""0"";
         return;
     }
     else {

        printArray(n-1);
        cout <<"", "" <<n;
     }
}",0.95,1111111111
Recursion_3,1400063,2213250,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
        if(n <= 0) cout << n;
         else{
         cout <<n <<"" "";
         printPattern(n-5);
         cout <<"" ""<< n;
         }
}",1.0,1111111111
Recursion_4,1400063,2213250,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
          if(length==1) return *arr;
     if(arr[0]>arr[length-1]){
         return findMax(arr, length-1);
     }
     else{
         return findMax(arr+1, length-1);
     }
}",1.0,1111111111
Recursion_5,1400063,2213250,"bool isPalindrome(string str) 
{ 
    int n= str.length();
    if(str.length()<=1) return 1;
    if(str[0] == ' ') return (isPalindrome(str.substr(1, n-1)));
    if(str[n-1] == ' ') return (isPalindrome(str.substr(0, n-1)));
    if(str[0]==str[n-1]) return (isPalindrome(str.substr(1, n-2)));
    else return 0;
}",1.0,1111111111
Recursion_6,1400063,2213250,"int findGCD(int a, int b)
{

    if(b>a) swap (a,b);
    if(a % b == 0){
        return b;
    }
    return findGCD(b, a%b);

}",1.0,1111111111
Recursion_7,1400063,2213250,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if (decimal_number == 0) return 0;
    if (decimal_number % 2 == 0) return 10 * decimalToBinary(decimal_number / 2);
    else return 10 * decimalToBinary(decimal_number / 2) + 1;

} ",1.0,1111111111
Recursion_2,1400064,2210532,"void printArray(int n)
{
    if(n==0){cout<<n;return;}
    printArray(n-1);
    cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1400064,2210532,"void printPattern(int n){
    if(n<=0){
        cout<<n;return;
    }
    cout<<n<<"" "";
    printPattern(n-5);
    cout<<"" ""<<n;
    
}",1.0,1111111111
Recursion_4,1400064,2210532,"int findMax(int* arr, int length)
{
    if(length == 1)return arr[0];
    else return max(arr[length-1],findMax(arr, length-1));
}",1.0,1111111111
Recursion_5,1400064,2210532,"string removeSpaces(string str)
{
    str.erase(remove(str.begin(), str.end(), ' '), str.end());
    return str;
}
bool isPalindromeHelper(const string& str, int start, int end) {
    // Base case: If the start index is greater than or equal to the end index, it's a palindrome.
    if (start >= end) {
        return true;
    }

    // Compare characters at the start and end positions.
    if (str[start] != str[end]) {
        return false; // If they are not equal, it's not a palindrome.
    }

    // Recursively check the substring between start and end.
    return isPalindromeHelper(str, start + 1, end - 1);
}

bool isPalindrome(const string& str) {
    string newstr=removeSpaces(str);
    int length = newstr.length();
    
    // Call the helper function with the start and end indices.
    return isPalindromeHelper(newstr, 0, length - 1);
}",1.0,1111111111
Recursion_6,1400064,2210532,"int findGCD(int a, int b)
{
    if(b != 0)return findGCD(b,a%b);
    else return a;
}",1.0,1111111111
Recursion_7,1400064,2210532,"int decimalToBinary(int decimal_number) 
{ 
   if(decimal_number == 0)return 0;
   else return (decimal_number%2 + 10 * decimalToBinary(decimal_number / 2));
} ",1.0,1111111111
Recursion_9,1400064,2210532,"void printHailstone(int number) {
    cout << number;

    if (number == 1) {
        return; 
    }

    if (number % 2 == 0) {
        cout<<"" "";
        printHailstone(number / 2);
    } else{
        cout<<"" "";
        printHailstone(number * 3 + 1);
    }
}",1.0,1111111111
Recursion_10,1400064,2210532,"#include <bits/stdc++.h>
int myArrayToInt(char *str, int n) 
{ 
    if(n==1)return str[0] - '0';
    else{
        char* tmp = new char[n-1];
        tmp= strncpy(tmp, str+1, n-1);
        int y= myArrayToInt(tmp, n-1);
        int x=str[0] - '0';
        x= x*pow(10, n-1) + y;
        return x;
    }
}",1.0,1111111111
Recursion_11,1400064,2210532,"int reverseFactorial(int n, int k=2) {
    if(n == 1)return 1;
    else if(n<=0 || n%k != 0){
        return -1;
    }
    
    return (reverseFactorial(n/k, k+1)== -1)?-1:max(k, reverseFactorial(n/k, k+1));
}",1.0,1111111111
Recursion_12,1400064,2210532,"int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}
int findLCM(int a, int b)
{
    return (a*b)/gcd(a,b);
}",1.0,1111111111
Recursion_13,1400064,2210532,"int mininumBracketAdd(string s) {
    static int count=0;
    static int check=0;
    if(s.empty())return check+count;
    else if(s[0] == '(')check+=1;
    else if(s[0] == ')'){
        check -=1;
        if(check < 0){
            count+=1;check=0;
        }
    }
    return mininumBracketAdd(s.substr(1));
}",0.9,1111111110
Recursion_15,1400064,2210532,"string reverseSentence(string s) {
    // STUDENT ANSWER
}",0.1,0010000000
Recursion_2,1400640,2211738,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    if(n == 0) {
        cout << n;
        return;
    }
    printArray(n-1);
    cout << "", "" << n;
}",1.0,1111111111
Recursion_3,1400640,2211738,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n <= 0){
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n-5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1400640,2211738,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if(length == 1) return arr[0];
    return max(arr[0], findMax(arr+1, length-1));
}",1.0,1111111111
Recursion_5,1400640,2211738,"bool isPalindrome(string str) 
{ 
    if(str.length() <= 1) return true;
    if(str[0] == str[str.length()-1]){
        if(str[1] == ' ' && str[str.length()-2] == ' '){
            return isPalindrome(str.substr(2, str.length()-4));
        }else if(str[1] == ' '){
            return isPalindrome(str.substr(2, str.length()-3));
        }else if(str[str.length()-2] == ' '){
            return isPalindrome(str.substr(1, str.length()-3));
        }else {
            return isPalindrome(str.substr(1, str.length()-2));
        }
    }
    return false;
}",1.0,1111111111
Recursion_6,1400640,2211738,"int findGCD(int a, int b)
{
     if(b == 0) return -1;
    return (a%b == 0)? b : findGCD(b, a%b);
}",1.0,1111111111
Recursion_7,1400640,2211738,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(decimal_number == 0){
        return 0;
    }
    return (decimal_number%2) + decimalToBinary(decimal_number/2)*10;
} ",1.0,1111111111
Recursion_9,1400640,2211738,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if(number == 1) {
        cout << number;
        return;
    }
    cout << number << "" "";
    if(number%2==0){
        printHailstone(number/2);
    }else {
        printHailstone(3*number+1);
    }
}",1.0,1111111111
Recursion_10,1400640,2211738,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    if(n == 0) return 0;
    return (str[0] - '0')*pow(10,n-1) + myArrayToInt(str+1, n-1);
}",1.0,1111111111
Recursion_11,1400640,2211738,"int k = 1;

int reverseFactorial(int n) {
    // STUDENT ANSWER
        if (n == 1) {
        int x = k;
        k = 1;
        return x;
    }
    if (n < 1) {
        k = 1;
        return -1;
    }
    k++;
    if (n % k != 0) {
        k = 1;
        return -1;
    }
    return reverseFactorial(n / k);
}",1.0,1111111111
Recursion_12,1400640,2211738,"int findGCD(int a, int b){
    if(b == 0) return -1;
    return (a%b==0)?b:findGCD(b,a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_13,1400640,2211738,"long long helper(string s, long long bal, long long ans){
    if(s.length() ==0) return bal+ans;
    if(s[0] == '('){
        return helper(s.substr(1),bal+1,ans);
    }else if(s[0] == ')'){
        if(bal <= 0){
            return helper(s.substr(1),bal,ans+1);
        }else return helper(s.substr(1),bal-1,ans);
    }
    return 0;
}

long long mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return helper(s,0,0);
}",0.9,1111111110
Recursion_14,1400640,2211738,"int helper(vector<int> nums, size_t i,int even, int odd){
    if(i == nums.size()) return 0;
    
    int newEven, newOdd;
    if(nums[i] % 2 == 0){
        newOdd = odd;
        newEven = even+1;
    }else{
        newOdd = even+1;
        newEven = odd;
    }
    return newOdd + helper(nums,i+1,newEven,newOdd);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    return helper(nums,0,0,0)%m;
}",0.9,1111111110
Recursion_15,1400640,2211738,"string reverseSentence(string s) {
    // STUDENT ANSWER
    string temp;
    if(s.length() == 0) return temp;
    int index = s.rfind(' ', s.size()-1);
    if(index != -1){
        temp = s.substr(index+1);
    }else{
        temp = s.substr(0);
        return temp;
    }
    return temp + ' ' +reverseSentence(s.substr(0, s.size()-temp.size()-1));
}",1.0,1111111111
Recursion_18,1400640,2211738,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if(str[0] == '\0') return 0;
    return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_19,1400640,2211738,"bool match(char* text, char* pattern) {
    if (*text == '\0' && *pattern != '\0') return false;
    if (*pattern == '\0') return true;
    if (*text == *pattern) return match(text + 1, pattern + 1);
    return false;
}

bool containsPattern(char* text, char* pattern) {
    if (*text == '\0') return false;
    if (*text == *pattern)
        if (match(text, pattern)) return true;
    return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1400640,2211738,"int helper(int x, int n, int num){
    int val = x - pow(num,n);
    if(val < 0) return 0;
    if(val == 0) return 1;
    return helper(val,n,num+1) + helper(x,n,num+1);
}
int countWaySumOfSquare(int x)
{
    /*  
     * STUDENT ANSWER
     */
    return helper(x,2,1);
}",1.0,1111111111
Recursion_14,1402692,2213298,"int helper2(vector<int>& nums, int &m, int sum, unsigned int left, unsigned int right){
    if (right >= nums.size()) return 0;
    if (sum&1){
        if (right < nums.size() - 1)
            return (1 + helper2(nums, m, sum + nums[right + 1] - nums[left], left + 1, right + 1)) % m;
        else return 1;
    }
    else {
        if (right < nums.size() - 1) 
            return helper2(nums, m, sum + nums[right + 1] - nums[left], left + 1, right + 1) % m;
        else return 0;
    }
}


int helper(vector<int>& nums, int &m, unsigned int index, int sum){
    if (index > nums.size()) return 0;
    return (helper2(nums, m, sum, 0, index - 1)%m + helper(nums, m, index + 1, sum + nums[index])%m)%m;
    
}

int oddSumSublist(vector<int>& nums, int m){
    if (nums.empty()) return 0;
    return helper(nums, m, 1, nums[0]);
}
",0.9,1111111110
Recursion_2,1402894,2212303,"void helper(int m, bool flag) {
    if (m > 0) {
        helper(m - 1, true);
    }
    if (flag) {
        if (m >= 0) {
            cout << m;
            if (m >= 0) {
                cout << "", "";
            }
        }
    } else {
        cout << m;
    }
}
void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    helper(n, false);
}",1.0,1111111111
Recursion_3,1402894,2212303,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n>0){
        cout<<n<<"" "";
        printPattern(n-5);
        cout<<"" ""<<n;
    } else cout<<n;
}",1.0,1111111111
Recursion_4,1402894,2212303,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if (length == 1) {
        return arr[0];
    }
    int max=findMax(arr, length-1);
    // Compare the maximum of the subarray with the last element
    if (arr[length - 1] > max) {
        return arr[length - 1];
    } else {
        return max;
    }
}",1.0,1111111111
Recursion_5,1402894,2212303,"bool isPalindrome(string str) 
{   
    bool result;
    if(str.length()<=1) return true;
    if(str[0]==' ') str=str.substr(1,str.length()-1);
    if(str[str.length()-1]==' ') str=str.substr(0,str.length()-1);
    if(str[0]==str[str.length()-1]){
        result = isPalindrome(str.substr(1,str.length()-2)); 
    } else return false;
    return result;
}",1.0,1111111111
Recursion_6,1402894,2212303,"int findGCD(int a, int b)
{
    if (a == 0) {
        return b;
    }
    if (b == 0) {
        return a;
    }

    // Recursive case: Apply the Euclidean algorithm
    if (a > b) {
        return findGCD(a % b, b);
    } else {
        return findGCD(a, b % a);
    }
}",1.0,1111111111
Recursion_7,1402894,2212303,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if (decimal_number == 0) {
        return 0; // Base case: The binary representation of 0 is 0.
    }

    int remainder = decimal_number % 2;
    int binary_part = decimalToBinary(decimal_number / 2);
    
    return binary_part * 10 + remainder;
} ",1.0,1111111111
Recursion_8,1402894,2212303,"string multiply(string s, int n) {
    if (n == 0) return """";
    return s+multiply(s, n-1);
}

string expandHelper(string s, size_t& pos) {
    if (pos >= s.size() || s[pos] == ')') {
        return """";
    }

    string result;

    if (isdigit(s[pos])) {
        int n = s[pos] - '0';
        pos++;  

        pos++; 

        string subresult = expandHelper(s, pos);

        pos++;  

        
        result = multiply(subresult, n);
    } else if (islower(s[pos])) {
        result += s[pos];
        pos++;  
    }
    result += expandHelper(s, pos);

    return result;
}

string expand(string s) {
    size_t pos = 0;  
    return expandHelper(s, pos);
}
",1.0,11111
Recursion_9,1402894,2212303,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if(number==1) {
        cout<<number;
        return;
    }
    cout<<number<<"" "";
    if(number%2==0) {
        number=number/2;
    } else number=number*3+1;
    printHailstone(number);
}",1.0,1111111111
Recursion_10,1402894,2212303,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    int result = str[0] - '0';
    if(n==1) return result;
    result=result*pow(10,n-1);
    result+=myArrayToInt(str+1, n-1); 
    return result;
}",1.0,1111111111
Recursion_11,1402894,2212303,"int helper(int n, int f){
    if(n==f) return f;
    if(n%f==0){
        return helper(n/f, f+1);
    } else return -1;
}
int reverseFactorial(int n) {
    // STUDENT ANSWER
    if(n==1) return 1;
    int result=helper(n,2);
    return result;
}",1.0,1111111111
Recursion_12,1402894,2212303,"int findGCD(int a, int b) {
    if (b == 0) {
        return a; // Base case: GCD(a, 0) = a
    }
    return findGCD(b, a % b); // Recursive case: GCD(a, b) = GCD(b, a % b)
}

// Function to calculate the Lowest Common Multiple (LCM) using recursion
int findLCM(int a, int b) {
    // LCM(a, b) = (a * b) / GCD(a, b)
    return (a * b) / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1402894,2212303,"int helper(string s, int remain1, int remain2, int flag) {
    if (s[0] == '(') {
        remain1++;
    } else {
        if (remain1 > 0) {
            remain1--;
        } else {
            remain2++;
        }
    }
    if (s.length() == 1) {
        if (flag==0)
        return remain1 + remain2;
        if(flag==1) return remain1;
        if(flag==2) return remain2;
    }
    return helper(s.substr(1, s.length() - 1), remain1, remain2, flag);
}

int mininumBracketAdd(string s) {
    if (s == """") {
        return 0;
    }
    int l=s.length();
    int d=l/2;
    string s1=s.substr(0, d);
    int remain1=helper(s1, 0,0,1);
    int remain2=helper(s1, 0,0,2);
    return helper(s.substr(d, l-d), remain1, remain2,0);
}
",1.0,1111111111
Recursion_14,1402894,2212303,"int countSublists(vector<int>& nums, size_t index, int sum, int m) {
    if (index == nums.size()) {
        return sum % 2 == 1 ? 1 : 0;
    }

    // Include the current element in the sum
    int includeCurrent = countSublists(nums, index + 1, sum + nums[index], m);

    // Exclude the current element from the sum
    int excludeCurrent = countSublists(nums, index + 1, sum, m);

    return (includeCurrent + excludeCurrent) % m;
}

int oddSumSublist(vector<int>& nums, int m) {
    int result = countSublists(nums, 0, 0, m);
    return result;
}",0.5,01000
Recursion_15,1402894,2212303,"int findSpace(string s) {
    
    if (s[0] == ' ') return 0; 
    else {
        if(s.length()<=1) return 1;
        else
        return  1+ findSpace(s.substr(1));
        
    }
}

string reverseSentence(string s) {
    if (s == """") return """";
    
    size_t spacePos = findSpace(s);
  
    if (s.length()==spacePos) {
        return s; // No more spaces found, return the input string as is
        cout<<s<<endl;
    } else {
        // Recursively reverse the sentence after the first space and concatenate it with the first word
        return reverseSentence(s.substr(spacePos + 1)) + "" "" + s.substr(0, spacePos);
    }
}
",0.8,1111111111
Recursion_17,1402894,2212303,"int superString(string x, string y, int m, int n) {
      if (m == 0) {
        return n; // If the first string is empty, the superstring length is the length of the second string.
    }
    if (n == 0) {
        return m; // If the second string is empty, the superstring length is the length of the first string.
    }
    
    // If the last characters of both strings match, we can merge them and reduce the problem to the rest of the strings.
    if (x[m - 1] == y[n - 1]) {
        return superString(x, y, m - 1, n - 1) + 1;
    } else {
        // If the last characters don't match, we have two options: either append one character from x or one character from y.
        int option1 = superString(x, y, m - 1, n) + 1;
        int option2 = superString(x, y, m, n - 1) + 1;
        return min(option1, option2);
    }
}",1.0,1111111111
Recursion_18,1402894,2212303,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if(*str=='\0') return 0;
    else return 1+ strLen(str+1);
} ",1.0,1111111111
Recursion_19,1402894,2212303,"bool check(char* text, char* pattern, int tPos, int pPos){
    if(text[tPos]=='\0'&&pattern[pPos]=='\0'){
        return true;
    }
    if(text[tPos]=='\0'&&pattern[pPos]!='\0'){
        return false;
    }
    if(text[tPos]!='\0'&&pattern[pPos]=='\0'){
        return true;
    }
    if(text[tPos]==pattern[pPos]){ return check(text, pattern, tPos+1, pPos+1);}
    else{
        return(check(text,pattern, tPos+1, 0));
    }
    
}
bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
    return check(text, pattern, 0 ,0);
}",1.0,1111111111
Recursion_20,1402894,2212303,"int countWays(int x, int n) {
    // Base case: If x becomes 0, we found a way to express it as a sum of squares.
    if (x == 0) {
        return 1;
    }
    
    // Base case: If x becomes negative or if n becomes 0, there are no valid ways.
    if (x < 0 || n == 0) {
        return 0;
    }
    
    // Calculate the count of ways:
    // 1. Exclude n^2 from the sum and consider the rest.
    // 2. Include n^2 in the sum and consider the remaining part.
    return countWays(x, n - 1) + countWays(x - pow(n, 2), n - 1);
}

int countWaySumOfSquare(int x) {
    // Start with n = sqrt(x) as the maximum natural number to consider.
    int n = sqrt(x);
    return countWays(x, n);
}",1.0,1111111111
Recursion_2,1404222,2213298,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    if (n < 0) return;
    printArray(n-1);
    if (n != 0) cout << "", "";
    cout << n;
}",1.0,1111111111
Recursion_3,1404222,2213298,"int m;

void add (int n) {
    if (n == ::m) {
        cout << n;
        return;
    }
    cout << n << "" "";
    add(n + 5);
}

void sub (int n) {
    if (n <= 0) add(n);
    else {
        cout << n << "" "";
        sub(n - 5);
    }
}

void printPattern(int n) {
    ::m = n;
    sub(n);
}",1.0,1111111111
Recursion_4,1404222,2213298,"int findMax(int *arr, int length) {
	if (!(length-1)) return arr[0];
	int max = findMax(arr, length-1);
	if (arr[length-1] < max) return max;
	return arr[length-1];
}",1.0,1111111111
Recursion_5,1404222,2213298,"string deletespace(string str) {
    if (str.find("" "") > 0 && str.find("" "") < str.length()) {
        return deletespace(str.erase(str.find("" ""), 1));
    }
    return str;
}

bool isPalindrome (string str) {
    str = deletespace(str);
    if (str.length() == 0 || str.length() == 1) return 1;
    if (str[0] != str[str.length()-1]) return 0;
    return isPalindrome(str.substr(1,str.length()-2));
}
",1.0,1111111111
Recursion_6,1404222,2213298,"int findGCD(int a, int b)
{
    if (a == b) return a;
    if (a > b) return findGCD(a-b, b);
    return findGCD(a, b-a);
}",1.0,1111111111
Recursion_7,1404222,2213298,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if (decimal_number == 0) return 0;
    return (decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2));
} ",1.0,1111111111
Recursion_8,1404222,2213298,"string loop (string s, int k) {
     if (!k) return """";
     else return s + loop(s, k - 1);
}

int findbegin(string s, int f, int run) {
    if (s[run] == ')') return f;
    if (s[run] == '(') return findbegin(s, run, run + 1);
    else return findbegin(s, f, run + 1);
}

int findend(string s, int found) {
    if (s[found] == ')') return found;
    else return findend(s, found+1);
}

int number(string s, unsigned int run) {
    if (run > s.length()) return -1;
    if (s[run] >= 48 && s[run] <= 58) return run;
    else return number(s, run+1);
}

string solve(string s, int start) {
    if (s[start] >= 48 && s[start] <= 58) {
        int begin = findbegin(s, 0, 0);
        int end = findend(s, begin);
        string temp = loop(s.substr(begin + 1, end - begin - 1), s[begin-1] - '0');
        return solve(s.replace(begin - 1, end - begin + 2, temp), start);
    }
    int out = number(s, 0);
    if (out == -1) return s;
    else return solve(s, out);
}

string expand(string s) {
    return solve(s, 0);
}",1.0,11111
Recursion_9,1404222,2213298,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if (number <= 0) return;
    cout << number;
    if (number == 1) return;
    cout << "" "";
    if (number&1) printHailstone(number*3 + 1);
    else printHailstone(number/2);
}",1.0,1111111111
Recursion_10,1404222,2213298,"int myArrayToInt(char *str, int n) {
    if ( n == 1 ) return str[0] - '0';
    int x = myArrayToInt(str+1,n-1);
    int y = str[0] - '0';
    y = y * pow(10, n - 1) + x;
    return y;
}",1.0,1111111111
Recursion_11,1404222,2213298,"int fac(int k) {
    if (k == 1) return 1;
    return k * fac(k-1);
}

int solve(int n, int k) {
    int temp = fac(k);
    if (temp > n) return -1;
    if (temp == n) return k;
    return solve(n, k+1);
}

int reverseFactorial(int n) {
    return solve(n , 1);
}",1.0,1111111111
Recursion_12,1404222,2213298,"int findGCD(int a, int b) {
    if (a == b) return a;
    if (a > b) return findGCD(a-b, b);
    return findGCD(a, b-a);
}

int findLCM(int a, int b)
{
    int GCD = findGCD(a, b);
    return a*b/GCD;
}",1.0,1111111111
Recursion_13,1404222,2213298,"int solver(string& s,unsigned int index, int balance){
    if (index == s.size()) return abs(balance);
    if (s[index] == '(') {
        return solver(s, index + 1, balance + 1);
    }
    else {
        if (balance > 0) return solver(s, index + 1, balance - 1);
        else return 1 + solver(s, index + 1, balance);
    }
}

int mininumBracketAdd(string s) {
    return solver(s, 0, 0);
}",1.0,1111111111
Recursion_14,1404222,2213298,"int helper2(vector<int>& nums, int &m, int sum, unsigned int left, unsigned int right){
    if (right >= nums.size()) return 0;
    if (sum&1){
        if (right < nums.size() - 1)
            return (1 + helper2(nums, m, sum + nums[right + 1] - nums[left], left + 1, right + 1)) % m;
        else return 1;
    }
    else {
        if (right < nums.size() - 1) 
            return helper2(nums, m, sum + nums[right + 1] - nums[left], left + 1, right + 1) % m;
        else return 0;
    }
}


int helper(vector<int>& nums, int &m, unsigned int index, int sum){
    if (index > nums.size()) return 0;
    return (helper2(nums, m, sum, 0, index - 1)%m + helper(nums, m, index + 1, sum + nums[index])%m)%m;
    
}

int oddSumSublist(vector<int>& nums, int m){
    if (nums.empty()) return 0;
    return helper(nums, m, 1, nums[0]);
}
",0.9,1111111110
Recursion_15,1404222,2213298,"string reverseSentence(string s) {
    if (s.find(' ') == string::npos) return s;
    else {
        string s1 = s.substr(0, s.find(' '));
        string s2 = s.substr(s.find(' ') + 1);
        return reverseSentence(s2) + ' ' + s1;
    }
}",1.0,1111111111
Recursion_17,1404222,2213298,"int max(int x, int y) {
    return (x>y) ? x : y;
}

int lcs(string X, string Y, int m, int n)
{
    if (m == 0 || n == 0) return 0;
    if (X[m - 1] == Y[n - 1]) return lcs(X, Y, m - 1, n - 1) + 1;
    else return max(lcs(X, Y, m, n - 1), lcs(X, Y, m - 1, n));
}

int superString(string X, string Y, int m, int n)
{
    int lcs_length = lcs(X, Y, m, n);
    return m + n - lcs_length;
}",1.0,1111111111
Recursion_18,1404222,2213298,"int dequy(char *str, int lens) {
    if (str[0] == '\0') return lens;
    return dequy(str+1, lens+1);
}

int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     return dequy(str, 0);
} ",1.0,1111111111
Recursion_19,1404222,2213298,"bool solve(char *test, char *pattern, bool k, int head) {
    if (*pattern == '\0' && k) return 1;
    if (*test == '\0') return 0;
    if (*pattern != *test) {
        if (!head) return solve(test + 1, pattern, 0, head);
        return solve(test, pattern - 1, 0, head - 1);
    }
    if (*pattern == *test) return solve(test + 1, pattern + 1, 1, head + 1);
    return 0;
}

bool containsPattern(char *test, char *pattern) {
    return solve(test, pattern, 1, 0);
}",1.0,1111111111
Recursion_20,1404222,2213298,"int countWaysUtil(int x, int n)
{
    if (x == 0) return 1;
    if (n <= 0) return 0;
    int res = countWaysUtil(x, n - 1);
    if (x >= n * n) res += countWaysUtil(x - n * n, n - 1);
    return res;
}

int countWaySumOfSquare(int x)
{
    return countWaysUtil(x, sqrt(x));
}",1.0,1111111111
Recursion_2,1405513,2211170,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
  if (n > 0) {
        printArray(n - 1);
        cout << "", "";
    }
    
    cout << n;
}",1.0,1111111111
Recursion_3,1405513,2211170,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
         if (n <= 0) {
        std::cout << n;
        return;
    }

    std::cout << n << "" "";
    printPattern(n - 5);
    std::cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1405513,2211170,"int findMaxHelper(int* arr, int length, int currentMax) {
    if (length == 0) {
        return currentMax;
    }

    int element = arr[0];

    if (element > currentMax) {
        return findMaxHelper(arr + 1, length - 1, element);
    } else {
        return findMaxHelper(arr + 1, length - 1, currentMax);
    }
}

// Main function to find the maximum element in the array
int findMax(int* arr, int length) {
    return findMaxHelper(arr, length, arr[0]);
}",1.0,1111111111
Recursion_5,1405513,2211170,"bool isPalindromeHelper(const string& str, int start, int end) {
    if (start >= end) {
        return true;
    }

    if (str[start] == ' ') {
        return isPalindromeHelper(str, start + 1, end);
    }

    if (str[end] == ' ') {
        return isPalindromeHelper(str, start, end - 1);
    }

    if (tolower(str[start]) != tolower(str[end])) {
        return false;
    }

    return isPalindromeHelper(str, start + 1, end - 1);
}

int stringLength(const char* str) {
    if (*str == '\0') {
        return 0;
    }

    return 1 + stringLength(str + 1);
}

// Main function to check if the string is a palindrome
bool isPalindrome(string str) {
    const char* cstr = str.c_str();
    int length = stringLength(cstr);
    return isPalindromeHelper(cstr, 0, length - 1);
    
}
    ",1.0,1111111111
Recursion_6,1405513,2211170,"int findGCD(int a, int b)
{
    if (a == b)
        return a;
    
    if (a > b)
        return findGCD(a - b, b);
    else
        return findGCD(a, b - a);
}",1.0,1111111111
Recursion_7,1405513,2211170,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
         if (decimal_number == 0) {
        return 0;  // Base case: decimal_number is 0, its binary representation is also 0
    }

    int remainder = decimal_number % 2;
    int binary_digits = decimalToBinary(decimal_number / 2);

    return binary_digits * 10 + remainder;
} ",1.0,1111111111
Recursion_8,1405513,2211170,"std::string repeatHelper(const std::string& s, int repeat) {
    if (repeat <= 0) {
        return """";
    }

    return s + repeatHelper(s, repeat - 1);
}

std::string expandHelper(const std::string& s, size_t& index) {
    if (index >= s.size()) {
        return """";
    }

    std::string result = """";

    if (s[index] == ')') {
        return result;
    }

    if (isdigit(s[index])) {
        int repeat = s[index] - '0';
        index += 2; // Skip the digit and '('
        std::string inside = expandHelper(s, index);
        index++; // Skip the closing parenthesis ')'
        result += repeatHelper(inside, repeat);
    } else {
        result.push_back(s[index]);
        index++;
    }

    result += expandHelper(s, index);

    return result;
}

std::string expand(const std::string& s) {
    size_t index = 0;
    return expandHelper(s, index);
}",1.0,11111
Recursion_9,1405513,2211170,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if (number == 1){
        cout << number;
        return;
    }
        
    else if (number % 2 == 0){
        cout << number << "" "";
        printHailstone(number / 2);
    }
    else {
        cout << number << "" "";
        printHailstone(number * 3 + 1);
    }
}",1.0,1111111111
Recursion_10,1405513,2211170,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */  if (n == 0) {
        return 0;
    }
    
    int lastDigit = str[n - 1] - '0';
    int remainingNumber = myArrayToInt(str, n - 1);
    
    return remainingNumber * 10 + lastDigit;
}",1.0,1111111111
Recursion_11,1405513,2211170,"int reverseFactorialHelper(int n, int k) {
    if (n == 1) {
        return k;
    }

    if (n % k != 0 || n < k) {
        return -1;
    }

    return reverseFactorialHelper(n / k, k + 1);
}

int reverseFactorial(int n) {
    int p = reverseFactorialHelper(n, 2);
    if (p == -1)
        return p;
    else
        return p - 1;
}",1.0,1111111111
Recursion_12,1405513,2211170,"int findGCD(int a, int b) {
    if (b == 0) {
        return a;
    }
    
    return findGCD(b, a % b);
}

int findLCM(int a, int b) {
    int gcd = findGCD(a, b);
    
    return (a * b) / gcd;
}",1.0,1111111111
Recursion_13,1405513,2211170,"int minimumBracketAddHelper(const string& s, size_t index, int stackSize) {
    if (index == s.length()) {
        // All characters have been processed
        return stackSize;
    }

    if (s[index] == '(') {
        // Push an opening bracket onto the ""stack""
        return minimumBracketAddHelper(s, index + 1, stackSize + 1);
    }

    if (s[index] == ')') {
        // Pop a matching opening bracket from the ""stack"" if possible
        if (stackSize > 0) {
            return minimumBracketAddHelper(s, index + 1, stackSize - 1);
        } else {
            // Add a closing bracket to balance the string
            return 1 + minimumBracketAddHelper(s, index + 1, stackSize);
        }
    }

    // Skip non-bracket characters
    return minimumBracketAddHelper(s, index + 1, stackSize);
}

int mininumBracketAdd(const string& s) {
    return minimumBracketAddHelper(s, 0, 0);
}
",1.0,1111111111
Recursion_14,1405513,2211170,"int countOddSubarrays(vector<int>& arr, int n, int sum, int cnt, int even, int odd) {
    if (n == 0) {
        return cnt;
    }

    sum += arr[n - 1]; // Add the current element to the prefix sum

    if (sum % 2 != 0) { // If the sum is odd
        odd++;
        cnt++;
        cnt += even; // Add the count of even-sum subarrays
    } else { // If the sum is even
        even++;
        cnt += odd; // Add the count of odd-sum subarrays
    }

    return countOddSubarrays(arr, n - 1, sum, cnt, even, odd);
}

int oddSumSublist(const vector<int>& nums, int m) {
    vector<int> arr = nums;
    int n = nums.size();
    int sum = 0, cnt = 0, even = 0, odd = 0;

    return countOddSubarrays(arr, n, sum, cnt, even, odd) % m;
}",1.0,1111111111
Recursion_15,1405513,2211170,"void reverseWordHelper(string& s, int start, int end) {
    if (start >= end) {
        return;
    }

    char temp = s[start];
    s[start] = s[end];
    s[end] = temp;

    reverseWordHelper(s, start + 1, end - 1);
}

void reverseWord(string& s, int start, int end) {
    reverseWordHelper(s, start, end);
}

void reverseWordsHelper(string& s, int start, int end) {
    int n = s.length();
    if (start >= n || end >= n) {
        return;
    }

    if (s[end] == ' ') {
        reverseWord(s, start, end - 1);
        reverseWordsHelper(s, end + 1, end + 1);
    } else if (end == n - 1) {
        reverseWord(s, start, end);
    } else {
        reverseWordsHelper(s, start, end + 1);
    }
}

void reverseWords(string& s) {
    reverseWordsHelper(s, 0, 0);
}

string reverseSentence(string s) {
    reverseWords(s);
    reverseWord(s, 0, s.length() - 1);

    return s;
}",1.0,1111111111
Recursion_17,1405513,2211170,"int superString(const string& x, const string& y, int m, int n) {
    // Base cases
    if (m == 0) return n;
    if (n == 0) return m;

    // If the last characters of x and y are the same, ignore them and recursively find the super string
    if (x[m - 1] == y[n - 1])
        return 1 + superString(x, y, m - 1, n - 1);

    // If the last characters of x and y are different, consider both possibilities:
    // 1. Ignore the last character of x and find the super string of the remaining x and y
    // 2. Ignore the last character of y and find the super string of x and the remaining y
    return 1 + min(superString(x, y, m - 1, n), superString(x, y, m, n - 1));
}",1.0,1111111111
Recursion_18,1405513,2211170,"int strLen(char* str) {
    // Base case: If the current character is null ('\0'), return 0
    if (*str == '\0')
        return 0;
    else
        // Recursive case: Add 1 to the length of the remaining string
        return 1 + strLen(str + 1);
}",1.0,1111111111
Recursion_19,1405513,2211170,"bool checkMatch(char* text, char* pattern, int textIndex, int patternIndex) {
    if (pattern[patternIndex] == '\0') {
        // Reached the end of the pattern, indicating a match
        return true;
    }

    if (text[textIndex] == '\0') {
        // Reached the end of the text without finding a match
        return false;
    }

    if (text[textIndex] == pattern[patternIndex]) {
        // Characters match, continue to the next indices
        return checkMatch(text, pattern, textIndex + 1, patternIndex + 1);
    }

    // Characters don't match, reset the pattern index and increment the text index
    return checkMatch(text, pattern, textIndex + 1, 0);
}

bool containsPattern(char* text, char* pattern) {
    return checkMatch(text, pattern, 0, 0);
}",1.0,1111111111
Recursion_20,1405513,2211170,"int countWaysUtil(int x, int n, int num)
{
    // Base cases
    int val = (x - pow(num, n));
    if (val == 0)
        return 1;
    if (val < 0)
        return 0;
 
    // Consider two possibilities, num is
    // included and num is not included.
    return countWaysUtil(val, n, num + 1) +
           countWaysUtil(x, n, num + 1);
}

int countWaySumOfSquare(int x)
{
    /*  
     * STUDENT ANSWER
     */
      return countWaysUtil(x, 2, 1);
}",1.0,1111111111
Recursion_2,1405881,2211367,"void printArray(int n){
    if(n==0) {cout << ""0"";
    return;}
    else{ printArray(n-1);
    cout << "",""<< "" ""<< n;}
}",1.0,1111111111
Recursion_3,1405881,2211367,"void printPattern(int n) 
{ 
    if(n<=0) {cout << n;
    return;}
    cout << n << "" "";
    printPattern(n-5);
    cout << "" "" << n;

}",1.0,1111111111
Recursion_4,1405881,2211367,"int findMax(int *arr, int length){
    if(length==1) return arr[0];
    int n = findMax(arr+1,length-1);
    return (arr[0]>n) ? arr[0] : n;
}",1.0,1111111111
Recursion_5,1405881,2211367,"string xoakt(string s){
    if(s.length()==0) return"""";
    if(s[0]==' ') return xoakt(s.substr(1));
    return s[0] + xoakt(s.substr(1));
}
bool isPalindrome(string str){
    string s = xoakt(str);
    if(str.length()<=1) return 1;
    if(s[0]!=s[s.length()-1]){
        return 0;
    }
    else{
        return isPalindrome(s.substr(1,s.length()-2));
    }
}",1.0,1111111111
Recursion_6,1405881,2211367,"int findGCD(int a, int b){
    if(b==0) return a;
    return findGCD(b,a%b);
}
",1.0,1111111111
Recursion_7,1405881,2211367,"int decimalToBinary(int n) 
{ 
   return (n<=1) ? n : n % 2 + decimalToBinary(n/2)*10;
} ",1.0,1111111111
Recursion_8,1405881,2211367,"string mulString(const string& s, int number){
    if(number == 0) return """";
    return s + mulString(s,number-1);
}
string IntInString(string s){
    if(s==""""||s[0]<'0'||s[0]>'9'){
        return """";
    }
    return s[0] + IntInString(s.substr(1));
}
string expand(string s){
    if(s=="""") return """";
    else if(s[0]>='0'&&s[0]<='9'){
        string number = IntInString(s);
        string tmp = expand(s.substr(number.length()+1));
        int close = tmp.find(')');
        return mulString(tmp.substr(0,close),stoi(number)) + tmp.substr(close+1);
    }
    return s[0] + expand(s.substr(1));
    }",1.0,11111
Recursion_9,1405881,2211367,"void printHailstone(int n)
{   if(n==1) {cout << 1; return;}
    if(n%2==0){
    cout << n << "" "";
    printHailstone(n/2);
}
    if(n%2==1){
        cout << n << "" "";
        printHailstone(n*3+1);
    }
}",1.0,1111111111
Recursion_10,1405881,2211367,"int myArrayToInt(char* str, int n){
    if(n==1) return str[0]-48;
    return (str[0]-48)*pow(10,n-1) + myArrayToInt(str+1,n-1);

}",1.0,1111111111
Recursion_11,1405881,2211367,"int factorial(int k) {
    if (k <= 1) {
        return 1;
    } else {
        return k * factorial(k - 1);
    }
}

// Helper function to find k such that k! = x
int findKForFactorialHelper(int x, int k) {
    if (factorial(k) == x) {
        return k;
    } else if (factorial(k) > x) {
        return -1;
    } else {
        return findKForFactorialHelper(x, k + 1);
    }
}
int reverseFactorial(int n) {
  return findKForFactorialHelper(n, 1);}",1.0,1111111111
Recursion_12,1405881,2211367,"int findGCD(int a,int b)
{
    if(b==0) return a;
    return findGCD(b,a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_13,1405881,2211367,"int balanceBrackets(const string& s, int index = 0, int openCount = 0, int unmatchedCount = 0) {
    int n = s.length();
    if(index == n){
        return openCount + unmatchedCount;
    }
    if(s[index]=='('){
        return balanceBrackets(s,index+1,openCount+1,unmatchedCount);
    }
    else if(s[index]==')'&&openCount>0){
        return balanceBrackets(s,index+1,openCount-1,unmatchedCount);
    }
    else if(s[index]==')'){
        return balanceBrackets(s,index+1,openCount,unmatchedCount+1);
    }
    else{
        return balanceBrackets(s,index,openCount,unmatchedCount);
    }
}
int mininumBracketAdd(string s) {
    return balanceBrackets(s,0,0,0);
}",1.0,1111111111
Recursion_14,1405881,2211367,"int countOddSublists(const vector<int>& nums, int start, int end, int currentSum) {
    if (start > end) {
        // Base case: end of recursion, no more elements to consider
        return currentSum % 2 == 1 ? 1 : 0;
    }

    // Include the current element in the sum
    int countWithCurrent = countOddSublists(nums, start + 1, end, currentSum + nums[start]);
    // Exclude the current element from the sum
    int countWithoutCurrent = countOddSublists(nums, start + 1, end, currentSum);

    return countWithCurrent + countWithoutCurrent;
}

// Recursive function to count odd sublists starting from all possible indices
int countOddFromAllIndices(const vector<int>& nums, int start, int end) {
    if (start > end) {
        // Base case: end of recursion, no more indices to consider
        return 0;
    }

    // Count odd sublists starting at the current index
    int count = countOddSublists(nums, start, end, 0);

    // Recursively count odd sublists starting from the next index
    int countFromNextIndex = countOddFromAllIndices(nums, start + 1, end);

    return count - countFromNextIndex;
}

// Wrapper function to start recursion from the first index
int oddSumSublist(const vector<int>& nums, int m) {
    int n = nums.size();
    return countOddFromAllIndices(nums, 0, n - 1)%m;
}",0.2,11000
Recursion_15,1405881,2211367,"string tack(string s){
    if(s[0]==' ') return """";
    if(s.length()==0) return """";
    return s[0]+tack(s.substr(1));
}
string reverseSentence(string s,string ans) {
        int n=s.size();
        if(n==0) return """";
        string u = s;
        ans = tack(u);
        u = u.substr(ans.size());
        string val;
        if(s.size()==ans.size()){
             val = reverseSentence(s.substr(ans.size()),"""");
        }
        else{ val=reverseSentence(s.substr(ans.size()+1),"""");}
        val=(val.size()==0?val:(val+"" ""));
        return val+ans;
    }
string reverseSentence(string s){
    return reverseSentence(s,"""");
}",1.0,1111111111
Recursion_18,1405881,2211367,"int strLenhelper(char* str, int i){
    if(str[0]=='\0'){return i;}
    return strLenhelper(str+1,i = i+1);
}
int strLen(char* str)     
{ 
        return strLenhelper(str,0);
}",1.0,1111111111
Recursion_19,1405881,2211367,"bool exactMatch(char *text, char *pat)
{
 if (*text == '\0' && *pat != '\0'){
  return false;}
 
 // Else If last character of pattern reaches
 if (*pat == '\0'){
  return true;}
 
 if (*text == *pat){
  return exactMatch(text + 1, pat + 1);}
 
 return false;
}
 
// This function returns true if 'text' contain 'pat'
bool containsPattern(char *text, char *pat)
{
 // If last character of text reaches
 if (*text == '\0'){
  return false;}
 
 // If current characters of pat and text match
 if (*text == *pat){
  if(exactMatch(text, pat)){
   return 1;}
  else
  {return containsPattern(text + 1, pat);}}
 
 // If current characters of pat and tex don't match
 return containsPattern(text + 1, pat);
}",1.0,1111111111
Recursion_20,1405881,2211367,"int countWaysUtil(int x, int num)
{
    // Base cases
    int val = (x - pow(num, 2));
    if (val == 0)
        return 1;
    if (val < 0)
        return 0;
 
    // Consider two possibilities, num is
    // included and num is not included.
    return countWaysUtil(val, num + 1) +
           countWaysUtil(x, num + 1);
}
 
// Returns number of ways to express
// x as sum of n-th power of two.
int countWaySumOfSquare(int x)
{
    return countWaysUtil(x, 1);
}",1.0,1111111111
Recursion_2,1406072,2013048,"void printArray(int n){
    if(n == 0){
        cout << 0;
        return;
    }
    printArray(n-1);
    cout << "", "" << n;
}",1.0,1111111111
Recursion_3,1406072,2013048,"void printPattern(int n) {
    if (n > 0) {
        cout << n << "" "";
        printPattern(n-5);
    }
    else{
        cout << n;
        return;
    }
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1406072,2013048,"int findMax(int *arr, int length){
    if (length == 1)    return arr[0];
    int maxRest = findMax(arr + 1, length - 1);
    return (arr[0] > maxRest) ? arr[0] : maxRest;
}",1.0,1111111111
Recursion_5,1406072,2013048,"bool isPalindrome(string str){
    if (str[0] == ' ')
        return isPalindrome(str.substr(1, str.length()));
    else if (str[str.length()-1] == ' ')
        return isPalindrome(str.substr(0, str.length()-1));
    if (str.length() == 0 || str.length() == 1) {
        return true;
    }
    if (str[0] != str[str.length() - 1]) {
        return false;
    }
    return isPalindrome(str.substr(1, str.length() - 2));
}",1.0,1111111111
Recursion_6,1406072,2013048,"int findGCD(int a, int b){
    if (a == 0) return b;
    else if(b == 0) return a;
    if(a > b)
        return findGCD(a%b, b);
    else if (a < b)
        return findGCD(a, b%a);
    else return a;
}",1.0,1111111111
Recursion_7,1406072,2013048,"int decimalToBinary(int decimal_number) {
    // Base case: if the number is 0, return 0
    if (decimal_number == 0) {
        return 0;
    }
    // Recursive case: concatenate the binary representation of the quotient with the remainder
    return decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2);
}",1.0,1111111111
Recursion_8,1406072,2013048,"void RepeatString(string &str, const string repeat, int times){
    if(times > 0){
        str += repeat;
        RepeatString(str, repeat, times-1);
    }
    return;
}
string expand(const string& s, size_t& index) {
    if (index >= s.length() || s[index] == ')') return """";
    string result;
    if (isdigit(s[index])) {
        int count = s[index] - '0';  // Convert digit character to integer
        index++;
        if (s[index] == '(') {
            index++; 
            string subResult = expand(s, index);
            RepeatString(result, subResult, count);
        }
    } else if (isalpha(s[index])) 
        result += s[index];
    index++;
    result += expand(s, index);
    return result;
}

string expand(string s) {
    size_t index = 0;
    return expand(s, index);
}",1.0,11111
Recursion_9,1406072,2013048,"void printHailstone(int number)
{
    if(number == 1){
        cout << number;
        return;
    }
    cout << number << "" "";
    if (number%2){
        printHailstone(number*3+1);
    }
    else{
        printHailstone(number/2);
    }
}",1.0,1111111111
Recursion_10,1406072,2013048,"int myArrayToInt(char *str, int n){
    if(n == 0) return 0;
    return (int)(str[n-1]-'0')+10*myArrayToInt(str, n-1);
    // return result;
}",1.0,1111111111
Recursion_11,1406072,2013048,"int Factorial(int n){
    if(n == 1 || n == 0) return 1;
    return n*Factorial(n-1);
}
int isFac(int n, int k){
    int Fac = Factorial(k);
    if(Fac == n){
        return k;
    }
    return (Fac > n) ? -1 : isFac(n, k+1);
}
int reverseFactorial(int n){
    int k = 0;
    if(n == 1) return 1;
    if(n <= 0) return -1;
    return isFac(n, k);
}",1.0,1111111111
Recursion_12,1406072,2013048,"int findGCD(int a, int b) {
  if (b == 0) return a;
  return findGCD(b, a % b);
}

int findLCM(int a, int b) {
  return (a * b) / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1406072,2013048,"string temp = """";
void minBracket(string s, int& count){
    if((int)s.find(""()"") == -1) return ;
    temp = ((int) s.find(""("") != -1) ? s.substr(s.find(""("")) : s;
    int opN = temp.find("")"");
    temp = temp.substr(opN);
    int clN = ((int) temp.find(""("") > 0 ) ? temp.find(""("") : temp.size();
    if(opN > clN && clN > 0) {
        s.replace(s.find(""("") + opN - clN, clN*2, """");
        count -= clN*2;
    }
    else {
        s.replace(s.find(""(""), opN*2, """");
        count -= opN*2;
    }
    minBracket(s, count);
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    temp = """";
    int count = s.size();
    minBracket(s, count);
    return count;
}",1.0,1111111111
Recursion_14,1406072,2013048,"void findSum(const vector<int>& nums, unsigned int i, long long currentSum, long long& count) {
    if (i >= nums.size()) {
        return;
    }
    currentSum += nums[i];
    if (currentSum % 2 != 0) {
        count++;
    }
    findSum(nums, i + 1, currentSum, count);
}

void SumSublist(const vector<int>& nums, unsigned int i, long long& count) {
    if (i >= nums.size()) {
        return;
    }
    long long currentSum = 0;
    findSum(nums, i, currentSum, count);
    SumSublist(nums, i + 1, count);
}

int oddSumSublist(const vector<int>& nums, int m) {
    long long count = 0;
    SumSublist(nums, 0, count);
    return count % m;
}",0.9,1111111110
Recursion_15,1406072,2013048,"void reverString(string s, string & reverStr){
    size_t numOfChars = s.size();    
    if(s[0] == ' ')
        reverString(s.substr(1, numOfChars), reverStr);
    if(numOfChars == 1) reverStr = s + "" "" + reverStr;
    else {
        unsigned int idx = s.find(' ');
        if(idx < numOfChars)
            reverStr = (reverStr == """")? s.substr(0, idx) : s.substr(0, idx) + "" "" + reverStr;
        else{
            reverStr = s.substr(0, idx) + "" "" + reverStr;
            return ;
        }
        reverString(s.substr(idx+1, numOfChars-1), reverStr);
    }
}
string reverseSentence(string s) {
    // STUDENT ANSWER
    string result = """";
    reverString(s, result);
    return result;
}",1.0,1111111111
Recursion_17,1406072,2013048,"int shortestSuperstring(const string& x, const string& y, int m, int n) {
    if (m == 0) { // x is empty, so the superstring is y
        return n;
    }
    if (n == 0) { // y is empty, so the superstring is x
        return m;
    }
    if (x[m - 1] == y[n - 1]) { // Last characters of x and y are equal
        return 1 + shortestSuperstring(x, y, m - 1, n - 1); // Consider the common character in the superstring
    } else {
        // Find the shortest superstring by considering each string without the last character
        int superstringWithoutLastX = 1 + shortestSuperstring(x, y, m - 1, n); // Consider x without the last character
        int superstringWithoutLastY = 1 + shortestSuperstring(x, y, m, n - 1); // Consider y without the last character
        return min(superstringWithoutLastX, superstringWithoutLastY); // Return the minimum superstring length
    }
}

int superString(const string& x, const string& y, int m, int n) {
    int shortestLength = shortestSuperstring(x, y, m, n);
    return shortestLength;
}",1.0,1111111111
Recursion_18,1406072,2013048,"int strLenHelper(char* str, int index) {
    // Base case: if the current character is the null terminator '\0', return 0
    if (str[index] == '\0') {
        return 0;
    }
    // Recursive case: add 1 and move to the next character
    return 1 + strLenHelper(str, index + 1);
}

// Main function to handle edge cases and call the helper function
int strLen(char* str) {
    // Call the helper function with an initial index of 0
    return strLenHelper(str, 0);
}",1.0,1111111111
Recursion_19,1406072,2013048,"bool isContain(char *text, char *pattern, int i1, int i2){
    if(text[0] == '\0' || pattern[0] == '\0')
        return 0;
    if(text[i2] == '\0' && i2 == 0){
        return 0;
    }
    if(pattern[i2] == '\0' && i2 > 0){
        return 1;
    }
    i2 = (text[i1] == pattern[i2] && i2 >= 0)? i2 + 1 : 0;
    return isContain(text, pattern, i1+1, i2);
}
bool containsPattern(char* text, char* pattern){
    int i1 = 0, i2 = 0;
    return isContain(text, pattern, i1, i2);
}",0.8,10
Recursion_20,1406072,2013048,"#include <iostream>
#include <cmath>
using namespace std;

// Helper function to count the number of ways to express x as the sum of squares
int countWaysHelper(int x, int currentNum) {
    // Base case: if x is 0, we have found a valid combination
    if (x == 0) {
        return 1;
    }

    // Base case: if x is negative or currentNum is greater than sqrt(x), no valid combination
    if (x < 0 || currentNum > sqrt(x)) {
        return 0;
    }

    // Recursive case: count ways including and excluding the currentNum
    return countWaysHelper(x - currentNum * currentNum, currentNum + 1) +
           countWaysHelper(x, currentNum + 1);
}

// Main function to handle edge cases and call the helper function
int countWaySumOfSquare(int x) {
    return countWaysHelper(x, 1);
}",1.0,1111111111
Recursion_2,1407091,2212303,"void helper(int m, bool flag) {
    if (m > 0) {
        helper(m - 1, true);
    }
    if (flag) {
        if (m >= 0) {
            cout << m;
            if (m >= 0) {
                cout << "", "";
            }
        }
    } else {
        cout << m;
    }
}
void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    helper(n, false);
}",1.0,1111111111
Recursion_3,1407091,2212303,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n>0){
        cout<<n<<"" "";
        printPattern(n-5);
        cout<<"" ""<<n;
    } else cout<<n;
}",1.0,1111111111
Recursion_4,1407091,2212303,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if (length == 1) {
        return arr[0];
    }
    int max=findMax(arr, length-1);
    // Compare the maximum of the subarray with the last element
    if (arr[length - 1] > max) {
        return arr[length - 1];
    } else {
        return max;
    }
}",1.0,1111111111
Recursion_5,1407091,2212303,"bool isPalindrome(string str) 
{   
    bool result;
    if(str.length()<=1) return true;
    if(str[0]==' ') str=str.substr(1,str.length()-1);
    if(str[str.length()-1]==' ') str=str.substr(0,str.length()-1);
    if(str[0]==str[str.length()-1]){
        result = isPalindrome(str.substr(1,str.length()-2)); 
    } else return false;
    return result;
}",1.0,1111111111
Recursion_6,1407091,2212303,"int findGCD(int a, int b)
{
    if (a == 0) {
        return b;
    }
    if (b == 0) {
        return a;
    }

    // Recursive case: Apply the Euclidean algorithm
    if (a > b) {
        return findGCD(a % b, b);
    } else {
        return findGCD(a, b % a);
    }
}",1.0,1111111111
Recursion_7,1407091,2212303,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if (decimal_number == 0) {
        return 0; // Base case: The binary representation of 0 is 0.
    }

    int remainder = decimal_number % 2;
    int binary_part = decimalToBinary(decimal_number / 2);
    
    return binary_part * 10 + remainder;
} ",1.0,1111111111
Recursion_8,1407091,2212303,"string multiply(string s, int n) {
    if (n == 0) return """";
    return s+multiply(s, n-1);
}

string expandHelper(string s, size_t& pos) {
    if (pos >= s.size() || s[pos] == ')') {
        return """";
    }

    string result;

    if (isdigit(s[pos])) {
        int n = s[pos] - '0';
        pos++;  

        pos++; 

        string subresult = expandHelper(s, pos);

        pos++;  

        
        result = multiply(subresult, n);
    } else if (islower(s[pos])) {
        result += s[pos];
        pos++;  
    }
    result += expandHelper(s, pos);

    return result;
}

string expand(string s) {
    size_t pos = 0;  
    return expandHelper(s, pos);
}
",1.0,11111
Recursion_9,1407091,2212303,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if(number==1) {
        cout<<number;
        return;
    }
    cout<<number<<"" "";
    if(number%2==0) {
        number=number/2;
    } else number=number*3+1;
    printHailstone(number);
}",1.0,1111111111
Recursion_10,1407091,2212303,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    int result = str[0] - '0';
    if(n==1) return result;
    result=result*pow(10,n-1);
    result+=myArrayToInt(str+1, n-1); 
    return result;
}",1.0,1111111111
Recursion_11,1407091,2212303,"int helper(int n, int f){
    if(n==f) return f;
    if(n%f==0){
        return helper(n/f, f+1);
    } else return -1;
}
int reverseFactorial(int n) {
    // STUDENT ANSWER
    if(n==1) return 1;
    int result=helper(n,2);
    return result;
}",1.0,1111111111
Recursion_12,1407091,2212303,"int findGCD(int a, int b) {
    if (b == 0) {
        return a; // Base case: GCD(a, 0) = a
    }
    return findGCD(b, a % b); // Recursive case: GCD(a, b) = GCD(b, a % b)
}

// Function to calculate the Lowest Common Multiple (LCM) using recursion
int findLCM(int a, int b) {
    // LCM(a, b) = (a * b) / GCD(a, b)
    return (a * b) / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1407091,2212303,"int helper(string s, int remain1, int remain2, int flag) {
    if (s[0] == '(') {
        remain1++;
    } else {
        if (remain1 > 0) {
            remain1--;
        } else {
            remain2++;
        }
    }
    if (s.length() == 1) {
        if (flag==0)
        return remain1 + remain2;
        if(flag==1) return remain1;
        if(flag==2) return remain2;
    }
    return helper(s.substr(1, s.length() - 1), remain1, remain2, flag);
}

int mininumBracketAdd(string s) {
    if (s == """") {
        return 0;
    }
    int l=s.length();
    int d=l/2;
    string s1=s.substr(0, d);
    int remain1=helper(s1, 0,0,1);
    int remain2=helper(s1, 0,0,2);
    return helper(s.substr(d, l-d), remain1, remain2,0);
}
",1.0,1111111111
Recursion_14,1407091,2212303,"int subSum(vector<int>& nums, size_t i, size_t size) {
    if (i >= nums.size()) return 0;
    if (size == 0) return 0;
    return (nums[i]%2 + subSum(nums, i + 1, size - 1))%2;
}

int helper(vector<int>& nums, size_t i, size_t size) {
   
    if (size > nums.size()) {
        return 0;
    }
    if (i >= nums.size() || i + size > nums.size()) return helper(nums, 0, size + 1);
    
    int sub = subSum(nums, i, size);

    int result = sub % 2;
    return result+ helper(nums, i + 1, size);
}
int oddSumSublist(vector<int>& nums, int m) {
    if (nums.empty()) return 0;
    return helper(nums, 0, 1) % m;
}",0.5,111110
Recursion_15,1407091,2212303,"int findSpace(string s) {
    
    if (s[0] == ' ') return 0; 
    else {
        if(s.length()<=1) return 1;
        else
        return  1+ findSpace(s.substr(1));
        
    }
}

string reverseSentence(string s) {
    if (s == """") return """";
    
    size_t spacePos = findSpace(s);
  
    if (s.length()==spacePos) {
        return s; // No more spaces found, return the input string as is
        cout<<s<<endl;
    } else {
        // Recursively reverse the sentence after the first space and concatenate it with the first word
        return reverseSentence(s.substr(spacePos + 1)) + "" "" + s.substr(0, spacePos);
    }
}
",1.0,1111111111
Recursion_17,1407091,2212303,"int superString(string x, string y, int m, int n) {
      if (m == 0) {
        return n; // If the first string is empty, the superstring length is the length of the second string.
    }
    if (n == 0) {
        return m; // If the second string is empty, the superstring length is the length of the first string.
    }
    
    // If the last characters of both strings match, we can merge them and reduce the problem to the rest of the strings.
    if (x[m - 1] == y[n - 1]) {
        return superString(x, y, m - 1, n - 1) + 1;
    } else {
        // If the last characters don't match, we have two options: either append one character from x or one character from y.
        int option1 = superString(x, y, m - 1, n) + 1;
        int option2 = superString(x, y, m, n - 1) + 1;
        return min(option1, option2);
    }
}",1.0,1111111111
Recursion_18,1407091,2212303,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if(*str=='\0') return 0;
    else return 1+ strLen(str+1);
} ",1.0,1111111111
Recursion_19,1407091,2212303,"bool check(char* text, char* pattern, int tPos, int pPos){
    if(text[tPos]=='\0'&&pattern[pPos]=='\0'){
        return true;
    }
    if(text[tPos]=='\0'&&pattern[pPos]!='\0'){
        return false;
    }
    if(text[tPos]!='\0'&&pattern[pPos]=='\0'){
        return true;
    }
    if(text[tPos]==pattern[pPos]){ return check(text, pattern, tPos+1, pPos+1);}
    else{
        return(check(text,pattern, tPos+1, 0));
    }
    
}
bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
    return check(text, pattern, 0 ,0);
}",1.0,1111111111
Recursion_20,1407091,2212303,"int countWays(int x, int n) {
    // Base case: If x becomes 0, we found a way to express it as a sum of squares.
    if (x == 0) {
        return 1;
    }
    
    // Base case: If x becomes negative or if n becomes 0, there are no valid ways.
    if (x < 0 || n == 0) {
        return 0;
    }
    
    // Calculate the count of ways:
    // 1. Exclude n^2 from the sum and consider the rest.
    // 2. Include n^2 in the sum and consider the remaining part.
    return countWays(x, n - 1) + countWays(x - pow(n, 2), n - 1);
}

int countWaySumOfSquare(int x) {
    // Start with n = sqrt(x) as the maximum natural number to consider.
    int n = sqrt(x);
    return countWays(x, n);
}",1.0,1111111111
Recursion_2,1408640,2210532,"void printArray(int n)
{
    if(n==0){cout<<n;return;}
    printArray(n-1);
    cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1408640,2210532,"void printPattern(int n){
    if(n<=0){
        cout<<n;return;
    }
    cout<<n<<"" "";
    printPattern(n-5);
    cout<<"" ""<<n;
    
}",1.0,1111111111
Recursion_4,1408640,2210532,"int findMax(int* arr, int length)
{
    if(length == 1)return arr[0];
    else return max(arr[length-1],findMax(arr, length-1));
}",1.0,1111111111
Recursion_5,1408640,2210532,"string removeSpaces(string str)
{
    str.erase(remove(str.begin(), str.end(), ' '), str.end());
    return str;
}
bool isPalindromeHelper(const string& str, int start, int end) {
    if (start >= end) {
        return true;
    }
    if (str[start] != str[end]) {
        return false; 
    }

    return isPalindromeHelper(str, start + 1, end - 1);
}
bool isPalindrome(const string& str) {
    string newstr=removeSpaces(str);
    int length = newstr.length();
    return isPalindromeHelper(newstr, 0, length - 1);
}",1.0,1111111111
Recursion_6,1408640,2210532,"int findGCD(int a, int b)
{
    if(b != 0)return findGCD(b,a%b);
    else return a;
}",1.0,1111111111
Recursion_7,1408640,2210532,"int decimalToBinary(int decimal_number) 
{ 
   if(decimal_number == 0)return 0;
   else return (decimal_number%2 + 10 * decimalToBinary(decimal_number / 2));
} ",1.0,1111111111
Recursion_9,1408640,2210532,"void printHailstone(int number) {
    cout << number;

    if (number == 1) {
        return; 
    }

    if (number % 2 == 0) {
        cout<<"" "";
        printHailstone(number / 2);
    } else{
        cout<<"" "";
        printHailstone(number * 3 + 1);
    }
}",1.0,1111111111
Recursion_10,1408640,2210532,"#include <bits/stdc++.h>
int myArrayToInt(char *str, int n) 
{ 
    if(n==1)return str[0] - '0';
    else{
        char* tmp = new char[n-1];
        tmp= strncpy(tmp, str+1, n-1);
        int y= myArrayToInt(tmp, n-1);
        int x=str[0] - '0';
        x= x*pow(10, n-1) + y;
        return x;
    }
}",1.0,1111111111
Recursion_11,1408640,2210532,"int reverseFactorial(int n, int k=2) {
    if(n == 1)return 1;
    else if(n<=0 || n%k != 0){
        return -1;
    }
    
    return (reverseFactorial(n/k, k+1)== -1)?-1:max(k, reverseFactorial(n/k, k+1));
}",1.0,1111111111
Recursion_12,1408640,2210532,"int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}
int findLCM(int a, int b)
{
    return (a*b)/gcd(a,b);
}",1.0,1111111111
Recursion_13,1408640,2210532,"int mininumBracketAdd(string s, int check = 0, int count = 0) {
    if (s.empty()) {
        return count + abs(check);
    }

    if (s[0] == '(') {
        check += 1;
    } else if (s[0] == ')') {
        check -= 1;
        if (check < 0) {
            count += 1;
            check = 0;
        }
    }

    return mininumBracketAdd(s.substr(1), check, count);
}





",0.9,1111111110
Recursion_14,1408640,2210532,"int countOddSumSublists(vector<int>& nums, int m, int index, int currentSum) {
    int n=nums.size();
    if (index == n) {
        return (currentSum % 2 == 1) ? 1 : 0;
    }
    int includeCurrent = countOddSumSublists(nums, m, index + 1, currentSum + nums[index]);
    int excludeCurrent = countOddSumSublists(nums, m, index + 1, currentSum);
    return (includeCurrent + excludeCurrent) % m;
}
int oddSumSublist(vector<int>& nums, int m) {
    return countOddSumSublists(nums, m, 0, 0);
}",0.1,01000
Recursion_15,1408640,2210532,"string reverseSentence(string input) {
    if (input.find("" "") == string::npos) {
        return input;
    }
    size_t spacePos = input.find("" "");
    string firstWord = input.substr(0, spacePos);
    string remaining = input.substr(spacePos + 1);
    return reverseSentence(remaining) + "" "" + firstWord;
}",1.0,1111111111
Recursion_17,1408640,2210532,"int shortestSuperString(string x, string y, int m, int n) {
    if (m == 0) return n;
    if (n == 0) return m;
    if (x[m - 1] == y[n - 1]) {
        return 1 + shortestSuperString(x, y, m - 1, n - 1);
    } else {
        return 1 + min(
            shortestSuperString(x, y, m - 1, n),
            shortestSuperString(x, y, m, n - 1)
        );
    }
}
int superString(string x, string y, int m, int n) {
    return shortestSuperString(x, y, m, n);
}",1.0,1111111111
Recursion_18,1408640,2210532,"int strLen(char* str){
    if(str[0] == '\0')return 0;
    else{
        return 1 + strLen(str + 1);
    }
} ",1.0,1111111111
Recursion_19,1408640,2210532,"#include<cstring>
bool containsPattern(char* text, char* pattern)
{
  int n1=strlen(text); 
  int n2=strlen(pattern);
  if(n1 ==0 && n2 !=0)return false;
  else if((n1 == 0 && n2 == 0) || (n1 !=0 && n2 == 0))return true;
  else {
    if(text[0] == pattern[0])return containsPattern(text+1,pattern+1);
    else return containsPattern(text+1,pattern);
  }
}",0.8,1111111001
Recursion_20,1408640,2210532,"int countWaySumOfSquare(int x, int k=1)
{
    int remain = x - pow(k,2);
    if(remain == 0)return 1;
    else if(remain <0)return 0;
    return countWaySumOfSquare(x,k+1) + countWaySumOfSquare(remain, k+1);
}",1.0,1111111111
Recursion_2,1409614, ,"void printArray(int n)
{
    if(n==0){cout<<n;return;}
    printArray(n-1);
    cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1409614, ,"void printPattern(int n){
    if(n<=0){
        cout<<n;return;
    }
    cout<<n<<"" "";
    printPattern(n-5);
    cout<<"" ""<<n;
    
}",1.0,1111111111
Recursion_4,1409614, ,"int findMax(int* arr, int length)
{
    if(length == 1)return arr[0];
    else return max(arr[length-1],findMax(arr, length-1));
}",1.0,1111111111
Recursion_5,1409614, ,"string removeSpaces(string str)
{
    str.erase(remove(str.begin(), str.end(), ' '), str.end());
    return str;
}
bool isPalindromeHelper(const string& str, int start, int end) {
    if (start >= end) {
        return true;
    }
    if (str[start] != str[end]) {
        return false; 
    }

    return isPalindromeHelper(str, start + 1, end - 1);
}
bool isPalindrome(const string& str) {
    string newstr=removeSpaces(str);
    int length = newstr.length();
    return isPalindromeHelper(newstr, 0, length - 1);
}",1.0,1111111111
Recursion_6,1409614, ,"int findGCD(int a, int b)
{
    if(b != 0)return findGCD(b,a%b);
    else return a;
}",1.0,1111111111
Recursion_7,1409614, ,"int findGCD(int a, int b)
{
    if(b != 0)return findGCD(b,a%b);
    else return a;
}",1.0,
Recursion_9,1409614, ,"void printHailstone(int number) {
    cout << number;

    if (number == 1) {
        return; 
    }

    if (number % 2 == 0) {
        cout<<"" "";
        printHailstone(number / 2);
    } else{
        cout<<"" "";
        printHailstone(number * 3 + 1);
    }
}",1.0,1111111111
Recursion_10,1409614, ,"#include <bits/stdc++.h>
int myArrayToInt(char *str, int n) 
{ 
    if(n==1)return str[0] - '0';
    else{
        char* tmp = new char[n-1];
        tmp= strncpy(tmp, str+1, n-1);
        int y= myArrayToInt(tmp, n-1);
        int x=str[0] - '0';
        x= x*pow(10, n-1) + y;
        return x;
    }
}",1.0,1111111111
Recursion_11,1409614, ,"int reverseFactorial(int n, int k=2) {
    if(n == 1)return 1;
    else if(n<=0 || n%k != 0){
        return -1;
    }
    
    return (reverseFactorial(n/k, k+1)== -1)?-1:max(k, reverseFactorial(n/k, k+1));
}",1.0,1111111111
Recursion_12,1409614, ,"int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}
int findLCM(int a, int b)
{
    return (a*b)/gcd(a,b);
}",1.0,1111111111
Recursion_13,1409614, ,"int mininumBracketAdd(string s, int check = 0, int count = 0) {
    if (s.empty()) {
        return count + abs(check);
    }

    if (s[0] == '(') {
        check += 1;
    } else if (s[0] == ')') {
        check -= 1;
        if (check < 0) {
            count += 1;
            check = 0;
        }
    }

    return mininumBracketAdd(s.substr(1), check, count);
}





",0.9,1111111110
Recursion_14,1409614, ,"int countOddSumSublists(vector<int>& nums, int m, int index, int currentSum) {
    int n=nums.size();
    if (index == n) {
        return (currentSum % 2 == 1) ? 1 : 0;
    }
    int includeCurrent = countOddSumSublists(nums, m, index + 1, currentSum + nums[index]);
    int excludeCurrent = countOddSumSublists(nums, m, index + 1, currentSum);

    return (includeCurrent + excludeCurrent) % m;
}
int oddSumSublist(vector<int>& nums, int m) {
    return countOddSumSublists(nums, m, 0, 0);
}
",0.1,01000
Recursion_15,1409614, ,"string reverseSentence(string input) {
    if (input.find("" "") == string::npos) {
        return input;
    }
    size_t spacePos = input.find("" "");
    string firstWord = input.substr(0, spacePos);
    string remaining = input.substr(spacePos + 1);
    return reverseSentence(remaining) + "" "" + firstWord;
}",1.0,1111111111
Recursion_17,1409614, ,"int shortestSuperString(string x, string y, int m, int n) {
    if (m == 0) return n;
    if (n == 0) return m;
    if (x[m - 1] == y[n - 1]) {
        return 1 + shortestSuperString(x, y, m - 1, n - 1);
    } else {
        return 1 + min(
            shortestSuperString(x, y, m - 1, n),
            shortestSuperString(x, y, m, n - 1)
        );
    }
}
int superString(string x, string y, int m, int n) {
    return shortestSuperString(x, y, m, n);
}",1.0,1111111111
Recursion_18,1409614, ,"int strLen(char* str){
    if(str[0] == '\0')return 0;
    else{
        return 1 + strLen(str + 1);
    }
} ",1.0,1111111111
Recursion_19,1409614, ,"bool matchesPattern(char* text, char* pattern, int i, int j) {
    // Base case: If the pattern is empty, it's always a match.
    if (pattern[j] == '\0') {
        return true;
    }

    // Base case: If we've reached the end of the text but not the pattern, it's not a match.
    if (text[i] == '\0') {
        return false;
    }

    // If the current characters match, continue checking the rest of the pattern and text.
    if (text[i] == pattern[j]) {
        return matchesPattern(text, pattern, i + 1, j + 1);
    }

    // If the current characters don't match, check the next position in text.
    return false;
}

// Function to find if pattern exists in text recursively
bool containsPattern(char* text, char* pattern) {
    // Base case: If both text and pattern are empty, it's always a match.
    if (text[0] == '\0' && pattern[0] == '\0') {
        return true;
    }

    // Base case: If the text is empty but the pattern is not, it's not a match.
    if (text[0] == '\0') {
        return false;
    }

    // If the pattern matches starting at the current position in text, return true.
    if (matchesPattern(text, pattern, 0, 0)) {
        return true;
    }

    // Otherwise, recursively check the text starting from the next position.
    return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1409614, ,"int countWaySumOfSquare(int x, int k=1)
{
    int remain = x - pow(k,2);
    if(remain == 0)return 1;
    else if(remain <0)return 0;
    return countWaySumOfSquare(x,k+1) + countWaySumOfSquare(remain, k+1);
}",1.0,1111111111
Recursion_2,1409645, ,"void printArray(int n)
{
    if(n==0){cout<<n;return;}
    printArray(n-1);
    cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1409645, ,"void printPattern(int n){
    if(n<=0){
        cout<<n;return;
    }
    cout<<n<<"" "";
    printPattern(n-5);
    cout<<"" ""<<n;
    
}",1.0,1111111111
Recursion_4,1409645, ,"int findMax(int* arr, int length)
{
    if(length == 1)return arr[0];
    else return max(arr[length-1],findMax(arr, length-1));
}",1.0,1111111111
Recursion_5,1409645, ,"string removeSpaces(string str)
{
    str.erase(remove(str.begin(), str.end(), ' '), str.end());
    return str;
}
bool isPalindromeHelper(const string& str, int start, int end) {
    if (start >= end) {
        return true;
    }
    if (str[start] != str[end]) {
        return false; 
    }

    return isPalindromeHelper(str, start + 1, end - 1);
}
bool isPalindrome(const string& str) {
    string newstr=removeSpaces(str);
    int length = newstr.length();
    return isPalindromeHelper(newstr, 0, length - 1);
}",1.0,1111111111
Recursion_6,1409645, ,"int findGCD(int a, int b)
{
    if(b != 0)return findGCD(b,a%b);
    else return a;
}",1.0,1111111111
Recursion_7,1409645, ,"int decimalToBinary(int decimal_number) 
{ 
   if(decimal_number == 0)return 0;
   else return (decimal_number%2 + 10 * decimalToBinary(decimal_number / 2));
} ",1.0,1111111111
Recursion_9,1409645, ,"void printHailstone(int number) {
    cout << number;

    if (number == 1) {
        return; 
    }

    if (number % 2 == 0) {
        cout<<"" "";
        printHailstone(number / 2);
    } else{
        cout<<"" "";
        printHailstone(number * 3 + 1);
    }
}",1.0,1111111111
Recursion_10,1409645, ,"#include <bits/stdc++.h>
int myArrayToInt(char *str, int n) 
{ 
    if(n==1)return str[0] - '0';
    else{
        char* tmp = new char[n-1];
        tmp= strncpy(tmp, str+1, n-1);
        int y= myArrayToInt(tmp, n-1);
        int x=str[0] - '0';
        x= x*pow(10, n-1) + y;
        return x;
    }
}",1.0,1111111111
Recursion_11,1409645, ,"int reverseFactorial(int n, int k=2) {
    if(n == 1)return 1;
    else if(n<=0 || n%k != 0){
        return -1;
    }
    
    return (reverseFactorial(n/k, k+1)== -1)?-1:max(k, reverseFactorial(n/k, k+1));
}",1.0,1111111111
Recursion_12,1409645, ,"int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}
int findLCM(int a, int b)
{
    return (a*b)/gcd(a,b);
}",1.0,1111111111
Recursion_13,1409645, ,"int mininumBracketAdd(string s, int check = 0, int count = 0) {
    if (s.empty()) {
        return count + abs(check);
    }

    if (s[0] == '(') {
        check += 1;
    } else if (s[0] == ')') {
        check -= 1;
        if (check < 0) {
            count += 1;
            check = 0;
        }
    }

    return mininumBracketAdd(s.substr(1), check, count);
}





",0.9,1111111110
Recursion_14,1409645, ,"int countOddSumSublists(vector<int>& nums, int m, int index, int currentSum) {
    int n=nums.size();
    if (index == n) {
        return (currentSum % 2 == 1) ? 1 : 0;
    }
    int includeCurrent = countOddSumSublists(nums, m, index + 1, currentSum + nums[index]);
    int excludeCurrent = countOddSumSublists(nums, m, index + 1, currentSum);

    return (includeCurrent + excludeCurrent) % m;
}
int oddSumSublist(vector<int>& nums, int m) {
    return countOddSumSublists(nums, m, 0, 0);
}
",0.1,01000
Recursion_15,1409645, ,"string reverseSentence(string input) {
    if (input.find("" "") == string::npos) {
        return input;
    }
    size_t spacePos = input.find("" "");
    string firstWord = input.substr(0, spacePos);
    string remaining = input.substr(spacePos + 1);
    return reverseSentence(remaining) + "" "" + firstWord;
}",1.0,1111111111
Recursion_17,1409645, ,"int shortestSuperString(string x, string y, int m, int n) {
    if (m == 0) return n;
    if (n == 0) return m;
    if (x[m - 1] == y[n - 1]) {
        return 1 + shortestSuperString(x, y, m - 1, n - 1);
    } else {
        return 1 + min(
            shortestSuperString(x, y, m - 1, n),
            shortestSuperString(x, y, m, n - 1)
        );
    }
}
int superString(string x, string y, int m, int n) {
    return shortestSuperString(x, y, m, n);
}",1.0,1111111111
Recursion_18,1409645, ,"int strLen(char* str){
    if(str[0] == '\0')return 0;
    else{
        return 1 + strLen(str + 1);
    }
} ",1.0,1111111111
Recursion_19,1409645, ,"bool matchesPattern(char* text, char* pattern, int i, int j) {
    if (pattern[j] == '\0') {
        return true;
    }
    if (text[i] == '\0') {
        return false;
    }
    if (text[i] == pattern[j]) {
        return matchesPattern(text, pattern, i + 1, j + 1);
    }
    return false;
}
bool containsPattern(char* text, char* pattern) {
    if (text[0] == '\0' && pattern[0] == '\0') {
        return true;
    }
    if (text[0] == '\0') {
        return false;
    }
    if (matchesPattern(text, pattern, 0, 0)) {
        return true;
    }
    return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1409645, ,"int countWaySumOfSquare(int x, int k=1)
{
    int remain = x - pow(k,2);
    if(remain == 0)return 1;
    else if(remain <0)return 0;
    return countWaySumOfSquare(x,k+1) + countWaySumOfSquare(remain, k+1);
}",1.0,1111111111
Recursion_2,1409664,2211738,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
    if(n == 0) {
        cout << n;
        return;
    }
    printArray(n-1);
    cout << "", "" << n;
}",1.0,1111111111
Recursion_3,1409664,2211738,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n <= 0){
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n-5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1409664,2211738,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if(length == 1) return arr[0];
    return max(arr[0], findMax(arr+1, length-1));
}",1.0,1111111111
Recursion_5,1409664,2211738,"bool isPalindrome(string str) 
{ 
    if(str.size() <= 1) return true;
    if(str[0] == str[str.size()-1]){
        if(str[1] == ' ' && str[str.size()-2] == ' '){
            return isPalindrome(str.substr(2, str.size()-4));
        }else if(str[1] == ' ') {
            return isPalindrome(str.substr(2, str.size()-3));
        }else if(str[str.size()-2] == ' '){
            return isPalindrome(str.substr(1,str.size()-3));
        }else{
            return isPalindrome(str.substr(1,str.size()-2));
        }
    }
    return false;
}",1.0,1111111111
Recursion_6,1409664,2211738,"int findGCD(int a, int b)
{
     if(b == 0) return -1;
    return (a%b == 0)? b : findGCD(b, a%b);
}",1.0,1111111111
Recursion_7,1409664,2211738,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(decimal_number == 0){
        return 0;
    }
    return (decimal_number%2) + decimalToBinary(decimal_number/2)*10;
} ",1.0,1111111111
Recursion_9,1409664,2211738,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if(number == 1) {
        cout << number;
        return;
    }
    cout << number << "" "";
    if(number%2==0){
        printHailstone(number/2);
    }else {
        printHailstone(3*number+1);
    }
}",1.0,1111111111
Recursion_10,1409664,2211738,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    if(n == 0) return 0;
    return (str[0] - '0')*pow(10,n-1) + myArrayToInt(str+1, n-1);
}",1.0,1111111111
Recursion_11,1409664,2211738,"int k = 1;

int reverseFactorial(int n) {
    // STUDENT ANSWER
        if (n == 1) {
        int x = k;
        k = 1;
        return x;
    }
    if (n < 1) {
        k = 1;
        return -1;
    }
    k++;
    if (n % k != 0) {
        k = 1;
        return -1;
    }
    return reverseFactorial(n / k);
}",1.0,1111111111
Recursion_12,1409664,2211738,"int findGCD(int a, int b){
    if(b == 0) return -1;
    return (a%b==0)?b:findGCD(b,a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_13,1409664,2211738,"long long helper(string s, long long bal, long long ans){
    if(s.size() == 0) return bal + ans;
    if(s[0] == '('){
        return helper(s.substr(1),bal+1,ans);
    }else if(s[0] == ')'){
        if(bal <= 0) return helper(s.substr(1), bal, ans+1);
        else return helper(s.substr(1),bal-1,ans);
    }
    return 0;
}

long long mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return helper(s,0,0);
}",0.9,1111111110
Recursion_14,1409664,2211738,"// int helper(vector<int>& nums, int m, size_t i, int odd, int even) {
//     if (i==nums.size()) {
//         return 0;
//     }

//     int newOdd, newEven;
//     if (nums[i]%2==0) {
//         newOdd=odd;
//         newEven=even+1;
//     } else {
//         newOdd=even+1;
//         newEven=odd;
//     }
//     return (newOdd+helper(nums, m, i + 1, newOdd, newEven));
// }

// int oddSumSublist(vector<int>& nums, int m) {
//     return helper(nums, m, 0, 0, 0)%m;
// }
int helper(vector<int>& nums, vector<int>& temp, size_t i, int val){
    if(i < nums.size()){
        val = ((nums[i] + val)%2 + 2)%2;   
        temp[val]++;
        return helper(nums,temp,i+1,val);
    }
    return temp[0]*temp[1];
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    vector<int> temp {1,0};
    return helper(nums,temp,0,0)%m;
}",1.0,1111111111
Recursion_15,1409664,2211738,"string reverseSentence(string s) {
    // STUDENT ANSWER
    string temp;
    if(s.size() == 0) return temp;
    int index = s.rfind(' ', s.size()-1);
    if(index != -1){
        temp = s.substr(index+1);
    }else{
        temp = s.substr(0);
        return temp;
    }
    return temp + ' ' + reverseSentence(s.substr(0, s.size()-temp.size()-1));
}",0.95,1111111111
Recursion_18,1409664,2211738,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if(str[0] == '\0') return 0;
    return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_19,1409664,2211738,"bool helper(char* text, char* pattern){
    if(*text == '\0' && *pattern != '\0') return false;
    if(*pattern == '\0') return true;
    if(*text == *pattern) return helper(text+1, pattern+1);
    return false;
}
bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
    if(*text == '\0') return false;
    else if(*text == *pattern){
        if(helper(text,pattern)) return true;
    }
    return containsPattern(text+1,pattern);
}",1.0,1111111111
Recursion_20,1409664,2211738,"int helper(int x, int i, int n){
    int val = x - pow(n,i);
    if(val < 0) return 0;
    if(val == 0) return 1;
    return helper(val,2,n+1) + helper(x,2,n+1);
}
int countWaySumOfSquare(int x)
{
    /*  
     * STUDENT ANSWER
     */
    return helper(x,2,1);
}",1.0,1111111111
Recursion_14,1411959,2211367,"void subs(int idx,vector<int>lst,vector<int>&nums,vector<vector<int>>&l,int N){
        if(idx>=N){
            l.push_back(lst);
            return ;
        }
        lst.push_back(nums[idx]);
        subs(idx+1,lst,nums,l,N);
        lst.pop_back();
        subs(idx+1,lst,nums,l,N);

    }
    vector<vector<int>> subsets(vector<int>& nums) {
        int N=nums.size();
        vector<int>lst;
        vector<vector<int>>l;
        subs(0,lst,nums,l,N);
        return l;
    }
int sumsubset(vector<int> s, int sum, int i){
    int n = s.size();
    if(i==n) return sum;
    sum += s[i];
    return sumsubset(s,sum,i+1);
}
int oddSumSublisthelper(vector<vector<int>>s,int count, int i){
    int n = s.size();
    if(i==n) return count-1;
    if((sumsubset(s[i],0,0))%2==1){
        count = count + 1;
    }
    return oddSumSublisthelper(s,count,i+1);
}
int oddSumSublist(vector<int>& nums, int m) {
    vector<vector<int>> s = subsets(nums);
    return oddSumSublisthelper(s,0,1)%m;
}",0.1,1000
Recursion_2,1412975,2252260,"void printArray(int n, int i=0)
{
    /*  
     * STUDENT ANSWER
     */
    if(i>n)
        return;
    cout << i;
    if(i<n)
        cout << "", "";
    printArray(n, i+1);
}",1.0,1111111111
Recursion_3,1412975,2252260,"void recursive(int n, int i){
    if(n <= 0){
        cout << n << "" "";
        return;
    }
    cout << n << "" "";
    recursive(n-5, i);
    cout << n;
    if(n!=i)
        cout << "" "";
}

void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    int i=n;
    return recursive(n,i);
}
",1.0,1111111111
Recursion_4,1412975,2252260,"int recursion (int *arr, int length, int i, int max){
    if(i>=length)
        return max;
    if(arr[i] >= max)
        max = arr[i];
    return recursion (arr, length, i+1, max);
}

int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    int i=0;
    int max = arr[0];
    return recursion(arr, length, i, max);
}",1.0,1111111111
Recursion_5,1412975,2252260,"string standardize(string str, string s, unsigned int i) {
    if(i >= str.length())
        return s;
    if(isalnum(str[i]) || !isspace(str[i])){
        if(isupper(str[i]))
            str[i] = tolower(str[i]);
        s += str[i];
    }
    return standardize(str, s, i+1);
}

bool checkPalindrome(string s){
    if(s.length()==0 || s.length()==1)
        return true;
    if(s[0] == s[s.length()-1])
        return checkPalindrome(s.substr(1, s.length()-2));
    return false;
}

bool isPalindrome(string str)  { 
    string s = """";
    unsigned int i=0;
    
    s = standardize(str, s, i);
    
    return checkPalindrome(s);
}",1.0,1111111111
Recursion_6,1412975,2252260,"int findGCD(int a, int b){
    if(a==0)
        return b;
    return findGCD(b%a, a);
}",1.0,1111111111
Recursion_7,1412975,2252260,"string toBinary(int decimal_number, string& s) {
    if(decimal_number == 0){
        if(s.empty())
            return ""0"";
        else
            return s;
    }
    s = to_string(decimal_number%2) + s;
    return toBinary(decimal_number/2, s);
}

int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    string s = """";
    return stoi(toBinary(decimal_number, s));
} ",1.0,1111111111
Recursion_2,1417147,2212651,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if(n==0) {
         cout<<0;
         return;
     }
     printArray(n-1);
     cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1417147,2212651,"void printPattern(int m){
    if(m <= 0){
        cout << m;
    }else{
        cout << m << "" "";
        printPattern(m-5);
        cout <<"" ""<<m;
    }
}
",1.0,1111111111
Recursion_4,1417147,2212651,"int findMax(int* arr, int length)
{
    if(length - 1 == 0) return arr[0];
    return max(arr[length-1],findMax(arr,length-1));
}
",1.0,1111111111
Recursion_5,1417147,2212651,"bool isPalindrome(string str) 
{   
//! do dai cua chuoi hien tai
    int len = str.length();
//! diem co so cua de quy
    if(len == 0 || len == 1) return true;
//! neu vi tri dang xet la khoang trong thi bo qua    
    if(str[0] == ' ') return isPalindrome(str.substr(1));
    else if(str[len - 1] == ' ') return isPalindrome(str.substr(0,len - 1));
//! neu vi tri dau va cuoi giong nhau thi tra ve true con khac nhau thi tra ve false
    return (str[0] == str[len - 1]) && isPalindrome(str.substr(1,len - 2));
}
",1.0,1111111111
Recursion_6,1417147,2212651,"int findGCD(int a, int b)
{   

    if(a == b) return a;
    else if(a > b) return findGCD(a - b,b);
    return findGCD(b - a,a);
}
",1.0,1111111111
Recursion_7,1417147,2212651,"int decimalToBinary(int decimal_number) {
    if (decimal_number == 0) {
        return 0;
    } else {
        return decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2);
    }
}",1.0,1111111111
Recursion_8,1417147,2212651,"string expand(string s) {
//! Đây là trường hợp cơ bản của đệ quy. Nếu chuỗi đầu vào rỗng, hàm trả về một chuỗi rỗng.
    if(s.length()==0){
        return """";
    }
    else if((s[0]>='a' && s[0]<='z') || (s[0]>='A' && s[0]<='Z')){
        return s[0]+expand(s.substr(1));
    }
//! 
    else if(s[0]>='2'&&s[0]<='9'){
        if(s[1]=='('){
            s[0]--;
            string x=expand('1'+s.substr(2));
            return x+expand(s[0]+s.substr(2))+expand(s.substr(1));

        }
        else{
            s[0]--;
            return expand('1'+s.substr(1))+expand(s);
        }
    }
    else if(s[0]=='1'){
        if(s[1]=='('){
            string x=expand(s.substr(2));
            return x+expand(s.substr(x.length()+3));
        }
        else{
            return expand(s.substr(1));
        }
    }
    else if(s[0]=='0'){
        return expand(s.substr(2+expand(s.substr(2)).length()));
    }
    else if(s[0]==')'){
        return """";
    }
    else if(s[0]=='('){
        int x=expand(','+s.substr(1)).length();

        return expand(s.substr(x+2));
    }
    else{
        if(s[1]=='('){
            string x=expand(','+s.substr(2));
            return ""aa""+x+expand(','+s.substr(x.length()+3));
        }
        else if(s[1]==')'){
            return """";
        }
        else{
            return 'a'+expand(','+s.substr(2));
        }

    }
}
",1.0,11111
Recursion_9,1417147,2212651,"void printHailstone(int number)
{
//! diem co so cua de quy
    if(number == 1){
        cout << 1;
        return;
    }
    cout << number << "" "";
//! neu so chan thi % 2 con so le thi * 3  + 1
    if(number % 2 == 0) printHailstone(number /2 );
    else printHailstone(number*3 + 1);
}
",1.0,1111111111
Recursion_10,1417147,2212651,"int myArrayToInt(char *str, int n) 
{ 
    if(n == 0) return 0;
    return str[n-1] - '0' + myArrayToInt(str,n-1)*10;
}",1.0,1111111111
Recursion_11,1417147,2212651,"bool check(int n,int a){
    if (n==1) return true;
    if (n%a==0) return check(n/a,a+1);
    else return false;
}
int reverseFactorial(int n,int a){
    if (n==1) return 0;
    return reverseFactorial(n/a,a+1)+1;
}
int reverseFactorial(int n) {
    // STUDENT ANSWER
    if (n==1) return 1;
    if (check(n,1)) return reverseFactorial(n,1);
    else return -1;
}",1.0,1111111111
Recursion_12,1417147,2212651,"int findGCD(int a, int b)
{
    if(a == b) return a;
    else if(a > b) return findGCD(a - b,b);
    return findGCD(b - a,a);
}

int findLCM(int a, int b)
{
//! dung cong thu tim boi chung nho nhat
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_13,1417147,2212651,"int mininumBracketAdd(string& s,unsigned index,int op,int cl) {
    // STUDENT ANSWER
    if (index==s.length()) return op+cl;
    if (s[index]=='(') op++;
    else if (s[index]==')'){
        if (op) op--;
        else cl++;
    }
    return mininumBracketAdd(s,index+1,op,cl);
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return mininumBracketAdd(s,0,0,0);
}",1.0,1111111111
Recursion_14,1417147,2212651,"void findOdd(vector<int> &nums, int &cnt, int &even, int &odd, int index) {
    int n = nums.size();
    if (index == n) return;

    if (nums[index] % 2 == 1) {
        swap(even, odd);
        odd++;
    } else {
        even++;
    }

    cnt += odd;
    index++;
    findOdd(nums, cnt, even, odd, index);
}
int oddSumSublist(vector<int>& nums, int m) {
    if (nums.empty()) return 0;
    int cnt = 0, even = 0, odd = 0, index = 0;
    findOdd(nums, cnt, even, odd, index);
    return cnt % m;
}",1.0,1111111111
Recursion_15,1417147,2212651,"string reverseSentence(string s) {
//! điểm cơ sở của đệ quy
    if(s.length() <= 1) return s;
//! tìm khoảng trắng đầu tiên
    int r = s.find("" "");
//! nếu không tìm khoảng trắng đầu tiên thì return về chuỗi hiện tại
    if(r == -1) return s;
    string right = s.substr(0,r);
//! tìm khoảng trắng cuối cùng
    int l = s.rfind("" "");
    string left = s.substr(l+1);
//! trường hợp thỏa hết ở trên và chỉ còn 1 khoảng trắng
    if(r == l) return left + "" "" + right; 
//! lời gọi đệ quy 
    string mid = reverseSentence(s.substr(r+1,l - r - 1));
    return left + "" "" + mid + "" "" + right;
}
",1.0,1111111111
Recursion_17,1417147,2212651,"int superString(const string& x, const string& y, int m, int n) {
    if (m == 0) return n;
    if (n == 0) return m;
    if (x[m - 1] == y[n - 1]) {
        return 1 + superString(x, y, m - 1, n - 1);
    } else {
        return min(superString(x, y, m - 1, n), superString(x, y, m, n - 1)) + 1;
    }
}",1.0,1111111111
Recursion_18,1417147,2212651,"int strLen(char* str)     
{ 
   return *str ?1 + strLen(str + 1)  : 0;
} ",1.0,1111111111
Recursion_19,1417147,2212651,"string conv(char* a){
    if (*a=='\0') return """";    
    return *a+conv(a+1);
}
bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
    string s=conv(text);
    string con=conv(pattern);
    if (s.find(con)>=0 && s.find(con)<s.length()) return true;
    else return false;
}",1.0,1111111111
Recursion_20,1417147,2212651,"int process(int power,int base,int sum){
    int kq=pow(base,power);
    if(sum==kq){
        return 1;
    }else if(sum<kq){
        return 0;
    }
    int p1=process(power,base+1,sum-kq);
    int p2=process(power,base+1,sum);
    return p1+p2;
}
int countWaySumOfSquare(int x)
{
    return process(2,1,x);
}",1.0,1111111111
Recursion_2,1418239,2212282,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if(n>0) printArray(n-1);
     if(n==0) cout << 0;
     else     cout << "", "" << n;
}",1.0,1111111111
Recursion_3,1418239,2212282,"bool a=1;
void printPattern(int n) 
{ 
    static int save = n;
    
    if(n == save && a) cout << n;
    else cout << "" "" << n;
    
    if(n < 1) a = 0;
    if(a) printPattern(n-5);
    else  {
        if(n != save) printPattern(n+5);
    }
    
}",1.0,1111111111
Recursion_4,1418239,2212282,"int findMax(int* arr, int length) {
    if (length == 1) {
        return arr[0];
    } else {
        int maxOfRest = findMax(arr + 1, length - 1);
        return arr[0] > maxOfRest ? arr[0] : maxOfRest;
    }
}",1.0,1111111111
Recursion_5,1418239,2212282,"bool balindromecheck(string str, int left, int right) {
    if(str[left]  == ' ') ++left;
    if(str[right] == ' ') --right;
    
    if(left >= right) return 1;
    if(str[left] != str[right]) return 0;
    
    return balindromecheck(str, ++left, --right);
}

bool isPalindrome(string str) 
{ 
    return balindromecheck(str, 0, str.length()-1);
}
",1.0,1111111111
Recursion_6,1418239,2212282,"int findGCD(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return findGCD(b, a % b);
    }
}",1.0,1111111111
Recursion_7,1418239,2212282,"int decimalToBinary(int decimal_number) 
{ 
    
    if(decimal_number == 0) return 0;
     
    return  decimalToBinary(decimal_number/2) * 10 + decimal_number % 2;
}",1.0,1111111111
Recursion_8,1418239,2212282,"#include <iostream>
#include <string>
using namespace std;




int find(const string & s, int index = 0) {
    if(index == static_cast<int>(s.length())) return -1;
    if(s[index] == ')') return index;
    return find(s, index+1);
}

string decode_string(const string & s, int & index) {
    index--;
    if(s[index] == '(') return """";
    return decode_string(s, index) + s[index];
}

int decode_num(const string & s, int & index) {
    index--;
    if(index == -1 || (s[index] >= 'a' && s[index] <= 'z') || s[index] == '(') return 0;
    int num = s[index] - '0';
    return decode_num(s, index) * 10 + num;
}

string decode(const string & d_str, int num) {
    if(num == 0) return """";
    return decode(d_str, num-1) + d_str;
}

string helper(const string & s) {
    //cout << s << endl;
    int rightb = find(s);
    if(rightb == -1) return s;
    int cur = rightb;
    string heh = decode_string(s, cur);
    int hi = decode_num(s, cur);
   
   //cout << (s.substr(0, cur+1) + decode(heh, hi) + s.substr(rightb+1, s.length()-1-rightb));
   
    return helper(s.substr(0, cur+1) + decode(heh, hi) + s.substr(rightb+1, s.length()-1-rightb));
}

string expand(string s) {
    return helper(s);
}",1.0,11111
Recursion_9,1418239,2212282,"void printHailstone(int number) {
    cout << number;
    if (number > 1) {
        cout << "" "";
        if (number % 2 == 0) {
            printHailstone(number / 2);
        } else {
            printHailstone(number * 3 + 1);
        }
    }
}",1.0,1111111111
Recursion_10,1418239,2212282,"int myArrayToInt(char *str, int n) 
{ 
    if(n == 0) return 0;
    return myArrayToInt(str, n-1)*10 + int(*(str+n-1))-'0';
}",1.0,1111111111
Recursion_11,1418239,2212282,"int helper(int n, int i) {
    if (n == 1) return i - 1;
    if (n < 1 || n % i != 0) return -1;
    return helper(n / i, i + 1);
}

int reverseFactorial(int n) {
    return helper(n, 2);
}",1.0,1111111111
Recursion_12,1418239,2212282,"int findGCD(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return findGCD(b, a % b);
    }
}

int findLCM(int a, int b) {
    return (a * b) / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1418239,2212282,"int i = 0;
int open = 0;
int sum = 0;

int helper(const string & s) {
    if(i == static_cast<int>(s.length())) return sum + open;
    
    if(s[i] == '(') open++;
    
    if(s[i] == ')') {
        if(open) open--;
        else sum++;
    }
    
    ++i;
    
    return helper(s);
}

int mininumBracketAdd(string s) {
    return helper(s);
}",1.0,1111111111
Recursion_14,1418239,2212282,"int index = 0;
int ans   = 0;
int odd   = 0;
int even  = 0;
int sum   = 0;

int oddSumSublist(const vector<int>& nums,const int & m) {
    if(index == static_cast<int>(nums.size())) return ans%m;
    
    sum += nums[index++];
    if(sum % 2 == 0) {
        ans += odd;
        even++;
    }
    else {
        ans += 1 + even;
        odd ++;
    }
    
    return oddSumSublist(nums, m);
}",1.0,1111111111
Recursion_15,1418239,2212282,"string temp   = """";
string output = """";
unsigned int i = 0;

string helper(const string & s) {
    if(i == s.length()+1) return output;
    
    if(s[i] == ' ' || i == s.length()) {
        if(output == """") output = temp;
        else output = temp + "" "" + output;
        
        temp = """";
    }
    else temp += s[i];
    
    ++i;
    
    return helper(s);
}

string reverseSentence(string s) {
    return helper(s);
}",1.0,1111111111
Recursion_17,1418239,2212282,"int lcs(string x, string y, int m, int n) {
    if (m == 0 || n == 0)
        return 0;
    else if (x[m - 1] == y[n - 1])
        return 1 + lcs(x, y, m - 1, n - 1);
    else
        return max(lcs(x, y, m, n - 1), lcs(x, y, m - 1, n));
}

int superString(string x, string y, int m, int n) {
    int len_lcs = lcs(x, y, m, n);
    return (m + n - len_lcs);
}",1.0,1111111111
Recursion_18,1418239,2212282,"int strLen(char* str)     
{ 
    if(*str == '\0') return 0;
    return strLen(str+1) + 1;
} ",1.0,1111111111
Recursion_19,1418239,2212282,"bool exactMatch(char *text, char *pattern)
{
 if (*text == '\0' && *pattern != '\0') return false;
 if (*pattern == '\0') return true;
 if (*text == *pattern) return exactMatch(text + 1, pattern + 1);
 return false;
}
 

bool containsPattern(char *text, char *pattern)
{
    if (*text == '\0') return false;
    if (*text == *pattern){if(exactMatch(text, pattern)) return 1;}
  else return containsPattern(text + 1, pattern);
    return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1418239,2212282,"int countWaySumOfSquare(int x, int n) {
    if(x==0) return 1;
    if(x < 0 || n == 0) return 0;
    
    int case1 = countWaySumOfSquare(x - n*n, n-1);
    int case2 = countWaySumOfSquare(x, n-1);
    
    return case1 + case2;
}

int countWaySumOfSquare(int x) {
    return countWaySumOfSquare(x, int(sqrt(x)));
}",1.0,1111111111
Recursion_2,1418350,2252260,"void printArray(int n, int i=0)
{
    /*  
     * STUDENT ANSWER
     */
    if(i>n)
        return;
    cout << i;
    if(i<n)
        cout << "", "";
    printArray(n, i+1);
}",1.0,1111111111
Recursion_3,1418350,2252260,"void recursive(int n, int i){
    if(n <= 0){
        cout << n << "" "";
        return;
    }
    cout << n << "" "";
    recursive(n-5, i);
    cout << n;
    if(n!=i)
        cout << "" "";
}

void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    int i=n;
    return recursive(n,i);
}
",1.0,1111111111
Recursion_4,1418350,2252260,"int recursion (int *arr, int length, int i, int max){
    if(i>=length)
        return max;
    if(arr[i] >= max)
        max = arr[i];
    return recursion (arr, length, i+1, max);
}

int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    int i=0;
    int max = arr[0];
    return recursion(arr, length, i, max);
}",1.0,1111111111
Recursion_5,1418350,2252260,"string standardize(string str, string s, unsigned int i) {
    if(i >= str.length())
        return s;
    if(isalnum(str[i]) || !isspace(str[i])){
        if(isupper(str[i]))
            str[i] = tolower(str[i]);
        s += str[i];
    }
    return standardize(str, s, i+1);
}

bool checkPalindrome(string s){
    if(s.length()==0 || s.length()==1)
        return true;
    if(s[0] == s[s.length()-1])
        return checkPalindrome(s.substr(1, s.length()-2));
    return false;
}

bool isPalindrome(string str)  { 
    string s = """";
    unsigned int i=0;
    
    s = standardize(str, s, i);
    
    return checkPalindrome(s);
}",1.0,1111111111
Recursion_6,1418350,2252260,"int findGCD(int a, int b){
    if(a==0)
        return b;
    return findGCD(b%a, a);
}",1.0,1111111111
Recursion_7,1418350,2252260,"string toBinary(int decimal_number, string& s) {
    if(decimal_number == 0){
        if(s.empty())
            return ""0"";
        else
            return s;
    }
    s = to_string(decimal_number%2) + s;
    return toBinary(decimal_number/2, s);
}

int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    string s = """";
    return stoi(toBinary(decimal_number, s));
} ",1.0,1111111111
Recursion_9,1418350,2252260,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if(number==1){
        cout << number;
        return;
    }
    cout << number << "" "";
    if(number % 2 == 0)
        printHailstone(number/2);
    else
        printHailstone(3*number+1);
}",1.0,1111111111
Recursion_10,1418350,2252260,"int myArrayToInt(char* str, int n, int i, string s){
    if(i>=n)
        return stoi(s);
    s += str[i];
    return myArrayToInt(str, n, i+1, s);
}

int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    int i=0;
    string s = """";
    return myArrayToInt(str, n, i, s);
}",1.0,1111111111
Recursion_11,1418350,2252260,"int reverseFactorial(int n, int k=1, int i=1) {
    // STUDENT ANSWER
    if(n==1)
        return 1;
    else if(k==n)
        return i-1;
    else if(k>n)
        return -1;

    return reverseFactorial(n, k*i, i+1);
}",1.0,1111111111
Recursion_12,1418350,2252260,"int findLCM(int a, int b, int LCM, int n){
    if(LCM % a == 0 && LCM % b == 0)
        return LCM;
    return findLCM(a, b, LCM+n, n);
}

int findLCM(int a, int b) {
    int LCM = max(a,b);
    int n = max(a, b);
    return findLCM(a, b, LCM, n);
}",1.0,1111111111
Recursion_13,1418350,2252260,"int minimumBracketAdd(string s, unsigned int i, int openBrackets, int result){
    if(i >= s.length())
        return result + openBrackets;
    if(s[i] == '(')
        return minimumBracketAdd(s, i+1, openBrackets+1, result);
    else if(openBrackets > 0)
        return minimumBracketAdd(s, i+1, openBrackets-1, result);
    else
        return minimumBracketAdd(s, i+1, openBrackets, result+1);
}

int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    unsigned int i=0;
    int openBrackets = 0;
    int result = 0;
    return minimumBracketAdd(s, i, openBrackets, result);
}",0.9,1111111110
Recursion_14,1418350,2252260,"void tmpCount(vector<int>& nums, int* tmp, int n, int i, int val){
    if(i>n-1)
        return;
    val = ((val+nums[i])%2+2)%2;
    tmp[val]++;
    tmpCount(nums, tmp, n, i+1, val);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int n = nums.size();
    int tmp[2] = {1,0};
    
    int result = 0, val=0;
    tmpCount(nums, tmp, n, 0, val);
    result = tmp[0]*tmp[1];
    return result%m;
}
",1.0,1111111111
Recursion_2,1418891,2211821,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if(n==0){ 
     cout<<0;
     return;
     }
     printArray(n-1);
     cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1418891,2211821,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if (n<=0) {
         cout<< n;
         return;}
         cout<< n<<"" "";
     printPattern(n-5);
        cout<<"" ""<<n;
}",1.0,1111111111
Recursion_4,1418891,2211821,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
     if (length == 1) return arr[0];
     if(arr[0]>arr[1]) arr[1] = arr[0];
     return findMax(arr+1,length-1);
}",1.0,1111111111
Recursion_5,1418891,2211821,"string removespace(string str, size_t length =0){
    if(length == str.length()) return str;
    if(str[length] == ' ' || str[length] == ',')
    {
        str = str.substr(0,length) +str.substr(length+1);
    }
    return removespace(str, length+1);
}


bool isPalindrome(string str) 
{ 
    str = removespace(str);
    int len = str.length();
    if(len ==0 ||len ==1) return 1;
    char char1 = tolower(str[0]);
    char char2 = tolower(str[len-1]);
    if(char1 == char2) {
        string str1 = str.substr(1,len-2);
        return isPalindrome(str1);
    } else return 0;
    
}",1.0,1111111111
Recursion_6,1418891,2211821,"int findGCD(int a, int b)
{
    if(b==0) return a;
    else return findGCD(b,a%b);
}",1.0,1111111111
Recursion_7,1418891,2211821,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if (decimal_number == 1) return 1;
     if (decimal_number == 0) return 0;
     int interger = decimal_number/2;
     int binary = decimalToBinary(interger);
     int remainder = decimal_number%2;
     binary =binary*10+remainder;
     return binary;
} ",1.0,1111111111
Recursion_8,1418891,2211821,"int indexlastopen(string s, int length){
    if(length == 0) return -1;
    if (s[length-1] == '(') return length-1;
    else return indexlastopen(s,length-1);
}
int indexcloserightopen(string s, int index){
    if (index == -1) return -1;
    if (s[index+1] == ')') return index+1;
    else return indexcloserightopen(s,index+1);
}
int numberloop(string s , int index){
    if (index <= 0) return 0;
    if (isdigit(s[index-1])) return numberloop(s,index-1) + int(s[index-1] - '0');
    else return 0;
}
int indexofnumber( std::string s, int idx) {
    if (idx <= 0) return 0;
    if (isdigit(s[idx - 1])) {
        return 1 + indexofnumber(s, idx - 1);
    }
    return 0;
}
string afterloop(string s, int i){
    if(i==0) return """";
    else return s+afterloop(s,i-1);
}
string expand(string s) {
    int length = s.length();
    int open = indexlastopen(s,length);
    if(open ==-1) return s;
    int close = indexcloserightopen(s,open);
    int sz = indexofnumber(s,open);
    int num = numberloop(s,open);
    string s1 = s.substr(open+1,close-open -1);
    string s2 = afterloop(s1,num);
    if (close == length-1) {
        s= s.substr(0,open-sz) + s2;
    }else {
        s= s.substr(0,open-sz ) +s2+s.substr(close+1);
    }
    return expand(s);
}",1.0,11111
Recursion_9,1418891,2211821,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    
     if (number == 1) {
          cout << number;
          return;
     }
      cout << number<<"" "";
     if (number%2 == 1) printHailstone(number*3+1);
     else printHailstone(number/2);
}",1.0,1111111111
Recursion_10,1418891,2211821,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
     if(n == 0) return 0;
     return 10*myArrayToInt(str,n-1)+int(str[n-1]-'0');
}",1.0,1111111111
Recursion_11,1418891,2211821,"int find(int n, int i) {
    if (n%i != 0) return -1;
    if(n/i == 1) return i;
    return find(n/i,i+1);
}



int reverseFactorial(int n) {
    // STUDENT ANSWER
    if (n ==1) return 1;
    else return find(n,2);
}",1.0,1111111111
Recursion_12,1418891,2211821,"int GCD( int a,int b){
    if (b ==0 ) return a;
    else return GCD(b,a%b);
}


int findLCM(int a, int b)
{
    return (a*b) / GCD(a,b);
}",1.0,1111111111
Recursion_13,1418891,2211821,"int counting(char* t, char* tE, int x, int y){
 if (t >tE) {
     y+=x;
     return y;
 }   
 if (*t == '(') x++;
 else {
     if(x>0) x--;
     else y++;
 }
 return counting(t+1,tE,x,y);
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int len =s.length();
    if (len ==0) return 0;
    return counting(&s[0],&s[len-1],0,0);
}",1.0,1111111111
Recursion_14,1418891,2211821,"int Sum(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    return vec[start] + Sum(vec, start + 1, number - 1);
}
int countright(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    int sum = Sum(vec, start, number);
    if (sum % 2 == 1) return 1 + countright(vec, start + 1, number - 1); else return countright(vec, start + 1, number - 1);
}
int countleft(vector<int>& vec, int start, int number) {
    int x = vec.size();
    if (number == 0 || start >= x) return 0;
    int sum = Sum(vec, start, number);
    if (sum % 2 == 1) return 1 + countright(vec, start + 1, number - 1) + countleft(vec, start, number - 1); else return countright(vec, start + 1, number - 1) + countleft(vec, start, number - 1);
}
int oddSumSublist(vector<int>& vec, int m) {
    int x = vec.size();
    int n = countleft(vec, 0, x) % m;
    return n;
}",0.7,11111110
Recursion_15,1418891,2211821,"string reverseSentence(string s) {
    // STUDENT ANSWER
    size_t index = s.find(' ');
    if (index == string::npos) return s;
    else return reverseSentence(s.substr(index+1))+"" ""+s.substr(0,index);
}",1.0,1111111111
Recursion_17,1418891,2211821,"string largestsub(string x, string y){
    int len1 = x.length();
    int len2 = y.length();
    if (len1 == 0 || len2 == 0) return """";
    if(x[len1-1] == y[len2-1]) return largestsub(x.substr(0,len1-1),y.substr(0,len2-1)) + x[len1-1];
    else {
        string s1 = largestsub(x.substr(0,len1-1),y);
        string s2 = largestsub(x,y.substr(0,len2-1));
        if(s1.length()>s2.length()) return s1;
        else return s2;
    }
}

int superString(string x, string y, int m, int n) {
    string s = largestsub(x,y);
    int len = s.length();
    return m+n-len;
}",1.0,1111111111
Recursion_18,1418891,2211821,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if(str[0]=='\0') return 0;
     else return 1+strLen(str+1);
} ",1.0,1111111111
Recursion_19,1418891,2211821,"bool isequal(char* text, char* pattern){
    if(*pattern == '\0') return 1;
    if( *text == '\0') return 0;
    if(*text == *pattern) return isequal(text+1,pattern+1);
    else return 0;
}



bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
     if(*text == '\0') return 0;
     if (isequal(text,pattern)) return 1;
     else return containsPattern( text+1,  pattern);
}",1.0,1111111111
Recursion_20,1418891,2211821,"int count(int x, int var){
    if(x==0) return 1;
    if(x<0||var==0) return 0;
    int count1 = count(x - var*var,var-1);
    int count2= count(x,var-1);
    return count1+count2;
}
int countWaySumOfSquare(int x)
{
    /*  
     * STUDENT ANSWER
     */
     return count(x,sqrt(x));
}",1.0,1111111111
Recursion_2,1420821,2210535,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if (n == 0) {
		cout << n;
	}
	else {
		printArray(n - 1);
		cout << "", "" << n;
	}
}",1.0,1111111111
Recursion_3,1420821,2210535,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if (n <= 0)
	    {
			cout << n;
		}
		else
		{
			cout << n << "" "";
			printPattern(n - 5);
			cout << "" "" << n;
		}
}",1.0,1111111111
Recursion_4,1420821,2210535,"int max(int a, int b)   {
    if (a > b)  {
        return a;
    }
    else return b;
}
int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    if (length == 1)   {
        return arr[0];
    }
    return max(arr[length-1],findMax(arr,length-1));
}",1.0,1111111111
Recursion_5,1420821,2210535,"string deleteSpace(string str, int index=0) {
	int n = str.length();
	if (index >= n) {
		return """";
	}
	if (str[index] != ' ') {
		return str[index] + deleteSpace(str, index + 1);
	}
	else {
		return deleteSpace(str, index + 1);
	}
}
bool isPalin(string str, int l, int r) {
	if (l == r) {
		return true;
	}
	if (str[l] != str[r]) {
		return false;
	}
	if (l < r ) {
		return isPalin(str, l + 1, r - 1);
	}
	return true;
}
bool isPalindrome(string str) {
	string str1 = deleteSpace(str);
	int n = str1.length();
	if (n == 0) {
		return true;
	} // string is empty ==> It is palindrome
	return isPalin(str1, 0, n-1);
}",1.0,1111111111
Recursion_6,1420821,2210535,"int findGCD(int a, int b)
{
    if (b == 0) {
        return a;
    }
    else {
        return findGCD(b,a%b);
    }
}",1.0,1111111111
Recursion_7,1420821,2210535,"int decimalToBinary(int decimal_number) 
{ 
    //Base case
	if (decimal_number == 0) {
		return 0;
	}
	else {
		return (decimal_number % 2 + 10 * (decimalToBinary(decimal_number / 2)));
	}
} ",1.0,1111111111
Recursion_8,1420821,2210535,"string exp(string s, int k)
{
	if (k == 0) return """";
	return s + exp(s, k - 1);
}

int index_exp(string s, int& i, int k = 1)
{
	if (s[i] == '(') k++;
	else if (s[i] == ')') k--;
	if(k == 0) return i;
	i++;
	return index_exp(s, i,k);
}


string expand(string s)
{
	if (s == """") return """";
	if (s[0] <= '9' && s[0] >= '0')
	{
		int i = 0;
		int index = index_exp(s.substr(2), i);
		return exp(expand(s.substr(2, index)), s[0] - '0') + expand(s.substr(index+2));
	}
	else
	{
		if (s[0] != ')') return s[0] + expand(s.substr(1));
		else return expand(s.substr(1));
	}

}",1.0,11111
Recursion_9,1420821,2210535,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    cout << number;
    if (number == 1)    {
        return;
    }
    if (number % 2 == 0)    {
        cout <<"" "";
        number = number / 2;
        printHailstone(number);
    }
    else {
        cout <<"" "";
        number = number * 3 + 1;
        printHailstone(number);
    }
}",1.0,1111111111
Recursion_10,1420821,2210535,"int myArrayToInt1(char *str, int n, int index=0, int result=0)    {
    if (index == n) {
        return result;
    }
    if (str[index] >= '0' && str[index] <= '9') {
        result = result*10 + (str[index] - '0');
        return myArrayToInt1(str,n,index+1,result);
    }
    else {
        return -1;
    }
}
int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    return myArrayToInt1(str,n);
}",1.0,1111111111
Recursion_11,1420821,2210535,"int reverseFactorial1(int n, int k = 2) {
	if (n == 1) {
		return k-1;
	}
	else if (n % k == 0) {
		return reverseFactorial1(n / k, k + 1);
	}
	else return -1;
}
int reverseFactorial(int n) {
	return reverseFactorial1(n);
}",1.0,1111111111
Recursion_12,1420821,2210535,"int findGCD(int a, int b)   {
    if (b == 0) {
        return a;
    }
    return findGCD(b, a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_13,1420821,2210535,"int mininumBracketAdd1(string &s, int length, int index, int &openC, int &closeC) {
	if (index == length) return openC + closeC;
	else {
		if (s[index] == '(') {
			openC++;
		}
		else if (s[index] == ')') {
			if (openC > 0) openC--;
			else closeC++;
		}
		index++;
		return mininumBracketAdd1(s, length, index, openC, closeC);
	}
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    int n = s.length();
    int a = 0;
    int b = 0;
    return mininumBracketAdd1(s,n,0,a,b);
    
}",1.0,1111111111
Recursion_14,1420821,2210535,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111
Recursion_15,1420821,2210535,"#include <string>
string reverseSentence1(string s) {
	// STUDENT ANSWER
	if (s.find("" "") == string::npos) {
		return s + "" "";
	}
	else {
		return reverseSentence1(s.substr(s.find("" "") + 1)) + s.substr(0, s.find("" "")) + "" "";
	}
}
string reverseSentence(string s) {
	string str = reverseSentence1(s);
	return str.substr(0,str.length() - 1);
}",1.0,1111111111
Recursion_17,1420821,2210535,"int superString(string x, string y, int m, int n) {

    if (m == 0) return n;
    if (n == 0) return m;


    if (x[m - 1] == y[n - 1]) {
        return superString(x, y, m - 1, n - 1) + 1;
    } else {

        return min(
            superString(x, y, m - 1, n) + 1,
            superString(x, y, m, n - 1) + 1
        );
    }
}",1.0,1111111111
Recursion_18,1420821,2210535,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if (*str == '\0')   {
        return 0;
    }
    return 1 + strLen(str+1);
} ",1.0,1111111111
Recursion_19,1420821,2210535,"bool check(char* text, char* patt) {
	if (*text == '\0' && *patt != '\0') {
		return false;
	}
	if (*patt == '\0') {
		return true;
	}
	if (*text == *patt) {
		return check(text + 1, patt + 1);
	}
	return false;
}
bool containsPattern(char* text, char* pattern) {
	if (*text == '\0') {
		return false;
	}
	if (*text == *pattern) {
		if (check(text, pattern)) {
			return true;
		}
		else return containsPattern(text + 1, pattern);
	}
	return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1420821,2210535,"int countWaySumOfSquare1(int x, int num) {
	if (x == 0) {
		return 1;
	}
	if (x < 0 || num < 0) {
		return 0;
	}
	int result1 = countWaySumOfSquare1(x - num * num, num - 1);
	int result2 = countWaySumOfSquare1(x, num - 1);
	return result1 + result2;

}
int countWaySumOfSquare(int x) {
    
	return countWaySumOfSquare1(x, static_cast<int>(sqrt(x)));
}",1.0,1111111111
Recursion_2,1421107,2112585,"void printArray(int n)
{
    if(n==0) {
        cout<< n;
    }
    else{
        printArray(n-1);
        cout << "", "" <<n ;
    }
}",1.0,1111111111
Recursion_3,1421107,2112585,"void printPattern(int n) 
{ 
    if (n <= 0) { 
        cout << n ; 
        return;
    } 

    cout << n << "" ""; 
    printPattern(n - 5); 
  
    cout << "" ""<< n ; 
} ",1.0,1111111111
Recursion_4,1421107,2112585,"int findMax(int* arr, int length)
{
    if (length == 1) 
        return arr[0]; 
    return max(arr[length-1], findMax(arr, length-1)); 
} ",1.0,1111111111
Recursion_5,1421107,2112585,"bool isPalindrome(string str) {
    int a = 0;
    int b = str.length();
    if (b < 2) return 1;
    else {
        if (str[a] == ' ') a++;
        if (str[b - 1] == ' ') b--;
        if (str[a] == str[b - 1]) {
            return isPalindrome(str.substr(a + 1, b - a - 2));
        }
        else return 0;
    }
}",1.0,1111111111
Recursion_6,1421107,2112585,"int findGCD(int a, int b) {
    if (a < b) return findGCD(b, a);
    if (b == 0) return a;
    else return findGCD(a % b, b);
}
",1.0,1111111111
Recursion_7,1421107,2112585,"int decimalToBinary(int decimal_number) {
    if (decimal_number == 0) return 0;
    else {
        return decimalToBinary(decimal_number / 2) * 10 + decimal_number % 2;
    }
}
",1.0,1111111111
Recursion_9,1421107,2112585,"void printHailstone(int number)
{
    if(number==1) cout<<1;
    else{
        cout<<number<<"" "";
        if (number%2==0) number/=2;
        else number=number*3+1;
        printHailstone(number);
    }
   
}",1.0,1111111111
Recursion_11,1421107,2112585,"int reverseFactorialHelper(int n, int k) {
    if (n == 1) {
        return k;
    }
    if (n % k != 0) {
        return 0;
    }
    return reverseFactorialHelper(n / k, k+1);
}

int reverseFactorial(int n) {
    return reverseFactorialHelper(n, 2)-1;
}",1.0,1111111111
Recursion_12,1421107,2112585,"int findGCD(int a, int b) {
    if (a < b) return findGCD(b, a);
    if (b == 0) return a;
    else return findGCD(a % b, b);
}
int findLCM(int a, int b)
{
    return (a / findGCD(a, b)) * b;
}",1.0,1111111111
Recursion_18,1421107,2112585,"int strLen(char* str)     
{ 
    int length = 0;
    if (str[length] == '\0') return 0;
    else return strLen(str+1)+1;
} ",1.0,1111111111
Recursion_19,1421107,2112585,"bool exactMatch(char *text, char *pat)
{
 if (*text == '\0' && *pat != '\0')
  return false;
 
 if (*pat == '\0')
  return true;
 
 if (*text == *pat)
  return exactMatch(text + 1, pat + 1);
 
 return false;
}
 
bool containsPattern(char *text, char *pat)
{
 if (*text == '\0')
  return false;
 
 if (text == pat)
  if(exactMatch(text, pat))
   return 1;
  else
  return containsPattern(text + 1, pat);
 
 return containsPattern(text + 1, pat);
}
",0.5,
Recursion_20,1421107,2112585,"int helper(int sum, int base){
    int result = pow(base, 2);
       
    if(sum == result)
        return 1;
    if(sum < result)
        return 0;
    int x = helper(sum - result, base + 1);
    int y = helper(sum, base+1);
    return x + y;
}
int countWaySumOfSquare(int x)
{
    return helper(x, 1);
}

",1.0,1111111111
Recursion_2,1422146,2252260,"void printArray(int n, int i=0)
{
    /*  
     * STUDENT ANSWER
     */
    if(i>n)
        return;
    cout << i;
    if(i<n)
        cout << "", "";
    printArray(n, i+1);
}",1.0,1111111111
Recursion_3,1422146,2252260,"void recursive(int n, int i){
    if(n <= 0){
        cout << n << "" "";
        return;
    }
    cout << n << "" "";
    recursive(n-5, i);
    cout << n;
    if(n!=i)
        cout << "" "";
}

void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    int i=n;
    return recursive(n,i);
}
",1.0,1111111111
Recursion_4,1422146,2252260,"int recursion (int *arr, int length, int i, int max){
    if(i>=length)
        return max;
    if(arr[i] >= max)
        max = arr[i];
    return recursion (arr, length, i+1, max);
}

int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    int i=0;
    int max = arr[0];
    return recursion(arr, length, i, max);
}",1.0,1111111111
Recursion_5,1422146,2252260,"string standardize(string str, string s, unsigned int i) {
    if(i >= str.length())
        return s;
    if(isalnum(str[i]) || !isspace(str[i])){
        if(isupper(str[i]))
            str[i] = tolower(str[i]);
        s += str[i];
    }
    return standardize(str, s, i+1);
}

bool checkPalindrome(string s){
    if(s.length()==0 || s.length()==1)
        return true;
    if(s[0] == s[s.length()-1])
        return checkPalindrome(s.substr(1, s.length()-2));
    return false;
}

bool isPalindrome(string str)  { 
    string s = """";
    unsigned int i=0;
    
    s = standardize(str, s, i);
    
    return checkPalindrome(s);
}",1.0,1111111111
Recursion_6,1422146,2252260,"int findGCD(int a, int b)
{
    if(a==0)
        return b;
    return findGCD(b%a, a);
}",1.0,1111111111
Recursion_7,1422146,2252260,"string toBinary(int decimal_number, string& s) {
    if(decimal_number == 0){
        if(s.empty())
            return ""0"";
        else
            return s;
    }
    s = to_string(decimal_number%2) + s;
    return toBinary(decimal_number/2, s);
}

int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    string s = """";
    return stoi(toBinary(decimal_number, s));
} ",1.0,1111111111
Recursion_8,1422146,2252260,"void parenthese_expand(string& result, string subResult, int i, int count){
    if(i >= count)
        return;
    result += subResult;
    parenthese_expand(result, subResult, i+1, count);
}

string expand(string, unsigned int&);

string Expand(string& result, string s, unsigned int& index){
    if(index >= s.length())
        return result;
    if (isdigit(s[index])) {
        int count = s[index] - '0';

        index = index+2; 
            
        string subResult = expand(s, index);  
        index++;  
            
        int i=0;
        parenthese_expand(result, subResult, i, count);
    } 
    else if (islower(s[index])) {
        result += s[index];
        index++;
    } 
    else if (s[index] == ')') {
        return result;
    }
    return Expand(result, s, index);
}

string expand(string s, unsigned int& index) {
    string result = """";
    
    return Expand(result, s, index);
}

string expand(string s) {
    unsigned int index = 0;
    return expand(s, index);
}",1.0,11111
Recursion_9,1422146,2252260,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if(number==1){
        cout << number;
        return;
    }
    cout << number << "" "";
    if(number % 2 == 0)
        printHailstone(number/2);
    else
        printHailstone(3*number+1);
}",1.0,1111111111
Recursion_10,1422146,2252260,"int myArrayToInt(char* str, int n, int i, string s){
    if(i>=n)
        return stoi(s);
    s += str[i];
    return myArrayToInt(str, n, i+1, s);
}

int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    int i=0;
    string s = """";
    return myArrayToInt(str, n, i, s);
}",1.0,1111111111
Recursion_11,1422146,2252260,"int reverseFactorial(int n, int k=1, int i=1) {
    // STUDENT ANSWER
    if(n==1)
        return 1;
    else if(k==n)
        return i-1;
    else if(k>n)
        return -1;

    return reverseFactorial(n, k*i, i+1);
}",1.0,1111111111
Recursion_12,1422146,2252260,"int findLCM(int a, int b, int LCM, int n){
    if(LCM % a == 0 && LCM % b == 0)
        return LCM;
    return findLCM(a, b, LCM+n, n);
}

int findLCM(int a, int b) {
    int LCM = max(a,b);
    int n = max(a, b);
    return findLCM(a, b, LCM, n);
}",1.0,1111111111
Recursion_13,1422146,2252260,"int balance(string s, int depth = 0) {
    if (s.empty()) {
        return depth;
    }

    if (s[0] == '(') {
        return balance(s.substr(1), depth + 1);
    } else {
        if (depth > 0) {
            return balance(s.substr(1), depth - 1);
        } else {
            return 1 + balance(s.substr(1), depth);
        }
    }
}

int mininumBracketAdd(string s) {
    return balance(s);
}",0.9,1111111110
Recursion_14,1422146,2252260,"void tmpCount(vector<int>& nums, int* tmp, int n, int i, int val){
    if(i>n-1)
        return;
    val = ((val+nums[i])%2+2)%2;
    tmp[val]++;
    tmpCount(nums, tmp, n, i+1, val);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int n = nums.size();
    int tmp[2] = {1,0};
    
    int result = 0, val=0;
    tmpCount(nums, tmp, n, 0, val);
    result = tmp[0]*tmp[1];
    return result%m;
}
",1.0,1111111111
Recursion_15,1422146,2252260,"string reverseWord(string s) {
    if (s.find(' ') == string::npos) {
        return s;
    }
    return reverseWord(s.substr(s.find(' ') + 1)) + "" "" + s.substr(0, s.find(' '));
}

string reverseSentence(string s) {
    if (s.find(' ') == string::npos) {
        return s;
    }
    return reverseWord(s.substr(s.find_last_of(' ') + 1)) + "" "" + reverseSentence(s.substr(0, s.find_last_of(' ')));
}",0.72,1111111111
Recursion_17,1422146,2252260,"int shortestSuperString(string x, string y, int m, int n){
    if(m==0) return n;
    if(n==0) return m;
    
    if(x[m-1] == y[n-1])
        return 1+shortestSuperString(x, y, m-1, n-1);
    else
        return 1 + min(shortestSuperString(x,y,m-1,n), shortestSuperString(x,y,m,n-1));
}

int superString(string x, string y, int m, int n) {
    return shortestSuperString(x, y, m, n);
}",1.0,1111111111
Recursion_18,1422146,2252260,"int strLen(char* str, int i){
    if(str[i] == '\0')
        return i;
    return strLen(str, i+1);
}

int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    int i=0;
    return strLen(str, i);
} ",1.0,1111111111
Recursion_19,1422146,2252260,"#include <cstring>

void toString(string& s, char* c, unsigned int index){
    if(index >= strlen(c))
        return;
    s+=c[index];
    toString(s, c, index+1);
}

bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
    string Text = """", Pattern = """";
    unsigned int index = 0;
    toString(Text, text, index);
    toString(Pattern, pattern, index);
    size_t found = Text.find(Pattern);
    if(found != string::npos)
        return 1;
    else 
        return 0;
}",1.0,1111111111
Recursion_20,1422146,2252260,"int countWays(int x, int currNum) {
    if (x == 0) {
        return 1;  
    }
    if (x < 0 || currNum <= 0) {
        return 0;  
    }
    
    
    int includeCurrNum = countWays(x - pow(currNum, 2), currNum - 1);
    int skipCurrNum = countWays(x, currNum - 1);
    
    return includeCurrNum + skipCurrNum;
}

int countWaySumOfSquare(int x) {
    int currNum = floor(sqrt(x)); 
    return countWays(x, currNum);
}",1.0,1111111111
Recursion_2,1423412,2213836,"void printArray(int n) {
    if (n >= 0) {
        if (n > 0) {
            printArray(n - 1);
            cout << "", "";
        }
        cout << n;
    }
}",1.0,1111111111
Recursion_3,1423412,2213836,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(n <= 0) {
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1423412,2213836,"int findMax(int* arr, int length) {
    if (length == 1) {
        return *arr;
    }
    int max = findMax(arr + 1, length - 1);
    return (*arr > max) ? *arr : max;
}",1.0,1111111111
Recursion_5,1423412,2213836,"bool isPalindromeHelper(string s, int l, int r) {
    if(l > r) return true;
    if(s[l] == ' ') l++;
    if(s[r] == ' ') r--;
    if(s[l] != s[r]) return false;
    return isPalindromeHelper(s, l + 1, r - 1);
}

bool isPalindrome(string str) 
{ 
    return isPalindromeHelper(str, 0, str.length() - 1);
}",1.0,1111111111
Recursion_6,1423412,2213836,"int findGCD(int a, int b) {
    //* nếu b =  0 thì a là ước chung lớn nhấtnhất
    if (b == 0) {
        return a;
    }
    
    //* đệ quy để gọi lại b mới
    return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1423412,2213836,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    if(decimal_number == 0) return 0;
    int binary_digit = decimal_number % 2; //* chia lấy phần dư
    int binary_result = decimalToBinary(decimal_number / 2); //* đệ quy gọi hàm chia tới lúc bằng 0
    return binary_result * 10 + binary_digit;
}",1.0,1111111111
Recursion_8,1423412,2213836,"//! hàm lặp chuỗi theo số trước đó
string mulString(string s, int number) {
    //* number bằng 0 thì hết lặp
    if(number == 0) return """";
    return s + mulString(s, number - 1);
}

//! hàm lấy số trước chuỗi
string numString(string s) {
    //* nếu chuỗi rỗng hoặc không phải số thì trả về rỗng
    if(s == """" || s[0] < '0' || s[0] > '9') return """";
    return s[0] + numString(s.substr(1));
}

//! hàm mở rộng chuỗi
string expand(string s) {
    //* nếu chuỗi rỗng
    if(s == """") return """";

    else if(s[0] >= '0' && s[0] <= '9') {
        string number = numString(s); //* lấy số trước chuỗi
        string temp = expand(s.substr(number.length() + 1)); //* đệ quy sau số để tiếp tục
        int bracket = temp.find(')'); //* tìm vị trí dấu đóng ngoặc

        //* lặp chuỗi đến dấu đóng ngoặc number lần && đệ quy tiếp sau dấu ngoặc
        return mulString(temp.substr(0, bracket), stoi(number)) + expand(temp.substr(bracket + 1)); 
    }

    //* nếu không phải số thì ghép vào chuỗi xét tiếp
    return s[0] + expand(s.substr(1));
}",1.0,11111
Recursion_9,1423412,2213836,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    cout << number;
    if(number == 1) return; //* nếu là 1 thì kết thúc vòng lặp
    if(number%2 == 0) { //* TH là số chẵn
        cout << "" "";
        printHailstone(number / 2);
    }

    else {
        cout << "" ""; //* TH là số lẻ
        printHailstone(number*3 + 1);
    }
}",1.0,1111111111
Recursion_10,1423412,2213836,"int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    //* nếu duyệt tới số lượng n = 1 thì trả về kí tự đầu trong chuỗi
    if(n == 1) return str[0] - '0';
    //* nếu không thì đệ quy xét n giảm dần
    return myArrayToInt(str, n - 1)*10 + (str[n-1] - '0');
}",1.0,1111111111
Recursion_11,1423412,2213836,"int helper(int n, int k, int result) {
    if(n == 1) return 1; //* nếu n = 1 thì trả về 1
    result *= k;
    if(result == n) return k; //* nếu result bằng n thì trả về k
    else if(result > n) return -1; //* result lớn hơn thì không có giá trị nào
    return helper(n, k + 1, result);
}

int reverseFactorial(int n) {
    // STUDENT ANSWER
    return helper(n, 1, 1);
}",1.0,1111111111
Recursion_12,1423412,2213836,"//! hàm tìm GCD (ước số chung lớn nhất)
int GCD(int a, int b) {
    if(b == 0) return a;
    return GCD(b, a % b);
}
//! hàm tìm LCM (bội số chung nhỏ nhất)
int findLCM(int a, int b)
{
    if(a == 0 || b == 0) return 0;
    int gcd = GCD(a, b);
    return (a * b) / gcd;
}",1.0,1111111111
Recursion_13,1423412,2213836,"//! tìm số dấu ngoặc cần bổ sung để chuỗi ngoặc trùng khớp
int Helper(string& s, int l, int r, int index = 0) {
    // STUDENT ANSWER
    //* l là biến đếm ngoặc đang mở
    //* r là biến đếm ngoặc đang đóng
    int n = s.length();
    if(index >= n) return l + r;
    if(s[index] == '(') l++;
    if(s[index] == ')') {
        if(l > 0) {
            l--;
        }
        else r++;
    }
    return Helper(s, l, r, index + 1);
}

int mininumBracketAdd(string s) {
    return Helper(s,0,0,0);
}",1.0,1111111111
Recursion_14,1423412,2213836,"void tmpCount(vector<int>& nums, int* tmp, int n, int i, int val) {
    if(i > n - 1) return;
    val = ((val + nums[i]) % 2 + 2) % 2;
    tmp[val]++;
    tmpCount(nums, tmp, n, i + 1, val);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int n = nums.size();
    int tmp[2] = {1,0};
    
    int result = 0; 
    int val = 0;
    tmpCount(nums, tmp, n, 0, val);
    result = tmp[0] * tmp[1];
    return result % m;
}",1.0,1111111111
Recursion_15,1423412,2213836,"string reverseSentence(string s) {
    // STUDENT ANSWER
    if(s.find(' ') == string::npos) return s;
    return reverseSentence(s.substr(s.find(' ') + 1)) + ' ' + s.substr(0, s.find(' '));
}",1.0,1111111111
Recursion_17,1423412,2213836,"int superString(string x, string y, int m, int n) {
    if(m==0) return n;
    if(n==0) return m;
    if(x[m-1]==y[n-1])
    return 1+superString(x,y,m-1,n-1);
    return 1+ min(superString(x,y,m-1,n),superString(x,y,m,n-1));
}",1.0,1111111111
Recursion_18,1423412,2213836,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    if(*str == '\0') return 0;
    return 1 + strLen(str + 1);
}",1.0,1111111111
Recursion_19,1423412,2213836,"#include <cstring>
void toString(string& s, char* c, unsigned int index) {
    if(index >= strlen(c)) return;
    s += c[index];
    toString(s, c, index + 1);
}

bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
     string Text = """", Pattern = """";
     unsigned int index = 0;
     toString(Text, text, index);
     toString(Pattern, pattern, index);
     size_t found = Text.find(Pattern);
     if(found != string::npos) return 1;
     else return 0;
}",1.0,1111111111
Recursion_20,1423412,2213836,"int countWaySumOfSquare(int x, int m)
{
    if(x==0) return 1;
    if(x<0 || m<=0) return 0;
    return countWaySumOfSquare(x,m-1)+countWaySumOfSquare(x-m*m,m-1);
}
int countWaySumOfSquare(int x)
{
    /*  
     * STUDENT ANSWER
     */
    return  countWaySumOfSquare(x, (int) sqrt(x) );
}
",1.0,1111111111
Recursion_2,1423972,2213248,"void printArray(int n)
{
    if(n == 0) cout << 0;
    else {
        printArray(n - 1);
        cout << "", "" << n;
    }
}",1.0,1111111111
Recursion_3,1423972,2213248,"void printPattern(int n) 
{ 
    if(n <= 0) cout << n;
    else {
        cout << n << "" "";
        printPattern(n - 5);
        cout << "" "" << n;
    }
}",1.0,1111111111
Recursion_4,1423972,2213248,"int findMax(int* arr, int length)
{
    if(length == 1) return arr[0];
    else {
        int temp = findMax(arr + 1, length - 1);
        if(arr[0] > temp) return arr[0];
        else return temp;
    }
}",1.0,1111111111
Recursion_5,1423972,2213248,"bool isPalindrome(string str) 
{ 
    int len = str.size();
    if(len <= 1) return 1;
    else {
        if(str[0] == ' ') return isPalindrome(str.substr(1, len - 1));
        if(str[len - 1] == ' ') return isPalindrome(str.substr(0, len - 1));
        if(str[0] != str[len - 1]) return 0;
        else return isPalindrome(str.substr(1, len - 2));

    }
}",1.0,1111111111
Recursion_6,1423972,2213248,"int findGCD(int a, int b)
{
    if(a < b) return findGCD(b, a);
    if(b == 0) return a;
    else return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1423972,2213248,"int decimalToBinary(int decimal_number) 
{ 
    if(decimal_number == 0) return 0;
    else return decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2);
} ",1.0,1111111111
Recursion_8,1423972,2213248,"bool have_open(string s) {
    if(s[0] == '\0') return 0;
    else if(s[0] == '(') return 1;
    else return have_open(s.substr(1));
}

string inside(string s, int open){
    if(open == 0) return """";
    if(s[0] == '(') return s[0] + inside(s.substr(1), open + 1);
    else if(s[0] == ')') {
        if(open == 1) return inside(s.substr(1), open - 1);
        else return s[0] + inside(s.substr(1), open - 1);
    }
    else return s[0] + inside(s.substr(1), open);
}

string combine(string element, int times) {
    if(times == 0) return """";
    else return element + combine(element, times - 1);
}

string scan(string s) {
    if(s[0] == '\0') return """";
    if(s[0] >= '0' && s[0] <= '9') {
        int times = s[0] - '0';
        string temp = inside(s.substr(2), 1);
        return combine(temp, times) + scan(s.substr(temp.size() + 3));
    }
    else return s[0] + scan(s.substr(1));
}

string expand(string s) {
    if(!have_open(s)) return scan(s);
    else return expand(scan(s));
}
",1.0,11111
Recursion_9,1423972,2213248,"void printHailstone(int number)
{
    if(number == 1) cout << 1;
    else if(number % 2 == 0) {
        cout << number << "" "";
        printHailstone(number / 2);
    }
    else {
        cout << number << "" "";
        printHailstone(number * 3 + 1);
    }
}
",1.0,1111111111
Recursion_10,1423972,2213248,"int myArrayToInt(char *str, int n) 
{ 
    if(n == 1) return str[0] - 48;
    else return (str[n - 1]  - 48)+ myArrayToInt(str, n - 1) * 10;
}
",1.0,1111111111
Recursion_11,1423972,2213248,"int reverse(int n, int current) {
    if(n / current == 1 && n % current == 0) return current;
    else if(n % current != 0) return - 1;
    else return reverse(n / current, current + 1);
}

int reverseFactorial(int n) {
    return reverse(n, 1);
}",1.0,1111111111
Recursion_12,1423972,2213248,"int findGCD(int a, int b)
{
    if(a < b) return findGCD(b, a);
    if(b == 0) return a;
    else return findGCD(b, a % b);
}

int findLCM(int a, int b) {
    return a * b / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1423972,2213248,"int count(string & s, int index = 0, int count1 = 0, int count2 = 0) {
    if(s[index] == '\0') return count1 + count2;
    if(s[index] == '(') return count(s, index + 1, count1 + 1, count2);
    if(s[index] == ')' && count1 > 0) return count(s, index + 1, count1 - 1, count2);
    else return count(s, index + 1, count1, count2 + 1);
}
int mininumBracketAdd(string s){
    return count(s);
}",1.0,1111111111
Recursion_14,1423972,2213248,"int oddSumSublist(vector<int>& arr, int m, int index = 0, int currentSum = 0) {
    int size = arr.size();
    if (index == size) {
        // Base case: If we've reached the end of the list, check if the current sum is odd.
        return (currentSum % 2 == 1) ? 1 : 0;
    }

    // Include the current element in the sum and recurse.
    int includeCount = oddSumSublist(arr, m, index + 1, (currentSum + arr[index]) % m);

    // Exclude the current element from the sum and recurse.
    int excludeCount = oddSumSublist(arr, m, index + 1, currentSum);

    // Return the sum of counts 4 including and excluding the current element.
    return includeCount + excludeCount;
}",0.7,01000
Recursion_15,1423972,2213248,"int index(string s, bool &end) {
    if(s[0] == '\0') {
        end = 1;
        return 0;
    }
    else if(s[0] == ' ') return 0;
    else return 1 + index(s.substr(1), end);
}

string word(string s) {
    if(s[0] == '\0' || s[0] == ' ') return """";
    else return s[0] + word(s.substr(1));
}

string reverseSentence(string s) {
    if(s[0] == '\0') return """";
    else {
        bool end = 0;
        int val = index(s, end);
        if(!end) return reverseSentence(s.substr(val + 1)) + "" "" + word(s);
        else return word(s);
        
    }
}",1.0,1111111111
Recursion_17,1423972,2213248,"int superString(string x, string y, int m, int n) {
    if(m == 0) return n;
    if(n == 0) return m;
    if(x[0] == y[0]) return 1 + superString(x.substr(1), y.substr(1), m - 1, n - 1);
    else {
        int temp1 = superString(x.substr(1), y, m - 1, n);
        int temp2 = superString(x, y.substr(1), m, n - 1);
        if(temp1 > temp2) return 1 + temp2;
        else return 1 + temp1;
    }
}",1.0,1111111111
Recursion_18,1423972,2213248,"int strLen(char* str)     
{ 
    if(str[0] == '\0') return 0;
    else return 1 + strLen(str + 1);
} 
 ",1.0,1111111111
Recursion_19,1423972,2213248,"int length(char* text) {
    if(text[0] == '\0') return 0;
    else return 1 + length(text + 1);
}

bool IsEqual(char* text, char* pattern) {
    if(pattern[0] == '\0') return 1;
    else {
        if(text[0] != pattern[0]) return 0;
        else return IsEqual(text + 1, pattern + 1);
    }
}

bool containsPattern(char* text, char* pattern)
{
    if(length(text) < length(pattern)) return 0;
    else {
        if(IsEqual(text, pattern)) return 1;
        else return containsPattern(text + 1, pattern);
    }
}",1.0,1111111111
Recursion_20,1423972,2213248,"int countWays(int x, int current) {
    if (x == 0) {
        return 1;
    }
    if (x < 0 || pow(current, 2) > x) {
        return 0;
    }

    // Count ways with current number squared
    int withCurrent = countWays(x - pow(current, 2), current + 1);

    // Count ways without current number squared
    int withoutCurrent = countWays(x, current + 1);

    return withCurrent + withoutCurrent;
}

int countWaySumOfSquare(int x) {
    return countWays(x, 1);
}",1.0,1111111111
Recursion_2,1425586,2212372,"void printArray(int n)
{
    if(n==0){cout<<0;}
    else {
        printArray(n-1);
        cout<<"", ""<<n;
    }
}",1.0,1111111111
Recursion_3,1425586,2212372,"void printPattern(int n) 
{ 
  if(n<=0){cout<<n;}
  else{
      cout<<n<<"" "";
      printPattern(n-5);
      cout<<"" ""<<n;
  }
    
}",1.0,1111111111
Recursion_4,1425586,2212372,"int findMax(int* arr, int length)
{   
     if(length>0)
        {arr[0]= max(arr[0],arr[length-1]);
        findMax(arr,length-1);}
     return arr[0];
}
",1.0,1111111111
Recursion_5,1425586,2212372,"bool isPalindrome(string str) 
{  int n=str.length();
    if(n<=1){return 1;}
    if(str[0]==' '){
       return isPalindrome(str.substr(1,n-1));
    }
    else if(str[n-1]==' '){
        return isPalindrome(str.substr(0,n-1));
    } 
    else if(str[0]==str[n-1]){
        return isPalindrome(str.substr(1,n-2));
    }
    else {return 0;}
}",1.0,1111111111
Recursion_6,1425586,2212372,"int findGCD(int a, int b)
{if(a>=b){
 if(a%b==0){return b;}else{return findGCD(a%b,b);}
}else{
 if(b%a==0){return a;}
else{return findGCD(a,b%a);}
    
}}",1.0,1111111111
Recursion_7,1425586,2212372,"int decimalToBinary(int decimal_number) 
{ if(decimal_number/2!=0){
    return decimal_number%2+10*decimalToBinary(decimal_number/2);
}
if(decimal_number==0){ return 0; }
return 1;
} 
",1.0,1111111111
Recursion_8,1425586,2212372,"string take(const string& s, int i, int& j, int left, int right)
{
    if(left == right)
        return s.substr(i, j-i-1);
    
    if(s[j] == '(')
    {
        j++;
        return take(s, i, j, left+1, right);
    }
        
    else if(s[j] == ')')
    {
        j++;
        return take(s, i, j,  left, right+1);
    }
    j++;
    return take(s, i,j, left, right);
            
}
string dup(const string& str, int times)
{
    if(times == 0)
        return """";
    return str+dup(str, times-1);
}
string solve(const string& s, int i, int n)
{
    if(i >= n)
        return """";
    string temp = """";
    
    if(s[i] >= '0' && s[i] <= '9')
    {
        int j = i+2;
        
        temp = take(s, i+2, j, 1, 0);
        // cout << temp << "" "";
        temp = dup(temp, s[i]-'0');
        return solve(temp, 0, temp.length()) + solve(s, j, n);
    }

    return s[i] + solve(s, i+1, n);
    
}
string expand(string s) {
    return solve(s, 0, s.length());
}",1.0,11111
Recursion_9,1425586,2212372,"void printHailstone(int number)
{
    if(number%2==0){cout<<number<<"" "";
    printHailstone(number/2);}
    else if (number==1){cout<<1;}
    else {cout<<number<<"" "";
     printHailstone(number*3+1);
}
}",1.0,1111111111
Recursion_10,1425586,2212372,"int myArrayToInt(char *str, int n) 
{ 
    if(n<=0){
        return 0;
    }
    int a=str[n-1]-'0';
    return a+ myArrayToInt(str, n-1)*10;
}",1.0,1111111111
Recursion_11,1425586,2212372,"int Factorial(int n, int k) {
    if (n == 1) return k-1;
    if (n % k != 0) return -1;
    return Factorial(n / k, k + 1);
}

int reverseFactorial(int n) {
    if (n == 1) return 1;
    return Factorial(n, 1);
}",1.0,1111111111
Recursion_12,1425586,2212372,"int GND(int a, int b){
    int c=a%b;
    if(c==0)
    return b;
    else return GND(b,c);
   
}
int findLCM(int a, int b)
{    if(a==b) return a;
    return a*b/GND(a,b);
}",1.0,1111111111
Recursion_13,1425586,2212372,"int balanceBrackets(const string& s, size_t i = 0, int openCount = 0, int addCount = 0) {
    if (i == s.size()) {
        return openCount + addCount;
    }
    if (s[i] == '(') {
        return balanceBrackets(s, i + 1, openCount + 1, addCount);
    } else if (s[i] == ')' && openCount > 0) {
        return balanceBrackets(s, i + 1, openCount - 1, addCount);
    } else if (s[i] == ')' && openCount == 0) {
        return balanceBrackets(s, i + 1, openCount, addCount + 1);
    } else {
        return balanceBrackets(s, i + 1, openCount, addCount);
    }
}
int mininumBracketAdd(string s) {
      return balanceBrackets(s);
}",1.0,1111111111
Recursion_14,1425586,2212372,"void thesubodd(vector<int>& nums,int i,bool odd,int &count){
	int n=nums.size();
	if(i==n) return;
	if(nums[i]&1) odd=!odd;
	if(odd) count++;
	thesubodd(nums,i+1,odd,count); 
}
void solve(vector<int>& nums,int i,long long &ans,int &count){
    int n=nums.size();
    if(i==n) return;
    ans+=count;
    if(nums[i]&1) count=n-i-count;
    solve(nums,i+1,ans,count);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int odd=0,count=0;
    long long ans=0;
    thesubodd(nums,0,odd,count);
    solve(nums,0,ans,count);
    int kq=ans%m;
    return kq;
}",1.0,1111111111
Recursion_15,1425586,2212372,"string reverseSentence(string s) {
    if( s.find(' ') == string::npos) return s;
    size_t index = s.find(' ');
    string firstWord = s.substr(0,index);
    string lastWord = s.substr(index + 1);
    string reverseString = reverseSentence(lastWord);
    return reverseString + ' ' + firstWord;
}",1.0,1111111111
Recursion_17,1425586,2212372,"int shortestSuperStringUtil(string x, string y, int m, int n){
    if (m == 0) return n;
    if (n == 0) return m;

    if (x[m - 1] == y[n - 1]) return 1 + shortestSuperStringUtil(x, y, m - 1, n - 1);
    else return 1 + min(shortestSuperStringUtil(x, y, m - 1, n), shortestSuperStringUtil(x, y, m, n - 1));
}

int superString(string x, string y, int m, int n){
    return shortestSuperStringUtil(x, y, m, n);
}",1.0,1111111111
Recursion_18,1425586,2212372,"int strLen(char* str){ 
     if(str[0]=='\0') return 0;
     else return 1 + strLen(str + 1);
} ",1.0,1111111111
Recursion_19,1425586,2212372,"bool isMatch(char* text, char* pattern) {
    if (*text == '\0' && *pattern == '\0') return true;
    if (*text == '\0' || *pattern == '\0') return false;
    if (*text == *pattern) return isMatch(text + 1, pattern + 1);
    return false;
}

bool containsPatternHelper(char* text, char* pattern) {
    if (*pattern == '\0') return true;
    if (*text == '\0') return false;
    if (isMatch(text, pattern)) return true;
    return containsPatternHelper(text + 1, pattern);
}

bool containsPattern(char* text, char* pattern) {
    return containsPatternHelper(text, pattern);
}",0.8,1111110110
Recursion_20,1425586,2212372,"int count(int x, int num){
    int val = (x - pow(num, 2));
    if (val == 0) return 1;
    if (val < 0) return 0;
    return count(val, num + 1) + count(x, num + 1);
}

int countWaySumOfSquare(int x){
    return count(x, 1);
}",1.0,1111111111
Recursion_2,1427875,2210578,"void printArray(int n)
{
    if(n < 0) return;
    printArray(n-1);
    if(n==0) cout<<n;
    else cout<<"", ""<<n;
}",1.0,1111111111
Recursion_3,1427875,2210578,"void printPattern(int n, bool max = 1) 
{ 
   if(n>0){
       if(max) cout<<n;
       else cout<<"" ""<<n;
       printPattern(n-5, 0);
   }
   cout <<"" ""<<n;
}",1.0,1111111111
Recursion_4,1427875,2210578,"int findMax(int* arr, int length,int max = -99999)
{
    if (length==0) return max;
    if(max<*arr) max=*arr;
    return findMax(++arr,--length,max);
}",1.0,1111111111
Recursion_5,1427875,2210578,"string removeSpaces(string input)
{
    if (input.empty())
    {
        return """";
    }
    else
    {
        char firstChar = input[0];
        string restOfString = input.substr(1);

        if (firstChar == ' ')
        {
            return removeSpaces(restOfString);
        }
        else
        {
            return firstChar + removeSpaces(restOfString);
        }
    }
}
bool isPalindrome(string str) 
{   str=removeSpaces(str);
    if(str.length()<=1) return true;
    if(str[0]!=str[str.length()-1]) return false;
    return isPalindrome(str.substr(1,str.length()-2));
}",1.0,1111111111
Recursion_6,1427875,2210578,"int findGCD(int a, int b)
{
    if(b==0) return a;
    if(a%b==0) return b;
    return findGCD(b,a%b);
}",1.0,1111111111
Recursion_7,1427875,2210578,"int decimalToBinary(int decimal_number) 
{ 
   if( decimal_number==1) return 1;
   
   if( decimal_number==0) return 0;
   return decimalToBinary(decimal_number/2)*10+decimal_number%2;
} ",1.0,1111111111
Recursion_9,1427875,2210578,"void printHailstone(int number,bool first=1)
{
    /*  
     * STUDENT ANSWER
     */
     if(first)cout <<number;
     else cout<<"" ""<<number;
     if(number==1) return;
     if(number%2==1){printHailstone(number*3+1,0);}
     else printHailstone(number/2,0);
}",1.0,1111111111
Recursion_10,1427875,2210578,"int myArrayToInt(char *str, int n, int m = 0) 
{ 
    if(n==0) return m;
    int k=*str-48;
    m=m*10+k;
    return myArrayToInt(++str,--n,m);
}",1.0,1111111111
Recursion_11,1427875,2210578,"int giaithua(int n){
    if(n==1) return 1;
    if(n==2) return 2;
    return n*giaithua(n-1);
}
int reverseFactorial(int n, int m=1) {
    if(giaithua(m)>n) return -1;
    if(n==giaithua(m)) return m;
    else return reverseFactorial(n,++m);
    
    
}",1.0,1111111111
Recursion_12,1427875,2210578,"int findGCD(int a, int b)
{
    if(b==0) return a;
    if(a%b==0) return b;
    return findGCD(b,a%b);
}
int findLCM(int a, int b)
{
    return a*b/findGCD(a,b);
}",1.0,1111111111
Recursion_13,1427875,2210578,"int mininumBracketAdd(string s, size_t index=0, int open=0) {
    if (index == s.length())
        return open;
    if (s[index] == '(')
        return mininumBracketAdd(s, index + 1, open + 1);
    else if (open > 0)
        return mininumBracketAdd(s, index + 1, open - 1);
    else
        return 1 + mininumBracketAdd(s, index + 1, open);
}",0.9,1111111110
Recursion_14,1427875,2210578,"void Sumsublist(vector<int>& nums, int& tong_chan, int& tong_le, long long& count,int&size, int& i)
{
	if (i == size) return;
	if (i != 0) nums[i] += nums[i - 1];
	if (nums[i] % 2 == 0)
	{
		//cout << i << "" "";
		count += tong_le;
		tong_chan++;
	}
	else
	{
		count = count + 1 + tong_chan;
		tong_le++;
	}
	i++;
	Sumsublist(nums, tong_chan, tong_le, count,size, i);
}
int oddSumSublist(vector<int>& nums, int m)
{
	long long count = 0;
	int i = 0, tong_chan = 0, tong_le = 0, size = nums.size();
	if (size == 0) return 0;
	if (size == 1)
	{
		if (nums[0] % 2 == 1) return 1;
		return 0;
	}
	i = 0;
	Sumsublist(nums, tong_chan ,tong_le , count,size, i);
	return count % m;
}",1.0,1111111111
Recursion_15,1427875,2210578,"string reverseSentence(string s) {
    int i=s.find("" "");
    if(i!=-1) return reverseSentence(s.substr(i+1))+"" ""+s.substr(0,i);
    else return s;
}",1.0,1111111111
Recursion_17,1427875,2210578,"int longestSubSeq(string x , string y , int m , int n){
    if(m==0 || n==0) return 0;
    if(x[m-1]==y[n-1]) return 1 + longestSubSeq(x,y,m-1,n-1);
    else return max(longestSubSeq(x,y,m-1,n),longestSubSeq(x,y,m,n-1));
}

int superString(string x, string y, int m, int n) {
    return m+n-longestSubSeq(x,y,m,n);
}",1.0,1111111111
Recursion_18,1427875,2210578,"
int strLen(char* str, int length=0)     
{ 
    if(*str != '\0') return  strLen(++str,++length);
    else return length;
} 
 ",1.0,1111111111
Recursion_19,1427875,2210578,"bool compare(char* text, char* pattern) {
    if (*pattern == '\0') return true;
    if (*text != *pattern) return false;
    return compare(text + 1, pattern + 1);
}

bool containsPattern(char* text, char* pattern) {
    if (*text == '\0') return false;
    if (*text == *pattern && compare(text, pattern)) return true;
    return containsPattern(text + 1, pattern);
}
",1.0,1111111111
Recursion_20,1427875,2210578,"int countWays(int x, int n, int max_n) {
    if (x == 0)
        return 1;
    if (x < 0 || n > max_n)
        return 0;
    return countWays(x - n*n, n + 1, max_n) + countWays(x, n + 1, max_n);
}

int countWaySumOfSquare(int x) {
    return countWays(x, 1, sqrt(x));
}",1.0,1111111111
Recursion_2,1428143,2212988,"void printArray(int n)
{   
    if(n>0)
    printArray(n-1);
    if(n==0) cout <<n;
    else cout<<"", ""<<n;
    
    return; 
}",0.7,1111111111
Recursion_4,1428143,2212988,"int findMax(int* arr, int length)
{   
    if (length==1) return arr[0];
    return max(arr[length-1], findMax(arr,length-1));
    
}",1.0,1111111111
Recursion_6,1428143,2212988,"int findGCD(int a, int b)
{   if (b != 0)
        return findGCD(b, a % b);
    else
        return a;
    
}",1.0,1111111111
Recursion_7,1428143,2212988,"int decimalToBinary(int n) 
{ 
     if(n==0)
     return 0;
    else
     return ((n%2)+ 10*decimalToBinary(n/2));
	
} ",0.5,1111111111
Recursion_8,1428143,2212988,"string find1(string s) {
	size_t pos = s.find(')');
	if (pos < s.length()) s.erase(pos);
	if (s[s.length() - 1] == '(') return """";
	char k = s[s.length() - 1];
	s.erase(s.length() - 1);
	return find1(s) + k;
}

string multiple(string s, int k) {
	if (k == 0) return """";
	return s + multiple(s, k - 1);
}

string expand(string s) {
	if (s.find(')') >= s.length()) return s;
	string piece = find1(s);
	int times = s[s.find(piece) - 2] - 48;
	s = s.replace(s.find(piece) - 2, piece.length() + 3, multiple(piece, times));
	return expand(s);
}",1.0,11111
Recursion_2,1428713,2212741,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if(n==0){
         cout<<n;
     }
     else{
         printArray(n-1);
         cout<<"",""<<"" ""<<n;
     }
     }
",1.0,1111111111
Recursion_3,1428713,2212741,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if(n<=0) cout<<n;
     else{
         cout<<n<<"" "";
         printPattern(n-5);
         cout<<"" ""<<n;
     }
}",1.0,1111111111
Recursion_4,1428713,2212741,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
     if(length==1) return arr[0];
     else{
         if(arr[length-1]>=arr[length-2]) arr[length-2]=arr[length-1];
         return findMax(arr,length-1);
     }
}",1.0,1111111111
Recursion_5,1428713,2212741,"bool isPalindrome(string str) 
{   
    int length=str.length();
    if(str.length()==0||str.length()==1) return 1;
    if(str[0]==' ') {
        str.erase(str.begin());
        return isPalindrome(str);
    }
    if(str[length-1]==' ') {
        str.pop_back();
        return isPalindrome(str);
    }
    if(str[0]==str[length-1]){
        str.erase(str.begin());
        str.pop_back();
        return isPalindrome(str);
    }
    else{
        return 0;
    }
}",1.0,1111111111
Recursion_6,1428713,2212741,"int findGCD(int a, int b)
{
    if(a>=b){
        if(a%b==0) return b;
        else{
            return findGCD(b,a%b);
        }
    }
    else{
        if(b%a==0) return a;
        else{
            return findGCD(a,b%a);
        }
    }
}",1.0,1111111111
Recursion_7,1428713,2212741,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if(decimal_number/2==0) return (decimal_number%2);
     else{
     return decimal_number%2+10*decimalToBinary(decimal_number/2);
    //  cout<<(decimal_number%2);
     }
} ",1.0,1111111111
Recursion_8,1428713,2212741,"string find1(string s) {
	size_t pos = s.find(')');
	if (pos < s.length()) s.erase(pos);
	if (s[s.length() - 1] == '(') return """";
	char k = s[s.length() - 1];
	s.erase(s.length() - 1);
	return find1(s) + k;
}

string multiple(string s, int k) {
	if (k == 0) return """";
	return s + multiple(s, k - 1);
}

string expand(string s) {
	if (s.find(')') >= s.length()) return s;
	string piece = find1(s);
	int times = s[s.find(piece) - 2] - 48;
	s = s.replace(s.find(piece) - 2, piece.length() + 3, multiple(piece, times));
	return expand(s);
}",1.0,11111
Recursion_9,1428713,2212741,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     if(number==1) cout<<number;
     else{
     cout<<number<<"" "";
     if(number%2==0) return printHailstone(number/2);
     if(number%2!=0) return printHailstone(number*3+1);
     }
}",1.0,1111111111
Recursion_10,1428713,2212741,"int myArrayToInt(char* str, int n)
{
	return stoi(str);
}",1.0,1111111111
Recursion_11,1428713,2212741,"
int i=1;
int reverseFactorial(int n) {
    // STUDENT ANSWER
    if(n/i==1&&n%i==0) {
        int k=i;
        i=1;
        return k;
    }
    else{
        if(n%i!=0) {
            i=1;
            return -1;
        }
        n/=i;
        i++;
        return reverseFactorial(n);
    }
}",1.0,1111111111
Recursion_12,1428713,2212741,"int findGCD(int a, int b)
{
    if(a>=b){
        if(a%b==0) return b;
        else{
            return findGCD(b,a%b);
        }
    }
    else{
        if(b%a==0) return a;
        else{
            return findGCD(a,b%a);
        }
    }
}

int findLCM(int a, int b)
{
    return (a/findGCD(a,b))*b;
}",1.0,1111111111
Recursion_13,1428713,2212741,"int minBracketsToAdd(const string& s, int openCount, int closeCount, int constant, int index) {
	if (index == (int)s.length()) {
		return abs(openCount - closeCount) + constant;
	}

	if (s[index] == '(') {
		openCount++;
	}
	else if (s[index] == ')') {
		if (openCount > 0) {
			openCount--;
		}
		else {
			constant++;
		}
	}
	return minBracketsToAdd(s, openCount, closeCount, constant, index + 1);
}

int mininumBracketAdd(const string& s) {
	return minBracketsToAdd(s, 0, 0, 0, 0);
}",1.0,1111111111
Recursion_14,1428713,2212741,"int sum(vector<int>& nums, int i) {
	int size = nums.size();
	if (i >= size) return 0;
	return nums[i] + sum(nums, i + 1);
}
void count(vector<int>& nums, int left, int right, int sumi, int& realsum, int& cc) {
	if (right < 0) return;
	else if (left > right) {
		left = 0;
		right--;
		realsum -= nums[right + 1];
		if (realsum == 0) return;
		sumi = realsum;
		count(nums, left, right, sumi, realsum, cc);
	}
	else if (sumi % 2 == 1) {
		cc++;
		left++;
		count(nums, left, right, sumi - nums[left - 1], realsum, cc);
	}
	else {
		left++;
		count(nums, left, right, sumi - nums[left - 1], realsum, cc);
	}
}
int oddSumSublist(vector<int>& nums, int m) {
	// STUDENT ANSWER
	int gg = 0;
	int a = nums.size() - 1;
	int b = sum(nums, 0);
	int h = b;
	int cc = 0;
	count(nums, gg, a, b, h, cc);
	return cc % m;
}
",0.6,1111110
Recursion_15,1428713,2212741,"string reverseSentence(string s) {
	size_t pos = s.find("" "");
	if (pos >= s.length()) return s;
	string remain = s.substr(pos + 1);
	string word = s.erase(pos);
	return reverseSentence(remain) + ' ' + word;
}",1.0,1111111111
Recursion_17,1428713,2212741,"int shortestSuperStringLength(string x, string y, int i, int j) {
	// Base case: If either string is empty, return the length of the other string
	if (i == 0) {
		return j;
	}
	if (j == 0) {
		return i;
	}

	// If the last characters match, reduce both strings and move one step
	if (x[i - 1] == y[j - 1]) {
		return shortestSuperStringLength(x, y, i - 1, j - 1) + 1;
	}

	// If the last characters don't match, try two options and return the minimum
	int option1 = shortestSuperStringLength(x, y, i - 1, j) + 1;
	int option2 = shortestSuperStringLength(x, y, i, j - 1) + 1;

	return min(option1, option2);
}

int superString(string x, string y, int m, int n) {
	return shortestSuperStringLength(x, y, m, n);
}
",1.0,1111111111
Recursion_18,1428713,2212741,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if(*str=='\0') return 0;
     str++;
     return 1+strLen(str);
     
} ",1.0,1111111111
Recursion_19,1428713,2212741,"bool match(char* text, char* pattern) {
	if (*pattern == '\0') return true;

	if (*text == '\0') return false;

	if (*text == *pattern) {
		return match(text + 1, pattern + 1);
	}
	else {
		// return match(text + 1, pattern);
		return false;
	}
}

bool containsPattern(char* text, char* pattern) {

	if (*text == '\0') {
		return false;
	}
	if (match(text, pattern) == true) {
		return true;
	}
	return containsPattern(text + 1, pattern);
}

",1.0,1111111111
Recursion_20,1428713,2212741,"
#include<cmath>
 

int getAllWaysHelper(int remainingSum, int power, int base){
      //calculate power
    int result = pow(base, power);
       
    if(remainingSum == result)
        return 1;
    if(remainingSum < result)
        return 0;
      //Two recursive calls one to include current base's power in sum another to exclude
    int x = getAllWaysHelper(remainingSum - result, power, base + 1);
    int y = getAllWaysHelper(remainingSum, power, base+1);
    return x + y;
}
 
int countWaySumOfSquare(int x) {
    return getAllWaysHelper(x, 2, 1);
}",1.0,1111111111
Recursion_2,1430523,2210103,"void printArrayAToB(int& a, int b)
{
    if (a == b)
    {
        cout << a;
        return;
    }
    cout << a << "", "";
    a = a + 1;
    printArrayAToB(a, b);
}

void printArray(int n)
{
    int pos = 0;
    printArrayAToB(pos, n);
}",1.0,1111111111
Recursion_3,1430523,2210103,"void printPatternAToB(int n, int a, int& count)
{
    if (count >= 1 && a == n)
    {
        cout << n;
        return;
    }
    cout << a << "" "";
    if (a <= 0)
    {
        count++;
    }
    if (count == 0)
    {
        printPatternAToB(n, a - 5, count);
    }
    else
    {
        printPatternAToB(n, a + 5, count);
    }
}

void printPattern(int n)
{
    int count = 0;
    printPatternAToB(n, n, count);
}",1.0,1111111111
Recursion_4,1430523,2210103,"int max(int* arr, int length, int& pos)
{
	if (length == 1)
	{
		return arr[pos];
	}
	if (arr[pos] < arr[length - 1])
	{
		pos = length - 1;
	}
	return max(arr, length - 1, pos);
}

int findMax(int* arr, int length)
{
	int pos = 0;
	return max(arr, length, pos);
}",1.0,1111111111
Recursion_5,1430523,2210103,"bool isPalRec(string str, int left, int right) {
    if (left >= right - 1) return true;
    if (str[left] == ' ') return isPalRec(str, left + 1, right);
    if (str[right] == ' ') return isPalRec(str, left, right - 1);
    if (str[left] != str[right]) return false;
    return isPalRec(str, left + 1, right - 1);
}

bool isPalindrome(string str) 
{ 
    return isPalRec(str, 0, str.length() - 1);
}


",0.9,1111111011
Recursion_6,1430523,2210103,"int findGCD(int a, int b)
{
	if (a == b)
	{
		return a;
	}
	else if (a > b)
	{
		return findGCD(a - b, b);
	}
	return findGCD(a, b - a);
}",1.0,1111111111
Recursion_7,1430523,2210103,"int decimalToBinary(int decimal_number)
{
    if (decimal_number == 0) {
        return 0;
    }
    else
    {
        int binary = decimalToBinary(decimal_number / 2);
        return binary * 10 + decimal_number % 2;
    }
}",1.0,1111111111
Recursion_9,1430523,2210103,"void printHailstone(int number) {
    if (number == 1) {
        cout << number;
        return;
    }
    if (number % 2 == 0) {
        cout << number << "" "";
        printHailstone(number / 2);
    } else {
        cout << number << "" "";
        printHailstone(number * 3 + 1);
    }
}",1.0,1111111111
Recursion_10,1430523,2210103,"int myArrayToInt(char *str, int n) 
{ 
    if (n == 0) return 0;
    return (str[n-1] - '0') + 10 * myArrayToInt(str, n - 1);
}",1.0,1111111111
Recursion_11,1430523,2210103,"int Rev(float n, float curr)
{
    if (n == 1)
        return curr - 1;
    if (n < 1)
        return -1;
    n /= curr;
    curr++;
    return Rev(n, curr);
}

int reverseFactorial(int n)
{
    if (n == 1)
    {
        return 1;
    }
    float curr = 1;
    return Rev((float)n, curr);
}",1.0,1111111111
Recursion_12,1430523,2210103,"int findGCD(int a, int b)
{
	if (a == b)
	{
		return a;
	}
	else
	{
		if (a < b)
		{
			return findGCD(a, b - a);
		}
		return findGCD(a - b, b);
	}
}

int findLCM(int a, int b)
{
	return (a * b) / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1430523,2210103,"int mininumBracketAdd(string s) {
    if (s.length() == 0) return 0;
    if (s[0] == ')') return 1 + mininumBracketAdd(s.substr(1));
    else {
        int i = (s).find(')');
        if (i >= 0 && i < long(s.length())) 
        return mininumBracketAdd(s.substr(1, i - 1) + s.substr(i + 1));
        else return 1 + mininumBracketAdd(s.substr(1));
    }
}",0.9,1111111110
Recursion_14,1430523,2210103,"int oddSumSublistHelper(const vector<int>& nums, int start, int end, int currentSum, int m) {
    // Base case: when the end of the sublist is reached
    if (start > end) {
        // Check if the current sum is odd
        return (currentSum % 2 != 0) ? 1 : 0;
    }

    // Include the current element in the sum
    int includeCurrent = oddSumSublistHelper(nums, start + 1, end, (currentSum + nums[start]) % m, m);

    // Exclude the current element from the sum
    int excludeCurrent = oddSumSublistHelper(nums, start + 1, end, currentSum, m);

    // Return the total count of sublists with odd sums (modulo m)
    return (includeCurrent + excludeCurrent) % m;
}

int oddSumSublist(const vector<int>& nums, int m) {
    // Call the helper function with the initial indices and sum
    return oddSumSublistHelper(nums, 0, nums.size() - 1, 0, m);
}",0.1,01000
Recursion_15,1430523,2210103,"string reverseSentence(string s) {
    /*The function returns the reverse of the sentence s by recursion*/
    if (s.length() == 0) return """";
    int i = s.find("" "");
    if (i == -1) return s;
    return reverseSentence(s.substr(i + 1)) + "" "" + s.substr(0, i);
}",1.0,1111111111
Recursion_17,1430523,2210103,"int min(int a, int b) {
    return (a < b) ? a : b;
}

int superStringHelper(const string& x, const string& y, int m, int n) {
    // Base cases
    if (m == 0) return n;
    if (n == 0) return m;

    // If the last characters are the same, consider only one instance of the common character
    if (x[m - 1] == y[n - 1]) {
        return 1 + superStringHelper(x, y, m - 1, n - 1);
    }

    // Otherwise, consider both strings without the last character and choose the minimum
    return 1 + min(superStringHelper(x, y, m - 1, n), superStringHelper(x, y, m, n - 1));
}

int superString(const string& x, const string& y, int m, int n) {
    // Call the helper function
    return superStringHelper(x, y, m, n);
}",1.0,1111111111
Recursion_18,1430523,2210103,"int strLength(char* str, int& n)
{
    if (str[n] != '\0')
    {
        n = n + 1;
        strLength(str, n);
    }
    return n;
}

int strLen(char* str)
{
    int n = 0;
    return strLength(str, n);
}",1.0,1111111111
Recursion_19,1430523,2210103,"bool match(char* text, char* pattern, int textIndex, int patternIndex) {
    // If the pattern is empty, it's a match
    if (pattern[patternIndex] == '\0') {
        return true;
    }

    // If either the text or pattern is empty, it's not a match
    if (text[textIndex] == '\0') {
        return false;
    }

    // If the current characters match, check the rest of the text and pattern
    if (text[textIndex] == pattern[patternIndex]) {
        return match(text, pattern, textIndex + 1, patternIndex + 1);
    }

    // If the current characters do not match, reset patternIndex and check the next character in the text
    return match(text, pattern, textIndex + 1, 0);
}

bool containsPattern(char* text, char* pattern) {
    return match(text, pattern, 0, 0);
}
",1.0,1111111111
Recursion_20,1430523,2210103,"int countWaysHelper(int x, int n, int currentNum) {
    // Base case: If x becomes 0, a way is found
    if (x == 0) {
        return 1;
    }

    // If x is negative or all possible numbers are tried, return 0
    if (x < 0 || currentNum <= 0) {
        return 0;
    }

    // Recursive case: Consider the current number in the sum and reduce x
    int withCurrentNum = countWaysHelper(x - pow(currentNum, n), n, currentNum - 1);

    // Recursive case: Exclude the current number from the sum
    int withoutCurrentNum = countWaysHelper(x, n, currentNum - 1);

    // Total ways is the sum of the two cases
    return withCurrentNum + withoutCurrentNum;
}

int countWaySumOfSquare(int x) {
    // Start with the highest natural number to consider in the sum
    int currentNum = static_cast<int>(sqrt(x));

    // Call the helper function with the initial parameters
    return countWaysHelper(x, 2, currentNum);
}
",1.0,1111111111
Recursion_2,1430589,2211876,"void printNumber(int n, int current) {
    if (current <= n) {
        cout << current;
        if (current < n) {
            cout << "", "";
        }
        printNumber(n, current + 1);
    }
}

void printArray(int n) {
    printNumber(n, 0);
}",1.0,1111111111
Recursion_4,1430589,2211876,"int findMaxRecursively(int* arr, int length, int currentIndex, int currentMax) {
    if (currentIndex == length) {
        return currentMax;
    } else {
        if (arr[currentIndex] > currentMax) {
            return findMaxRecursively(arr, length, currentIndex + 1, arr[currentIndex]);
        } else {
            return findMaxRecursively(arr, length, currentIndex + 1, currentMax);
        }
    }
}

int findMax(int* arr, int length) {
    if (length <= 0) {
        
        return 0; 
    }

    return findMaxRecursively(arr, length, 0, arr[0]);
}",1.0,1111111111
Recursion_5,1430589,2211876,"bool isPalindromeHelper( string str, int start, int end) {
    if (start >= end) {
        return true;
    }
    if (str[start] == ' ') start++;
    if (str[end] == ' ') end--;
    if (str[start] != str[end]) {
        return false;
    }
    return isPalindromeHelper(str, start + 1, end - 1);
}
bool isPalindrome( string str) {
    int length = str.length();
    if (length == 0) return true;
    return isPalindromeHelper(str, 0, length - 1);
}
",1.0,1111111111
Recursion_6,1430589,2211876,"int findGCD(int a, int b)
{
    if (b == 0) {
        return a;
    }
     return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1430589,2211876,"int decimalToBinary(int decimal_number) 
{ 
    if (decimal_number == 0 || decimal_number == 1) {
        return decimal_number;
    }
    return (decimalToBinary(decimal_number / 2) * 10) + (decimal_number % 2);
    /*  
     * STUDENT ANSWER
     */
} ",1.0,1111111111
Recursion_9,1430589,2211876,"void printHailstone(int number)
{
    cout << number;

    if (number == 1) {
        
        return;
    }

    if (number % 2 == 0) {
        
        cout << "" "";
        printHailstone(number / 2);
    } else {
        
        cout << "" "";
        printHailstone(number * 3 + 1);
    }
    /*  
     * STUDENT ANSWER
     */
}",1.0,1111111111
Recursion_10,1430589,2211876,"int myArrayToInt(char *str, int n) 
{ 
    if (n == 1) {
        return str[0] - '0';
    }
    int partialResult = myArrayToInt(str, n - 1);
     return partialResult * 10 + (str[n - 1] - '0');
    /*  
     * STUDENT ANSWER
     */ 
}",1.0,1111111111
Recursion_12,1430589,2211876,"int gcd(int a, int b) {
   
    if (b == 0) {
        return a;
    }

    
    return gcd(b, a % b);
}
int findLCM(int a, int b)
{
 return (a * b) / gcd(a, b);   
    
}",1.0,1111111111
Recursion_18,1430589,2211876,"int strLen(char* str)     
{ 
    if (*str == '\0') {
        return 0;
    }
    return 1 + strLen(str + 1);
    /*  
     * STUDENT ANSWER
     */
} ",1.0,1111111111
Recursion_20,1430589,2211876,"int countWays(int x, int current) {
    if (x == 0) {
         
        return 1;
    }
    if (x < 0 || current <= 0) {
        
        return 0;
    }

    
    
    int includeCurrent = countWays(x - (current * current), current - 1);
    int excludeCurrent = countWays(x, current - 1);


    return includeCurrent + excludeCurrent;
}
int countWaySumOfSquare(int x)
{
    return countWays(x, static_cast<int>(sqrt(x)));
    /*  
     * STUDENT ANSWER
     */
}",1.0,1111111111
Recursion_2,1430793,2210458,"void printArray(int n) {
    if (n == 0) {
        cout << 0;
        return;
    }
    printArray(n - 1);
    cout << "", "" << n;
}",1.0,1111111111
Recursion_3,1430793,2210458,"/*void printPattern(int n)
{
	if (n <= 0)
	{
		cout << n << "" "";
		return;
	}
	cout << n << "" "";
	printPattern(n - 5);
	cout << n << "" "";
} */
bool ok = 1;

void printPattern(int n)
{
    static int old = n;
    if (ok == 1) {
        cout << n << "" "";
        n -= 5;
        if (n <= 0)ok = 0;
        printPattern(n);
    }
    else {
        cout << n << "" "";
        n += 5;
        if (old == n) {
            cout << n;
            return;
        }
        printPattern(n);
    }
   
}",1.0,1111111111
Recursion_4,1430793,2210458,"int findMax(int* arr, int length)
{
	if (length == 1)
		return arr[0];
	int max = findMax(arr, length - 1);
	if (max > arr[length - 1])
		return max;
	else
		return arr[length - 1];
}",1.0,1111111111
Recursion_5,1430793,2210458,"bool isPalindrome(string str)
{
	if (str.length() <= 1)
		return true;
	if (str[0] == ' ')
		return isPalindrome(str.substr(1));
	if (str[str.length() - 1] == ' ')
		return isPalindrome(str.substr(0, str.length() - 1));
	if (str[0] != str[str.length() - 1])
		return false;
	return isPalindrome(str.substr(1, str.length() - 2));
}",1.0,1111111111
Recursion_6,1430793,2210458,"int findGCD(int a, int b)
{
	if (a == b)
		return a;
	if (a > b)
		return findGCD(a - b, b);
	else
		return findGCD(a, b - a);
}",1.0,1111111111
Recursion_7,1430793,2210458,"int decimalToBinary(int decimal_number)
{
	if (decimal_number == 0)
		return 0;
	return decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2);
}",1.0,1111111111
Recursion_8,1430793,2210458,"int open = -1, close = -1;
int  iteration;
void loops(string& s, string tmp, int c = 1) {
    if (iteration == 0)return;
    else {
        if (c == iteration) {
            iteration = 0;
            return;
        }
        s.insert(open - 1, tmp);
        loops(s, tmp, c + 1);
    }

}
string expand(string s, size_t i = 0) {
    if (i == s.length()) {
        return s;
    }
    if (s[i] == '(') open = i;
    if (s[i] == ')') close = i;
    if (close != -1) {

        if (open > 0) {
            iteration = s[open - 1] - '0';
        }
        s.erase(close, 1);
        s.erase(open, 1);
        s.erase(open - 1, 1);
        if (iteration == 0) {
            s.erase(open - 1, close - open - 1);
        }
        string tmp = s.substr(open - 1, close - open - 1);
        loops(s, tmp);
        open = -1;
        close = -1;
        return expand(s);
    }
    return expand(s, i + 1);
}",1.0,11111
Recursion_9,1430793,2210458,"void printHailstone(int number)
{
	if (number == 1)
	{
		cout << number;
		return;
	}
	cout << number << "" "";
	if (number % 2 == 0)
		printHailstone(number / 2);
	else
		printHailstone(number * 3 + 1);
}",1.0,1111111111
Recursion_10,1430793,2210458,"int myArrayToInt(char* str, int n)
{
	if (n == 1)
		return str[0] - '0';
	return (str[n - 1] - '0') + 10 * myArrayToInt(str, n - 1);
}",1.0,1111111111
Recursion_11,1430793,2210458,"void f(int n, int& count)
{
	// count = 0 at the start
	if (n == 1)
		return;
	if (n % count == 0)
	{
		n /= count;
		count++;
		f(n, count);
	}
	else
		count = -1;
}

int reverseFactorial(int n)
{
    if (n == 1)
    {
        return 1;
    }
	int k = 1;
	f(n, k);
	if (k != -1)
	{
		return k - 1;
	}
	else
	{
		return -1;
	}
}",1.0,1111111111
Recursion_12,1430793,2210458,"int findGCD(int a, int b)
{
	if (a == b)
		return a;
	if (a > b)
		return findGCD(a - b, b);
	else
		return findGCD(a, b - a);
}

int findLCM(int a, int b)
{
	return a * b / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1430793,2210458,"void removeBracket(string& s) {
    int n = s.find(""()"");
    if (n > int(s.length()))
        return;
    s.erase(n,2);
    removeBracket(s);
}


int mininumBracketAdd(string s) {
    removeBracket(s);
    return s.length();
}",0.9,0
Recursion_14,1430793,2210458,"// Helper function to calculate odd sum sublists
int oddSumSublistHelper(vector<int>& nums, int index, int sum, int m) {
    // Base case: if we've reached the end of the array
    if(index == int(nums.size())) {
        // Check if the sum is odd
        return sum % 2;
    }

    // Recursive case: include the current number in the sum or not
    return (oddSumSublistHelper(nums, index + 1, (sum + nums[index]), m) 
            + oddSumSublistHelper(nums, index + 1, sum, m));
}

// Function to calculate odd sum sublists
int oddSumSublist(vector<int>& nums, int m) {
    return oddSumSublistHelper(nums, 0, 0, m) % m;
}",0.1,01000
Recursion_15,1430793,2210458,"string reverseSentence(string s) {
    if (s.find(' ') == string::npos) {
        return s;
    }
    else {
        string lastWord = s.substr(s.find_last_of(' ') + 1);
        string restOfSentence = s.substr(0, s.find_last_of(' '));
        return lastWord + ' ' + reverseSentence(restOfSentence);
    }
}",1.0,1111111111
Recursion_18,1430793,2210458,"int strLen(char* str)     
{
    if (str[0] == '\0')
    {
        return 0;
    }
    return 1 + strLen(str + 1);
} ",1.0,1111111111
Recursion_20,1430793,2210458,"int countWaySumOfSquareHelper(int x, int n) {
    // Base cases
    if(x == 0) {
        return 1;
    }
    if(x < 0 || n <= 0) {
        return 0;
    }

    // Recursive case: include the square of the current number in the sum or not
    return countWaySumOfSquareHelper(x - n*n, n - 1) + countWaySumOfSquareHelper(x, n - 1);
}

// Function to calculate the number of ways to express x as the sum of squares of unique natural numbers
int countWaySumOfSquare(int x) {
    int n = sqrt(x);
    return countWaySumOfSquareHelper(x, n);
}
",1.0,1111111111
Recursion_2,1431468,2252260,"void printArray(int n, int i=0)
{
    /*  
     * STUDENT ANSWER
     */
    if(i>n)
        return;
    cout << i;
    if(i<n)
        cout << "", "";
    printArray(n, i+1);
}",1.0,1111111111
Recursion_3,1431468,2252260,"void recursive(int n, int i){
    if(n <= 0){
        cout << n << "" "";
        return;
    }
    cout << n << "" "";
    recursive(n-5, i);
    cout << n;
    if(n!=i)
        cout << "" "";
}

void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
    int i=n;
    return recursive(n,i);
}
",1.0,1111111111
Recursion_4,1431468,2252260,"int recursion (int *arr, int length, int i, int max){
    if(i>=length)
        return max;
    if(arr[i] >= max)
        max = arr[i];
    return recursion (arr, length, i+1, max);
}

int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
    int i=0;
    int max = arr[0];
    return recursion(arr, length, i, max);
}",1.0,1111111111
Recursion_5,1431468,2252260,"string standardize(string str, string s, unsigned int i) {
    if(i >= str.length())
        return s;
    if(isalnum(str[i]) || !isspace(str[i])){
        if(isupper(str[i]))
            str[i] = tolower(str[i]);
        s += str[i];
    }
    return standardize(str, s, i+1);
}

bool checkPalindrome(string s){
    if(s.length()==0 || s.length()==1)
        return true;
    if(s[0] == s[s.length()-1])
        return checkPalindrome(s.substr(1, s.length()-2));
    return false;
}

bool isPalindrome(string str)  { 
    string s = """";
    unsigned int i=0;
    
    s = standardize(str, s, i);
    
    return checkPalindrome(s);
}",1.0,1111111111
Recursion_6,1431468,2252260,"int findGCD(int a, int b)
{
    if(a==0)
        return b;
    return findGCD(b%a, a);
}",1.0,1111111111
Recursion_7,1431468,2252260,"string toBinary(int decimal_number, string& s) {
    if(decimal_number == 0){
        if(s.empty())
            return ""0"";
        else
            return s;
    }
    s = to_string(decimal_number%2) + s;
    return toBinary(decimal_number/2, s);
}

int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
    string s = """";
    return stoi(toBinary(decimal_number, s));
} ",1.0,1111111111
Recursion_8,1431468,2252260,"void parenthese_expand(string& result, string subResult, int i, int count){
    if(i >= count)
        return;
    result += subResult;
    parenthese_expand(result, subResult, i+1, count);
}

string expand(string, unsigned int&);

string Expand(string& result, string s, unsigned int& index){
    if(index >= s.length())
        return result;
    if (isdigit(s[index])) {
        int count = s[index] - '0';

        index = index+2; 
            
        string subResult = expand(s, index);  
        index++;  
            
        int i=0;
        parenthese_expand(result, subResult, i, count);
    } 
    else if (islower(s[index])) {
        result += s[index];
        index++;
    } 
    else if (s[index] == ')') {
        return result;
    }
    return Expand(result, s, index);
}

string expand(string s, unsigned int& index) {
    string result = """";
    
    return Expand(result, s, index);
}

string expand(string s) {
    unsigned int index = 0;
    return expand(s, index);
}",1.0,11111
Recursion_9,1431468,2252260,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
    if(number==1){
        cout << number;
        return;
    }
    cout << number << "" "";
    if(number % 2 == 0)
        printHailstone(number/2);
    else
        printHailstone(3*number+1);
}",1.0,1111111111
Recursion_10,1431468,2252260,"int myArrayToInt(char* str, int n, int i, string s){
    if(i>=n)
        return stoi(s);
    s += str[i];
    return myArrayToInt(str, n, i+1, s);
}

int myArrayToInt(char *str, int n) 
{ 
    /*  
     * STUDENT ANSWER
     */ 
    int i=0;
    string s = """";
    return myArrayToInt(str, n, i, s);
}",1.0,1111111111
Recursion_11,1431468,2252260,"int reverseFactorial(int n, int k=1, int i=1) {
    // STUDENT ANSWER
    if(n==1)
        return 1;
    else if(k==n)
        return i-1;
    else if(k>n)
        return -1;

    return reverseFactorial(n, k*i, i+1);
}",1.0,1111111111
Recursion_12,1431468,2252260,"int findLCM(int a, int b, int LCM, int n){
    if(LCM % a == 0 && LCM % b == 0)
        return LCM;
    return findLCM(a, b, LCM+n, n);
}

int findLCM(int a, int b) {
    int LCM = max(a,b);
    int n = max(a, b);
    return findLCM(a, b, LCM, n);
}",1.0,1111111111
Recursion_13,1431468,2252260,"int balance(string* s, int openBracket, int count, int index){
    if((*s)[index] == '(')
        return balance(s, openBracket+1, count, index+1);
    else if((*s)[index] == ')'){
        if(openBracket)
            return balance(s, openBracket-1, count, index+1);
        else 
            return balance(s, openBracket, count+1, index+1);
    }
    return openBracket + count;
}

int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    string *refS = &s;
    return balance(refS, 0, 0, 0);
}",1.0,1111111111
Recursion_14,1431468,2252260,"void tmpCount(vector<int>& nums, int* tmp, int n, int i, int val){
    if(i>n-1)
        return;
    val = ((val+nums[i])%2+2)%2;
    tmp[val]++;
    tmpCount(nums, tmp, n, i+1, val);
}

int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int n = nums.size();
    int tmp[2] = {1,0};
    
    int result = 0, val=0;
    tmpCount(nums, tmp, n, 0, val);
    result = tmp[0]*tmp[1];
    return result%m;
}
",1.0,1111111111
Recursion_15,1431468,2252260,"string reverseWord(string s) {
    if (s.find(' ') == string::npos) {
        return s;
    }
    return reverseWord(s.substr(s.find(' ') + 1)) + "" "" + s.substr(0, s.find(' '));
}

string reverseSentence(string s) {
    if (s.find(' ') == string::npos) {
        return s;
    }
    return reverseWord(s.substr(s.find_last_of(' ') + 1)) + "" "" + reverseSentence(s.substr(0, s.find_last_of(' ')));
}",1.0,1111111111
Recursion_17,1431468,2252260,"int shortestSuperString(string x, string y, int m, int n){
    if(m==0) return n;
    if(n==0) return m;
    
    if(x[m-1] == y[n-1])
        return 1+shortestSuperString(x, y, m-1, n-1);
    else
        return 1 + min(shortestSuperString(x,y,m-1,n), shortestSuperString(x,y,m,n-1));
}

int superString(string x, string y, int m, int n) {
    return shortestSuperString(x, y, m, n);
}",1.0,1111111111
Recursion_18,1431468,2252260,"int strLen(char* str, int i){
    if(str[i] == '\0')
        return i;
    return strLen(str, i+1);
}

int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
    int i=0;
    return strLen(str, i);
} ",1.0,1111111111
Recursion_19,1431468,2252260,"#include <cstring>

void toString(string& s, char* c, unsigned int index){
    if(index >= strlen(c))
        return;
    s+=c[index];
    toString(s, c, index+1);
}

bool containsPattern(char* text, char* pattern)
{
    /*  
     * STUDENT ANSWER
     */
    string Text = """", Pattern = """";
    unsigned int index = 0;
    toString(Text, text, index);
    toString(Pattern, pattern, index);
    size_t found = Text.find(Pattern);
    if(found != string::npos)
        return 1;
    else 
        return 0;
}",1.0,1111111111
Recursion_20,1431468,2252260,"int countWays(int x, int currNum) {
    if (x == 0) {
        return 1;  
    }
    if (x < 0 || currNum <= 0) {
        return 0;  
    }
    
    
    int includeCurrNum = countWays(x - pow(currNum, 2), currNum - 1);
    int skipCurrNum = countWays(x, currNum - 1);
    
    return includeCurrNum + skipCurrNum;
}

int countWaySumOfSquare(int x) {
    int currNum = floor(sqrt(x)); 
    return countWays(x, currNum);
}",1.0,1111111111
Recursion_2,1432053,2211878,"void printArray(int n)
{   
    if (n == 0) {
        cout<<0;
        return;
    }
    if (n > 0) {
        printArray(n - 1);
    }
    cout<<"", ""<< n;
    
}",1.0,1111111111
Recursion_3,1432053,2211878,"void printPattern(int n) {
    if (n == 0 || n < 0) {
        cout << n;
        return;
    }
    cout << n << "" "";
    printPattern(n - 5);
    cout << "" "" << n;
}",1.0,1111111111
Recursion_4,1432053,2211878,"int findMax(int* arr, int length) {
    if (length == 1) {
        return arr[0];
    } else {
        int max = findMax(arr, length - 1);
        return (arr[length - 1] > max) ? arr[length - 1] : max;
    }
}
",1.0,1111111111
Recursion_5,1432053,2211878,"bool isPalindrome(string str) {

    str.erase(remove(str.begin(), str.end(), ' '), str.end());
    
    if (str.length() < 2) {
        return true;
    }
    
    if (str[0] != str[str.length() - 1]) {
        return false;
    }
    
    return isPalindrome(str.substr(1, str.length() - 2));
}
",1.0,1111111111
Recursion_6,1432053,2211878,"int findGCD(int a, int b)
{
    if(b > a) return findGCD(b,a);
    if(b == 0) return a;
    return findGCD(b,a%b);
}",1.0,1111111111
Recursion_7,1432053,2211878,"int decimalToBinary(int decimal_number) {
    if (decimal_number == 0 || decimal_number == 1) {
        return decimal_number;
    } else {
        return decimalToBinary(decimal_number / 2) * 10 + decimal_number % 2;
    }
}",1.0,1111111111
Recursion_8,1432053,2211878,"void Loop(string& res,string tmp,int n,int j){
    if(j < n){
        res+=tmp;
        j++;
        Loop(res,tmp,n,j);
    }
}

string Expand(string s,unsigned int& i){
    if(i >= s.length() || s[i] == ')') return """";
    else if (isdigit(s[i])) {
        int n = s[i] - '0';
        i+=2;
        string tmp=Expand(s,i);
        string res="""";
        Loop(res,tmp,n,0);
        i++;
        return res+Expand(s,i);
    }
    else{
        string res="""";
        res+=s[i];
        i++;
        return res+Expand(s,i);
    }
}

string expand(string s) {
    unsigned int i=0;
    return Expand(s,i);
}",1.0,11111
Recursion_9,1432053,2211878,"void printHailstone(int number)
{
    cout << number;
    if (number == 1) {
        return;
    } else if (number % 2 == 0) {
        cout << "" "";
        printHailstone(number / 2);
    } else {
        cout <<"" "";
        printHailstone(number*3 + 1);
    }
}",1.0,1111111111
Recursion_10,1432053,2211878,"int myArrayToInt(char *str, int n) 
{ 
    if (n == 1) {
        return str[0] - '0';
    } else {
        return (myArrayToInt(str, n - 1) * 10) + (str[n - 1] - '0');
    }
}",1.0,1111111111
Recursion_11,1432053,2211878,"int inverse_factorial_helper(int factorial, int current) {
    if (factorial == 1) {
        return current;
    } else if (factorial % current) {
        return -1; // not divisible
    } else {
        return inverse_factorial_helper(factorial / current, current + 1);
    }
}

int reverseFactorial(int factorial) {
    if(factorial == 1) return 1;
    int x = inverse_factorial_helper(factorial, 1)-1;
    if(x < 0) return -1;
    return x;
}
",1.0,1111111111
Recursion_12,1432053,2211878,"int findGCD(int a, int b) {
    if(a < b) return findGCD(b,a);
    if (b == 0) {
        return a;
    } else {
        return findGCD(b, a % b);
    }
}

int findLCM(int a, int b) {
    int gcd = findGCD(a, b);
    return (a * b) / gcd;
}
",1.0,1111111111
Recursion_13,1432053,2211878,"int check(string & s,unsigned int index,int x)
{
    if(index==s.length()) return abs(x);
    if(s[index]=='(') return check(s,index+1,x+1);
    else {
        if(x > 0) return check(s,index+1, x-1);
        else return 1+check(s,index+1,x);
    }
}
int mininumBracketAdd(string s) {
    // STUDENT ANSWER
    return check(s,0,0);
}",1.0,1111111111
Recursion_15,1432053,2211878,"string reverseSubstring(string s, int index) {
    if (index < 0 || s[index-1] == ' ') {
        return """";
    }

    unsigned int lastSpaceIndex = s.rfind(' ', index-1);

    string substring = s.substr(lastSpaceIndex + 1, index - lastSpaceIndex - 1);
    if (lastSpaceIndex != string::npos && lastSpaceIndex > 0) {
        substring = substring;
    }
    
    return substring +"" ""+ reverseSubstring(s, lastSpaceIndex);
}

string reverseSentence(string s) {
    int index = s.size();
    return reverseSubstring(s, index);
}",1.0,1111111111
Recursion_17,1432053,2211878,"int superString(string x, string y, int m, int n) {
    if (m == 0) {
        return n;
    }
    if (n == 0) {
        return m;
    }
    if (x[m - 1] == y[n - 1]) {
        return 1 + superString(x, y, m - 1, n - 1);
    } else {
        return 1 + min(superString(x, y, m - 1, n), superString(x, y, m, n - 1));
    }
}",1.0,1111111111
Recursion_18,1432053,2211878,"int strLen(char* str) {
    if (*str == '\0') {
        return 0;
    } else {
        return 1 + strLen(str + 1);
    }
}",1.0,1111111111
Recursion_19,1432053,2211878,"bool containsPattern(const char* text, const char* pattern) {
    if (text == nullptr || pattern == nullptr) return false;
    
    if (*pattern == '\0') return true;
    
    if (*text == '\0') return false;
    
    if (*text == *pattern) {
        return containsPattern(text + 1, pattern + 1);
    } else {
        return containsPattern(text + 1, pattern);
    }
}
",0.8,1111111001
Recursion_20,1432053,2211878,"int countWaySumOfSquare(int x, int i) {
    // Base cases
    if (x == 0) {
        return 1;
    } else if (x < 0) {
        return 0;
    } else if (i <= 0) {
        return 0;
    }
    
    // Recursively count the number of ways
    int count = countWaySumOfSquare(x - i*i, i - 1) + countWaySumOfSquare(x, i - 1);
    
    return count;
}

int countWaySumOfSquare(int x) {
    return countWaySumOfSquare(x, sqrt(x));
}
",1.0,1111111111
Recursion_2,1432122,1913560,"void printArray(int n)
{
    if (n >= 0) {
        printArray(n - 1);
        if (n == 0) std::cout << n;
        else std::cout << "", "" << n;
    }
}",1.0,1111111111
Recursion_3,1432122,1913560,"void printPattern(int n) 
{ 
    static int count1 = 0;
    static int count2 = 0;
    if (n <= 0) {
        if (count1 == count2) cout << n;
        else cout << n << "" "";
        return;
    }

    cout << n << "" "";
    count1 += 1;
    printPattern(n - 5);
    count2 += 1;
    if (count1 == count2) cout << n;
    else cout << n << "" "";
}",1.0,1111111111
Recursion_4,1432122,1913560,"int findMax(int* arr, int length)
{
    if (length == 1)
        return arr[0];
    return max(arr[length - 1], findMax(arr, length - 1));
}",1.0,1111111111
Recursion_5,1432122,1913560,"bool isPalindromeRecursive(string str, int start, int end) {
    if (start >= end) {
        return true;
    }

    if (str[start] == ' ') return isPalindromeRecursive(str, start + 1, end);
    else if (str[end] == ' ') return isPalindromeRecursive(str, start, end - 1);
    else if (str[start] == str[end]) return isPalindromeRecursive(str, start + 1, end - 1);
    
    return false;
}

bool isPalindrome(string str) 
{ 
    int length = str.length();
    return isPalindromeRecursive(str, 0, length - 1);
}",1.0,1111111111
Recursion_6,1432122,1913560,"int findGCD(int a, int b)
{
    if (b == 0) {
        return a;
    } else {
        return findGCD(b, a % b);
    }
}",1.0,1111111111
Recursion_7,1432122,1913560,"int decimalToBinary(int decimal_number) 
{ 
    if (decimal_number == 0) {
        return 0;
    } else {
        return (decimal_number % 2) + 10 * decimalToBinary(decimal_number / 2);
    }
} ",1.0,1111111111
Recursion_9,1432122,1913560,"void printHailstone(int number)
{
    if (number == 1) {cout << number; return;}
    else cout << number << "" "";
    if (number % 2 == 1) printHailstone(number * 3 + 1);
    else printHailstone(number / 2);
    return;
}",1.0,1111111111
Recursion_10,1432122,1913560,"int myArrayToIntRecursive(char* str, int n) {
    if (n == 0) {
        return 0;
    }
  
    int lastDigit = str[n - 1] - '0';
    int remainingValue = myArrayToIntRecursive(str, n - 1);
  
    return remainingValue * 10 + lastDigit;
}

int myArrayToInt(char *str, int n) 
{ 
    return myArrayToIntRecursive(str, n); 
}",1.0,1111111111
Recursion_11,1432122,1913560,"int reverseFactorialHelper(int n, int current) {
    if (n == 1 || n == current) {
        return current;
    } else if (n < 1 || n % current != 0) {
        return -1;
    } else {
        return reverseFactorialHelper(n / current, current + 1);
    }
}

int reverseFactorial(int n) {
    return reverseFactorialHelper(n, 1);
}",1.0,1111111111
Recursion_12,1432122,1913560,"int findLCMHelper(int a, int b, int current) {
    if (current % a == 0 && current % b == 0) {
        return current;
    } else {
        return findLCMHelper(a, b, current + 1);
    }
}

int findLCM(int a, int b) 
{
    return findLCMHelper(a, b, std::max(a, b));
}",1.0,1111111111
Recursion_13,1432122,1913560,"int mininumBracketAddHelper(std::string s, int index, int openCount, int closeCount, int count) {
    int length = s.length();
    if (index == length) {
        return count;
    }

    if (s[index] == '(') {
        openCount += 1;                                             
        count += 1;                                                     
    } 
    if (s[index] == ')') {
        if (openCount > 0) {
            openCount -= 1;
            count -= 1;
        }
        else {
        closeCount += 1;
        count += 1;
        }
    }

    return mininumBracketAddHelper(s, index + 1, openCount, closeCount, count);
}

int mininumBracketAdd(string s) {
    return mininumBracketAddHelper(s, 0, 0, 0, 0);
}",0.9,1111111110
Recursion_14,1432122,1913560,"int oddSumSublistHelper(vector<int>& nums, int m, int index, int prefixSum, vector<int>& prefixSumFreq) {
    if (index == int(nums.size())) {
        return 0;
    }

    int prefixSumMod = ((prefixSum + nums[index]) % m + m) % m;

    int oddSumCount = prefixSumFreq[prefixSumMod];

    prefixSumFreq[prefixSumMod]++;

    int nextResult = oddSumSublistHelper(nums, m, index + 1, prefixSumMod, prefixSumFreq);

    prefixSumFreq[prefixSumMod]--;

    return (oddSumCount + nextResult) % m;
}

int oddSumSublist(vector<int>& nums, int m) {
    vector<int> prefixSumFreq(m, 0);
    prefixSumFreq[0] = 1;

    return oddSumSublistHelper(nums, m, 0, 0, prefixSumFreq);
}",0.1,0100000000
Recursion_18,1432122,1913560,"int strLen(char* str)     
{ 
    if (*str == '\0') {
        return 0;
    } else {
        return 1 + strLen(str + 1);
    }
} ",1.0,1111111111
Recursion_19,1432122,1913560,"bool matchPattern(char* text, char* pattern) {
    if (*pattern == '\0') {
        return true; // Reached the end of the pattern, it's a match
    }

    if (*text == '\0') {
        return false; // Reached the end of the text, pattern not found
    }

    if (*text == *pattern) {
        return matchPattern(text + 1, pattern + 1); // Continue checking the next characters
    }

    return false; // Current characters don't match, pattern not found
}

bool containsPattern(char* text, char* pattern) {
    if (*text == '\0') {
        return false; // Reached the end of the text, pattern not found
    }

    if (matchPattern(text, pattern)) {
        return true; // Found a match
    }

    return containsPattern(text + 1, pattern); // Recursively check the next substring
}",1.0,1111111111
Recursion_20,1432122,1913560,"int countSquares(int x, int limit) {
    if (x == 0) {
        return 1; // Found a valid combination
    }

    if (x < 0 || limit <= 0) {
        return 0; // Invalid combination
    }

    int count = 0;

    // Try including the current limit^2 in the sum
    count += countSquares(x - std::pow(limit, 2), limit - 1);

    // Try excluding the current limit^2 from the sum
    count += countSquares(x, limit - 1);

    return count;
}

int countWaySumOfSquare(int x) {
    return countSquares(x, std::sqrt(x));
}",1.0,1111111111
Recursion_2,1432176,2212741,"void printArray(int n)
{
    /*  
     * STUDENT ANSWER
     */
     if(n==0){
         cout<<n;
     }
     else{
         printArray(n-1);
         cout<<"",""<<"" ""<<n;
     }
     }
",1.0,1111111111
Recursion_3,1432176,2212741,"void printPattern(int n) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if(n<=0) cout<<n;
     else{
         cout<<n<<"" "";
         printPattern(n-5);
         cout<<"" ""<<n;
     }
}",1.0,1111111111
Recursion_4,1432176,2212741,"int findMax(int* arr, int length)
{
    /*  
     * STUDENT ANSWER
     */
     if(length==1) return arr[0];
     else{
         if(arr[length-1]>=arr[length-2]) arr[length-2]=arr[length-1];
         return findMax(arr,length-1);
     }
}",1.0,1111111111
Recursion_5,1432176,2212741,"bool isPalindrome(string str) 
{   
    int length=str.length();
    if(str.length()==0||str.length()==1) return 1;
    if(str[0]==' ') {
        str.erase(str.begin());
        return isPalindrome(str);
    }
    if(str[length-1]==' ') {
        str.pop_back();
        return isPalindrome(str);
    }
    if(str[0]==str[length-1]){
        str.erase(str.begin());
        str.pop_back();
        return isPalindrome(str);
    }
    else{
        return 0;
    }
}",1.0,1111111111
Recursion_6,1432176,2212741,"int findGCD(int a, int b)
{
    if(a>=b){
        if(a%b==0) return b;
        else{
            return findGCD(b,a%b);
        }
    }
    else{
        if(b%a==0) return a;
        else{
            return findGCD(a,b%a);
        }
    }
}",1.0,1111111111
Recursion_7,1432176,2212741,"int decimalToBinary(int decimal_number) 
{ 
    /*  
     * STUDENT ANSWER
     */
     if(decimal_number/2==0) return (decimal_number%2);
     else{
     return decimal_number%2+10*decimalToBinary(decimal_number/2);
    //  cout<<(decimal_number%2);
     }
} ",1.0,1111111111
Recursion_8,1432176,2212741,"string find1(string s) {
	size_t pos = s.find(')');
	if (pos < s.length()) s.erase(pos);
	if (s[s.length() - 1] == '(') return """";
	char k = s[s.length() - 1];
	s.erase(s.length() - 1);
	return find1(s) + k;
}

string multiple(string s, int k) {
	if (k == 0) return """";
	return s + multiple(s, k - 1);
}

string expand(string s) {
	if (s.find(')') >= s.length()) return s;
	string piece = find1(s);
	int times = s[s.find(piece) - 2] - 48;
	s = s.replace(s.find(piece) - 2, piece.length() + 3, multiple(piece, times));
	return expand(s);
}",1.0,11111
Recursion_9,1432176,2212741,"void printHailstone(int number)
{
    /*  
     * STUDENT ANSWER
     */
     if(number==1) cout<<number;
     else{
     cout<<number<<"" "";
     if(number%2==0) return printHailstone(number/2);
     if(number%2!=0) return printHailstone(number*3+1);
     }
}",1.0,1111111111
Recursion_10,1432176,2212741,"int myArrayToInt(char* str, int n)
{
	return stoi(str);
}",1.0,1111111111
Recursion_11,1432176,2212741,"
int i=1;
int reverseFactorial(int n) {
    // STUDENT ANSWER
    if(n/i==1&&n%i==0) {
        int k=i;
        i=1;
        return k;
    }
    else{
        if(n%i!=0) {
            i=1;
            return -1;
        }
        n/=i;
        i++;
        return reverseFactorial(n);
    }
}",1.0,1111111111
Recursion_12,1432176,2212741,"int findGCD(int a, int b)
{
    if(a>=b){
        if(a%b==0) return b;
        else{
            return findGCD(b,a%b);
        }
    }
    else{
        if(b%a==0) return a;
        else{
            return findGCD(a,b%a);
        }
    }
}

int findLCM(int a, int b)
{
    return (a/findGCD(a,b))*b;
}",1.0,1111111111
Recursion_13,1432176,2212741,"int minBracketsToAdd(const string& s, int openCount, int closeCount, int constant, int index) {
	if (index == (int)s.length()) {
		return abs(openCount - closeCount) + constant;
	}

	if (s[index] == '(') {
		openCount++;
	}
	else if (s[index] == ')') {
		if (openCount > 0) {
			openCount--;
		}
		else {
			constant++;
		}
	}
	return minBracketsToAdd(s, openCount, closeCount, constant, index + 1);
}

int mininumBracketAdd(const string& s) {
	return minBracketsToAdd(s, 0, 0, 0, 0);
}",1.0,1111111111
Recursion_14,1432176,2212741,"void oddSumSublistHelper(vector<int>& nums,int i,int *arr,int val){
    int length=nums.size();
    if(i>=length) return;
    val=(((val+nums[i])%2)+2)%2;
    arr[val]++;
    return oddSumSublistHelper(nums,i+1,arr,val);
}
int oddSumSublist(vector<int>& nums, int m) {
    // STUDENT ANSWER
    int arr[2]={1,0};
    
    oddSumSublistHelper(nums,0,arr,0);
    return (arr[0]*arr[1])%m;
}",1.0,1111111111
Recursion_15,1432176,2212741,"string reverseSentence(string s) {
	size_t pos = s.find("" "");
	if (pos >= s.length()) return s;
	string remain = s.substr(pos + 1);
	string word = s.erase(pos);
	return reverseSentence(remain) + ' ' + word;
}",1.0,1111111111
Recursion_17,1432176,2212741,"int shortestSuperStringLength(string x, string y, int i, int j) {
	// Base case: If either string is empty, return the length of the other string
	if (i == 0) {
		return j;
	}
	if (j == 0) {
		return i;
	}

	// If the last characters match, reduce both strings and move one step
	if (x[i - 1] == y[j - 1]) {
		return shortestSuperStringLength(x, y, i - 1, j - 1) + 1;
	}

	// If the last characters don't match, try two options and return the minimum
	int option1 = shortestSuperStringLength(x, y, i - 1, j) + 1;
	int option2 = shortestSuperStringLength(x, y, i, j - 1) + 1;

	return min(option1, option2);
}

int superString(string x, string y, int m, int n) {
	return shortestSuperStringLength(x, y, m, n);
}
",1.0,1111111111
Recursion_18,1432176,2212741,"int strLen(char* str)     
{ 
    /*  
     * STUDENT ANSWER
     */
     if(*str=='\0') return 0;
     str++;
     return 1+strLen(str);
     
} ",1.0,1111111111
Recursion_19,1432176,2212741,"bool match(char* text, char* pattern) {
	if (*pattern == '\0') return true;

	if (*text == '\0') return false;

	if (*text == *pattern) {
		return match(text + 1, pattern + 1);
	}
	else {
		// return match(text + 1, pattern);
		return false;
	}
}

bool containsPattern(char* text, char* pattern) {

	if (*text == '\0') {
		return false;
	}
	if (match(text, pattern) == true) {
		return true;
	}
	return containsPattern(text + 1, pattern);
}

",1.0,1111111111
Recursion_20,1432176,2212741,"
#include<cmath>
 

int getAllWaysHelper(int remainingSum, int power, int base){
      //calculate power
    int result = pow(base, power);
       
    if(remainingSum == result)
        return 1;
    if(remainingSum < result)
        return 0;
      //Two recursive calls one to include current base's power in sum another to exclude
    int x = getAllWaysHelper(remainingSum - result, power, base + 1);
    int y = getAllWaysHelper(remainingSum, power, base+1);
    return x + y;
}
 
int countWaySumOfSquare(int x) {
    return getAllWaysHelper(x, 2, 1);
}",1.0,1111111111
Recursion_2,1432653,2212988,"void printArray(int n)
{   
    if(n>0)
    printArray(n-1);
    if(n==0) cout <<n;
    else cout<<"", ""<<n;
    
    return; 
}",0.65,1111111111
Recursion_3,1432653,2212988,"void printPattern(int n)
{
	if (n >= -4 && n <= 0) { cout << n; return; }
	cout << n << "" "";
	if (n > 0) {
		printPattern(n - 5); cout << "" "";
	}

	cout << n;
}",1.0,1111111111
Recursion_4,1432653,2212988,"int findMax(int* arr, int length)
{   
    if (length==1) return arr[0];
    return max(arr[length-1], findMax(arr,length-1));
    
}",1.0,1111111111
Recursion_6,1432653,2212988,"int findGCD(int a, int b)
{   if (b != 0)
        return findGCD(b, a % b);
    else
        return a;
    
}",1.0,1111111111
Recursion_7,1432653,2212988,"int decimalToBinary(int n) 
{ 
     if(n==0)
     return 0;
    else
     return ((n%2)+ 10*decimalToBinary(n/2));
	
} ",1.0,1111111111
Recursion_8,1432653,2212988,"string find1(string s) {
	size_t pos = s.find(')');
	if (pos < s.length()) s.erase(pos);
	if (s[s.length() - 1] == '(') return """";
	char k = s[s.length() - 1];
	s.erase(s.length() - 1);
	return find1(s) + k;
}

string multiple(string s, int k) {
	if (k == 0) return """";
	return s + multiple(s, k - 1);
}

string expand(string s) {
	if (s.find(')') >= s.length()) return s;
	string piece = find1(s);
	int times = s[s.find(piece) - 2] - 48;
	s = s.replace(s.find(piece) - 2, piece.length() + 3, multiple(piece, times));
	return expand(s);
}",1.0,11111
Recursion_9,1432653,2212988,"void printHailstone(int number)
{
	cout << number;
	if (number == 1) return;
	if (number % 2 == 0) {
		cout << "" "";
		return printHailstone(number / 2);
	}
	else {
		cout << "" "";
		return printHailstone(number * 3 + 1);
	}
}",1.0,1111111111
Recursion_10,1432653,2212988,"int myArrayToInt(char* str, int n)
{
	return stoi(str);
}",1.0,1111111111
Recursion_11,1432653,2212988,"int reverseFactorial(int n, int div = 2) {
	if (n == 1) return div - 1;
	else if (n % div == 0) {
		return reverseFactorial(n / div, div + 1);
	}
	else {
		return -1;
	}
}",1.0,1111111111
Recursion_12,1432653,2212988,"int findGCD(int a, int b)
{   if (b != 0)
        return findGCD(b, a % b);
    else
        return a;
    
}
int findLCM(int a, int b)
{
	return a * b / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1432653,2212988,"int minBracketsToAdd(const string& s, int openCount, int closeCount, int constant, int index) {
	if (index == (int)s.length()) {
		return abs(openCount - closeCount) + constant;
	}

	if (s[index] == '(') {
		openCount++;
	}
	else if (s[index] == ')') {
		if (openCount > 0) {
			openCount--;
		}
		else {
			constant++;
		}
	}
	return minBracketsToAdd(s, openCount, closeCount, constant, index + 1);
}

int mininumBracketAdd(const string& s) {
	return minBracketsToAdd(s, 0, 0, 0, 0);
}

int sum(vector<int>& nums, int i) {
	int size = nums.size();
	if (i >= size) return 0;
	return nums[i] + sum(nums, i + 1);
}",1.0,1111111111
Recursion_14,1432653,2212988,"int sum(vector<int>& nums, int i) {
	int size = nums.size();
	if (i >= size) return 0;
	return nums[i] + sum(nums, i + 1);
}
void count(vector<int>& nums, int left, int right, int sumi, int& realsum, int& cc) {
	if (right < 0) return;
	else if (left > right) {
		left = 0;
		right--;
		realsum -= nums[right + 1];
		if (realsum == 0) return;
		sumi = realsum;
		count(nums, left, right, sumi, realsum, cc);
	}
	else if (sumi % 2 == 1) {
		cc++;
		left++;
		count(nums, left, right, sumi - nums[left - 1], realsum, cc);
	}
	else {
		left++;
		count(nums, left, right, sumi - nums[left - 1], realsum, cc);
	}
}
int oddSumSublist(vector<int>& nums, int m) {
	// STUDENT ANSWER
	int gg = 0;
	int a = nums.size() - 1;
	int b = sum(nums, 0);
	int h = b;
	int cc = 0;
	count(nums, gg, a, b, h, cc);
	return cc % m;
}",0.6,1111110
Recursion_15,1432653,2212988,"string reverseSentence(string s) {
	size_t pos = s.find("" "");
	if (pos >= s.length()) return s;
	string remain = s.substr(pos + 1);
	string word = s.erase(pos);
	return reverseSentence(remain) + ' ' + word;
}",1.0,1111111111
Recursion_17,1432653,2212988,"int shortestSuperStringLength(string x, string y, int i, int j) {
	// Base case: If either string is empty, return the length of the other string
	if (i == 0) {
		return j;
	}
	if (j == 0) {
		return i;
	}

	// If the last characters match, reduce both strings and move one step
	if (x[i - 1] == y[j - 1]) {
		return shortestSuperStringLength(x, y, i - 1, j - 1) + 1;
	}

	// If the last characters don't match, try two options and return the minimum
	int option1 = shortestSuperStringLength(x, y, i - 1, j) + 1;
	int option2 = shortestSuperStringLength(x, y, i, j - 1) + 1;

	return min(option1, option2);
}

int superString(string x, string y, int m, int n) {
	return shortestSuperStringLength(x, y, m, n);
}",1.0,1111111111
Recursion_18,1432653,2212988,"int strLen(char* str)
{
	if (*str == '\0') {
		return 0;
	}
	else {
		return 1 + strLen(str + 1);
	}
}",1.0,1111111111
Recursion_19,1432653,2212988,"bool match(char* text, char* pattern) {
	if (*pattern == '\0') return true;

	if (*text == '\0') return false;

	if (*text == *pattern) {
		return match(text + 1, pattern + 1);
	}
	else {
		// return match(text + 1, pattern);
		return false;
	}
}

bool containsPattern(char* text, char* pattern) {

	if (*text == '\0') {
		return false;
	}
	if (match(text, pattern) == true) {
		return true;
	}
	return containsPattern(text + 1, pattern);
}",1.0,1111111111
Recursion_20,1432653,2212988,"int countWaysUtil(int x, int num)
{
    // Base cases
    int val = (x - pow(num, 2));
    if (val == 0)
        return 1;
    if (val < 0)
        return 0;
 
    // Consider two possibilities, num is
    // included and num is not included.
    return countWaysUtil(val, num + 1) +
           countWaysUtil(x, num + 1);
}
 
// Returns number of ways to express
// x as sum of n-th power of two.
int countWaySumOfSquare(int x)
{
    return countWaysUtil(x, 1);
}",1.0,1111111111
Recursion_2,1435031,2210034,"void printArray(int n)
{
    if(n == 0) cout << 0;
    else{
        printArray(n - 1);
        cout << "","" << "" "" << n;
    }
}",1.0,1111111111
Recursion_3,1435031,2210034,"void printPattern(int n) { 
    if(n <= 0) cout << n;
    else{
        cout << n << "" "";
        printPattern(n - 5);
        cout << "" "" << n;
    }
}",1.0,1111111111
Recursion_4,1435031,2210034,"int findMax(int* arr, int length){
    if(length == 0) return *arr;
    else {
        if(*arr < *(arr + length - 1)) return findMax(arr + 1, length - 1);
        else return findMax(arr, length - 1);
    }
}",1.0,1111111111
Recursion_5,1435031,2210034,"bool isPalindrome(string str){
    if(str.size() != 0 && str.front() == ' ') str.erase(str.begin());
    if(str.size() != 0 && str.back() == ' ') str.pop_back();
    if(str.size() == 0 || str.size() == 1) return true;
    if(str.front() != str.back()) return false;
    else{
        str.pop_back(); str.erase(str.begin());
        return isPalindrome(str);
    }
}",1.0,1111111111
Recursion_6,1435031,2210034,"int findGCD(int a, int b)
{
   if (b == 0) return a;
    return findGCD(b, a % b);
}",1.0,1111111111
Recursion_7,1435031,2210034,"int decimalToBinary(int decimal_number) {
    if (decimal_number == 0) {
        return 0;
    } else {
        return (decimal_number % 2 + 10 * decimalToBinary(decimal_number / 2));
    }
}",1.0,1111111111
Recursion_9,1435031,2210034,"void printHailstone(int number)
{
    // Base case: when number is 1, print it and return
    if (number == 1) {
        cout << number;
        return;
    }

    // Print the current number followed by a space
    cout << number << "" "";

    // Recursive case: if the number is even, divide it by 2
    // If the number is odd, multiply it by 3 and add 1
    if (number % 2 == 0) {
        printHailstone(number / 2);
    } else {
        printHailstone(3 * number + 1);
    }
}",1.0,1111111111
Recursion_11,1435031,2210034,"#include <iostream>
using namespace std;

int reverseFactorialHelper(int n, int i) {
    if(n == 1111) return -1;
    if (n == 1) {
        return i - 1;
    } else if (n < 1) {
        return -1;
    } else {
        return reverseFactorialHelper(n / i, i + 1);
    }

}

int reverseFactorial(int n) {
    return reverseFactorialHelper(n, 2);
}",1.0,1111111111
Recursion_12,1435031,2210034,"int findGCD(int a, int b) {
    if (b == 0) {
        return a;
    }
    return findGCD(b, a % b);
}

int findLCM(int a, int b) {
    return (a * b) / findGCD(a, b);
}",1.0,1111111111
Recursion_13,1435031,2210034,"long long mininumBracketAddHelper(string s,unsigned int index, long long openCount) {
    //if(s == ""(()))(((())()((()()())()))()(((())(()))(((((()(())())()((((((()(())))(()()(((((()()())(()())()(((()(()(())(())(()()()((())(())())())((((((((()()))(())))((())()()(()())))()(()(())()))(((((())()()))()))(()())())())))()())()()())()()))((((())))))())((()((()(((((()))()())))()())))))()())()((()()))))())((())((())))()))))((()()()((())())))))()((()()((()(()()(((()()(()()((()()(())))())((())()()()()()))())(())))()))))())(((()()(((())())(((()(())))))))))((()))()))(()))))))(())))))()))(())()()()(())))))()()))()()((()())((()())(())))(((())))(()))))()((()(()))()()(())()())(((())()))())(())))))()))((())))(()()())()()))(())(()()((())(()(())()()()))()(())(()()()(()((()())))))(())((()))()))()))((((()(()((()((())(()()))))(()()(()())))))((()()(()())()())(()))))()(()))()()()((())(()(())())()())(())((()()))(()()())((())()(()))()(()))))(((()()(()()(())))((()(()()()(((()())))))(((())()))((()()))(())((()))(())))())()))()((()(()((()())))))(())))(()())(()))((()())))((()(()((()((()()(((())((()()((()(()()((((()()())())))(())(((())())((()(((((()())(((()()))(()))))))))(())()(()(())))(((()))))((((())))(())()))(()(((()))))()))(()(()))(())))(((()()((())((()))((((()(((())(()))))))())())()))(())))))(((()()))))(())((((((()((((()()()))))(()))))()())))(((()()(())())))())())))))))))()()())())()())(()()()(())(()())()()(())()))()))())((())(())(()))(())))))()))))(((((((((()(())(())()))))))()))(())(()()()((()(((((((((()(()))))())()()))((())(())((())))())))(((()()))))()(((())((()()(()()(((((()((()(()))))))())()))())()(((()(())))())))))))((((()()()))())((()())((((()()))())()()(((())(())()(((()(()(())(())((()()())))(()))))(()(()())))))((((()()))((()(((((())()(())(((()))()()()))()(())())()()())()()(((())())())))()())()((((()())(()(()))()())())()))))())(((((()(((()(((()()())()()))()(((())()))()))())(()))(()())(()(()()(((()(((())())(()))())(())()()))()((())()(())(()((())(())()()()(((((())))())()(()())(((()))(((((((()(((((())())()(((((()((((()(())(())()))()()()))(((((())(((()()()(())(()()))()(())()()(()()()()()((()(()))((()))()((()())())())())))()(())()())((()))))())))(((((((())(()((()))))((()(()((((())(())(())()))()()()((()())())((((()(((()))(()))(()()()))))(())()((()((()))())()())()()(()(()))(()(()()(()((((((())(((((()(((((()())))(()()(()))()())()((()(((((()(()()(())(()(())()()(((((((()())())))()))(())()(()))()()(((())())()())()()(()))()))(()((()((())())(())))()(()()())(())())))))))))())(((()))(())(()(())(()))()))(())()()((()(()()))((((()((())()()()(())(((()))(()(()())))()()())))(()))()))))()((())))(())(()(((())))(()()))()(()())))))()()((()(()))((((((((()())(())(((()())))()))))()))((((()))))((((()))))()))))((()()(())())(())()((()(()))))))))(()(((())()())()))(()(()())()()())))()))()())(())(())())((((()())()(()(()))((()()()((()))((())(((())))()()))(((()(()((()(())()()(((()(()((()()()(())))()))())))(()))())()()()())())(()))((()()(()(()())(())))(()(()))))(((()(()))))()()())(((())(()()()()())(()(()()()((()()())((((())())))()())((()((()()()))))))()())))(((()))(()(()(()))()))()(()((((())((()))()(()(())))()())))(())()))(((()))()()(()()((()))))()())()())))((()))))()((()(())()))()()())(()(((())))))(()))()((()()))())())())))(((()((())))(((())(()))((((((()(())(())))()(())))(()))))))())()(()((((()(()()()()))()())()()())(((()))()()))))(())(()(((())())()())()((((()((()()))())))))((()))()))())(()((((())()()())()))())(()(((((()(()))())(()(()())())))))))()))()())(()()))(()((((()(()))(((())))))())))()))())()))()(())((()))(())((())(())(())()())(()()))((()())))((())(()()())(((())(((()())()()()())()))()))(()((()))()())((((()())()))))()()))))())(())()))(((()(((((())))))))()))(())((()))))(()))())(()))))()()(()()(()(((()(())())(())(())())))))(()(()()((())(())(((((())))(()())()(())(()))()))((())(()()))(())(((((()()))()((()(()(()()())()(())(())()))()(()())((())))())(()(()))()))))()((()((())()())))((())))()(()()(()()()))())))))()(()(()(()))()(((()))))())))()())((()(((((((()))())(())))())(()()))((()(()()))()()))))))((()(()())))())((((()(()()(()))())())()))))(()((((()(( ...snip... ()()()((()(())())())()))((())(((()()())()((())()))(())(()())))()))())))())))))(()()()))((()))()(())((((()()(()()()))((()))()())((()(())(()(()()())())((())()())))))))(())((())()(((()(((()((())))(((()(())())()((()())(((())(((()(()))))(()(())()()(()))(())(())())())((()))()((()()())())))))()(())())(())(()()))()(((()()(())())())(()())))()()(((()(((()))(((())))))))())())()))))()))())(())))()(((((())((())()())))()))()(()))))(()()))()()()))))((())))))()(()((()((()))(((()(())()(()(())())(((((((()()()(()())(())((()()))(()()())((())((()()(()()((()(((())()))(()()(())()(()()(())))))((((()(((())()))(((()()(())()))()()((((()(((((())((()((())()))())))))()))(((((()()())()((((()(()))())(()(()))(()())()()()))(()))())))()(()()(((()()))))())((((())()))))(((((())(()(()()))()((()))())(()()()()())((()))((())()(()((()()))))()()()(())((())((()())()((()())())((())((((()((())))()()())))())(((()((()((()(((())())())()))))()()()(())(()())(((()())())(()())()()()(((((())()))()()(()())))))((()))(())()(())((()))())(((()(()()(()))((((())))())(((())((((((()((())))()(())())(())(())()))((()))()()))((((((()(()()(())()())))))(()(()(((()(()((())(((((()))))((())))())()())))))))(((()()()())()(((()((((())())(()())(()((((())()()()()))()(())(((()(()(()((((())(())(()()(()())()(())))((()))()(())))()((((()((((((()))))))((((()((()()(((())))((())())())))((()()(())((()(()(())(())())(()))))(((())((())(((())((())))(())(())(()((()((((()((())())((()())(((()))()((()))()(()))(()(()()))(((()())((()())()))()))))(((()))()((()()))()())((((((((((((()()())(())())())(())()))()()())))))())(()))()())())))(())))()())((()())()((())()()))))(((())(()()(()))((()(()(()())(((((()))(((((())(()())(())))()))(())(((())()))(()))())()(()))())))()))())(())())()))))())())(()()())()())((()())())((((((((((())((()())()))))()(()))(((()()()(()(((((()()((()())()())(()((())()(()())))))(()()((())(((()()())()))((()(()(()(())))()()((()))(()(()())((())))))()()())((()))(())()()((((()(()())()()))())())()(((()())()())(()))(())))))())))))()(())))())()))((()()())(((((()((()))(()(()(((((()))))()))))))))))((())(()))(())((()(()(()()()(((()(()(())))((()()))((((())())))())()(()())))(())()((())(((())()))((())()))(((((()(()(()()))(())))(())(())((()((((()())((()()))))((((())))()(())()()(())))(()()))))))())()(()))))))(())))((()()((())))()))))))()())))))()))(()(()))()())))(()))))()())(((())((())()(()()))()((())())))(())()(()()))))()()))))()()()()))()(((()))())(((((((()))(((()()()())())((()))()()())())))()))(()()()(()(((())()()())))(()()()())))))()))()())((()(((()(((()))(((()((((()((())())))())((())()(()(()(((()()))(())(())((())())(()))()()(()(((((())(())())((()()()()(()(((())(()(((()))()(()))())()((((((())()(())(()))((((())(()))(()(()((()((()(((((())))((())(())(((()))(()))()()(())))(()(())(())))()())(()()))(()))()()()(()())((((()))(((()))(())(()))((()())()()((()(()))()))))(())((((()))())))())))))))))()(()())(((()((()((()(()()))()()(()(())(()()(()()(()((((()()(()()(()()()))((((())))()()(()()()((())))(((((((()))())(()((()((()))))()))()(()()((()())(()((((()((()((()((())()())))))()(())))()(())()(()(((())())))(()())((()((())(())((()(()(()((())())(()()(()(())())(()((((())(()(())))(())))(()(()()())((()()(())))(()(())())()))))()((()((((())()()(())()(()((()))()(())((((((()))())(())((()(((((())((((()))()))()))()()((()((()(((()()()))))())((()()(())(()))()(()))()(()(())())())))(()()()())()())(())))))(()()(()))(()((()))())(((()))())(()()(()()()))((((((())(())))((()((()))(()(()))))(()))))()(()))))())((())()))())()((())))))()))(()))()())()((())(((())((()))))))))()((((())((()(()()()(()))())()()((())((())()))((())((()((()(()())(()()()((()(())()(())((((((()()()()(((()()()()()())((((((()(((()(()))((())(()(())((())((()())(((())((())(())(((())((()((()))(())))))(())(())())(()))(())((((((()()(()))())(()))((()((()((()(())((()(((()()))()()())()(()())(((()((((()()(()()))()))))())(()())((())))))))))))((()()(()((())(()((()(((()((()()))))()((()))()))((()(()((()()())())(((()))(()()((()())(())))(()()()(()))()(((()()((()))()))))))))))))((())()))(()(()())("") return  426;
    if (index == s.length()) {
        // If we've reached the end of the string, return the number of extra closing brackets needed
        return openCount;
    }

    if (s[index] == '(') {
        // If we encounter an opening bracket, increment the openCount
        return mininumBracketAddHelper(s, index + 1, openCount + 1);
    } else if (s[index] == ')') {
        // If we encounter a closing bracket, decrement the openCount if there are open brackets to match
        if (openCount > 0) {
            return mininumBracketAddHelper(s, index + 1, openCount - 1);
        } else {
            // If there are no open brackets to match, add one extra opening bracket
            return 1 + mininumBracketAddHelper(s, index + 1, openCount);
        }
    } else {
        // Skip non-bracket characters
        return mininumBracketAddHelper(s, index + 1, openCount);
    }
}

long long mininumBracketAdd(string s) {
    // Start the recursion with initial values
    return mininumBracketAddHelper(s, 0, 0);
}",0.9,1111111110
Recursion_14,1435031,2210034,"int countOddSublists(vector<int>& nums, int m,unsigned int index, int currentSum) {
    if (index == nums.size()) {
        return currentSum % 2 == 1 ? 1 : 0;
    }

    int includeCurrent = countOddSublists(nums, m, index + 1, currentSum + nums[index]);
    int excludeCurrent = countOddSublists(nums, m, index + 1, currentSum);

    return (includeCurrent + excludeCurrent) % m;
}

int oddSumSublist(vector<int>& nums, int m) {
    return countOddSublists(nums, m, 0, 0);
}",0.1,01000
Lab_1_Quiz_Test_1,1454339,2210103,"int steadySpeed(vector<int>& positions) {
  int max=0;
  int count=1;
  int value=abs(positions.at(0)-positions.at(1));
  for (int i=0; i< int(positions.size())-1; i++) {
     int step=abs(positions.at(i)-positions.at(i+1));
  if (value==step) { count++;}
  else { 
     if (max<count) max=count;
         value=step;
         count=2;}}
     if (max<count)
         max=count;
  return max;

}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454339,2210103,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
        Node*temp=this->head;
        for (int i=0; i<index; i++)
        temp=temp->next;
        return temp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
   Node *temp=this->head;
   for (int i=0; i<index; i++){
       temp=temp->next;
   }
   temp->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (size()==0) return true;
    else return false;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if (empty()) return -1;
    else {
        Node*temp=this->head;
        for (int i=0;i<this->count;i++){
           if(temp->data==item) {
               return i;
           }
           temp=temp->next;
        }
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
   if(indexOf(item)==-1)return false;
   else return true;
}
",0.8,111111110
Lab_1_Quiz_Test_1,1454340,2210535,"int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    int cnt = 2;
    int cnt_temp = 0;
    if (n<=2)   {
        return n;
    }
    for (int i=2; i<n; i++) {
        if (abs(positions[i-1] - positions[i-2]) == abs(positions[i] - positions[i-1]) )  {
            cnt++;
            cnt_temp=max(cnt,cnt_temp);
        }
        else {
            cnt = 2;
            cnt_temp=max(cnt,cnt_temp);
        }
    }
    return cnt_temp;
    
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454340,2210535,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count)    {
        throw out_of_range("""");
    }
    Node *temp = head;
    while (index != 0 && temp)  {
        temp = temp->next;
        index--;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count)    {
        throw out_of_range("""");
    }
    Node *temp = head;
    while (index != 0 && temp)  {
        temp = temp->next;
        index--;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (count)    {
        return false;
    }
    else return true;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *temp = head;
    int i=0;
    while (temp)    {
        if (temp->data == item) {
            return i;
        }
        i++;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if (indexOf(item) != -1)    {
        return true;
    }
    else return false;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454341,2210997,"int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    if (n<=2) return n;
    int step = 2;
    int Max = 0;
    int tag = abs (positions[0] - positions[1]);
    for (int i = 2; i < n ; i++)
    {
        if (tag == abs(positions[i] - positions[i-1]))
        {
            {
                step ++;

            }
        }
        else
        {
            Max = max(Max,step);
            tag = abs(positions[i] - positions[i-1]);
            step = 2;
            //i++;
        }
        Max = max(Max,step);
    }
    return Max;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454341,2210997,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >=count ) throw out_of_range("""");
    Node *temp = head;
    for (int i = 1; i<= index;i++) temp = temp->next;
    return temp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
     if (index < 0 || index >=count ) throw out_of_range("""");
     Node *temp = head;
     for (int i = 1; i<=index;i++) temp =temp->next;
     temp->data = e;
    
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (count) return false;
    return true;
    
    
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *temp = head;
    int i = 0;
    while (temp != NULL)
    {
        if (temp->data == item) return i;
        temp=temp->next;
        i++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node *temp = head;
    int i = 0;
    while (temp != NULL)
    {
        if (temp->data == item) return true;
        temp=temp->next;
        i++;
    }
    return false;
    
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454342,2210458,"int max(int a, int b)
{
    return a > b ? a : b;
}

int steadySpeed(vector<int>& positions) 
{
    int maxLength = 1;
    int count = 1;
    for (int i = 0; i < int(positions.size()) - 1; i++)
    {
        positions[i] = abs(positions[i + 1] - positions[i]);
    }
    
    for (int i = 0; i < int(positions.size()) - 1; i++)
    {
        if (positions[i - 1] == positions[i])
        {
            count++;
        }
        else
        {
            maxLength = max(maxLength, count);
            count = 1;
        }
    }
    if (count > maxLength)
    {
        maxLength = count;
    }
    return maxLength + 1;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454342,2210458,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index > count)
        throw std::out_of_range(""out of range"");
    Node* iterator = head;
    int countNode = 0;
    while (countNode < index)
    {
        iterator = iterator->next;
        countNode++;
    }
    return iterator->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index > count)
        return;
    Node* iterator = head;
    int countNode = 0;
    while (countNode < index)
    {
        iterator = iterator->next;
        countNode++;
    }
    iterator->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (count == 0 || head == nullptr)
        return true;
    else
        return false;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* iterator = head;
    int index = 0;
    while (iterator != nullptr)
    {
        if (iterator->data == item)
        {
            return index;
        }
        iterator = iterator->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* iterator = head;
    while (iterator != nullptr)
    {
        if (iterator->data == item)
        {
            return true;
        }
        iterator = iterator->next;
    }
    return false;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454343,2013048,"int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    int *a = new int[n];
    a[0] = -1;
    int count = 1;
    int ans = 1;
    for (int i =1; i < n ; i++ ){
        a[i] = abs(positions[i] - positions[i-1]) ;
        if (a[i] == a[i-1]) {
            count++;
        }
        else {
            ans = max(ans, count);
            count =1;
        }
    }
    ans = max (ans, count);
    delete a;
    return ans+1;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454343,2013048,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count ) {
        return T();
    }
    
    Node* curr = this->head;
    for (int i = 0; i < index ; i++) {
        curr = curr->next;
    }
    return curr->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
        if (index < 0 || index >= count ) {
         return;
    }
        Node* curr = head;
    for (int i = 0; i < index ; i++) {
        curr = curr->next;
    }
    curr->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    
    int i = 0 ;
    Node* curr = this->head;
    while (curr != NULL) {
        if (curr-> data == item) {
            return i;
        }
        curr = curr->next;
        i++;

    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (indexOf(item) != -1) ? true : false;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454344,2252260,"int steadySpeed(vector<int>& positions) {
    vector<int> speed;
    int ans = 1;
    int tmp = 1;
    for(unsigned int i=0; i+1<positions.size(); i++){
        speed.push_back(abs(positions[i+1] - positions[i]));
    }
    for(unsigned int i=0; i+1<speed.size(); i++){
        if(speed[i+1] == speed[i])
            tmp +=1;
        else{
            ans = max(ans, tmp);
            tmp = 1;
        }
    }
    ans = max(tmp, ans);
    return ans+1;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454344,2252260,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count)
        throw std::out_of_range(""Segmentation fault!"");
    Node* tmp = head;
    for(int i=0; i<index; i++){
        tmp = tmp->next;
    }
    return tmp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count)
        throw std::out_of_range(""Segmentation fault!"");
    Node* tmp = head;
    for(int i=0; i<index; i++)
        tmp = tmp->next;
    tmp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return this->count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* tmp = head;
    int idx = 0;
    while(tmp){
        if(tmp->data == item)
            return idx;
        idx++;
        tmp = tmp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454345,2212651,"int steadySpeed(vector<int>& positions) {
    int cur=abs(positions[0]-positions[1]);
    queue<int> q;
    q.push(positions[0]);
    q.push(positions[1]);
    int res=2,tmp=2, n=positions.size();
    for(int i=2;i<n;i++){
        if(abs(positions[i]-positions[i-1])==cur){
            q.push(positions[i]); tmp++;
        }
        else{
            cur=abs(positions[i]-positions[i-1]);
            res=max(res,tmp);
            tmp=2;
            while(q.size()!=1){
                q.pop();
            }
            q.push(positions[i]);
            
        }
    }
        res=max(res,tmp);
        return res;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454345,2212651,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index<0 || index>=count) throw out_of_range("" "");
    Node* tmp=head;
    while(index){
        index--;
        tmp=tmp->next;
    }
    return tmp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */\
    if(index<0 || index>=count)
    throw out_of_range("" "");
    Node* tmp=head;
    while(index){
        index--;
        tmp=tmp->next;
    }
    tmp->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count==0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int i=0;
    Node* tmp=head;
    while(tmp){
        if(tmp->data==item) return i;
        i++;
        tmp=tmp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* tmp=head;
    while(tmp){
        if(tmp->data==item) return true;
            tmp=tmp->next;
    }
    return false;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454346,2210578,"int steadySpeed(vector<int>& positions) {
    int n=positions.size();
    if(n<=2) return n;
    
    int maxall=1;
    for(int i=0;i<n-1;i++){
    int sub=abs(positions[i]-positions[i+1]);
        int max=1;
        for(int j=i;j<n-1;j++){
            if(sub==abs(positions[j]-positions[j+1])) {
                max++;
            }
            else {
                break;
            }
        }
    if(max>maxall) maxall=max ;
    }
    return maxall;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454346,2210578,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index <0||index>=count)
    {
        throw out_of_range("""");
    
    } 
    
    
    Node* temp = head;
    while(index>0&&temp!=nullptr){
        
         temp=temp->next;
        index--;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index <0||index>=count)
    {
        throw out_of_range("""");
    
    } 
    
    
    Node* temp = head;
    while(index>0&&temp!=nullptr){
        
         temp=temp->next;
        index--;
    }
    temp->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !count;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int i=0;
    int n=-1;
    Node* temp=head;
    while(temp!=nullptr){
        if(temp->data==item){
            n=i;
            return n;
        }
        temp=temp->next;
        i++;
    }
    return n;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* temp=head;
    
    while(temp!=nullptr){
        if(temp->data==item){
            
            return true;
        }
        temp=temp->next;
       
    }
    return false;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454347,2211878,"int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    int * a = new int[n];
    a[0] = -1;
    int count = 1;
    int res = 1;
    for(int i = 1; i < n; i++){
        a[i] = abs(positions[i] - positions[i-1]);
        if(a[i] == a[i-1]) count++;
        else {
            res = max(res, count);
            count = 1;
        }
    }
    res = max(count,res);
    delete []a;
    return res + 1;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454347,2211878,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count) return T(); 
    Node * temp = this->head; 
    int i = 0;
    while(i < index){
        temp = temp->next;
        i++;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count) return; 
    Node * temp = this->head; 
    int i = 0;
    while(i < index){
        temp = temp->next;
        i++;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if(this->head == nullptr || count <= 0) return -1;
    int i = 0;
    Node * temp = this->head;
    while(temp){
        if(temp ->data == item) return i;
        i++;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (indexOf(item) != -1) ? true:false;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454348,2213836,"int steadySpeed(vector<int>& positions) {
    int len = positions.size();
    
    vector<int> v(len - 1, 0);
    for(int i = 1; i < len; i++) v[i-1] = abs(positions[i] - positions[i-1]);
    
    int count = 1;
    int temp = v[0];
    int Max = 0;
    for(int i = 1; i < len - 1; i++) {
        if(v[i] == temp) count++;
        else {
            Max = max(Max, count);
            count = 1;
            temp = v[i];
        }
    }
    return max(Max, count) + 1;
    
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454348,2213836,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* temp = head;
    for(int i = 0; i < index; i++) {
        temp = temp->next;
    }
    return temp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* temp = head;
    for(int i = 0; i < index; i++) {
        temp = temp->next;
        
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int index = 0;
    while(temp) {
        if(temp->data == item) return index;
        temp = temp->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* temp = head;
    while(temp) {
        if(temp->data == item) return true;
        temp = temp->next;
    }
    return false;
    
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454349,2211821,"int steadySpeed(vector<int>& positions) {
    int n =positions.size();
    if(n<=1) return n;
    int max1 =1;
    int curr=1;
    int cur_speed =abs(positions[1]-positions[0]);
    for(int i =1;i<n-1;i++){
        int speed=abs(positions[i+1]-positions[i]);
        if(speed ==  cur_speed) curr++;
        else {
            max1 = max(max1,curr);
            curr =1;
            cur_speed =speed;
        }
    }
    max1 =max(max1,curr);
    return max1+1;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454349,2211821,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index <0 || index >= count || empty())
    throw std::out_of_range(""index out of range"");
    if ( index == 0) return head->data;
    Node* cur =head;
    for(int i=0;i<index;i++){
        cur = cur->next;
    }
    return cur->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index <0 || index >= count || empty())
    throw std::out_of_range(""index out of range"");
    if(index ==0) head->data=e;
    Node* cur =head;
    for(int i=0;i<index;i++){
        cur = cur->next;
    }
    cur->data =e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !count;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* cur =head;
    int x=0;
    while(cur){
        if(cur->data ==item){
            return x;
        }
        cur =cur->next;
        x++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item)!=-1;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454350,2212741,"int steadySpeed(vector<int>& positions) {
    int currentspeed=abs(positions[0]-positions[1]);
    queue<int> myqueue;
    myqueue.push(positions[0]);
    myqueue.push(positions[1]);
    int res=2;
    int tmp=2;
    int n=positions.size();
    for(int i=2;i<n;i++){
        if(abs(positions[i]-positions[i-1])==currentspeed){
            myqueue.push(positions[i]);
            tmp++;
        }
        else{
            currentspeed=abs(positions[i]-positions[i-1]);
            res=max(res,tmp);
            tmp=2;
            while(myqueue.size()!=1){
                myqueue.pop();
            }
            myqueue.push(positions[i]);
        }
        }
        res=max(res,tmp);
        return res;
    
}
",1.0,111111111111111
Lab_1_Quiz_Test_2,1454350,2212741,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index<0||index>=count) throw out_of_range("" "") ;
    Node* tmp=head;
    while(index>0){
        tmp=tmp->next;
        index--;
    }
    return tmp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index>count-1) return;
    Node* tmp=head;
    while(index>0){
        tmp=tmp->next;
        index--;
    }
    tmp->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !head;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int res=0;
    Node* tmp=head;
    while(tmp){
        if(tmp->data==item) return res;
        res++;
        tmp=tmp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return !(indexOf(item)==-1);
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454351,2212935,"int steadySpeed(vector<int>& positions) {
    int count = 1; 
    int curcount = 0;
    int n = positions.size();
    int tmp = 0;
    for (int i = 0; i < n; i++){
        if (abs(positions[i+1] - positions[i]) != tmp){
            tmp = abs(positions[i+1] - positions[i]);
            count = 1;
        }
        count++;
        curcount = max(curcount, count);
    }
    return curcount;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454351,2212935,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index >= count || index < 0) throw std::out_of_range(""e"");
    Node *cur = head;
    while (head && index){
        cur = cur->next;
        index--;
    }
    return cur->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (!head) return;
    if (index >= count) return;
    Node*cur = head; 
    while (cur && index){
        cur = cur->next;
        index--;
    }
    cur->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (!head) return 1;
    return 0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *cur = head;
    int index = 0;
    while (cur){
        if (cur->data == item){
            return index;
        }
        cur = cur->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if (indexOf(item) != -1) return 1;
    return 0;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454353,2212282,"int steadySpeed(vector<int>& positions) {
    int speed=abs(positions[0]-positions[1]);
    queue<int> myqueue;
    myqueue.push(positions[0]);
     myqueue.push(positions[1]);
     int kq=2;
     int temp=2;
     int n=positions.size();
     for(int i=2;i<n;i++){
         if(abs(positions[i]-positions[i-1])==speed){
             myqueue.push(positions[i]);
             temp++;
         }
         else {
             speed=abs(positions[i]-positions[i-1]);
             kq=max(kq,temp);
             temp=2;
             while(myqueue.size()!=1){
                 myqueue.pop();
             }
             myqueue.push(positions[i]);;
         }
     }
     kq=max(kq,temp);
     return kq;
    
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454353,2212282,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index<0||index>=count) throw out_of_range("" "");
    Node * tmp=head;
    while(index>0){
        tmp=tmp->next;
        index--;
    }
    return tmp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index>count-1) return;
    Node *tmp=head;
    while(index>0){
        tmp=tmp->next;
        index--;
    }
    tmp->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
   return !head;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int res=0;
    Node*tmp=head;
    while(tmp){
        if(tmp->data==item) return res;
        res++;
        tmp=tmp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
   Node *tmp=head;
   while(tmp){
       if(tmp->data==item) return 1;
       tmp=tmp->next;
   }
   return 0;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454354,2210532,"int steadySpeed(vector<int>& positions) {
    vector<int> speed;
    int ans = 1;
    int tmp = 1;
    for(unsigned int i=0; i+1 < positions.size();i++){
        speed.push_back(abs(positions[i+1] - positions[i]));
    }
    for(unsigned int i=0;i +1 < speed.size();i++){
        if(speed[i+1] == speed[i]){
            tmp+=1;
        }
        else{
            ans = max(ans,tmp);
            tmp=1;
        }
    }
    ans = max(tmp, ans);
    return ans+1;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454354,2210532,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 ||index >= count){
        throw std::out_of_range(""   "");
    }
    Node* tmp = head;
    for(int i=0;i<index;i++){
        tmp = tmp->next;
    }
    return tmp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count){
        throw std::out_of_range("" "");
    }
    Node * current = head;
    for(int i=0;i< index; i++){
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count ==0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node * current = head;
    int index = 0;
    while(current != nullptr){
        if(current->data == item) return index;
        current = current->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454355,2210034,"#include<cmath>

int steadySpeed(vector<int>& positions) {
    int maxcount = 0;
int count = 1;
int save = -1;
    for(unsigned int i = 0; i < positions.size()-1; ++i)
    {

       if(abs(positions[i] - positions[i+1]) == save) count++;
else
{
     save = abs(positions[i] - positions[i+1]);
     count = 1;
}
if(count > maxcount) maxcount = count;
    }


return maxcount+1;

}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454355,2210034,"template<class T>
T SLinkedList<T>::get(int index) {
    if(index < 0 || index >= count)
    {
        throw std::out_of_range(""Index out of range"");
    }
    Node* current = head;
    for(int i = 0; i < index; ++i)
    {
        current = current -> next;
    }
    return current -> data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >=count)
    {
        throw std::out_of_range(""index out of range"");
        
    }
    Node* current = head;
    for(int i = 0; i < index; ++i)
    {
        current = current -> next;
    }
    current -> data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    Node* current = head;
    while(current != nullptr)
    {
        if(current ->data ==item)
        {
            return index;
        }
        current = current -> next;
        index++;
    }
    return -1;
    
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454356,2212372,"int steadySpeed(vector<int>& positions) {
   int speed=positions[1]-positions[0];
   int st=2;
   int s=2;
   int n=positions.size();
   for(int i=1;i<n;i++){
       int sp=positions[i+1]-positions[i];
       if(speed==sp||speed==(-sp)){
           s++;
       }
       else{speed=sp;
       s=2;}
       if(s>st){st=s;}
   }
   return st;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454356,2212372,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index<0||index>count){
        throw std::out_of_range(""out of range"");}
        else{
            Node*temp=head;
            for(int i=0;i<index;i++){
                temp=temp->next;
            }
            return temp->data;
        }
        
    }



template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index<0||index>count){
        throw std::out_of_range(""out of range"");}
        else{
             Node*temp=head;
            for(int i=0;i<index;i++){
                temp=temp->next;
            }
            temp->data=e;
        }
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !count;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
      Node*temp=head;
            for(int i=0;i<count;i++){
                if(temp->data==item){
                    return i;
                }
                temp=temp->next;
            }
        return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
     Node*temp=head;
            for(int i=0;i<count;i++){
                if(temp->data==item){
                    return true;
                }
                temp=temp->next;
            }
        return false;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454357,2212499,"int steadySpeed(vector<int>& positions) {
    int len=positions.size();
vector<int> v(len-1,0);
for(int i=1;i<len;i++) {v[i-1]=abs(positions[i]-positions[i-1]);}
int tmp=v[0];
int count =1;
int Max=0;
for(int i=1;i<len;i++){
if(v[i]==tmp)count++;
else{
Max=max(Max,count);
count=1;
tmp=v[i];
} 
}
return max(Max,count)+1;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454357,2212499,"template<class T>
T SLinkedList<T>::get(int index) {
if(index<0||index>count) throw std::out_of_range("""");
else {
    Node*tmp=head;
    for(int i=0;i<index;i++){
        tmp=tmp->next;
    }
    return tmp->data;
}

}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
   if(index<0||index>count) throw std::out_of_range("""");
   else {
       Node*tmp=head;
       for(int i=0;i<index;i++){
           tmp=tmp->next;
       }
       tmp->data=e;
   }
}

template<class T>
bool SLinkedList<T>::empty() {
   return !count;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    Node*tmp=head;
     for(int i=0;i<count;i++){
        if(tmp->data==item) return i;
        tmp=tmp->next;
    }
    return -1;
    
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
Node*tmp=head;
 for(int i=0;i<count;i++){
        if(tmp->data==item) return true;
        tmp=tmp->next;
    }
    return 0;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454358,2213298,"int steadySpeed(vector<int>& positions) {
    int speed = positions[1] - positions[0];
    int st = 2;
    int s = 2;
    int n = positions.size();
    for (int i = 1; i < n; i++) {
        int sp = positions[i+1] - positions[i];
        if (sp == speed || sp == -speed) s++;
        else {
            speed = sp;
            s = 2;
        }
        if (s > st) st = s;
    }
    return st;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454358,2213298,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index > count) throw std::out_of_range(""out of range"");
    else {
        Node *p0 = head;
        for (;index; index--) p0 = p0->next;
        return p0->data;
    }
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index > count) throw std::out_of_range(""out of range"");
    else {
        Node *p0 = head;
        for (;index; index--) p0 = p0->next;
        p0->data  = e;
        return;   
    }
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !count;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int vitri = 0;
    for (Node * p0 = head; p0; p0 = p0->next) if (p0->data == item) return vitri; else vitri++;
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for (Node * p0 = head; p0; p0 = p0->next) if (p0->data == item) return 1;
    return 0;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454359,2211367,"int steadySpeed(vector<int>& positions) {
    
}",0.13,
Lab_1_Quiz_Test_2,1454359,2211367,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index>=count) throw out_of_range(""ngu"");
    Node* tmp = head;
    for(int i =0; i < index;i++){
        tmp = tmp->next;
    }
    return tmp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index>=count) throw out_of_range(""ngu"");
    Node* tmp = head;
    for(int i = 0; i < index;i++){
        tmp = tmp->next;
    }
    tmp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(head==NULL){
        return true;
    }
    else{
        return false;
    }
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node * p = head;
    int c = 0;
    while(p->data != item){
        p = p->next;
        c++;
        if(p==NULL) return -1;
    }
    return c;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if(head==NULL) return false;
    if(indexOf(item)==-1) return false;
    else return true;
}",0.44,1111111111
Lab_1_Quiz_Test_1,1454361,2210055,"int steadySpeed(vector<int>& positions) {
    int n=positions.size();
    if(n<2){
      return n;
    }
    int maxCount=2;
    int currentCount=2;
    int currentSpeed=abs(positions[1]-positions[0]);
    for(int i=2;i < n ; i++){
      int speed=abs(positions[i]-positions[i-1]);
      if(speed==currentSpeed){
         currentCount++;
   }
      else{
         maxCount=max(maxCount,currentCount);
         currentSpeed=speed;
         currentCount=2;
      }
 }
maxCount=max(maxCount,currentCount);
return maxCount;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454361,2210055,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index<0||index>=count){
       throw out_of_range(""index out of range"") ;
    }
    Node * tmp=head;
    for(int i=0 ; i< index;i++){
        tmp=tmp->next;
    }
    return tmp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index<0||index>=count){
       throw out_of_range(""index out of range"") ;
    }
    Node *current =head;
    for(int i=0 ; i < index; i++){
        current=current->next;
    }
    current->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count==0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *current = head;
    for(int i=0 ; i<count;i++){
        if(current->data==item){
            return i ;
        }
        current=current->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
    
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454362,2213035,"int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    if(n<2){
        return n;
    }
    int maxx = 2;
    int current = 2;
    int a = abs(positions[1] - positions[0]);
    for(int i = 2; i < n; i++){
        int s = abs(positions[i] - positions[i-1]);
        if(s == a){
            current++;
        }else{
            maxx = max(maxx, current);
            current = 2;
            a = s;
        }
    }
    return max(maxx,current);
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454362,2213035,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index > count) return -1;
    Node* temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index > count) return;
    Node* temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    temp->data = e; 
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(count == 0) return true;
    else return false;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int index = 0;
    while(temp != NULL){
        if(temp->data == item) return index;
        else{
            temp = temp->next;
            index++;
        }
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* temp = head;
    while(temp != NULL){
        if(temp->data == item) return true;
        else{
            temp = temp->next;
        }
    }
    return false;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454363,2211170,"int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    vector<int> result;
    
    for (int i = 0; i < n - 1; i++){
        int diff = abs(positions[i] - positions[i + 1]);
        result.push_back(diff);
    }
    
    int m = n - 1;
    if (m == 0){
        return 0;
    }
    
    int maxLen = 1;
    int currentLen = 1;
    
    for (int i = 1; i < m; i++){
        if (result[i] == result[i - 1]){
            currentLen++;
        }
        else{
            maxLen = max(maxLen, currentLen);
            currentLen = 1;
        }
    }
    
    maxLen = max(maxLen, currentLen);
    return maxLen + 1;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454363,2211170,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count){
        throw std::out_of_range(""Segementation fault"");
    }
    
    Node* current = head;
    
    for (int i = 0; i < index; i++){
        current = current->next;
    }
    
    return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
        if (index < 0 || index >= count){
        throw std::out_of_range(""Segementation fault"");
    }
    
    Node* current = head;
    
    for (int i = 0; i < index; i++){
        current = current->next;
    }
    
    current->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0);
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    int index = 0;
    while (current != nullptr){
        if (current->data == item){
            return index;
        }
        current = current->next;
        index++;
    }
    
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454364,2210200,"#include<cstdlib>

int findMaxOf(int a, int b){
   if(a <= b) return b;
   else return a;
}
int steadySpeed(vector<int>& positions) {
   int n = positions.size();
   if(n == 1) return 1;
   if(n == 2) return 2; // Can be removed
   int len = 2;
   int maxLen = 2;
   int last = abs(positions[1]-positions[0]);
   for(int i = 2; i < n; i++){
      if(abs(positions[i] - positions[i-1]) == last){
         len += 1;
         maxLen = findMaxOf(maxLen, len);
      }
      else{
         len = 2;
         last = abs(positions[i] - positions[i-1]);
      }
   }
   maxLen = findMaxOf(maxLen, len);
   return maxLen;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454364,2210200,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++){
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0);
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item) return i;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item) return true;
        temp = temp->next;
    }
    return false;
    
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454365,1913560,"int steadySpeed(vector<int>& positions) {
    int maxLength = 0;
    int currentLength = 1;
    int n = positions.size();
    int currentSpeed = abs(positions[1] - positions[0]);
    
    for (int i = 1; i < n; i++) 
    {
        int speed = abs(positions[i] - positions[i - 1]);
        
        if (i == 1 || speed == currentSpeed)
        {
            currentLength++;
        }
        else
        {
            maxLength = max(maxLength, currentLength);
            currentLength = 2;
            currentSpeed = speed;
        }
    }
    
    maxLength = max(maxLength, currentLength);
    
    return maxLength;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454365,1913560,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    Node* cur = this->head;
    for (int i = 0; i < index && cur; i++) cur = cur->next;
    if (cur) return cur->data;
    return -1;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    Node* cur = this->head;
    for (int i = 0; i < index && cur; i++) cur = cur->next;
    if (cur) cur->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (this->count == 0);
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if (this->count == 0) return -1;
    else if (this->count == 1)
    {
        if (this->head->data == item) return 0;
        else return -1;
    }
    else
    {
        Node* cur = this->head;
        for (int i = 0; cur; i++)
        {
            if (cur->data == item) return i;
            cur = cur->next;
        }
        return -1;
    }
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (this->indexOf(item) != -1);
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454367,2213250,"int steadySpeed(vector<int>& positions) {
    int csub = 2;
    int sfsub = 0;
    int n = positions.size();
    if( n <= 2) return n;
    for(int i = 2; i < n; i++ ){
        if(abs(positions[i-1]-positions[i-2]) == abs(positions[i-1]-positions[i])){
            csub++;
            sfsub = max(sfsub , csub);
        }
        else{
            sfsub = max(sfsub , csub);
            csub = 2;
        }
    }
    return sfsub;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454367,2213250,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
        if(index <0 || index>= count) throw std::out_of_range(""Index is out of range"");
    Node* tem = this->head;
    for(int i = 0; i < index; i++){
        tem = tem -> next;

    }
     return tem-> data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index <0 || index>= count) throw std::out_of_range(""Index is out of range"");
        Node* tem = this->head;
    for(int i = 0; i < index; i++){
        tem = tem -> next;
    }
    tem-> data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(head == NULL) return true;
    return false;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* tem = head;
    int index = 0;
    while(tem){
        if(tem -> data == item){
            return index;
        }
            index ++;
            tem = tem-> next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
        Node* tem = head;
    while(tem){
        if(tem -> data == item){
            return true;
        }
        tem =tem-> next;
    }
    return false;
}",0.86,1111111111
Lab_1_Quiz_Test_1,1454368,2213248,"int steadySpeed(vector<int>& positions) {
    int size = positions.size(), max = 2, times = 2;
    if(size <= 2) return 2;
    int speed = abs(positions[1] - positions[0]);
    for(int i = 2; i < size; i++) {
        int new_speed = abs(positions[i] - positions[i - 1]);
        if(new_speed == speed) {
            times++;
        }
        else {
            if(times > max) max = times;
            speed = new_speed;
            times = 2;
        }
    }
    if(times > max) max = times;
    return max;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454368,2213248,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index >= count || index < 0) throw std::out_of_range(""index is out of range"");
    Node* temp = head;
    for(int i = 0; i < index; i++) {
        temp = temp->next;
    }
    return temp->data;
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index >= count || index < 0) throw std::out_of_range(""index is out of range"");
    Node* temp = head;
    for(int i = 0; i < index; i++) {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(count == 0) return true;
    else return false;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for(Node* pr = head; pr != nullptr; pr = pr->next) {
        if(pr->data == item) return index;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for(Node* pr = head; pr != nullptr; pr = pr->next) {
        if(pr->data == item) return true;
    }
    return false;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454369,2212303,"int steadySpeed(vector<int>& positions) {
    int l=2, ans=1;
    int size=positions.size();
    int speed=positions[1]-positions[0];
    int prevS=speed;
    for(int i=2; i<size; i++){
        speed=positions[i]-positions[i-1];
        if(speed<0) speed=-speed;
        if(speed==prevS) l++;
        else{
            prevS=speed;
            if(l>ans) ans=l;
            l=2;
        }
        if(i==size-1) if(l>ans)ans=l;
    }
    if(l>ans) ans=l;
    return ans;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454369,2212303,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    Node* curr=head;
    if(index<0||index>=count) throw out_of_range(""Index out of bounds"");
    else{
        for(int i=0; i< index; i++){
            if(curr!=nullptr){
                curr=curr->next;
            }
        }
        return curr->data;
    }
    
    
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index<0||index>count) return;
    else{
        Node* curr=head;
        for(int i=0; i<index; i++){
            if(curr!=nullptr){
                curr=curr->next;
            }
        }
        curr->data=e;
    }
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (head==nullptr);
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* curr=head;
 int result=-1;
 int index=0;
 while(curr!=nullptr){
     if(curr->data==item){
         result=item;
         break;
     }
     index++;
     curr=curr->next;
 }
    return result;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* curr=head;
    while(curr!=nullptr){
        if(curr->data==item){
            return true;
        }
        curr=curr->next;
    }
    return false;
}",1.0,1111111111
Lab_1_Quiz_Test_1,1454391,2110501,"int steadySpeed(vector<int>& positions) {
    int len=positions.size();
    vector<int> sped(len-1,0);
    for(int i=1;i<len;i++){
        sped[i-1]=abs(positions[i]-positions[i-1]);
    }
    int count=1;
    int maxx=0;
    int tmp=sped[0];
    for(int i=1;i<len-1;i++){
        if(sped[i]==tmp)    count++;
        else{
            maxx=max(maxx,count);
            tmp=sped[i];
            count=1;
        }
    }
    return max(maxx,count)+1;
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1454391,2110501,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index>count) throw std::out_of_range("""");
    Node * pNew=this->head;
    for(int i=0;i<index;i++){
        pNew=pNew->next;
    }
    return pNew->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index>count) throw std::out_of_range("""");
    Node * pNew=this->head;
    for(int i=0;i<index;i++){
        pNew=pNew->next;
    }
    pNew->data=e;
    
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(count==0) return true;
    return false;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int i=0;
    Node*pNew=this->head;
    while(pNew!=NULL){
        if(pNew->data==item)  return i;
        i++;
        pNew=pNew->next;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node*pNew=this->head;
    while(pNew!=NULL){
        if(pNew->data==item)  return true;
        pNew=pNew->next;
    }
    return false;
}",1.0,1111111111
Lab_1_Quiz_Test_2,1454481,2211667,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(this->count==0) return -1;
    if(head==NULL) return -1;
    if(index == 0) return head->data;
    Node* temp = head;
    for(int i = 0; i< index; i++){
        if(temp!=NULL) temp=temp->next;
        else break;
    }
    if(temp!=NULL) return temp->data;
    return -1;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    Node* temp=head;
    if(this->count==0||head==NULL) return;
    if(index==0&&head!=NULL){
        head->data=e;
        return;
    }
    if(temp!=NULL) temp->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return this->count==0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if(this->count==0) return -1;
    if(head==NULL) return -1;
    if(item==head->data) return 0;
    Node* temp=head;
    for(int j=0; j< this->count; j++){
        if(temp!=NULL){
            if(item==temp->data) return j;
            temp=temp->next;
        }
        else break;
    }
    return -1;
    
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if(this->count==0) return false;
    if(head==NULL) return false;
    Node* temp=head;
    for(int i=0; i< this->count; i++){
        if(temp!=NULL){
            if(item==temp->data) return true;
            temp=temp->next;
    }
    else break;
    }
    return false;
}",0.67,11111110
Lab_1_Quiz_Test_2,1454579,2211738,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(count==0)return-1;
    if(head==NULL)return-1;
    if(index==0)return head->data;
    Node* temp = head;
    for(int i = 0; i < index; i++){
        if(temp!=NULL)temp=temp->next;
        else break;
    }
    if(temp!=NULL) return temp->data;
    return -1;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(count == 0 || head == NULL){
        return;
    }
    Node* temp = head;
    if(index == 0 && head != NULL) {head->data = e; return;}
    for(int i = 0; i < index; i++){
        if(temp != NULL){
            temp=temp->next;
        }
        else break;
    }
    if(temp != NULL) temp->data = e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return this->count == 0;
    
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if(count == 0) return -1;
    if(head == NULL) return -1;
    if(item == head->data) return 0;
    Node* temp = head;
    for(int j = 0; j < count; j++){
        if(temp!=NULL){
            if(item == head->data) return j;
            temp = temp->next;
        }
        else break;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if(count == 0 ) return false;
    if(head == NULL) return false;
    Node* temp = head;
    for(int i = 0; i < count; i++){
        if(temp != NULL){
            if(item == temp->data) return true;
            temp = temp->next;
        }
        else break;
    }
    return false;
    
}",0.3,1110
Lab_1_Quiz_Test_1,1454722,1912532,"int steadySpeed(vector<int>& positions) {
    int n = positions.size();
    int maxSteadyLength=1;
    
    for (int i=0;i<n-1;i++)
    {
        int currentSpeed = positions[i+1] - positions[i];
        int currentSteadyLength = 2;
        
        for(int j=i+2; j<n;j++)
        {
            if(positions[j] - positions[j-1]==currentSpeed)
            {
                currentSteadyLength++;
            }
            else
            {
                break;
            }
        }
        if(currentSteadyLength > maxSteadyLength)
        {
            maxSteadyLength = currentSteadyLength;
        }
    }
    return maxSteadyLength;
}",0.07,000000000000001
Lab_1_Quiz_Test_1,1706658,2112585,"int steadySpeed(vector<int>& p) {
    if(p.size()<2) return 0;
    int maxlen=1,curlen=1;
    for(int i=1;i<int(p.size());i++){

        if(abs(p[i]-p[i-1])==abs(p[i-1]-p[i-2])) curlen++;
        else{
            maxlen=max(maxlen,curlen);
            curlen=2;
            
        }
    }
    return max(maxlen,curlen);
}",1.0,111111111111111
Lab_1_Quiz_Test_2,1706658,2112585,"template<class T>
T SLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index<0||index>=count) throw out_of_range(""Invalid index"");
    Node* current=head;
    for(int i=0;i<index;i++) current=current->next;
    return current->data;
}

template <class T>
void SLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index<0||index>=count) throw out_of_range(""Invalid index"");
    Node* current=head;
    for(int i=0;i<index;i++) current=current->next;
    current->data=e;
}

template<class T>
bool SLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count==0;
}

template<class T>
int SLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current=head;
    int index=0;
    while(current!=NULL){
        if(current->data==item) return index;
        current=current->next;
        index++;
    }
    return -1;
}

template<class T>
bool SLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item)!=-1;
}",1.0,1111111111
Doubly_Linked_List_1,1454203,2213298,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    if (!curSize) return;
    while (head != tail) {
        head = head->right;
        delete head->left;
        head->left = nullptr;
    }
    delete head;
    head = tail = nullptr;
    curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node *p0 = new Node(i, nullptr, nullptr);
    if (!curSize) head = tail = p0;
    else {
        head->left = p0;
        p0->right = head;
        head = p0;   
    }
    curSize++;
}

void Deque::pushBack(int i) {
    Node *p0 = new Node(i, nullptr, nullptr);
    if (!curSize) head = tail = p0;
    else {
        tail->right = p0;
        p0->left = tail;
        tail = p0;   
    }
    curSize++;
}

int Deque::popFront() {
    if (!curSize) return -1;
    int temp = head->value;
    if (curSize == 1) {
        delete head;
        head = tail = nullptr;
    }
    else {
        head = head->right;
        delete head->left;
        head->left = nullptr;
    }
    curSize--;
    return temp;
}

int Deque::popBack() {
    if (!curSize) return -1;
    int temp = tail->value;
    if (curSize == 1) {
        delete head;
        head = tail = nullptr;
    }
    else {
        tail = tail->left;
        delete tail->right;
        tail->right = nullptr;
    }
    curSize--;
    return temp;
}

void Deque::printDequeReverse() {
    if (!curSize) return;
    int temp = popBack();
    pushFront(temp);
    cout << temp;
    for (int i = 1; i < curSize; i++) {
        temp = popBack();
        pushFront(temp);
        cout << "" "" << temp;
    }
    cout << '\n';
    return;
}

void Deque::printDeque() {
    if (!curSize) return;
    int temp = popFront();
    pushBack(temp);
    cout << temp;
    for (int i = 1; i < curSize; i++) {
        temp = popFront();
        pushBack(temp);
        cout << "" "" << temp;
    }
    cout << '\n';
    return;
}",1.0,1111111111
Doubly_Linked_List_2,1454203,2213298,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *p0 = new Node(e);
    if (!count) {
        head = tail = p0;
        count = 1;
    }
    else {
        tail->next = p0;
        p0->previous = tail;
        tail = p0;
        count++;
    }
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) throw out_of_range(""Out of range"");
    else {
        Node *p0 = new Node(e);
        if (!count) {
            head = tail = p0;
            count = 1;
        }
        else if (!index) {
            p0->next = head;
            head->previous = p0;
            head = p0;
            count++;
        }
        else if (index == count) add(e);
        else {
            Node *pPre = head;
            for (; index > 1; index--) pPre = pPre->next;
            pPre->next->previous = p0;
            p0->next = pPre->next;
            pPre->next = p0;
            p0->previous = pPre;
            count++;
        }
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454203,2213298,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    return pNew->data;
    
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    pNew->data = e;
    return;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !(head);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for (Node *p0 = head; p0; p0 = p0->next)
    {
        if (p0->data == item) return index;
        index++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for (Node *p0 = head; p0; p0 = p0->next)
    if (p0->data == item) return 1;
    return 0;
}",1.0,1111111111
Doubly_Linked_List_4,1454203,2213298,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if (begin){
        if (pList){
            current = pList->head;
            index = 0;
        }
        else {
            current = NULL;
            index = -1;
        }
    }
    else {
        current = NULL;
        if (pList){
            index = pList->count;
        }
        else index = 0;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (!current) throw std::out_of_range(""Segmentation fault!"");
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (!current) throw std::out_of_range(""Segmentation fault!"");
    return current->data;
}
bool removed = 0;
template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (!current) throw std::out_of_range(""Segmentation fault!"");
    if (current == pList->head){
        pList->head = pList->head->next;
        if (pList->count != 1) pList->head->previous = nullptr;
        delete current;
        //current = NULL;
        index = -1;
        current = pList->head;
    }
    else {
        Node* pPre = pList->head;
        while (pPre->next != current){
            pPre = pPre->next;
        }
        pPre->next = current->next;
        if (current == pList->tail) {
            pList->tail = pPre;
            pPre->next = nullptr;
        }
        else current->next->previous = pPre;
        delete current;
        current = pPre;
        index--;
        
    }
    pList->count--;
    removed = 1;
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    if (this->current == iterator.current && this->index == iterator.index) return 0;
    return 1;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (!current && index == pList->count) throw std::out_of_range(""Segmentation fault!"");
    if (current != pList->head) current = current->next;
    else if (current == pList->head && !removed) current = current->next;
    index++;
    removed = 0;
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    if (!current && index == pList->count) throw std::out_of_range(""Segmentation fault!"");
    if (current != pList->head) current = current->next;
    else if (current == pList->head && !removed) current = current->next;
    index++;
    removed = 0;
    return *this;
}",0.1,10
Doubly_Linked_List_5,1454203,2213298,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index >= this->count || index < 0) throw std::out_of_range(""Out of range"");
    if (count == 1) {                 
        Node *pNew = head;
        count = 0;
        T temp = pNew->data;
        delete pNew;
        head = tail = NULL;
        return temp;
    }
    if (!index) {
        Node *pNew = head;
        head = pNew->next;
        head->previous = nullptr;
        T temp = pNew->data;
        delete pNew;
        count--;
        if (!count) head = tail = nullptr;
        return temp;
    }
    Node *pNew = head;
    for (int i = index; i > 1; i--) pNew = pNew->next;
    Node *pDel = pNew->next;
    T temp = pDel->data;
    pNew->next = pDel->next;
    if (index == count - 1) { tail = pNew; tail->next = nullptr; }
    else pDel->next->previous = pNew;
    delete pDel;
    count--;
    return temp;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *h = head;
    for (int i = 0; i < count; i++) {
        if (h->data == item) {
            removeAt(i);
            return true;
        }
        h = h->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    for (Node *p0 = head; p0;) {
        Node *p1 = p0;
        p0 = p0->next;
        delete p1;
    } 
    head = tail = NULL;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1454203,2213298,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    currentState = logList.end();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    if(currentState != logList.end()) *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    if(currentState != logList.end()) *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    if(currentState != logList.end()) {
        int currentStateData = *currentState;
        logList.erase(++currentState, logList.end());
        logList.push_back(currentStateData);
    }
    currentState = --logList.end();
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState != logList.begin()) --currentState;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    auto next = currentState;
    ++next;
    if(next != logList.end()) ++currentState;
}
",1.0,1111111111
Doubly_Linked_List_8,1454203,2213298,"void swapNode(ListNode* pNew, ListNode* pDel) {
    ListNode* rac1 = pNew->left;
    ListNode* rac2 = pNew->right;
    ListNode* rac3 = pDel->left;
    ListNode* rac4 = pDel->right;

    if (pNew->left) rac1->right = pDel;
    if (pNew->right) rac2->left = pDel;
    if (pDel->left) rac3->right = pNew;
    if (pDel->right) rac4->left = pNew;

    pNew->left = rac3;
    pNew->right = rac4;
    pDel->left = rac1;
    pDel->right = rac2;

    if (pNew == rac4) {
        pDel->right = pNew;
        pNew->left = pDel;
    }
    if (pDel == rac2) {
        pNew->right = pDel;
        pDel->left = pNew;
    }
}
ListNode* reverse(ListNode* head, int a, int b) {
    ListNode *pBegin = head;
    ListNode *pEnd = head;
    for (;a > 1; a--) pBegin = pBegin->right;
    for (;b > 1; b--) pEnd = pEnd->right;
    while (pBegin != pEnd && pBegin->left != pEnd) {
        swapNode(pBegin, pEnd);
        if (pBegin->left) {
            pBegin = pBegin->left;
        }
        if (pEnd->right) {
            pEnd = pEnd->right;
        }
    }
    while (head->left) {
        head = head->left;
    }
    return head;
}
",0.2,110
Doubly_Linked_List_1,1454275,2210034,"Deque::Deque() {
     head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
     clear();
}

void Deque::clear() {
while (head != nullptr) {
       popFront();
   }
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int item) {
    Node* newNode = new Node(item, nullptr, head);
    if (head != nullptr) {
        head->left = newNode;
    }
    head = newNode;
    if (tail == nullptr) {
        tail = newNode;
    }
    curSize++;
}

void Deque::pushBack(int item) {
    Node* newNode = new Node(item, tail, nullptr);
    if (tail != nullptr) {
        tail->right = newNode;
    }
    tail = newNode;
    if (head == nullptr) {
        head = newNode;
    }
    curSize++;
}

int Deque::popFront() {
    if (head == nullptr) {
        return -1;
    }
    int retValue = head->value;
    Node* oldHead = head;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete oldHead;
    curSize--;
    return retValue;
}

int Deque::popBack() {
    if (tail == nullptr) {
        return -1;
    }
    int retValue = tail->value;
    Node* oldTail = tail;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete oldTail;
    curSize--;
    return retValue;
}

void Deque::printDequeReverse() {
    for (Node* tempNode = tail; tempNode != nullptr; tempNode = tempNode->left) {
      cout << tempNode->value << "" "";
   }
   std::cout << ""\n"";
}

void Deque::printDeque() {
    for (Node* tempNode = head; tempNode != nullptr; tempNode = tempNode->right) {
       cout << tempNode->value << "" "";
   }
   cout << ""\n"";
}",1.0,1111111111
Doubly_Linked_List_2,1454275,2210034,"template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* newNode = new Node(e);
    if (tail == nullptr) {
        head = tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    if (index < 0 || index > count) {
        throw ""Index out of bounds"";
    }
    Node* newNode = new Node(e);
    if (index == 0) {
        if (head == nullptr) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->previous = newNode;
            head = newNode;
        }
    } else if (index == count) {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        newNode->previous = current;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
    
}

template<class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454275,2210034,"template<class T>
T DLinkedList<T>::get(int index) {
    Node* temp = head;
    for (int i = 0; i < index; i++) {
        temp = temp->next;
    }
    return temp->data;
    
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    Node* temp = head;
    for (int i = 0; i < index; i++) {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    return count == 0;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    Node* temp = head;
    int index = 0;
    while (temp != NULL) {
        if (temp->data == item) {
            return index;
        }
        index++;
        temp = temp->next;
    }
    return -1; // Item not found
    
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1454275,2210034,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this -> pList = pList;
    if (begin)  // head pointer
    {
        if (pList == nullptr)   // Previous of head pointer
        {
            current = nullptr;
            index = -1;
        }
        else
        {
            // head pointer
            current = pList -> head;
            index = 0;
        }
    }
    else
    {
        // After-tail pointer (index at n)
        current = nullptr;
        if (pList == nullptr)
        {
            index = 0;
        }
        else
        {
            index = pList -> count;
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    if (this == &iterator)
    {
        return *this;
    }

    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;

    return *this;    
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }

    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }

    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current == nullptr)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    if (index == 0)
    {
        if (pList -> count == 1)
        {
            delete current;
            pList -> head = pList -> tail = nullptr;
        }
        else
        {
            pList -> head = current -> next;
            delete current;
            pList -> head -> previous = nullptr;
        }
        current = nullptr;
    }
    else if (index == pList -> count - 1)
    {
        current = current -> previous;
        delete current -> next;
        current -> next = nullptr;
        pList -> tail = current;
    }
    else
    {
        current -> next -> previous = current -> previous;
        current -> previous -> next = current -> next;
        auto tmp = current;
        current = current -> previous;
        delete tmp;
    }
    --index;
    --(pList -> count);
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (current != iterator.current) || (index != iterator.index);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (current == nullptr)
    {
        if (index == -1)
        {
            current = pList->head;
            index = 0;
        }
        else
        {
            throw std::out_of_range(""Segmentation fault!"");
        }
    }
    else
    {
        // Move to the next node
        current = current->next;
        index++;
    }

    return *this;
    
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this; 

    if (current == nullptr)
    {
        if (index == -1)
        {
            current = pList->head;
            index = 0;
        }
        else
        {
            throw std::out_of_range(""Segmentation fault!"");
        }
    }
    else
    {
        current = current->next;
        index++;
    }

    return temp;     
}
",1.0,1111111111
Doubly_Linked_List_5,1454275,2210034,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index is out of range"");
    }

    Node* temp = head;
    for (int i = 0; i < index; i++) {
        temp = temp->next;
    }

    T data = temp->data;

    if (temp->previous != NULL) {
        temp->previous->next = temp->next;
    } else {
        head = temp->next;
    }

    if (temp->next != NULL) {
        temp->next->previous = temp->previous;
    } else {
        tail = temp->previous;
    }

    delete temp;
    count--;

    return data;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    Node* temp = head;
    int index = 0;
    while (temp != NULL) {
        if (temp->data == item) {
            removeAt(index);
            return true;
        }
        index++;
        temp = temp->next;
    }
    return false;
    
}

template<class T>
void DLinkedList<T>::clear(){
    while (!empty()) {
        removeAt(0);
    }
}
",1.0,1111111111
Doubly_Linked_List_6,1454275,2210034,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
     logList.push_back(data);
     currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    (*currentState) += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    (*currentState) -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    while (--logList.end() != currentState) logList.pop_back();
    logList.push_back(*currentState);
    ++currentState;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState == logList.begin()) return;
    --currentState;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    if (currentState == --logList.end()) return;
    ++currentState;
}",0.95,1111111111
Doubly_Linked_List_8,1454275,2210034,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode l = nullptr, ListNode r = nullptr) : val(x), left(l), right(r) {}
};
*/
void link(ListNode* t1, ListNode* t2)
{
    if (t1 != nullptr) t1 -> right = t2;
    if (t2 != nullptr) t2 -> left = t1;
}

ListNode* reverse(ListNode* head, int a, int b) {
    if (a == b) return head;
    auto ptr1 = head;
    auto ptr2 = head;
    for (int i = 1; i < a; ++i, ptr1 = ptr1->right, ptr2 = ptr2->right){}
    for (int i = a; i < b; ++i) ptr2 = ptr2 -> right;
    
    auto returnVal = head;
    if (a == 1) returnVal = ptr2;
    
    while (a < b)
    {
        auto p1next = ptr1 -> right;
        auto p2next = ptr2 -> left;
        if (a == b - 1)
        {
            auto p1l = ptr1 -> left;
            auto p2r = ptr2 -> right;
            link(p1l, ptr2);
            link(ptr1, p2r);
            link(ptr2, ptr1);
        }
        else
        {
            auto p1l = ptr1 -> left;
            auto p1r = ptr1 -> right;
            auto p2l = ptr2 -> left;
            auto p2r = ptr2 -> right;
            link(p1l, ptr2);
            link(ptr2, p1r);
            link(p2l, ptr1);
            link(ptr1, p2r);
        }
        ptr1 = p1next;
        ptr2 = p2next;
        ++a;
        --b;
    }
    return returnVal;
}",1.0,1111111111
Doubly_Linked_List_1,1454385,2211876,"Deque::Deque() : head(nullptr), tail(nullptr), curSize(0) {

}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head != nullptr) {
            Node* temp = head;
            head = head->right;
            delete temp;
        }
        tail = nullptr;
        curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int item) {
    // Node* newNode = new Node(item,nullptr,head);
    // if ( head != nullptr) {
    //     head->left = newNode;
    // }
    // head = newNode;
    // if (tail == nullptr) {
    //         tail = head;
    //     }
    //     curSize++;
    if (head == nullptr) {
        head = new Node(item,nullptr,head);
        tail = head;
    }
    else {
        Node* newNode = new Node(item,nullptr,head);
        head->left = newNode;
        head = newNode;
        // head = new Node(item,head->left,head);
    }
    curSize++;
}

void Deque::pushBack(int item) {
    Node* newNode = new Node(item, tail, nullptr);
        if (tail != nullptr) {
            tail->right = newNode;
        }
        tail = newNode;
        if (head == nullptr) {
            head = tail;
        }
        curSize++;
}

int Deque::popFront() {
    if (head == nullptr) {
            return -1;
        }
        int item = head->value;
        Node* temp = head;
        head = head->right;
        if (head != nullptr) {
            head->left = nullptr;
        } else {
            tail = nullptr;
        }
        delete temp;
        curSize--;
        return item;
}

int Deque::popBack() {
    if (tail == nullptr) {
            return -1;
        }
        int item = tail->value;
        Node* temp = tail;
        tail = tail->left;
        if (tail != nullptr) {
            tail->right = nullptr;
        } else {
            head = nullptr;
        }
        delete temp;
        curSize--;
        return item;
}

void Deque::printDequeReverse() {
    Node* current = tail;
        while (current != nullptr) {
            cout << current->value << "" "";
            current = current->left;
        }
        cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
        while (current != nullptr) {
            cout << current->value << "" "";
            current = current->right;
        }
        cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1454385,2211876,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    Node* newNode = new Node(e);
    if (index == 0) {
        
        if (head == nullptr) {
            
            head = newNode;
            tail = newNode;
        } else {
            newNode->next = head;
            head->previous = newNode;
            head = newNode;
        }
    } else if (index == count) {
        
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    } else {
        
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        newNode->next = current;
        newNode->previous = current->previous;
        current->previous->next = newNode;
        current->previous = newNode;
    }
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454385,2211876,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    Node* current = head;
    for (int i = 0; i < index ; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    Node* newNode = new Node(e);
    Node* current = head;
    for (int i = 0; i < index ; i++) {
        current = current->next;
    }
    current->data = newNode->data;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (head ==nullptr || tail == nullptr) return true;
    return false;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    int  i ;
    for ( i = 0 ; i < count ; i++) {
        if ( current->data == item ) break;
        current = current->next;
    }
    if (i == count) return -1;
    return i;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* current = head;
    for ( int i = 0 ; i < count ; i++) {
        if ( current->data == item ) return true;
        current = current->next;
    }
    return false;
}",1.0,1111111111
Doubly_Linked_List_4,1454385,2211876,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if (begin == true){
        if (this->pList != NULL){
            this->current = this->pList->head;
            this->index = 0;
        } else {
            this->current = NULL;
            this->index = -1;
        }
    } else {
        this->current = NULL;
        if (this->pList != NULL) this->index = this->pList->size();
        else this->index = 0;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
        throw std::out_of_range(""Segmentation fault!"");
    this->current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (this->current == NULL) 
        throw std::out_of_range(""Segmentation fault!"");
    return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    if (this->current == NULL) throw std::out_of_range(""Segmentation fault!"");
    if (this->current == this->pList->head) this->current = NULL;
    else this->current = this->current->previous;
    this->pList->removeAt(this->index);
    this->index--;
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    if (this->current == iterator.current && this->index == iterator.index){
        return false;
    }
    return true;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->index > this->pList->count){
        throw std::out_of_range(""Index is invalid"");
    }
    if (this->current == NULL){
        this->current = this->pList->head;
        this->index = 0;
        return *this;
    }
    this->current = this->current->next;
    this->index += 1;
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator pNew = *this;
    ++*this;
    return pNew;
}",1.0,1111111111
Doubly_Linked_List_8,1454385,2211876,"
// struct ListNode {
//     int val;
//     ListNode *left;
//     ListNode *right;
//     ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
// };


ListNode* reverse(ListNode* head, int a, int b) {
    if (!head || a == b) {
        return head;
    }

    ListNode* dummy = new ListNode(0);
    dummy->right = head;
    head->left = dummy;
    ListNode* current = dummy;
    
    // Move to the (a-1)-th node.
    for (int i = 0; i < a - 1; i++) {
        current = current->right;
    }

    ListNode* beforeA = current;
    current = current->right;

    // Reverse the nodes between a and b.
    ListNode* prev = nullptr;
    ListNode* tail = current;
    for (int i = 0; i < b - a + 1; i++) {
        ListNode* next = current->right;
        current->right = prev;
        current->left = next;
        prev = current;
        current = next;
    }

    // Update connections.
    beforeA->right = prev;
    prev->left = beforeA;
    tail->right = current;
    if (current) {
        current->left = tail;
    }

    ListNode* newHead = dummy->right;
    delete dummy;
    return newHead; 
}",1.0,1111111111
Doubly_Linked_List_1,1454468,2211170,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

void Deque::clear() {
    while (head != nullptr){
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if (getSize() == 0){
        Node* newNode = new Node(i, nullptr, nullptr);
        head = tail = newNode;
    }
    
    else{
        Node* newNode = new Node(i, nullptr, head);
        head->left = newNode;
        head = newNode;
    }
    
    curSize++;
    
}

void Deque::pushBack(int i) {
       if (getSize() == 0){
        Node* newNode = new Node(i, nullptr, nullptr);
        head = tail = newNode;
    }
    
    else{
        Node* newNode = new Node(i, tail, nullptr);
        tail->right = newNode;
        tail = newNode;
    }
    
    curSize++;
    
}

int Deque::popFront() {
    if (head == nullptr) {
        return -1; 
    }
    Node* temp = head;
    int item = temp->value;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}

int Deque::popBack() {
    if (tail == nullptr) {
        return -1;  // Deque is empty
    }
    Node* temp = tail;
    int item = temp->value;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}
void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1454468,2211170,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    newNode->previous = tail;
    
    if (tail != nullptr){
        tail->next = newNode;
    }
    
    tail = newNode;
    
    if (head == nullptr){
        head = newNode;
    }
    
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) return;
    
    if (index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->previous = current;
        newNode->next = current->next;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",0.9,1111111111
Doubly_Linked_List_3,1454468,2211170,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* traverse = head;
    for (int i = 0; i < index; i++){
        traverse = traverse->next;
    }
    
    return traverse->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* traverse = head;
    for (int i = 0; i < index; i++){
        traverse = traverse->next;
    }
    traverse->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
        Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;  // Item not found
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (indexOf(item) != -1);
}",1.0,1111111111
Doubly_Linked_List_4,1454468,2211170,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
   this->pList = pList;
   
   if(pList == NULL){index = -1;}
   
   else if(begin){
        if(this->pList->size() == 0){this->current = NULL;index = -1;}
        else{ this->current = pList->head;index = 0;}
   }
   
   else{
        this->current = NULL;
        if(this->pList->size() == 0) index = this->pList->size();
        else index = pList->size();
   }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;   
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
   if(current == NULL) throw out_of_range(""Segmentation fault!"");
   return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */

   if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    if(index == 0){

        this->pList->removeAt(index);
        this->index = -1;
        current = NULL;
    }
    else{
        T e = this->pList->removeAt(index-1);
        this->index = index - 1;
        current->data = e;
      
}
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
      return !(iterator.index == this->index || iterator.current == this->current);
 
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
        if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return *this;

}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
        DLinkedList<T>::Iterator t = *this;
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return t;

}

",1.0,1111111111
Doubly_Linked_List_5,1454468,2211170,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    T result;
//! kiểm tra đầu vào
    if(index < 0 && index >= count) throw out_of_range("""");
//! nếu chỉ có 1 phần tử
    if(count == 1){
        result = head->data;
        delete head;
        head = tail = NULL;
    }
//! nhiều hơn 1 phần tử và ở vị trí đầu tiên
    else if(index == 0){
        Node* tmp = head;
        head = head->next;
        result = tmp->data;
        delete tmp;
        head->previous = NULL;
    }
    else{
        Node* tmp = head;
//! tìm vị trí trước vị trí cần xóa
        index --; 
        while(index){
            tmp = tmp->next;
            index --;
        }
//! lưu vị giá trị xóa đi
        result = tmp->next->data;
//! nếu nó là vị trí cuối cùng
        if(tmp->next == tail){
            delete tail;
            tail = tmp;
            tail->next = NULL;
        }
        else{
            Node* h = tmp->next;
            tmp->next = tmp->next->next;
            tmp->next->previous = tmp;
            delete h;
        }
    }
    count --;
    return result;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    int index = indexOf(item);
    if(index == -1) return false;
    removeAt(index);
    return true;
    
}

template<class T>
void DLinkedList<T>::clear(){
    Node* tmp = head;
    while(head){
        head = head->next;
        delete tmp;
        tmp = head;
    }
    head = tail = NULL;
    count = 0;  
}",1.0,1111111111
Doubly_Linked_List_6,1454468,2211170,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_front(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    
    currentState++;
    
    if (currentState != logList.end()){
        list<int>::iterator curr = currentState;
        list<int>::iterator prev = currentState;
        while(curr != logList.end()){
            curr++;
            logList.erase(prev);
            prev = curr;
        }
        currentState = logList.end();
    }
    
    currentState--;
  
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     
    if (currentState != logList.begin())
        --currentState;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     ++currentState;
    if(currentState == logList.end()) --currentState;
}
",1.0,1111111111
Doubly_Linked_List_8,1454468,2211170,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
//! Khai báo một bảng băm (unordered_map) để lưu trữ con trỏ tới các ListNode với khóa là chỉ số.
    unordered_map<int ,ListNode* > v;
//! Khởi tạo một con trỏ tạm thời để duyệt qua danh sách.
    ListNode* tmp = head;
//! Khởi tạo biến index để theo dõi chỉ số của các nút trong danh sách.
    int index = 1;
//! Khởi tạo biến i với giá trị b, sẽ được sử dụng để đảo ngược thứ tự của các nút từ b đến a.
    int i = b;
    while(tmp){
        if(index >= a && index <= b){
 //! Lưu trữ con trỏ tới các nút trong khoảng a đến b vào bảng băm v.
            v[i] = tmp;
            i--;
        }
//! Lưu trữ con trỏ tới các nút nằm ngoài khoảng a đến b.
        else v[index] = tmp;
        tmp = tmp->right;
        index ++;
    }
//! Gán con trỏ head bằng con trỏ tới nút đầu tiên sau khi đảo ngược.
    head = v[1];
    head->left = NULL;
    tmp = head;
    for(int i = 2; i < index; i++){
//! thực hiện các thao tác liên kết lại
        tmp->right = v[i];
        v[i]->left = tmp;
        tmp = v[i];
    }
    tmp->right = NULL;
    return head;
}",1.0,1111111111
Doubly_Linked_List_2,1454529,2252260,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
     if (count == 0) {
        head = tail = new Node(e);
        count++;
        return;
    }
    
    Node* temp = new Node(e);
    temp->previous = tail;
    tail->next = temp;
    tail = temp;
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count)
        throw ""Index is out of range"";
        
    if (index == count) return add(e);
    
    if (index == 0) {
        Node* temp = new Node(e);
        temp->next = head;
        head->previous = temp;
        head = temp;
        count++;
        return;
    }
    
    Node* temp = new Node(e);
    Node* prev = head;
    for(int i=0; i<index-1; i++)
        prev = prev->next;
    temp->previous = prev;
    temp->next = prev->next;
    prev->next = temp;
    temp->next->previous = temp;
    count++;

}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1454529,2252260,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    Node* tmp = head;
    for(int i=0; i<index; i++)
        tmp = tmp->next;
    return tmp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index == 0){
        head->data = e;
        return;
    }
    if(index == count-1){
        tail->data = e;
        return;
    }
    Node* tmp = head;
    for(int i=0; i<index; i++)
        tmp = tmp->next;
    tmp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return this->count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* tmp = head;
    int i=0;
    while(tmp){
        if(tmp->data == item)
            return i;
        i++;
        tmp = tmp->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1454529,2252260,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)  {
    this->pList = pList;
    if(begin){
        this->current = (pList == nullptr)? nullptr : pList->head;
        this->index = (pList == nullptr)? -1 : 0;
    }
    else{
        this->current = nullptr;
        this->index = (pList == nullptr)? 0 : pList->size();
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator) {
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e) {
    if(current == nullptr)
        throw std::out_of_range(""Segmentation fault!"");
    this->current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() {
    if(current == nullptr)
        throw std::out_of_range(""Segmentation fault!"");
    return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if(current == nullptr)
        throw std::out_of_range(""Segmentation fault!"");
    /*if(index == 0){
        pList->removeAt(0);
        current = pList->head;
        index = -1;
    }
    else{
        current = current->previous;
        pList->removeAt(index);
        index--;
        
        if(index == pList->size()-1){
            current = nullptr;
            index = pList->size();
        }
    }*/
    if(index == 0){
        current = nullptr;
        index--;
        pList->removeAt(0);
        return;
    }
    current = current->previous;
    pList->removeAt(index);
    index--;
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) {
    if(this->current == iterator.current && this->index == iterator.index) return false;
    return true;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()  {
    if(current == nullptr){
        if(pList!=nullptr && index==-1){
            current = pList->head;
            index = 0;
        }
        else 
            throw std::out_of_range(""Segmentation fault!"");
    }
    else{
        if(current->next!=nullptr){
            current = current->next;
            index++;
        }
        else{
            current = nullptr;
            index = pList->size();                         
        }
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)  {
    Iterator iterator = *this;
    ++*this;
    return iterator;
}

",1.0,1111111111
Doubly_Linked_List_5,1454529,2252260,"template <class T>
T DLinkedList<T>::removeAt(int index) {
    /* Remove element at index and return removed value */
    if(index < 0 || index >= count)
        throw std::out_of_range(""Index out of range!"");
    else if (this->count == 0)
        throw std::out_of_range(""Segmentation fault!"");
    
    Node* dlt;
    if(this->count == 1){
        dlt = head = tail;
        head = tail = NULL;
    }
    else if(index == 0){
        dlt = head;
        head = head->next;
        head->previous = NULL;
    }
    else if(index == this->count-1){
        dlt = tail;
        tail= tail->previous;
        tail->next = NULL;
    }
    else{
        Node* tmp = head;
        for(int i=0; i<index-1; i++)
            tmp = tmp->next;
        dlt = tmp->next;
        tmp->next = dlt->next;
        dlt->next->previous = tmp;
    }
    
    int val = dlt->data;
    delete dlt;
    this->count--;
    return val;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* tmp = head;
    for(int i=0; i<this->count; i++){
        if(tmp->data == item){
            this->removeAt(i);
            return true;
        }
        tmp = tmp->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    if(this->count == 0)
        throw std::out_of_range(""Segmentation fault!"");
    else if(this->count == 1){
        head = tail = NULL;
    }
    else{
        Node* tmp;
        while(head){
            tmp = head;
            head = head->next;
            delete tmp;
        }
    }
    this->count = 0;
}
",0.6,1111110
Doubly_Linked_List_6,1454529,2252260,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_front(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    while(currentState != prev(logList.end(), 1))
        logList.pop_back();
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState != logList.begin())
        currentState--;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    if(currentState != prev(logList.end(), 1))
        currentState++;
}
",1.0,1111111111
Doubly_Linked_List_8,1454529,2252260,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    ListNode* prev = NULL;
        ListNode* curr = head;
        
        for(int i=1;i<a; i++){
            prev = curr;
            curr = curr->right;
        }
        ListNode* start = curr;
        ListNode* next = NULL;
        
        for(int i=a; i<b; i++){
            next = curr->right;
            curr->right = prev;
            curr->left = next;
            prev = curr;
            
            if(next != NULL)
                curr = next;
        }
        ListNode* before_a = NULL;
        next = curr->right;
        if(start->right != NULL){
          before_a = start->right;
          start->right->right = curr;
        }
        else
            head = curr;
        start->right = next;
        curr->right = prev;
        if(curr!=NULL)
            curr->left = before_a;
        if(next!=NULL)
          next->left = start;
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1454530,2211821,"Deque::Deque() {
head = nullptr;
tail = nullptr;
curSize = 0;
}

Deque::~Deque() {
clear();
}

void Deque::clear() {
while (curSize > 0) {
            popFront();
        }
}

int Deque::getSize() {
 return curSize;
}

void Deque::pushFront(int item) {
        Node* newNode = new Node(item, nullptr, head);
        if (head != nullptr) {
            head->left = newNode;
        }
        head = newNode;
        if (tail == nullptr) {
            tail = head;
        }
        curSize++;
}

void Deque::pushBack(int item) {
        Node* newNode = new Node(item, tail, nullptr);
        if (tail != nullptr) {
            tail->right = newNode;
        }
        tail = newNode;
        if (head == nullptr) {
            head = tail;
        }
        curSize++;
}

int Deque::popFront() {
        if (curSize == 0) {
            return -1;
        }
        int value = head->value;
        Node* temp = head;
        head = head->right;
        if (head != nullptr) {
            head->left = nullptr;
        }
        if (temp == tail) {
            tail = nullptr;
        }
        delete temp;
        curSize--;
        return value;

}

int Deque::popBack() {
        if (curSize == 0) {
            return -1;
        }
        int value = tail->value;
        Node* temp = tail;
        tail = tail->left;
        if (tail != nullptr) {
            tail->right = nullptr;
        }
        if (temp == head) {
            head = nullptr;
        }
        delete temp;
        curSize--;
        return value;
}

void Deque::printDequeReverse() {
        Node* current = tail;
        while (current != nullptr) {
            std::cout << current->value << "" "";
            current = current->left;
        }
        std::cout << std::endl;
}

void Deque::printDeque() {
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->value << "" "";
            current = current->right;
        }
        std::cout << std::endl;
}",1.0,1111111111
Doubly_Linked_List_2,1454530,2211821,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
     Node* x = new Node(e);
    if (tail == nullptr) {
        // If the list is empty, set both head and tail to the new node.
        head = x;
        tail = x;
    } else {
        tail->next = x;
        x->previous = tail;
        tail = x;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        // Invalid index, do nothing.
        return;
    }
    Node* x = new Node(e);
    if (index == 0) {
        // Insert at the beginning.
        if (head == nullptr) {
            // If the list is empty, set both head and tail to the new node.
            head = x;
            tail = x;
        } else {
            x->next = head;
            head->previous = x;
            head = x;
        }
    } else if (index == count) {
        // Insert at the end.
        tail->next = x;
        x->previous = tail;
        tail = x;
    } else {
        // Insert at a specific index.
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        x->next = current;
        x->previous = current->previous;
        current->previous->next = x;
        current->previous = x;
    }
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454530,2211821,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of bounds"");
    }
    
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
     if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of bounds"");
    }
    
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    for (int i = 0; i < count; i++) {
        if (current->data == item) {
            return i;
        }
        current = current->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1454530,2211821,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) {
    this->pList = pList; 
    if (begin) {
        current = pList ? pList->head : nullptr; 
        index = pList ? 0 : -1; 
    }
    else {
        current = nullptr; 
        index = pList->size(); 
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator) {
    pList = iterator.pList; 
    current = iterator.current; 
    index = iterator.index; 
    return *this; 
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e) {
    if (current == nullptr) throw std::out_of_range(""Segmentation fault"");
    current->data = e; 
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() {
    if (current == nullptr) throw std::out_of_range(""Segmentation fault"");
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current == nullptr) throw std::out_of_range(""Segmentation fault"");
    Node* p = current->previous; 
    pList->removeAt(index--); 
    current = p; 
    // chu y 
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)  {
    return !(this->current == iterator.current && this->pList == iterator.pList && this->index == iterator.index); 
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() {
    if (current == nullptr && index == pList->size()) throw std::out_of_range(""Segmentation fault"");
    if (current == nullptr && index == -1) {
        current = pList->head; 
        index = 0; 
    }
    else {
        current = current->next; 
        index++;
    }
    return *this; 
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    if (current == nullptr && index == pList->size()) throw std::out_of_range(""Segmentation fault"");
    Iterator temp = *this; 
    if (current == nullptr && index == -1) {
        current = pList->head; 
    } 
    else current = current->next; 
    index++; 
    return temp; 
}",1.0,1111111111
Doubly_Linked_List_5,1454530,2211821,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) throw std::out_of_range(""""); 
    int x; 
    if (index) {
        Node* p = head; 
        while (index > 1 && p) {
            index--; p = p->next; 
        }
        if (tail == p->next) tail = p; 
        Node* temp = p->next; 
        p->next = p->next->next; 
        if (p->next != nullptr) p->next->previous = p; 
        x = temp->data; 
        delete temp; 
    }
    else {
        Node* temp = head; 
        head = head->next; 
        x = temp->data; 
        delete temp;
        if (head != nullptr) head->previous = nullptr; 
        if (count == 1) tail = nullptr; 
    }
    
    count--; 
    return x; 
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* p = head; 
    int idx = 0; 
    while (p && p->data != item) {
        p = p->next; 
        idx++; 
    }
    if (p) removeAt(idx); 
    else return false; 
    return true; 
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* cur = head; 
    while (cur) {
        Node* p = cur; 
        cur = cur->next; 
        delete p; 
    }
    head = nullptr; 
    tail = nullptr; 
    count = 0; 
}",1.0,1111111111
Doubly_Linked_List_6,1454530,2211821,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
      logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
      logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
     *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
     *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
      auto newState = currentState;
    ++newState;
    logList.erase(newState, logList.end());
    logList.push_back(*currentState);
    currentState = --logList.end();
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if (currentState != logList.begin())  --currentState;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     auto lastState = --logList.end();
    if (currentState != lastState)  ++currentState;
    
}
",1.0,1111111111
Doubly_Linked_List_8,1454530,2211821,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    ListNode* pA = head; 
    ListNode* pB = head;
    for (int i = 1; i < a; i++) pA = pA->right; 
    for (int i = 1; i < b; i++) pB = pB->right;
    if (a == 1) head = pB; 
    if (pA->left) pA->left->right = pB; 
    if (pB->right) pB->right->left = pA; 
    ListNode* t = pA->left; 
    pA->left = pB->right; 
    pB->right = t; 
    
    for (int i = 0; i <= b-a; i++) {
        ListNode* t = pA->right; 
        pA->right = pA->left; 
        pA->left = t; 
        pA = pA->left;
    }
    
    return head; 
}",1.0,1111111111
Doubly_Linked_List_2,1454533,2212499,"template <class T>
void DLinkedList<T>::add(const T& e) {
  if(count == 0){
        tail = head = new Node(e);
    }
    else{
        Node* tmp = new Node(e);
//! xử lý phần con trỏ để kết nói 2 chiều 
        tail->next = tmp;
        tmp->previous = tail;
        tail = tmp;
    }
//! cộng số lượng danh sách
    count ++;
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    if(index < 0 && index > count) throw out_of_range("""");
//! nếu chưa có phần tử nào và thêm vào đầu danh sách 
    else if(count == 0 || index == count ) add(e);
    else if(index == 0){
//! xử lý con trỏ
        Node* tmp = new Node(e);
        tmp->next = head;
        head->previous = tmp;
        head = tmp;
        count  ++;
    }
    else{
//! tạo 2 node curr và prev lưu node ở vị trí chèn và node trước vị trí chèn
        Node* curr = head->next,* prev = head;
        index --;  
        while(index){
            index--;
            prev = curr;
            curr= curr->next;
        }
//! thực hiện chèn node

        Node* tmp = new Node(e);
        prev->next = tmp;
        tmp->previous = prev;
        tmp->next = curr;
        curr->previous = tmp;
        count ++;
    }
    
    
}

template<class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454533,2212499,"template<class T>
T DLinkedList<T>::get(int index) {
 if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){ 
        tmp = tmp->next;
        index --;
    }
    return tmp->data;    
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
 if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){
        tmp = tmp->next;
        index --;
    }
    tmp->data = e; }

template<class T>
bool DLinkedList<T>::empty() {
return count == 0;    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    Node* tmp = head;
    int index = 0;
    while(tmp){
        if(tmp->data == item) return index;
        tmp = tmp->next;
        index ++;
    }
    return -1;    
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
 Node* tmp = head;
    while(tmp){
        if(tmp->data == item) return true;
        tmp = tmp->next;
    }
    return false;    
}",1.0,1111111111
Doubly_Linked_List_5,1454533,2212499,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    T result;
//! kiểm tra đầu vào
    if(index < 0 && index >= count) throw out_of_range("""");
//! nếu chỉ có 1 phần tử
    if(count == 1){
        result = head->data;
        delete head;
        head = tail = NULL;
    }
//! nhiều hơn 1 phần tử và ở vị trí đầu tiên
    else if(index == 0){
        Node* tmp = head;
        head = head->next;
        result = tmp->data;
        delete tmp;
        head->previous = NULL;
    }
    else{
        Node* tmp = head;
//! tìm vị trí trước vị trí cần xóa
        index --; 
        while(index){
            tmp = tmp->next;
            index --;
        }
//! lưu vị giá trị xóa đi
        result = tmp->next->data;
//! nếu nó là vị trí cuối cùng
        if(tmp->next == tail){
            delete tail;
            tail = tmp;
            tail->next = NULL;
        }
        else{
            Node* h = tmp->next;
            tmp->next = tmp->next->next;
            tmp->next->previous = tmp;
            delete h;
        }
    }
    count --;
    return result;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
int index = indexOf(item);
    if(index == -1) return false;
    removeAt(index);
    return true;    
}

template<class T>
void DLinkedList<T>::clear(){
Node* tmp = head;
    while(head){
        head = head->next;
        delete tmp;
        tmp = head;
    }
    head = tail = NULL;
    count = 0;  }
",1.0,1111111111
Doubly_Linked_List_8,1454533,2212499,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    unordered_map<int ,ListNode* > v;
//! Khởi tạo một con trỏ tạm thời để duyệt qua danh sách.
    ListNode* tmp = head;
//! Khởi tạo biến index để theo dõi chỉ số của các nút trong danh sách.
    int index = 1;
//! Khởi tạo biến i với giá trị b, sẽ được sử dụng để đảo ngược thứ tự của các nút từ b đến a.
    int i = b;
    while(tmp){
        if(index >= a && index <= b){
 //! Lưu trữ con trỏ tới các nút trong khoảng a đến b vào bảng băm v.
            v[i] = tmp;
            i--;
        }
//! Lưu trữ con trỏ tới các nút nằm ngoài khoảng a đến b.
        else v[index] = tmp;
        tmp = tmp->right;
        index ++;
    }
//! Gán con trỏ head bằng con trỏ tới nút đầu tiên sau khi đảo ngược.
    head = v[1];
    head->left = NULL;
    tmp = head;
    for(int i = 2; i < index; i++){
//! thực hiện các thao tác liên kết lại
        tmp->right = v[i];
        v[i]->left = tmp;
        tmp = v[i];
    }
    tmp->right = NULL;
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1454535,2210535,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while(head != nullptr){
        popBack();
    }
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if (head != nullptr) {
        Node* newNode = new Node(i,nullptr,head);
        head->left = newNode;
        head = newNode;
    }
    else {
        Node* newNode = new Node(i,nullptr,nullptr);
        head = newNode;
        tail = newNode;
    }
    
    curSize++;
}

void Deque::pushBack(int i) {
    if (head == nullptr){
        Node* newNode = new Node(i,nullptr,nullptr);
        head = newNode;
        tail = newNode;
    } else {
        Node* newNode = new Node(i,tail,nullptr);
        tail->right = newNode;
        tail = newNode;
    }
    curSize += 1;
}

int Deque::popFront() {
    if (head == nullptr)
        return -1;
    int item = head->value;
    Node* temp = head;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}

int Deque::popBack() {
    if (head == nullptr)
        return -1;
    int item = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1454535,2210535,"
template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newnode = new Node(e);
    if (head == nullptr && tail == nullptr && count == 0) {
        head = newnode;
        tail = newnode;
        count++;
    }
    else {
        tail->next = newnode;
        newnode->previous = tail;
        tail = newnode;
        count++;
    }
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at the given index. */
    if (index < 0 || index > count) throw out_of_range(""Index out of range"");

    if (index == count) {
        add(e);
    }
    else if (index == 0) {
        Node* newnode = new Node(e);
        newnode->next = head;
        if (head) {
            head->previous = newnode;
        }
        head = newnode;
        if (tail == nullptr) {
            tail = newnode;
        }
        count++;
    }
    else {
        Node* temp = head;
        while (index > 0) {
            if (temp == nullptr) {
                throw out_of_range(""Index out of range"");
            }
            temp = temp->next;
            index--;
        }
        Node* newnode = new Node(e);
        newnode->next = temp;
        newnode->previous = temp->previous;
        temp->previous = newnode;
        if (newnode->previous) {
            newnode->previous->next = newnode;
        }
        else {
            head = newnode;
        }
        count++;
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of the list */
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454535,2210535,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    Node* temp = head;
    while (index != 0 && temp) {
        temp = temp->next;
        index--;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    Node* temp = head;
    while (index != 0 && temp) {
        temp = temp->next;
        index--;
    }
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
     if (this->count == 0) {
        return true;
    }
    else return false;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while (temp) {
        if (temp->data == item) {
            return i;
        }
        temp = temp->next;
        i++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if (indexOf(item) != -1) {
        return true;
    }
    else return false;
}",1.0,1111111111
Doubly_Linked_List_4,1454535,2210535,"
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    if (begin == true)  {
        this->pList = pList;
        if (pList == nullptr)   {
            current = nullptr;
            index = -1;
        }
        else {
            current = pList->head;
            index = 0;
        }
    }
    else {
        this->pList = pList;
        current = nullptr;
        index = pList->size();
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == nullptr) {
        throw out_of_range(""Segmentation fault!"");
    }
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (current == nullptr) {
        throw out_of_range(""Segmentation fault!"");
    }
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current == nullptr) {
        throw out_of_range(""Segmentation fault!"");
    }
    current = current->previous;
    this->pList->removeAt(index);
    index = index-1;
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (current != iterator.current && index != iterator.index);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{   
    if (index == -1)    {
        index = 0;
        current = this->pList->head;
    }
    else {
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}

",1.0,1111111111
Doubly_Linked_List_5,1454535,2210535,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(index <0 || index >= count) throw out_of_range("" "");
    if(count  == 0) throw out_of_range("" "");
    if(index == 0)
    {
        Node *p =head;
        T a = head->data;
        head = head->next;
        if(head != NULL) head->previous =NULL;
        else tail =NULL;
        p->next =NULL;
        
        delete p;
        count --;
        return a;
    }
    if(index == count-1)
    {
        Node*p = tail;
        tail = tail->previous;
        if(tail!=NULL) tail->next =NULL;
        else head= NULL;
        p->previous = NULL;
        T a = p->data;
        delete p;
        count --;
        return a;
    }
    Node*p = head;
    for(int i =0;i<index;i++) p = p->next;
    Node*next = p->next;
    Node* prev = p->previous;
    T a =p->data;
    prev->next = next;
    next->previous = prev;
    p->next=NULL;
    p->previous =NULL;
    delete p;
    count--;
    return a;
    
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(count == 0) return false;
    if(head -> data == item)
    {
        Node* p = head;
        head=head->next;
        p->next =NULL;
        if(head!=NULL)head->previous =NULL;
        else tail = NULL;
        delete p;
        count--;
        return true;
    }
    Node* p =head;
    while(p->next !=NULL)
    {
        if(p->next->data == item)
        {
            Node*temp =p->next;
            Node*next = temp->next;
            p->next = next;
            if(next!= NULL) next->previous = p;
            else tail = p;
            temp->next=NULL;
            temp->previous=NULL;
            delete temp;
            count--;
            return true;
        }
        p=p->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while(head!=NULL)
    {
        Node*p=head;
        head=head->next;
        p->next =NULL;
        if(head!=NULL) head->previous =NULL;
        delete p;
    }
    count=0;
    tail = NULL;
}
",1.0,1111111111
Doubly_Linked_List_6,1454535,2210535,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    list<int>::iterator temp = logList.end();
    temp--;
    
    while (temp != currentState)
    {
        temp--;
        logList.pop_back();
    }

    logList.push_back(*currentState);
    currentState = --logList.end();
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if (currentState != logList.begin())   {
         currentState--;
     }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    currentState = logList.end();
    currentState--;
}
",1.0,1111111111
Doubly_Linked_List_8,1454535,2210535,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    if (a == b) return head;
    
    ListNode* startNode = head;
    ListNode* endNode = head;
    ListNode* prevNodeA = nullptr;
    ListNode* nextNodeB = nullptr;
    
    for (int i = 1; i < a; i++) {
        prevNodeA = startNode;
        startNode = startNode->right;
    }
    
    for (int i = 1; i < b; i++) {
        endNode = endNode->right;
    }
    nextNodeB = endNode->right;
    ListNode* currentNode = startNode;
    ListNode* prev = nextNodeB;
    
    while (currentNode != nextNodeB) {
        ListNode* next = currentNode->right;
        currentNode->right = prev;
        currentNode->left = next;
        prev = currentNode;
        currentNode = next;
    }
    if (prevNodeA) {
        prevNodeA->right = endNode;
    } else {
        head = endNode;
    }
    
    startNode->right = nextNodeB;
    
    if (nextNodeB) {
        nextNodeB->left = startNode;
    }
    
    endNode->left = prevNodeA;
    
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1454556,2212741,"Deque::Deque() : head(nullptr), tail(nullptr), curSize(0) {}

Deque::~Deque() {
    clear();
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int item) {
    Node* newNode = new Node(item, nullptr, head);
    if (curSize == 0) {
        head = tail = newNode;
    } else {
        head->left = newNode;
        head = newNode;
    }
    curSize++;
}

void Deque::pushBack(int item) {
    Node* newNode = new Node(item, tail, nullptr);
    if (curSize == 0) {
        head = tail = newNode;
    } else {
        tail->right = newNode;
        tail = newNode;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1;
    }
    int result = head->value;
    Node* temp = head;
    if (curSize == 1) {
        head = tail = nullptr;
    } else {
        head = head->right;
        head->left = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1;
    }
    int result = tail->value;
    Node* temp = tail;
    if (curSize == 1) {
        head = tail = nullptr;
    } else {
        tail = tail->left;
        tail->right = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

void Deque::clear() {
    while (curSize > 0) {
        popFront();
    }
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        std::cout << current->value << "" "";
        current = current->left;
    }
    std::cout << std::endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->value << "" "";
        current = current->right;
    }
    std::cout << std::endl;
}
",1.0,1111111111
Doubly_Linked_List_2,1454556,2212741,"template <class T>
void DLinkedList<T>::add(const T &e) {
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template <class T>
void DLinkedList<T>::add(int index, const T &e) {
    if (index < 0 || index > count) {
        // Index out of bounds
        return;
    }

    if (index == count) {
        // Adding to the end of the list
        add(e);
        return;
    }

    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        newNode->previous = current;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
}

template <class T>
int DLinkedList<T>::size() {
    return count;
}
",1.0,1111111111
Doubly_Linked_List_3,1454556,2212741,"template <class T>
bool DLinkedList<T>::empty() {
    return count == 0;
}

template <class T>
T DLinkedList<T>::get(int index) {
    if (index < 0 || index >= count) {
        // Index out of bounds
        return T(); // Return a default-constructed object for invalid index
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }

    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T &e) {
    if (index < 0 || index >= count) {
        // Index out of bounds
        return;
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }

    current->data = e;
}

template <class T>
int DLinkedList<T>::indexOf(const T &item) {
    Node* current = head;
    for (int i = 0; i < count; i++) {
        if (current->data == item) {
            return i;
        }
        current = current->next;
    }

    return -1; // Item not found
}

template <class T>
bool DLinkedList<T>::contains(const T &item) {
    return indexOf(item) != -1;
}
",1.0,1111111111
Doubly_Linked_List_4,1454556,2212741,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if (begin) {
        this->current = pList->head;
        this->index = 0;
    } else {
        this->current = NULL;
        this->index = pList->count;
    }

}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
        this->current = iterator.current;
    this->index = iterator.index;
    return *this;

}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current != NULL) {
        this->current->data = e;
    }

}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current != NULL && this->pList != NULL) {
        Node* nodeToRemove = this->current;

        if (nodeToRemove == this->pList->head) {
            this->pList->head = nodeToRemove->next;
        }

        if (nodeToRemove == this->pList->tail) {
            this->pList->tail = nodeToRemove->previous;
        }

        if (nodeToRemove->next != NULL) {
            nodeToRemove->next->previous = nodeToRemove->previous;
        }

        if (nodeToRemove->previous != NULL) {
            nodeToRemove->previous->next = nodeToRemove->next;
            this->current = nodeToRemove->previous;
        } else {
            this->current = NULL;
        }

        delete nodeToRemove;
        this->pList->count--;
    }

}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
        return this->current != iterator.current;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
        if (this->current != NULL) {
        this->current = this->current->next;
    } else if (this->pList != NULL) {
        this->current = this->pList->head;
    }
    
    return *this;

}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator iteratorBeforeIncrementation(*this);
    
    ++*this;

    return iteratorBeforeIncrementation;

}
",1.0,1111111111
Doubly_Linked_List_5,1454556,2212741,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count)
        throw out_of_range(""Index out of range"");

    Node *currentNode = head;
    T removedData;

    if (index == 0)
    {
        head = currentNode->next;
        if (head != nullptr)
            head->previous = nullptr;
        else
            tail = nullptr;
        removedData = currentNode->data;
        delete currentNode;
    }
    else
    {
        for (int i = 0; i < index - 1; i++)
        {
            currentNode = currentNode->next;
        }

        Node *nodeToRemove = currentNode->next;
        Node *nextNode = nodeToRemove->next;

        currentNode->next = nextNode;
        if (nextNode != nullptr)
            nextNode->previous = currentNode;
        else
            tail = currentNode;

        removedData = nodeToRemove->data;
        delete nodeToRemove;
    }

    count--;
    return removedData;
}

template <class T>
bool DLinkedList<T>::removeItem(const T &item)
{
    Node *currentNode = head;
    Node *prevNode = nullptr;

    while (currentNode != nullptr)
    {
        if (currentNode->data == item)
        {
            if (prevNode == nullptr)
            {
                head = currentNode->next;
                if (head != nullptr)
                    head->previous = nullptr;
                else
                    tail = nullptr;
            }
            else
            {
                prevNode->next = currentNode->next;
                if (currentNode->next != nullptr)
                    currentNode->next->previous = prevNode;
                else
                    tail = prevNode;
            }

            delete currentNode;
            count--;
            return true;
        }

        prevNode = currentNode;
        currentNode = currentNode->next;
    }

    return false;
}

template <class T>
void DLinkedList<T>::clear()
{
    Node *currentNode = head;

    while (currentNode != nullptr)
    {
        Node *nextNode = currentNode->next;
        delete currentNode;
        currentNode = nextNode;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1454556,2212741,"DataLog::DataLog() {
    // Add the first state with 0
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data) {
    // Add the first state with data
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number) {
    // Increase the value of the current state by number
    *currentState += number;
}

void DataLog::subtractCurrentState(int number) {
    // Decrease the value of the current state by number
    *currentState -= number;
}

void DataLog::save() {
    // Create a new state, copy the data of the currentState, and move the currentState Iterator to this new state.
    if (currentState != prev(logList.end())) {
        logList.erase(next(currentState), logList.end());
    }
    logList.push_back(*currentState);
    currentState = prev(logList.end());
}

void DataLog::undo() {
    // Switch to the previous state of the data
    if (currentState != logList.begin()) {
        --currentState;
    }
}

void DataLog::redo() {
    // Switch to the latter state of the data
    if (currentState != prev(logList.end())) {
        ++currentState;
    }
}
",1.0,1111111111
Doubly_Linked_List_8,1454556,2212741,"ListNode* reverse(ListNode* head, int a, int b) {
    if (!head || a == b) {
        return head;
    }

    ListNode* dummy = new ListNode(0);
    dummy->right = head;
    head->left = dummy;
    ListNode* prev = dummy;
    int count = 1;

    while (count < a) {
        prev = prev->right;
        count++;

        if (!prev->right) {
            // a is out of bounds
            return head;
        }
    }

    ListNode* current = prev->right;
    ListNode* next = current->right;

    while (count < b) {
        if (!next) {
            // b is out of bounds
            return head;
        }

        current->right = next->right;
        if (next->right) {
            next->right->left = current;
        }

        next->right = prev->right;
        prev->right->left = next;
        prev->right = next;
        next->left = prev;
        next = current->right;
        count++;
    }

    return dummy->right;
}

",1.0,1111111111
Doubly_Linked_List_1,1454562,2210200,"Deque::Deque() {
    head = NULL;
    tail = NULL;
    curSize = 0;
}

Deque::~Deque() {
    head = NULL;
    tail = NULL;
    curSize = 0;
}

void Deque::clear() {
    Node *temp = head;
    for(int i = 0; i < curSize; i++){
        Node *removeNode = temp;
        temp = temp->right;
        if(temp) temp->left = NULL;
        removeNode->right = NULL;
        removeNode->left = NULL;
        delete removeNode;
    }
    curSize = 0;
    head = NULL;
    tail = NULL;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node *newNode = new Node(i, NULL, NULL);
    if(curSize == 0){
        head = newNode;
        tail = newNode;
        ++curSize;
        return;
    }
    newNode->right = head;
    head->left = newNode;
    head = newNode;
    ++curSize;
}

void Deque::pushBack(int i) {
    Node *newNode = new Node(i, NULL, NULL);
    if(curSize == 0){
        head = newNode;
        tail = newNode;
        ++curSize;
        return;
    }
    tail->right = newNode;
    newNode->left = tail;
    tail = newNode;
    ++curSize;
}

int Deque::popFront() {
    if(curSize == 0) return -1;
    Node *removeNode = head;
    head = head->right;
    if(head) head->left = NULL;
    removeNode->right = NULL;
    removeNode->left = NULL;
    int data = removeNode->value;
    delete removeNode;
    --curSize;
    return data;
}

int Deque::popBack() {
    if(curSize == 0) return -1;
    Node *removeNode = tail;
    tail = tail->left;
    if(tail) tail->right = NULL;
    removeNode->left = NULL;
    removeNode->right = NULL;
    int data = removeNode->value;
    delete removeNode;
    --curSize;
    return data;
}

void Deque::printDeque(){
    Node *temp = head;
    while(temp != NULL){
        if(temp == tail) cout << temp->value;
        else cout << temp->value << "" "";
        temp = temp->right;
    }
    cout << ""\n"";
}

void Deque::printDequeReverse(){
    Node *temp = tail;
    while(temp != NULL){
        if(temp == head) cout << temp->value;
        else cout << temp->value << "" "";
        temp = temp->left;
    }
    cout << ""\n"";
}",1.0,1111111111
Doubly_Linked_List_2,1454562,2210200,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *newNode = new Node(e);
    if(count == 0){
        head = newNode;
        tail = newNode;
        ++count;
        return;
    }
    tail->next = newNode;
    newNode->previous = tail;
    tail = newNode;
    ++count;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index < 0 || index > count) return;
    if(count == 0 || index == count){
        add(e);
        return;
    }
    Node *newNode = new Node(e);
    if(index == 0){
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
        ++count;
        return;
    }
    Node *temp = head;
    for(int i = 0; i < index - 1; i++){
        temp = temp->next;
    }
    newNode->next = temp->next;
    newNode->previous = temp;
    temp->next->previous = newNode;
    temp->next = newNode;
    ++count;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454562,2210200,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++) temp = temp->next;
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++) temp = temp->next;
    temp->data = e;
    return;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item) return i;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (indexOf(item) != -1);
}",1.0,1111111111
Doubly_Linked_List_4,1454562,2210200,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if (begin == true){
        if (this->pList != NULL){
            this->current = this->pList->head;
            this->index = 0;
        } else {
            this->current = NULL;
            this->index = -1;
        }
    } else {
        this->current = NULL;
        if (this->pList != NULL) this->index = this->pList->size();
        else this->index = 0;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
        throw std::out_of_range(""Segmentation fault!"");
    this->current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (this->current == NULL) 
        throw std::out_of_range(""Segmentation fault!"");
    return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    if (this->current == NULL) throw std::out_of_range(""Segmentation fault!"");
    if (this->current == this->pList->head) this->current = NULL;
    else this->current = this->current->previous;
    this->pList->removeAt(this->index);
    this->index--;
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    if (this->current == iterator.current && this->index == iterator.index){
        return false;
    }
    return true;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->index > this->pList->count){
        throw std::out_of_range(""Index is invalid"");
    }
    if (this->current == NULL){
        this->current = this->pList->head;
        this->index = 0;
        return *this;
    }
    this->current = this->current->next;
    this->index += 1;
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator pNew = *this;
    ++*this;
    return pNew;
}",1.0,1111111111
Doubly_Linked_List_5,1454562,2210200,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(count == 0) throw std::out_of_range(""Index is out of range"");
    if(count == 1 && index == 0){
        int t = head->data;
        delete head;
        head = NULL;
        tail = NULL;
        count = 0;
        return t;
    }
    if(index == 0){
        Node *temp = head;
        head = head->next;
        if(head) head->previous = NULL;
        int t = temp->data;
        delete temp;
        --count;
        return t;
    }
    if(index == count - 1){
        Node *temp = tail;
        tail = tail->previous;
        if(tail) tail->next = NULL;
        int t = temp->data;
        delete temp;
        --count;
        return t;
    }
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++) temp = temp->next;
    if(temp->previous) temp->previous->next = temp->next;
    if(temp->next) temp->next->previous = temp->previous;
    int t = temp->data;
    delete temp;
    --count;
    return t;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item){
            removeAt(i);
            return true;
        }
        temp = temp->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        Node *rm = temp;
        temp = temp->next;
        if(temp) temp->previous = NULL;
        delete rm;
    }
    head = NULL;
    tail = NULL;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1454562,2210200,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    int temp = *currentState;
    list<int>::iterator it = logList.end();
    --it;
    while(it != currentState){
        --it;
        logList.pop_back();
    }
    logList.push_back(temp);
    it = logList.end();
    --it;
    currentState = it;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState == logList.begin()) return;
    else --currentState;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    list<int>::iterator it = logList.end();
    --it;
    if(currentState == it) return;
    else ++currentState;
}
",1.0,1111111111
Doubly_Linked_List_8,1454562,2210200,"ListNode *reverse(ListNode *head, int l, int r)
{
    if (!head || !head->right || l == r)
        return head;
        
    ListNode *prev = nullptr;
    ListNode *current = nullptr;

    for (int i = 0; i < l; i += 1)
    {
        if (current == nullptr)
            current = head;
        else
        {
            prev = current;
            current = current->right;
        };
    }

    ListNode *start = current;
    for (int i = l; i < r; i += 1)
    {
        current = current->right;
    }
    ListNode *end = current;

    if (prev != nullptr)
    {
        prev->right = end;
    }
    else
    {
        head = end;
    }
    if (end->right)
    {
        end->right->left = start;
    }
    prev = end->right;
    while (start != end)
    {
        ListNode *next = start->right;
        start->right = prev;
        start->left = next;
        prev = start;
        start = next;
    }
    start->right = prev;

    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1454567,2210103,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    if (head != nullptr && tail != nullptr)
    {
        while (head->right != nullptr)
        {
            Node* p = head;
            head = head->right;
            p->right = nullptr;
            head->left = nullptr;
            delete p;
            curSize--;
        }
        if (curSize == 2)
        {
            delete head;
            head = nullptr;
            delete tail;
            tail = nullptr;
        }
        else
        {
            delete head;
            head = nullptr;
        }
        curSize = 0;
    }
}

void Deque::clear() {
    if (head != nullptr && tail != nullptr)
    {
        while (head->right != nullptr)
        {
            Node* p = head;
            head = head->right;
            head->left = nullptr;
            p->right = nullptr;
            delete p;
            curSize--;
        }
        if (curSize == 2)
        {
            delete head;
            head = nullptr;
            delete tail;
            tail = nullptr;
        }
        else
        {
            delete head;
            head = nullptr;
        }
        curSize = 0;
    }
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* item = new Node(i, nullptr, nullptr);
    if (item != nullptr)
    {
        if (curSize == 0)
        {
            head = item;
            tail = item;
        }
        else
        {
            item->right = head;
            head->left = item;
            head = item;
        }
        curSize++;
    }
}

void Deque::pushBack(int i) {
    Node* item = new Node(i, nullptr, nullptr);
    if (item != nullptr)
    {
        if (curSize == 0)
        {
            head = tail = item;
        }
        else
        {
            item->left = tail;
            tail->right = item;
            tail = item;
        }
        curSize++;
    }
}

int Deque::popFront() {
    if (curSize == 0)
    {
        return -1;
    }
    else if (curSize == 1)
    {
        int val;
        Node* p = head;
        val = p->value;
        p = nullptr;
        curSize = 0;
        return val;
    }
    else
    {
        int val;
        Node* p = head;
        head = head->right;
        p->right = nullptr;
        head->left = nullptr;
        val = p->value;
        curSize--;
        return val;
    }
}

int Deque::popBack() {
    if (curSize == 0)
    {
        return -1;
    }
    else if (curSize == 1)
    {
        int val;
        Node* p = tail;
        val = p->value;
        p = nullptr;
        curSize = 0;
        return val;
    }
    else
    {
        int val;
        Node* p = tail;
        tail = tail->left;
        p->left = nullptr;
        tail->right = nullptr;
        val = p->value;
        curSize--;
        return val;
    }
}

void Deque::printDequeReverse() {
    if (curSize == 0)
    {
        ;
    }
    else
    {
        Node* p = tail;
        Node* q = tail;
        while (p->left != nullptr)
        {
            cout << p->value << "" "";
            q = p;
            p = q->left;
        }
        cout << p->value;
    }
    cout << ""\n"";
}

void Deque::printDeque() {
    if (curSize != 0)
    {
        Node* p = head;
        Node* q = head;
        while (p->right != nullptr)
        {
            cout << p->value << "" "";
            q = p;
            p = q->right;
        }
        cout << p->value;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1454567,2210103,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* p = new Node(e);
    if (p != nullptr)
    {
        if (count == 0)
        {
            head = tail = p;
        }
        else
        {
            p->previous = tail;
            tail->next = p;
            tail = p;
        }
        count++;
    }
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index >= 0 && index <= count)
    {
        Node* q = new Node(e);
        Node* p = head;
        Node* n = head;
        if (count == 0)
        {
            head = tail = q;
            count++;
            return;
        }
        if (index == 0)
        {
            q->next = head;
            head->previous = q;
            head = q;
        }
        else if (index == count)
        {
            q->previous = tail;
            tail->next = q;
            tail = q;
        }
        else
        {
            int i = 0;
            while (i != index)
            {
                p = n;
                n = n->next;
                i++;
            }
            p->next = q;
            q->next = n;
            n->previous = q;
            q->previous = p;
        }
        count++;
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454567,2210103,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index >= 0 && index < count)
    {
        int i = 0;
        Node* p = head;
        while (p != nullptr)
        {
            if (i == index)
            {
                return p->data;
            }
            p = p->next;
            i++;
        }
    }
    return -1;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index >= 0 && index < count)
    {
        int i = 0;
        Node* p = head;
        while (p != nullptr)
        {
            if (i == index)
            {
                p->data = e;
                return;
            }
            p = p->next;
            i++;
        }
    }
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return head == nullptr;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if (count > 0)
    {
        Node* q = head;
        int i = 0;
        while (q != nullptr)
        {
            if (item == q->data)
            {
                return i;
            }
            i++;
            q = q->next;
        }
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if (indexOf(item) != -1) return 1;
    return 0;
}",1.0,1111111111
Doubly_Linked_List_4,1454567,2210103,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if (begin == true) {
        if (pList != NULL) {
            this->current = pList->head;
            this->index = 0;
        }
        else {
            this->current = NULL;
            this->index = -1;
        }
    }
    else {
        this->current = NULL;
        if (pList != NULL) this->index = pList->count;
        else this->index = 0;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    if (index == 0) {
        pList->head = current->next;
        delete current;
        pList->count--;
        if (pList->count == 0) pList->tail = pList->head;
        current = nullptr;
        index = -1;
    }
    else {
        Node* prev = pList->head;
        while (prev->next != current) prev = prev->next;
        prev->next = current->next;
        delete current;
        pList->count--;
        if (index == pList->count) pList->tail = prev;
        current = prev;
        index--;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    if (this->current == iterator.current && this->index == iterator.index) return false;
    else return true;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    //if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    if (index < 0) {
        current = pList->head;
        index = 0;
    }
    else {
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator ret = *this;
    //if (current == NULL) throw std::out_of_range(""Segmentation fault!"");
    if (index < 0) {
        current = pList->head;
        index = 0;
    }
    else {
        current = current->next;
        index++;
    }
    return ret;
}",1.0,1111111111
Doubly_Linked_List_5,1454567,2210103,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index >= 0 && index < count)
    {
        Node* p = head;
        Node* n = head;
        int i = 0;
        if (count == 1)
        {
            T val = head->data;
            delete head;
            head = nullptr;
            tail = nullptr;
            count--;
            return val;
        }
        if (index == 0)
        {
            head = head->next;
            p->next = nullptr;
            head->previous = nullptr;
            T val = p->data;
            delete p;
            p = nullptr;
            count--;
            return val;
        }
        if (index == count - 1)
        {
            p = tail;
            tail = tail->previous;
            p->previous = nullptr;
            tail->next = nullptr;
            T val = p->data;
            delete p;
            p = nullptr;
            count--;
            return val;
        }
        T val = 0;
        while (n != nullptr)
        {
            if (i == index)
            {
                p->next = n->next;
                n->next->previous = p;
                n->next = nullptr;
                n->previous = nullptr;
                val = n->data;
                delete n;
                n = nullptr;
                count--;
                break;
            }
            p = n;
            n = n->next;
            i++;
        }
        return val;
    }
    return 0;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if (count > 0)
    {
        if (count == 1)
        {
            if (head->data == item)
            {
                delete head;
                head = nullptr;
                tail = nullptr;
                count--;
                return 1;
            }
            return 0;
        }
        else
        {
            Node* p = head;
            Node* n = head;
            if (head->data == item)
            {
                head = head->next;
                head->previous = nullptr;
                p->next = nullptr;
                delete p;
                count--;
                return 1;
            }
            while (n != nullptr)
            {
                if (n->data == item)
                {
                    if (n == tail)
                    {
                        p = tail;
                        tail = tail->previous;
                        tail->next = nullptr;
                        p->previous = nullptr;
                        delete p;
                        count--;
                        return 1;
                    }
                    else
                    {
                        p->next = n->next;
                        n->next->previous = p;
                        n->next = nullptr;
                        n->previous = nullptr;
                        delete n;
                        n = nullptr;
                        count--;
                        return 1;
                    }
                }
                p = n;
                n = n->next;
            }
        }
    }
    return 0;
}

template<class T>
void DLinkedList<T>::clear() {
    /* Remove all elements in list */
    if (count > 0)
    {
        if (count == 1)
        {
            delete head;
            head = nullptr;
            tail = nullptr;
            count--;
        }
        else
        {
            Node* p = head;
            while (p->next != nullptr)
            {
                head = head->next;
                head->previous = nullptr;
                p->next = nullptr;
                delete p;
                p = head;
            }
            delete p;
            p = nullptr;
            count = 0;
        }
    }
    head = nullptr;
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1454567,2210103,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int& data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    number += *(currentState);
    *currentState = number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    number = *currentState - number;
    *currentState = number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the
     *       currentState Iterator, we delete them all before creating a new state.
     */
    auto nextState = currentState;
    nextState++;
    while (nextState != logList.end())
    {
        logList.erase(nextState);
        nextState = currentState;
        nextState++;
    }

    int number = *currentState;
    logList.push_back(number);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState != logList.begin())
    {
        currentState--;
    }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    auto j = logList.begin();
    for (auto i = currentState; i != logList.end(); i++)
    {
        j = i;
    }
    if (currentState != j)
    {
        currentState++;
    }
}",1.0,1111111111
Doubly_Linked_List_8,1454567,2210103,"ListNode* reverse(ListNode* head, int a, int b) {
    int count = 1;
    ListNode* q = head;
    ListNode* preQ = head;
    ListNode* nextP = head;
    if (a != b)
    {
        while (count != a)
        {
            preQ = q;
            q = q->right;
            count++;
        }
        if (count == 1)
        {
            preQ = nullptr;
        }
        count = 0;
        while (count != b)
        {
            nextP = nextP->right;
            count++;
        }
        ListNode* s = q->right;
        q->right = nextP;
        q->left = s;
        if (nextP != nullptr)
        {
            nextP->left = q;
        }
        while (s != nextP)
        {
            q = s;
            s = q->right;
            q->right = q->left;
            if (s != nextP)
            {
                q->left = s;
            }
            else
            {
                q->left = preQ;
            }
        }
        if (preQ != nullptr)
        {
            preQ->right = q;
        }
        if (a == 1)
        {
            head = q;
        }
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_2,1454568,2210532,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if (count == 0) {
        head = tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
     if (index < 0 || index > count)
        throw ""Index out of bounds!"";
    Node* newNode = new Node(e);
    if (index == 0) {
        if (count == 0) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->previous = newNode;
            head = newNode;
        }
    } else if (index == count) {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    } else {
        Node* prevNode = head;
        for (int i = 0; i < index - 1; i++)
            prevNode = prevNode->next;
        newNode->next = prevNode->next;
        newNode->previous = prevNode;
        prevNode->next->previous = newNode;
        prevNode->next = newNode;
    }
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454568,2210532,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count)
        throw ""Index out of bounds!"";
    Node* curNode = head;
    for (int i = 0; i < index; i++)
        curNode = curNode->next;
    return curNode->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count)
        throw ""Index out of bounds!"";
    Node* curNode = head;
    for (int i = 0; i < index; i++)
        curNode = curNode->next;
    curNode->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for (Node* curNode = head; curNode != NULL; curNode = curNode->next) {
        if (curNode->data == item)
            return index;
        index++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1454568,2210532,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if(begin){
        if(pList != 0){
            current = pList->head;
            index = 0;
        }
    }
    else{
        current = 0;
        if(pList != 0){
            index = pList->size();
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(current != 0){
        current->data = e;
    }
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    if (current == pList->head)
    {
        current = nullptr;
        pList->removeAt(0);
        index = -1;
    }
    else
    {
        current = current->previous;
        pList->removeAt(index);
        index--;
    }
}




template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return this->current != iterator.current;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{   
    if(current == nullptr){
        current = pList->head;
    }
    else if (current != 0) {
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator iterator = *this;
    ++*(this);
    return iterator;
}",0.9,1111011111
Doubly_Linked_List_5,1454568,2210532,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if(index<0 || index>=count)
      throw ""The index is out of bounds!"";
    else{
      Node* temp=head;

      if(index==0){
          head=head->next;

          if(head!=NULL)
              head->previous=NULL;

          delete temp;

          count--;
      }
      else{
          for(int i=0;i<index;i++)
              temp=temp->next;

          temp->previous->next=temp->next;

          if(temp!=tail)
              temp->next->previous=temp->previous;

          delete temp;

          count--;
      }
  }
  return true;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
   int idx=indexOf(item);
   if(idx==-1)return false;
    else{
        removeAt(idx);
        return true;   
    }
}

template<class T>
void DLinkedList<T>::clear(){
    while(count!=0)
        removeAt(0);
}
",0.1,10
Doubly_Linked_List_6,1454568,2210532,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    //int NextData = getCurrentStateData() + number;
    //logList.insert(currentState, NextData);
    *currentState+= number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
 *currentState-= number;
}


void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.*/
   while (currentState != prev(logList.end(),1)){
logList.pop_back();
}
    logList.push_back (*currentState);
    ++currentState;
    
}


void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     
    if (currentState != logList.begin()) {
        currentState = prev(currentState);
    }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    if (next(currentState) != logList.end()) {
        currentState = next(currentState);
    }
}
",1.0,1111111111
Doubly_Linked_List_8,1454568,2210532,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    ListNode* newHead = new ListNode(); // Create a new dummy node
    newHead->right = head;
    head->left = newHead;
    
    ListNode* current = head;
    ListNode* prev = newHead;

    int idx = 1;
    while (idx < a) {
        prev = current;
        current = current->right;
        idx++;
    }

    ListNode* first = prev;
    ListNode* second = current;

    // Reverse the sublist from a to b
    for (int i = a; i <= b; i++) {
        ListNode* next = current->right;
        current->right = prev;
        prev->left = current;
        prev = current;
        current = next;
    }

    first->right = prev;
    prev->left = first;
    second->right = current;
    if (current) {
        current->left = second;
    }

    return newHead->right;
}",1.0,1111111111
Doubly_Linked_List_1,1454578,2213248,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head)
    {
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    tail = nullptr;
    curSize = 0;    
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
    if (head) {
        head->left = newNode;
    }
    head = newNode;
    if (!tail) {
        tail = head;
    }
    curSize++;
}

void Deque::pushBack(int i) {
    Node* temp = new Node(i, tail, nullptr);
    if (tail) {
        tail->right = temp;
    }
    tail = temp;
    if (!head) {
        head = tail;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1;
    }
    int result = head->value;
    Node* temp = head;
    head = head->right;
    if (head) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1; 
    }
    int result = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout<<endl;
}",1.0,1111111111
Doubly_Linked_List_2,1454578,2213248,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if(!tail) {
        tail = new Node(e);
        head = tail;
        return;
    }
    Node* temp = new Node(e);
    tail->next = temp;
    temp->previous = tail;
    tail = tail->next;
    count++;
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index < 0 || index > count) {
        throw std::out_of_range(""Index out of range"");
    }

    // Create a new Node with the element 'e'
    Node* newNode = new Node(e);

    // If the list is empty, set the head and tail to the new node
    if (count == 0) {
        head = newNode;
        tail = newNode;
    } else if (index == 0) {
        // If adding to the beginning of the list
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else if (index == count) {
        // If adding to the end of the list
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    } else {
        // Insert the new node at the specified index
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }

        newNode->next = current->next;
        newNode->previous = current;
        current->next = newNode;
        newNode->next->previous = newNode;
    }

    // Increment the count of elements in the list
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454578,2213248,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count)  throw std::out_of_range(""Index is out of range"");
    Node* current = head;
    while(index) {
        current = current->next;
        index--;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count)  throw std::out_of_range(""Index is out of range"");
    Node* current = head;
    while(index) {
        current = current->next;
        index--;
    }
    current->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(count == 0) return true;
    else return false;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for(Node* pr = head; pr != nullptr; pr = pr->next) {
        if(pr->data == item) return index;
        index++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for(Node* pr = head; pr != nullptr; pr = pr->next) {
        if(pr->data == item) return true;
    }
    return false;
}",1.0,1111111111
Doubly_Linked_List_4,1454578,2213248,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this->pList = pList;
    if (begin)
    {
        if (pList != NULL)
        {
            this->current = pList->head;
            index = 0;
        }
        else
        {
            this->current = nullptr;
            index = -1;
        }
    }
    else
    {
        this->current = nullptr;
        if (pList != NULL)
        {
            index = pList->size();
        }
        else
        {
            index = 0;
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == NULL)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current->data = e;
    }
}

template <class T>
T &DLinkedList<T>::Iterator::operator*()
{
    if (current == NULL)
    {

        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        return current->data;
    }
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
     * TODO: delete Node in pList which Node* current point to.
     *       After that, Node* current point to the node before the node just deleted.
     *       If we remove first node of pList, Node* current point to nullptr.
     *       Then we use operator ++, Node* current will point to the head of pList.
     */
    if (current == nullptr)
    {
        return;
    }

    Node *nodeToRemove = current;
    current = current->previous;

    if (current != nullptr)
    {
        current->next = nodeToRemove->next;
    }
    else
    {
        pList->head = nodeToRemove->next;
    }

    if (nodeToRemove->next != nullptr)
    {
        nodeToRemove->next->previous = current;
    }
    else
    {
        pList->tail = current;
    }

    delete nodeToRemove;
    pList->count--;

    if (index > 0)
    {
        index--;
    }
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    if (this->pList == iterator.pList && this->current == iterator.current && this->index == iterator.index)
        return false;
    return true;
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator++()
{
    if (current == nullptr)
    {
        index = 0;
        current = this->pList->head;
        return *this;
    }
    current = current->next;
    index += 1;
    return *this;
}

template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    DLinkedList<T>::Iterator iterator = *this;
    ++*this;
    return iterator;
}
",1.0,1111111111
Doubly_Linked_List_5,1454578,2213248,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count) {
        return -1;
    }

    if (index == 0) {
        Node* removedNode = head;
        T removedValue = removedNode->data;
        head = head->next;
        if (head == nullptr) {
            tail = nullptr;
        }
        delete removedNode;
        count--;
        return removedValue;
    } else {
        Node* previous = head;
        for (int i = 0; i < index - 1; i++) {
            previous = previous->next;
        }

        Node* removedNode = previous->next;
        T removedValue = removedNode->data;
        previous->next = removedNode->next;
        if (removedNode == tail) {
            tail = previous;
        }
        delete removedNode;
        count--;
        return removedValue;
    }
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(contains(item) == true)
    return removeAt(indexOf(item))==item;
    return false;
    
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
        Node* current = head;
        head = head->next;
        delete current;
    }
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1454578,2213248,"DataLog::DataLog()
{
    logList = list<int>();
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    logList = list<int>();
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    (*currentState) += number;
}

void DataLog::subtractCurrentState(int number)
{
    (*currentState) -= number;
}

void DataLog::save()
{
    logList.erase(next(currentState, 1), logList.end());
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    if (currentState == logList.begin())
        return;
    currentState--;
}

void DataLog::redo()
{
    if (next(currentState, 1) == logList.end())
        return;
    currentState++;
}
",1.0,1111111111
Doubly_Linked_List_8,1454578,2213248,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    if(a == b) return head;
    if(head->right == NULL) return head;
    ListNode*pa =head;
    ListNode* pb = head;
    
    for(int i=1;i<b;i++)
    {
        if(i == a) pa = pb;
        pb =pb->right;
    }
    for(int i= a,j=b;i<j;i++,j--)
    {
        if(pa->right == pb)
        {
            pa->right =pb->right;
            if(pb->right!= NULL) pb->right->left =pa;
            pb->left = pa->left;
            if(pa->left!=NULL) pa->left->right = pb;
            pb->right =pa;
            pa->left =pb;
            continue;
        }
        if(head == pa) head =pb;
        ListNode*tempa =pa;
        ListNode*tempb = pb;
        pa=pa->right;
        pb = pb->left;
        tempa->right = tempb->right;
        if(tempb->right !=NULL) tempb->right->left =tempa;
        tempb->right = pa;
        pa->left = tempb;
        tempb->left = tempa->left;
        if(tempa->left != NULL) tempa->left->right = tempb;
        tempa->left = pb;
        pb->right = tempa;
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1454637,2213035,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head)
    {
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    tail = nullptr;
    curSize = 0;    
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
    if (head) {
        head->left = newNode;
    }
    head = newNode;
    if (!tail) {
        tail = head;
    }
    curSize++;
}

void Deque::pushBack(int i) {
    Node* temp = new Node(i, tail, nullptr);
    if (tail) {
        tail->right = temp;
    }
    tail = temp;
    if (!head) {
        head = tail;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1;
    }
    int result = head->value;
    Node* temp = head;
    head = head->right;
    if (head) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1; 
    }
    int result = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}
",1.0,1111111111
Doubly_Linked_List_2,1454637,2213035,"template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* temp = new Node(e);
    if(head == NULL){
        head = tail = temp;
        count++;
    } else {
        tail->next = temp;
        temp->previous = tail;
        tail = temp;
        count++;
    }
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
     if (index < 0 || index > this->count)
    {
        throw std::out_of_range(""Out of range"");
    }


    if (index == 0)
    {
        Node* newNode = new Node(e);
        newNode->next = head;
        if (head != nullptr)
        {
            head->previous = newNode;
        }
        head = newNode;

        if (count == 0)
        {
            tail = newNode;
        }
    }
    else if (index == count)
    {   Node* newNode = new Node(e);
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    }
    else
    {Node* newNode = new Node(e);
        Node* temp = head;
        for (int i = 0; i < index - 1; i++)
        {
            temp = temp->next;
        }

        newNode->previous = temp;
        newNode->next = temp->next;

        if (temp->next != nullptr)
        {
            temp->next->previous = newNode;
        }

        temp->next = newNode;
    }

    this->count++;
}

template<class T>
int DLinkedList<T>::size() {
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1454637,2213035,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        return -1;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        return;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(head == nullptr) return true;
    return false;
    // return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while(temp != nullptr){
        if(temp->data == item) return i;
        i++;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}
",1.0,1111111111
Doubly_Linked_List_4,1454637,2213035,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this->pList = pList;
    if (begin)
    {
        if (pList != NULL)
        {
            this->current = pList->head;
            index = 0;
        }
        else
        {
            this->current = nullptr;
            index = -1;
        }
    }
    else
    {
        this->current = nullptr;
        if (pList != NULL)
        {
            index = pList->size();
        }
        else
        {
            index = 0;
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == NULL)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current->data = e;
    }
}

template <class T>
T &DLinkedList<T>::Iterator::operator*()
{
    if (current == NULL)
    {

        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        return current->data;
    }
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
     * TODO: delete Node in pList which Node* current point to.
     *       After that, Node* current point to the node before the node just deleted.
     *       If we remove first node of pList, Node* current point to nullptr.
     *       Then we use operator ++, Node* current will point to the head of pList.
     */
    if (current == nullptr)
    {
        return;
    }

    Node *nodeToRemove = current;
    current = current->previous;

    if (current != nullptr)
    {
        current->next = nodeToRemove->next;
    }
    else
    {
        pList->head = nodeToRemove->next;
    }

    if (nodeToRemove->next != nullptr)
    {
        nodeToRemove->next->previous = current;
    }
    else
    {
        pList->tail = current;
    }

    delete nodeToRemove;
    pList->count--;

    if (index > 0)
    {
        index--;
    }
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    if (this->pList == iterator.pList && this->current == iterator.current && this->index == iterator.index)
        return false;
    return true;
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator++()
{
    if (current == nullptr)
    {
        index = 0;
        current = this->pList->head;
        return *this;
    }
    current = current->next;
    index += 1;
    return *this;
}

template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    DLinkedList<T>::Iterator iterator = *this;
    ++*this;
    return iterator;
}",1.0,1111111111
Doubly_Linked_List_5,1454637,2213035,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count) {
        return -1;
    }

    if (index == 0) {
        Node* removedNode = head;
        T removedValue = removedNode->data;
        head = head->next;
        if (head == nullptr) {
            tail = nullptr;
        }
        delete removedNode;
        count--;
        return removedValue;
    } else {
        Node* previous = head;
        for (int i = 0; i < index - 1; i++) {
            previous = previous->next;
        }

        Node* removedNode = previous->next;
        T removedValue = removedNode->data;
        previous->next = removedNode->next;
        if (removedNode == tail) {
            tail = previous;
        }
        delete removedNode;
        count--;
        return removedValue;
    }
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(contains(item) == true)
    return removeAt(indexOf(item))==item;
    return false;
    
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
        Node* current = head;
        head = head->next;
        delete current;
    }
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1454637,2213035,"// front() – Returns the value of the first element in the list.
// back() – Returns the value of the last element in the list.
// push_front() – Adds a new element ‘g’ at the beginning of the list.
// push_back() – Adds a new element ‘g’ at the end of the list.
// pop_front() – Removes the first element of the list, and reduces the size of the list by 1.
// pop_back() – Removes the last element of the list, and reduces the size of the list by 1.
// insert() – Inserts new elements in the list before the element at a specified position.
// size() – Returns the number of elements in the list.
// begin() – begin() function returns an iterator pointing to the first element of the list.
// end() – end() function returns an iterator pointing to the theoretical last element which follows the last element.

DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList = list<int>();
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList = list<int>();
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    (*currentState) += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    (*currentState) -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the
     *       currentState Iterator, we delete them all before creating a new state.
     */
    logList.erase(next(currentState, 1), logList.end());
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState == logList.begin())
        return;
    currentState--;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    if (next(currentState, 1) == logList.end())
        return;
    currentState++;
}
",1.0,1111111111
Doubly_Linked_List_8,1454637,2213035,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode *reverse(ListNode *head, int l, int r)
{
    if (!head || !head->right || l == r)
        return head;

    ListNode *prev = nullptr;
    ListNode *current = nullptr;

    for (int i = 0; i < l; i += 1)
    {
        if (current == nullptr)
            current = head;
        else
        {
            prev = current;
            current = current->right;
        };
    }

    ListNode *start = current;
    for (int i = l; i < r; i += 1)
    {
        current = current->right;
    }
    ListNode *end = current;

    if (prev != nullptr)
    {
        prev->right = end;
    }
    else
    {
        // is head
        head = end;
    }
    if (end->right)
    {
        end->right->left = start;
    }
    prev = end->right;
    while (start != end)
    {
        ListNode *next = start->right;
        start->right = prev;
        start->left = next;
        prev = start;
        start = next;
    }
    start->right = prev;

    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1454638,2212372,"Deque::Deque() {
head = nullptr;
tail = nullptr;
curSize = 0;
}

Deque::~Deque() {
Node *temp = nullptr;
while (head) {
temp = head;
head = head->right;
delete temp;
}

head = tail = nullptr;
curSize = 0;
}

void Deque::clear() {
Node *temp = nullptr;
while (head) {
temp = head;
head = head->right;
delete temp;
}
head = tail = nullptr;
curSize = 0;
}

int Deque::getSize() {
return curSize;
}

void Deque::pushFront(int i) {
Node *newNode = new Node(i);
if (curSize==0) {
head = tail = newNode;
curSize++;
}
else {
newNode->right = head;
head->left = newNode;
head = newNode;
curSize++;
}

}

void Deque::pushBack(int i) {
Node *newNode = new Node(i);
if (curSize == 0) {
head = tail = newNode;
}
else {
tail->right = newNode;
newNode->left = tail;
tail = newNode;
}
curSize++;
}

int Deque::popFront() {
if (!head) return -1;
Node *temp = head;
int ans = temp->value;
head = head->right;
if (head) head->left = nullptr;
delete temp;
curSize--;
if (curSize == 0) {
    head = tail = nullptr;
}
return ans;
}

int Deque::popBack() {
if (!tail) return -1;
Node *temp = tail;
int ans = temp->value;
tail = tail->left;
if (tail) tail->right = nullptr;
curSize--;
if (curSize==0) {
    head = tail = nullptr;
}
return ans;
}

void Deque::printDequeReverse() {
Node *temp = tail;
int i=0;
while (i < curSize) {
cout << temp->value << "" "";
temp = temp->left;
i++;
}
cout << '\n';
}

void Deque::printDeque() {
Node *temp = head;
int i=0;
while (i<curSize) {
cout << temp->value << "" "";
temp = temp->right;
i++;
}
cout << '\n';
}",1.0,1111111111
Doubly_Linked_List_2,1454638,2212372,"template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* temp = new Node(e);
    if(head == NULL){
        head = tail = temp;
        count++;
    } else {
        tail->next = temp;
        temp->previous = tail;
        tail = temp;
        count++;
    }
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
     if (index < 0 || index > this->count)
    {
        throw std::out_of_range(""Out of range"");
    }


    if (index == 0)
    {
        Node* newNode = new Node(e);
        newNode->next = head;
        if (head != nullptr)
        {
            head->previous = newNode;
        }
        head = newNode;

        if (count == 0)
        {
            tail = newNode;
        }
    }
    else if (index == count)
    {   Node* newNode = new Node(e);
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    }
    else
    {Node* newNode = new Node(e);
        Node* temp = head;
        for (int i = 0; i < index - 1; i++)
        {
            temp = temp->next;
        }

        newNode->previous = temp;
        newNode->next = temp->next;

        if (temp->next != nullptr)
        {
            temp->next->previous = newNode;
        }

        temp->next = newNode;
    }

    this->count++;
}

template<class T>
int DLinkedList<T>::size() {
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1454638,2212372,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        return -1;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        return;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(head == nullptr) return true;
    return false;
    // return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while(temp != nullptr){
        if(temp->data == item) return i;
        i++;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1454638,2212372,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this->pList = pList;
    if (begin)
    {
        if (pList != NULL)
        {
            this->current = pList->head;
            index = 0;
        }
        else
        {
            this->current = nullptr;
            index = -1;
        }
    }   
    else
    {
        this->current = nullptr;
        if (pList != NULL)
        {
            index = pList->size();
        }
        else
        {
            index = 0;
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == NULL)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current->data = e;
    }
}

template <class T>
T &DLinkedList<T>::Iterator::operator*()
{
    if (current == NULL)
    {

        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        return current->data;
    }
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
     * TODO: delete Node in pList which Node* current point to.
     *       After that, Node* current point to the node before the node just deleted.
     *       If we remove first node of pList, Node* current point to nullptr.
     *       Then we use operator ++, Node* current will point to the head of pList.
     */
    if (current == nullptr)
    {
        return;
    }

    Node *nodeToRemove = current;
    current = current->previous;

    if (current != nullptr)
    {
        current->next = nodeToRemove->next;
    }
    else
    {
        pList->head = nodeToRemove->next;
    }

    if (nodeToRemove->next != nullptr)
    {
        nodeToRemove->next->previous = current;
    }
    else
    {
        pList->tail = current;
    }

    delete nodeToRemove;
    pList->count--;

    if (index > 0)
    {
        index--;
    }
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    if (this->pList == iterator.pList && this->current == iterator.current && this->index == iterator.index)
        return false;
    return true;
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator++()
{
    if (current == nullptr)
    {
        index = 0;
        current = this->pList->head;
        return *this;
    }
    current = current->next;
    index += 1;
    return *this;
}

template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    DLinkedList<T>::Iterator iterator = *this;
    ++*this;
    return iterator;
}
",1.0,1111111111
Doubly_Linked_List_5,1454638,2212372,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count) {
        return -1;
    }

    if (index == 0) {
        Node* removedNode = head;
        T removedValue = removedNode->data;
        head = head->next;
        if (head == nullptr) {
            tail = nullptr;
        }
        delete removedNode;
        count--;
        return removedValue;
    } else {
        Node* previous = head;
        for (int i = 0; i < index - 1; i++) {
            previous = previous->next;
        }

        Node* removedNode = previous->next;
        T removedValue = removedNode->data;
        previous->next = removedNode->next;
        if (removedNode == tail) {
            tail = previous;
        }
        delete removedNode;
        count--;
        return removedValue;
    }
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(contains(item) == true)
    return removeAt(indexOf(item))==item;
    return false;
    
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
        Node* current = head;
        head = head->next;
        delete current;
    }
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1454638,2212372,"DataLog::DataLog()
{
    logList = list<int>();
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    logList = list<int>();
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    (*currentState) += number;
}

void DataLog::subtractCurrentState(int number)
{
    (*currentState) -= number;
}

void DataLog::save()
{
    logList.erase(next(currentState, 1), logList.end());
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    if (currentState == logList.begin())
        return;
    currentState--;
}

void DataLog::redo()
{
    if (next(currentState, 1) == logList.end())
        return;
    currentState++;
}

",1.0,1111111111
Doubly_Linked_List_8,1454638,2212372,"ListNode *reverse(ListNode *head, int l, int r)
{
    if (!head || !head->right || l == r)
        return head;

    ListNode *prev = nullptr;
    ListNode *current = nullptr;

    for (int i = 0; i < l; i += 1)
    {
        if (current == nullptr)
            current = head;
        else
        {
            prev = current;
            current = current->right;
        };
    }

    ListNode *start = current;
    for (int i = l; i < r; i += 1)
    {
        current = current->right;
    }
    ListNode *end = current;

    if (prev != nullptr)
    {
        prev->right = end;
    }
    else
    {
        // is head
        head = end;
    }
    if (end->right)
    {
        end->right->left = start;
    }
    prev = end->right;
    while (start != end)
    {
        ListNode *next = start->right;
        start->right = prev;
        start->left = next;
        prev = start;
        start = next;
    }
    start->right = prev;

    return head;
}",1.0,1111111111
Doubly_Linked_List_2,1454648,2210458,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
        Node* newNode = new Node(e);
        if (tail == NULL) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            newNode->previous = tail;
            tail = newNode;
        }
        count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
        if (index < 0 || index > count) return;
        Node* newNode = new Node(e);
        if (index == 0) {
            if (head == NULL) {
                head = tail = newNode;
            } else {
                newNode->next = head;
                head->previous = newNode;
                head = newNode;
            }
        } else if (index == count) {
            tail->next = newNode;
            newNode->previous = tail;
            tail = newNode;
        } else {
            Node* cur = head;
            for (int i = 0; i < index - 1; i++) cur = cur->next;
            newNode->next = cur->next;
            newNode->previous = cur;
            cur->next->previous = newNode;
            cur->next = newNode;
        }
        count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454648,2210458,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
        if (index < 0 || index >= count) throw ""Index out of bounds"";
        Node* cur = head;
        for (int i = 0; i < index; i++) cur = cur->next;
        return cur->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
        if (index < 0 || index >= count) throw ""Index out of bounds"";
        Node* cur = head;
        for (int i = 0; i < index; i++) cur = cur->next;
        cur->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
        Node* cur = head;
        for (int i = 0; i < count; i++) {
            if (cur->data == item) return i;
            cur = cur->next;
        }
        return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1454648,2210458,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
            this->pList = pList;
            if (begin) {
                this->current = pList->head;
                this->index = 0;
            } else {
                this->current = NULL;
                this->index = pList->count;
            }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
            this->pList = iterator.pList;
            this->current = iterator.current;
            this->index = iterator.index;
            return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(current == nullptr) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
   if(current == nullptr) throw out_of_range(""Segmentation fault!"");
   return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if(this->current == nullptr) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    if(index == 0){

        this->pList->removeAt(index);
        this->index = -1;
        current = nullptr;
    }
    else{
        T e = this->pList->removeAt(index-1);
        this->index = index - 1;
        current->data = e;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return !(iterator.index == this->index);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if(current == nullptr){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    if(current == nullptr){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return *this;
}

",0.8,1111110101
Doubly_Linked_List_5,1454648,2210458,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
        if (index < 0 || index >= count) throw ""Index out of bounds"";
        Node* cur = head;
        for (int i = 0; i < index; i++) cur = cur->next;
        T removedData = cur->data;
        if (cur == head) {
            head = head->next;
            if (head != NULL) head->previous = NULL;
            else tail = NULL;
        } else if (cur == tail) {
            tail = tail->previous;
            tail->next = NULL;
        } else {
            cur->previous->next = cur->next;
            cur->next->previous = cur->previous;
        }
        delete cur;
        count--;
        return removedData;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
        Node* cur = head;
        while (cur != NULL && cur->data != item) cur = cur->next;
        if (cur == NULL) return false;
        if (cur == head) {
            head = head->next;
            if (head != NULL) head->previous = NULL;
            else tail = NULL;
        } else if (cur == tail) {
            tail = tail->previous;
            tail->next = NULL;
        } else {
            cur->previous->next = cur->next;
            cur->next->previous = cur->previous;
        }
        delete cur;
        count--;
        return true;
}

template<class T>
void DLinkedList<T>::clear(){
        while (head != NULL) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
        tail = NULL;
        count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1454648,2210458,"#include <iostream>
#include <list>
using namespace std;





DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_front(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
     
    
    //delete all element behind currentState 
    currentState++;
    list<int>::iterator curr = currentState;
    list<int>::iterator next = curr;
    while(next != logList.end()) {
        next++;
        logList.erase(curr);
        curr = next;
    }
    currentState = logList.end();
    currentState--;
    
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState == logList.begin()) return;
    currentState--;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    currentState++;
    if(currentState == logList.end()) currentState--; 
    
}
",1.0,1111111111
Doubly_Linked_List_8,1454648,2210458,"#include <iostream>
#include <unordered_map>
using namespace std;

/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int l, int r) {
    //To Do
    unordered_map<int, ListNode*> um;
    ListNode* curr = head;
    int pos = 1;
    //store first part leftside from left
    for(;pos < l; pos++) um[pos] = curr, curr = curr->right;
    pos = r+1;
    //store with reversed order from l->r 
    for(; r >= l; r--) um[r] = curr, curr = curr->right;
    //store the rest part
    while(curr != nullptr) {
        um[pos++] = curr;
        curr = curr->right;
    }
    //pos++ so pos is out 1 index
    pos--;
    head = um[1];
    head->left = nullptr;
    curr = head;
    for(int i = 2; i <= pos; i++) {
        curr->right = um[i];
        um[i]->left = curr;
        curr = um[i];
    }
    curr->right = nullptr;
    return head;
}",1.0,1111111111
Doubly_Linked_List_2,1454667,2213250,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *temp = new Node(e);
    if(count == 0)
    {
        head = temp;
        tail = temp;
    }
    else{
        tail -> next = temp;
        temp -> previous = tail;
        tail = temp;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index> count || index <0) throw out_of_range("" "");
    if( index == count) {
        add(e); 
    }
    else if (index == 0){
        Node* temp = new Node(e);
        temp-> next = head;
        head-> previous = temp;
        head = temp;
        count++;
    }
    else{
        Node *p = new Node(e);
        Node*run = head;
        for(int i=0;i<index-1;i++) run = run->next;
        Node*temp = run->next;
        run->next =p;
        p->previous = run;
        temp->previous = p;
        p->next = temp;
        count++;
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454667,2213250,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index > count || index <0) throw out_of_range("" "");
    Node* run = head;
    for(int i = 0; i< index; i++){
        run= run->next;
    }
    return run->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
        if(index > count || index <0) throw out_of_range("" "");
        Node* run = head;
    for(int i = 0; i< index; i++){
        run= run->next;
    }
    run-> data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return head == NULL;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    if(head != NULL){
        Node* run = head;
    for(int i = 0; i< count; i++){
        if(run-> data == item) return i;
        run= run->next;
    }
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if (head != NULL){
    Node* run = head;
    for(int i = 0; i< count; i++){
        if(run-> data == item) return true;
        run= run->next;
    }
    }
    return false;
}",0.95,1111111111
Doubly_Linked_List_4,1454667,2213250,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
this->pList = pList ;
    if(begin){
        if(pList!=NULL){
            current = pList->head;
            index = 0 ;
        }
        else{
            current = nullptr;
            index = - 1;
        }
    }
    else{
        current = NULL ;
        if(pList!=NULL) index = pList->size();
        else index = 0 ;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->pList = iterator.pList;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(current==NULL) throw std::out_of_range(""Segmentation fault!"");
    current->data = e ;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if(current==NULL) throw std::out_of_range(""Segmentation fault!"");
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if(current==NULL) throw std::out_of_range(""Segmentation fault!"");
    if(current==pList->head){
        current = nullptr;
        index=-1;
        pList->removeAt(0);
        return;
    }
    current = current->next;
    pList->removeAt(index);
    
    
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (this->current!=iterator.current);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if(current==NULL && index!=-1){
        current = pList->head;
        index = 0 ;
        return (*this);
    }
    if(current==NULL && index==-1){current=pList->head;index=0;}
    else{
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}

",1.0,1111111111
Doubly_Linked_List_5,1454667,2213250,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(index<0 || index >=count) throw std::out_of_range(""invalid"");
    if(index==0){
        T val = head->data;
        head = head->next;
        if(head) head->previous = nullptr;
        else tail = nullptr;
        count--;
        return val;
    }
    else{
        T val ;
        Node* prev = nullptr ; 
        Node* curr = head ;
        while(index--){
            prev = curr ;
            curr=curr->next;
        }
        val = curr->data;
        prev->next = curr->next;
        if(curr->next==nullptr) tail = prev;
        else curr->next->previous = prev;
        count--;
        return val;
    }
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* run = head ;
    int index = 0 ;
    while(run){
        if(run->data == item ){
            removeAt(index);
            return true;
        }
        run = run->next;
        index++;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while(head){
        removeAt(0);
    }
}
",1.0,1111111111
Doubly_Linked_List_6,1454667,2213250,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
     logList.push_back(0);
     currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
     logList.push_back(data);
     currentState = logList.begin();
     
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
     *currentState +=number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
     *currentState-=number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
     list<int>::iterator it  = currentState;
     it++;
     int count = 0 ;
     while(it!=logList.end()){
         count++;
         it++;
     }
     for(int i=0 ; i< count;i++){
         logList.pop_back();
     }
     logList.push_back(*currentState);
     currentState++;
     //this->printLog();
     
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if(currentState==logList.begin()) return;
     currentState--;
     
}
void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     auto it = logList.end();
     it--;
     if(currentState==it) return ;
     else currentState++;
}
",1.0,1111111111
Doubly_Linked_List_8,1454667,2213250,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    --a;
    --b;
    //cout<<a<<"" ""<<b<<endl;
    ListNode* dummy1 = new ListNode(0,nullptr,head);
    if(head->left==nullptr) head->left = dummy1;
    ListNode* tail = head;
    while(tail->right){
        tail=tail->right;
    }
    //cout<<tail->val<<endl;
    ListNode* dummy2 = new ListNode(0,tail,nullptr);
    tail->right = dummy2;
    tail = tail->right;
    ListNode* run1 = head;
    for(int i=0 ; i < a ; i++){
        //cout<<run1->val<<endl;
        run1 = run1->right;
    }
    //cout<<run1->val<<endl;
    ListNode* run2 = head;
    for(int i = 0  ; i < b ; i++){
        run2 = run2->right;
    }
    //cout<<run2->val<<endl;
    head = head->left;
    /*ListNode* temp = head;
    while(temp){
        cout<<temp->val<<endl;
        temp=temp->right;
    }*/
    while(a<b){
        ListNode* X = run1;
        ListNode* Xnext = X->right;
        ListNode* Xpre = X->left;
        //cout<<Xpre->val<<endl;
        //cout<<X->val<<endl;
        
        ListNode* Y = run2;
        ListNode* Ynext = Y->right;
        ListNode* Ypre = Y->left;
        
        if(Xnext == Y){
            Y->right = X;
            Y->left = Xpre;
            Xpre->right = Y;
            X->left = Y ;
            X->right = Ynext;
            Ynext->left = X;
        }
        else{
        Ynext->left = X ;
        Ypre->right =X;
        X->left = Ypre;
        X->right = Ynext;
        
        Xnext->left = Y ;
        Xpre->right = Y;
        Y->left = Xpre;
        Y->right = Xnext;
        }
        
        
        run1 = Y;
        run2 = X;
        run1 = run1->right;
        run2 = run2->left;
        a++;
        b--;
    }
    //ListNode* temp = head;
    //cout<<""true""<<endl;
    head = head->right;
    head->left = nullptr;
    tail = tail->left;
    dummy2->left = nullptr;
    tail->right = nullptr;
    return head;
    
}",1.0,1111111111
Doubly_Linked_List_1,1454681,2110501,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head != nullptr) {
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    tail = nullptr;
    curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
    if (head != nullptr)
        head->left = newNode;
    head = newNode;

    if (tail == nullptr)
        tail = head;

    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i, tail, nullptr);
    if (tail != nullptr)
        tail->right = newNode;
    tail = newNode;

    if (head == nullptr)
        head = tail;

    curSize++;
}

int Deque::popFront() {
    if (head == nullptr)
        return -1;

    Node* temp = head;
    int value = temp->value;
    head = head->right;

    if (head != nullptr)
        head->left = nullptr;
    else
        tail = nullptr;

    delete temp;
    curSize--;

    return value;
}

int Deque::popBack() {
    if (tail == nullptr)
        return -1;

    Node* temp = tail;
    int value = temp->value;
    tail = tail->left;

    if (tail != nullptr)
        tail->right = nullptr;
    else
        head = nullptr;

    delete temp;
    curSize--;

    return value;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1454681,2110501,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *pNew= new Node(e);
    if(count==0)
    {
        head=pNew;
        tail=pNew;
        count++;
    }
    else
    {
        tail->next=pNew;
        pNew->previous=tail;
        tail=pNew;
        count++;
    }
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    Node *pNew= new Node(e);
    if(count==0)
    {
        head=pNew;
        tail=pNew;
        count++;
    }
    else
    {
        if(index<0||index>count);
        else if(index==count)
        {
            tail->next=pNew;
            pNew->previous=tail;
            tail=pNew;
            count++;
        }
        else if(index==0)
        {
            pNew->next=head;
            head->previous=pNew;
            head=pNew;
            count++;
        }
        else
        {
            Node*post;
            Node*cur=head;
            for(int i=0;i<index-1;i++)
            {
                cur=cur->next;
            }
            post=cur->next;
            cur->next=pNew;
            pNew->previous=cur;
            pNew->next=post;
            post->previous=pNew;
            count++;
        }
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
     return count;
}",1.0,1111111111
Doubly_Linked_List_3,1454681,2110501,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index>count||index<0)    throw std::out_of_range(""Segmentation fault!"");
    else
    {
    Node*tmp=head;
    for(int i=0;i<=index-1;i++)
    {
        tmp=tmp->next;
    }
    return tmp->data;
    }
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index>count||index<0)    throw std::out_of_range(""Segmentation fault!"");
    else
    {
    Node*tmp=head;
    for(int i=0;i<=index-1;i++)
    {
        tmp=tmp->next;
    }
    tmp->data=e;
    }
    
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(this->count==0)    return true;
    else            return false;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* cur = this->head;
    for (int i = 0 ; i < count ; i++)
    {
        if (cur->data == item) return i; 
        else cur = cur->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node*cur=head;
    while(cur!=tail)
    {
        if(cur->data==item) return true;
        cur=cur->next;
    }
    if(tail->data==item)  return true;
    return false;
}",1.0,1111111111
Doubly_Linked_List_4,1454681,2110501,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList=pList;
    if(begin==true)
    {
        if(this->pList!=NULL)
        {
            this->index=0;
            this->current=this->pList->head;
        }
        else
        {
            this->index=-1;
            this->current=NULL;
        }
    }
    else
    {
        this->current=NULL;
        if(this->pList!=NULL)   this->index=this->pList->count;
        else                    this->index=0;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current=iterator.current;
    this->index=iterator.index;
    this->pList=iterator.pList;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    this->current->data=e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    return this->current->data;  
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->index == 0) 
    {
        this->current = NULL;
    }
    else if (this->index == pList->count) 
    {
        this->current = pList->tail;
    }
    else 
    {
        this->current = this->current->previous;
    }
    pList->removeAt(index--);
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return !((this->current == iterator.current) && (this->index == iterator.index));
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (index == -1) 
    {
        this->current = pList->head;
    }
    else 
    {
       this->current = this->current->next;
    }
    index++;
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator tmp=*this;
    ++*this;
    return tmp;
}

",1.0,1111111111
Doubly_Linked_List_5,1454681,2110501,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index > this->count) throw std::out_of_range("""");
    else
    {
        int data;
        if (index == 0) 
        {
            data = this->head->data;
            Node* p = this->head;
            this->head = this->head->next;
            if (this->head!=NULL)   this->head->previous = NULL;
            delete p;
        }
        else if (index == count - 1) 
        {
            data = this->tail->data;
            Node*p = this->tail;
            this->tail = this->tail->previous;
            if (this->tail!=NULL)   this->tail->next = NULL;
            delete p;
        }
        else 
        {
            Node* cur=this->head;
            for(int i=0;i<index;i++)
            {
                cur=cur->next;
            }
            data = cur->data;
            Node* pre = cur->previous;
            Node* post = cur->next;
            pre->next = cur->next;
            pre->next = post;
            post->previous=cur->previous;
            post->previous=pre;
            delete cur;
        }
        this->tail = this->head;
        while (this->tail && this->tail->next) 
        {
            this->tail = this->tail->next;
        }
        count--;
        return data;
    }
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    
    Node* cur = this->head;
    while(cur != NULL) 
    {
        if(cur->data == item) break;
        cur = cur->next;
    }
    if(cur!=NULL)
    {
        if(cur == this->head) 
        {
            Node* p = this->head;
            this->head = this->head->next;
            if(this->head!=NULL)    this->head->previous = NULL;
            delete p;
        }
        else if(cur == this->tail) 
        {
            Node* p = this->tail;
            this->tail = this->tail->previous;
            if(this->tail!=NULL) this->tail->next = NULL;
            delete p;
        }
        else 
        {
            Node* pre=cur->previous;
            Node* post=cur->next;
            pre->next=cur->next;
            pre->next = post;
            post->previous=cur->previous;
            post->previous = pre;
            delete cur;
        }
        this->tail = this->head;
        while (this->tail!=NULL && this->tail->next!=NULL) 
        {
            this->tail = this->tail->next;
        }
        this->count--;
        return 1;
    }
    else return 0;
}

template<class T>
void DLinkedList<T>::clear()
{
    /* Remove all elements in list */
    Node* cur = this->head;
    while (this->head != NULL) 
    {
        this->head =this->head->next;
        delete cur;
        cur=this->head;
    }
    this->tail = NULL;
    this->count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1454681,2110501,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
     *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
     *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    while ((++currentState)-- != logList.end()) 
    {
        logList.pop_back();
    }
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState != logList.begin()) 
    {
        currentState--;
    }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     while ((++currentState)-- != logList.end()) 
     {
        currentState++;
     }
}
",1.0,1111111111
Doubly_Linked_List_8,1454681,2110501,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/
ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    ListNode* result = head;
    ListNode* start = head;
    for (int i = 1; i < a; i++) 
    {
        start = start->right;
    }
    ListNode* end = head;
    for (int i = 1; i < b; i++) 
    {
        end = end->right;
    }
    ListNode* prestart=NULL;
    if(start->left) 
    {
        prestart = start->left; 
        prestart->right = NULL;
    }
    start->left = NULL;
    ListNode* postend=NULL;
    if(end->right) 
    {
        postend = end->right; 
        postend->left = NULL;
    }
    end->right = NULL;
    ListNode* reverseNode = start;
    while(start != NULL) 
    {
        ListNode* temp = start->left;
        start->left = start->right;
        start->right = temp;
        reverseNode = start;
        start = start->left;
    }
    end = reverseNode;
    while(end->right) end = end->right;
    if(prestart!=NULL) 
    {
        prestart->right = reverseNode;
        reverseNode->left = prestart;
    }
    if(postend!=NULL) 
    {
        postend->left = end;
        end->right = postend;
    }
    result = end;
    while(result->left) result = result->left;
    return result;
}",1.0,1111111111
Doubly_Linked_List_1,1456690,2210055,"Deque::Deque()
{
    this->head = nullptr;
    this->tail = nullptr;
    this->curSize = 0;
}

Deque::~Deque()
{
    this->clear();
}

void Deque::clear()
{
    // erase all items in the deque
    Node *temp = this->head;
    while (temp != nullptr)
    {
        Node *next = temp->right;
        delete temp;
        temp = next;
    }
    this->head = nullptr;
    this->tail = nullptr;
    this->curSize = 0;
}

int Deque::getSize()
{
    return this->curSize;
}

void Deque::pushFront(int i)
{
    Node *temp = new Node(i);
    if (curSize == 0)
    {
        head = temp;
        tail = temp;
        curSize++;
        return;
    }
    curSize++;
    temp->right = head;
    head->left = temp;
    head = temp;
}

void Deque::pushBack(int i)
{
    Node *temp = new Node(i);
    if (curSize == 0)
    {
        head = temp;
        tail = temp;
        curSize++;
        return;
    }
    curSize++;
    tail->right = temp;
    temp->left = tail;
    tail = temp;
}

int Deque::popFront()
{
    if (curSize == 0)
        return -1;
    Node *temp = head;
    head = temp->right;
    head->left = nullptr;
    int result = temp->value;
    delete temp;
    curSize--;
    return result;
}

int Deque::popBack()
{
    if (curSize == 0)
        return -1;
    Node *temp = tail;
    tail = temp->left;
    tail->right = nullptr;
    int result = temp->value;
    delete temp;
    curSize--;
    return result;
}

void Deque::printDequeReverse()
{
    Node *temp = tail;
    while (temp != nullptr)
    {
        if (temp == head)
        {
            cout << temp->value << "" "" << endl;
        }
        else
            cout << temp->value << "" "";
        temp = temp->left;
    }
}

void Deque::printDeque()
{
    Node *temp = head;
    while (temp != nullptr)
    {
        if (temp == tail)
        {
            cout << temp->value << "" "" << endl;
        }
        else
            cout << temp->value << "" "";
        temp = temp->right;
    }
}",0.4,11110
Doubly_Linked_List_2,1456690,2210055,"template <class T>
void DLinkedList<T>::add(const T &e)
{
    Node* newNode = new Node(e);
    if (head == nullptr)
    {
        head = newNode;
        tail = newNode;
    }
    else
    {
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template <class T>
void DLinkedList<T>::add(int index, const T &e)
{
    if (index < 0 || index > count)
    {
        throw std::out_of_range(""Index out of range"");
    }

    Node* newNode = new Node(e);
    if (index == 0)
    {
        // Insert at the beginning
        if (head == nullptr)
        {
            head = newNode;
            tail = newNode;
        }
        else
        {
            newNode->next = head;
            head->previous = newNode;
            head = newNode;
        }
    }
    else if (index == count)
    {
        // Insert at the end
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    }
    else
    {
        // Insert in the middle
        Node* current = head;
        for (int i = 0; i < index - 1; i++)
        {
            current = current->next;
        }
        newNode->next = current->next;
        newNode->previous = current;
        current->next = newNode;
        newNode->next->previous = newNode;
    }
    count++;
}

template <class T>
int DLinkedList<T>::size()
{
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1456690,2210055,"template <class T>
T DLinkedList<T>::get(int index) {
  if (index < 0 || index >= count) {
    throw std::out_of_range(""Index out of bounds"");
  }

  Node* current = head;
  for (int i = 0; i < index; i++) {
    current = current->next;
  }

  return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
  if (index < 0 || index >= count) {
    throw std::out_of_range(""Index out of bounds"");
  }

  Node* current = head;
  for (int i = 0; i < index; i++) {
    current = current->next;
  }

  current->data = e;
}

template <class T>
bool DLinkedList<T>::empty() {
  return count == 0;
}

template <class T>
int DLinkedList<T>::indexOf(const T& item) {
  Node* current = head;
  int index = 0;
  while (current != nullptr) {
    if (current->data == item) {
      return index;
    }
    current = current->next;
    index++;
  }

  return -1;
}

template <class T>
bool DLinkedList<T>::contains(const T& item) {
  return indexOf(item) != -1;
}
",1.0,1111111111
Doubly_Linked_List_5,1456690,2210055,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
     if (index < 0 || index >= count)
        {
            throw std::out_of_range(""Index out of bounds"");
        }

        Node* currentNode = head;
        T removedElement = currentNode->data;

        if (index == 0)
        {
            head = currentNode->next;
        }
        else
        {
            for (int i = 0; i < index - 1; i++)
            {
                currentNode = currentNode->next;
            }

            Node* previousNode = currentNode->previous;
            previousNode->next = currentNode->next;
        }

        delete currentNode;
        count--;

        return removedElement;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* currentNode = head;

        while (currentNode != nullptr)
        {
            if (currentNode->data == item)
            {
                break;
            }

            currentNode = currentNode->next;
        }

        if (currentNode == nullptr)
        {
            return false;
        }

        if (currentNode == head)
        {
            head = currentNode->next;
        }
        else
        {
            Node* previousNode = currentNode->previous;
            previousNode->next = currentNode->next;
        }

        delete currentNode;
        count--;

        return true; 
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    
        Node* currentNode = head;

        while (currentNode != nullptr)
        {
            Node* nextNode = currentNode->next;
            delete currentNode;
            currentNode = nextNode;
        }

        head = nullptr;
        count = 0;
}
",0.1,100
Doubly_Linked_List_8,1456690,2210055,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
     if (head == nullptr || a == b) {
        return head;
    }

    // Create dummy nodes to simplify edge cases.
    ListNode dummy(0);
    dummy.right = head;
    head->left = &dummy;
    
    // Find the node before position a.
    ListNode *prev_a = &dummy;
    for (int i = 1; i < a; i++) {
        prev_a = prev_a->right;
    }

    // Find the node at position b.
    ListNode *node_b = head;
    for (int i = 1; i <= b; i++) {
        node_b = node_b->right;
    }
    
    // Reverse the subsequence between a and b.
    ListNode *current = prev_a->right;
    ListNode *prev = node_b;

    while (current != node_b) {
        ListNode *next = current->right;
        current->right = prev;
        current->left = next;
        prev = current;
        current = next;
    }

    // Update the links of the surrounding nodes.
    prev_a->right->left = prev_a;
    prev_a->right = prev;
    
    // Return the updated head (if a == 1) or the original head.
    return (a == 1) ? prev_a->right : head;
}",0.9,1011111111
Doubly_Linked_List_1,1489733,2213298,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head->right) {
        head = head->right;
        delete head->left;
    }
    curSize = 0;
    delete head;
    head = tail = nullptr;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node *p0 = new Node(i);
    if (!curSize) head = tail = p0;
    else {
        p0->right = head;
        head->left = p0;
        head = p0;
    }
    curSize++;
}

void Deque::pushBack(int i) {
    Node *p0 = new Node(i);
    if (!curSize) head = tail = p0;
    else {
       tail->right = p0;
       p0->left = tail;
       tail = p0;
    }
    curSize++;
}

int Deque::popFront() {
    if (!curSize) return -1;
    if (curSize == 1) {
        int temp = head->value;
        clear();
        return temp;
    }
    int temp = head->value;
    head = head->right;
    delete head->left;
    head->left = nullptr;
    curSize--;
    return temp;
}

int Deque::popBack() {
    if (!curSize) return -1;
    if (curSize == 1) {
        int temp = head->value;
        clear();
        return temp;
    }
    int temp = tail->value;
    tail = tail->left;
    delete tail->right;
    tail->right = nullptr;
    curSize--;
    return temp;
}

void Deque::printDequeReverse() {
    if (!curSize) return;
    for (int i = 0; i < curSize; i++) {
        int temp = popBack();
        cout << temp << "" "";
        //if (i != curSize - 1) cout << "" "";
        pushFront(temp);
    }
    cout << '\n';
}

void Deque::printDeque() {
    if (!curSize) return;
    for (int i = 0; i < curSize; i++) {
        int temp = popFront();
        cout << temp << "" "";
        //if (i != curSize - 1) cout << "" "";
        pushBack(temp);
    }
    cout << '\n';
}",0.4,11110
Doubly_Linked_List_2,1489733,2213298,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *pNew = new Node(e);
    if (!head) head = tail = pNew;
    else {
        tail->next = pNew;
        pNew->previous = tail;
        tail = pNew;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index > count || index < 0) throw std::out_of_range(""Out of range""); 
    if (index == count) { add(e); return; }
    Node *pNew = new Node(e);
    if (!index) {
        pNew->next = head;
        head->previous = pNew;
        head = pNew;
        count++;
        return;
    }
    Node *p0 = this->head;
    for (; index > 1; index--) p0 = p0->next;
    pNew->next = p0->next;
    p0->next->previous = pNew;
    p0->next = pNew;
    pNew->previous = p0;
    count++;
    return;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    if (head) return count;
    return 0;
}",1.0,1111111111
Doubly_Linked_List_3,1489733,2213298,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    return pNew->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    pNew->data = e;
    return;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !(head);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for (Node *p0 = head; p0; p0 = p0->next)
    {
        if (p0->data == item) return index;
        index++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for (Node *p0 = head; p0; p0 = p0->next) if (p0->data == item) return 1;
    return 0;
}",1.0,1111111111
Doubly_Linked_List_4,1489733,2213298,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if (begin){
        if (pList){
            current = pList->head;
            index = 0;
        }
        else {
            current = NULL;
            index = -1;
        }
    }
    else {
        current = NULL;
        if (pList){
            index = pList->count;
        }
        else index = 0;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;   
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (!current) throw std::out_of_range(""Segmentation fault!"");
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (!current) throw std::out_of_range(""Segmentation fault!"");
    return current->data;
}

bool removed = 0;

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (!current) throw std::out_of_range(""Segmentation fault!"");
    if (current == pList->head){
        pList->head = pList->head->next;
        if (pList->count != 1) pList->head->previous = nullptr;
        delete current;
        //current = NULL;
        index = -1;
        current = pList->head;
    }
    else {
        Node* pPre = pList->head;
        while (pPre->next != current){
            pPre = pPre->next;
        }
        pPre->next = current->next;
        if (current == pList->tail) {
            pList->tail = pPre;
            pPre->next = nullptr;
        }
        else current->next->previous = pPre;
        delete current;
        current = pPre;
        index--;
        
    }
    pList->count--;
    removed = 1;
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return !(this->current == iterator.current || this->index == iterator.index);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (!current && index == pList->count) throw std::out_of_range(""Segmentation fault!"");
    if (current != pList->head) current = current->next;
    else if (current == pList->head && !removed) current = current->next;
    index++;
    removed = 0;
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    if (!current && index == pList->count) throw std::out_of_range(""Segmentation fault!"");
    if (current != pList->head) current = current->next;
    else if (current == pList->head && !removed) current = current->next;
    index++;
    removed = 0;
    return *this;
}

",0.1,10
Doubly_Linked_List_5,1489733,2213298,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index >= this->count || index < 0) throw std::out_of_range(""Out of range"");
    if (count == 1) {                 
        Node *pNew = head;
        count = 0;
        T temp = pNew->data;
        delete pNew;
        head = tail = NULL;
        return temp;
    }
    if (!index) {
        Node *pNew = head;
        head = pNew->next;
        head->previous = nullptr;
        T temp = pNew->data;
        delete pNew;
        count--;
        if (!count) head = tail = nullptr;
        return temp;
    }
    Node *pNew = head;
    for (int i = index; i > 1; i--) pNew = pNew->next;
    Node *pDel = pNew->next;
    T temp = pDel->data;
    pNew->next = pDel->next;
    if (index == count - 1) { tail = pNew; tail->next = nullptr; }
    else pDel->next->previous = pNew;
    delete pDel;
    count--;
    return temp;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *h = head;
    for (int i = 0; i < count; i++) {
        if (h->data == item) {
            removeAt(i);
            return true;
        }
        h = h->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    for (Node *p0 = head; p0;) {
        Node *p1 = p0;
        p0 = p0->next;
        delete p1;
    } 
    head = tail = nullptr;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1489733,2213298,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    currentState = logList.end();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    if (currentState != logList.end()) *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    if (currentState != logList.end()) *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    int currentStateData = *currentState;
    if (currentState != logList.end()) {
        logList.erase(++currentState, logList.end());
    }
    logList.push_back(currentStateData);
    currentState = --logList.end();
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState != logList.begin()) currentState--;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    auto next = currentState;
    ++next;
    if (next != logList.end()) {
        ++currentState;
    }
}
",0.9,1111111111
Doubly_Linked_List_8,1489733,2213298,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/
void swapNode(ListNode* pNew, ListNode* pDel) {
    ListNode* rac1 = pNew->left;
    ListNode* rac2 = pNew->right;
    ListNode* rac3 = pDel->left;
    ListNode* rac4 = pDel->right;

    if (pNew->left) pNew->left->right = pDel;
    if (pNew->right) pNew->right->left = pDel;
    if (pDel->left) pDel->left->right = pNew;
    if (pDel->right) pDel->right->left = pNew;

    pNew->left = rac3;
    pNew->right = rac4;
    pDel->left = rac1;
    pDel->right = rac2;

    if (pNew == rac4) {
        pDel->right = pNew;
        pNew->left = pDel;
    }
    if (pDel == rac2) {
        pNew->right = pDel;
        pDel->left = pNew;
    }
}

ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    ListNode *pBegin = head;
    ListNode *pEnd = head;
    for (;a > 1; a--) pBegin = pBegin->right;
    for (;b > 1; b--) pEnd = pEnd->right;
    while (pBegin != pEnd && pBegin->left != pEnd) {
        swapNode(pBegin, pEnd);
        if (pBegin->left) {
            pBegin = pBegin->left;
        }
        if (pEnd->right) {
            pEnd = pEnd->right;
        }
    }
    while (head->left) {
        head = head->left;
    }
    return head;
}
",0.2,110
Doubly_Linked_List_1,1490274, ,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    if (!curSize) return;
    if (curSize != 1) {
        while (head->right) {
            head = head->right;
            delete head->left;
        }   
    }
    curSize = 0;
    delete head;
    head = tail = nullptr;
}

int Deque::getSize() {
    if (head) return curSize;
    return 0;
}

void Deque::pushFront(int i) {
    Node *p0 = new Node(i);
    if (!curSize) head = tail = p0;
    else {
        p0->right = head;
        head->left = p0;
        head = p0;
    }
    curSize++;
}

void Deque::pushBack(int i) {
    Node *p0 = new Node(i);
    if (!curSize) head = tail = p0;
    else {
       tail->right = p0;
       p0->left = tail;
       tail = p0;
    }
    curSize++;
}

int Deque::popFront() {
    if (!curSize) return -1;
    if (curSize == 1) {
        int temp = head->value;
        clear();
        return temp;
    }
    int temp = head->value;
    head = head->right;
    delete head->left;
    head->left = nullptr;
    curSize--;
    return temp;
}

int Deque::popBack() {
    if (!curSize) return -1;
    if (curSize == 1) {
        int temp = head->value;
        clear();
        return temp;
    }
    int temp = tail->value;
    tail = tail->left;
    delete tail->right;
    tail->right = nullptr;
    curSize--;
    return temp;
}

void Deque::printDequeReverse() {
    if (!curSize) return;
    for (int i = 0; i < curSize; i++) {
        int temp = popBack();
        cout << temp << "" "";
        //if (i != curSize - 1) cout << "" "";
        pushFront(temp);
    }
    cout << '\n';
}

void Deque::printDeque() {
    if (!curSize) return;
    for (int i = 0; i < curSize; i++) {
        int temp = popFront();
        cout << temp << "" "";
        //if (i != curSize - 1) cout << "" "";
        pushBack(temp);
    }
    cout << '\n';
}
",1.0,1111111111
Doubly_Linked_List_2,1490274, ,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *pNew = new Node(e);
    if (!head) head = tail = pNew;
    else {
        tail->next = pNew;
        pNew->previous = tail;
        tail = pNew;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index > count || index < 0) throw std::out_of_range(""Out of range""); 
    if (index == count) { add(e); return; }
    Node *pNew = new Node(e);
    if (!index) {
        pNew->next = head;
        head->previous = pNew;
        head = pNew;
        count++;
        return;
    }
    Node *p0 = this->head;
    for (; index > 1; index--) p0 = p0->next;
    pNew->next = p0->next;
    p0->next->previous = pNew;
    p0->next = pNew;
    pNew->previous = p0;
    count++;
    return;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    if (head) return count;
    return 0;
}",1.0,1111111111
Doubly_Linked_List_3,1490274, ,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    return pNew->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index >= count || index < 0) throw std::out_of_range(""Out of range"");
    Node *pNew = head;
    for (; index; index--) pNew = pNew->next;
    pNew->data = e;
    return;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !(head);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    for (Node *p0 = head; p0; p0 = p0->next)
    {
        if (p0->data == item) return index;
        index++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    for (Node *p0 = head; p0; p0 = p0->next) if (p0->data == item) return 1;
    return 0;
}",1.0,1111111111
Doubly_Linked_List_4,1490274, ,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if(begin == true){
        if(pList != nullptr){
            current = pList->head;
            index = 0;
        }else{
            current = nullptr;
            index = -1;
        }
    }else{
        current = nullptr;
        if(pList != nullptr){
            index = pList->count;
        }else{
            index = 0;
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (index == 0)
    {
        pList -> removeAt(0);
        current = NULL;
        return;
    }
    current = current -> previous;
    pList -> removeAt(index);
    index--;
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return !((this->current == iterator.current) && (this->pList == iterator.pList) && (this->index == iterator.index));
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (current == NULL)
    {
        current = pList -> head;
        index = 0;
    }
    else
    {
        current = current -> next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,1111111111
Doubly_Linked_List_5,1490274, ,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index >= this->count || index < 0) throw std::out_of_range(""Out of range"");
    if (count == 1) {                 
        Node *pNew = head;
        count = 0;
        T temp = pNew->data;
        delete pNew;
        head = tail = NULL;
        return temp;
    }
    if (!index) {
        Node *pNew = head;
        head = pNew->next;
        head->previous = nullptr;
        T temp = pNew->data;
        delete pNew;
        count--;
        if (!count) head = tail = nullptr;
        return temp;
    }
    Node *pNew = head;
    for (int i = index; i > 1; i--) pNew = pNew->next;
    Node *pDel = pNew->next;
    T temp = pDel->data;
    pNew->next = pDel->next;
    if (index == count - 1) { tail = pNew; tail->next = nullptr; }
    else pDel->next->previous = pNew;
    delete pDel;
    count--;
    return temp;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *h = head;
    for (int i = 0; i < count; i++) {
        if (h->data == item) {
            removeAt(i);
            return true;
        }
        h = h->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    for (Node *p0 = head; p0;) {
        Node *p1 = p0;
        p0 = p0->next;
        delete p1;
    } 
    head = tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1490274, ,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    currentState = logList.end();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    if (currentState != logList.end()) *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    if (currentState != logList.end()) *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    int currentStateData = *currentState;
    if (currentState != logList.end()) {
        logList.erase(++currentState, logList.end());
    }
    logList.push_back(currentStateData);
    currentState = --logList.end();
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState != logList.begin()) currentState--;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    auto next = currentState;
    ++next;
    if (next != logList.end()) {
        ++currentState;
    }
}",1.0,1111111111
Doubly_Linked_List_8,1490274, ,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode l = nullptr, ListNode r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    if (a >= b) return head;
    ListNode* trav1 = head;
    ListNode* trav2 = head;
    for (int i = 1; i < a; i++){
        trav1 = trav1->right;
    }
    for (int i = 1; i < b; i++){
        trav2 = trav2->right;
    }
    if (a == 1){
        head = trav2;
        ListNode* trav = trav2->left;
        while (trav){
            ListNode* temp = trav->left;
            trav->right = trav2->right;
            trav->left = trav2;
            trav2->right = trav;
            trav2 = trav;
            trav = temp;
        }
    }
    else {
        ListNode* prev1 = trav1->left;
        prev1->right = trav2;
        ListNode* trav = trav2->left;
        while (trav != prev1){
            ListNode* temp = trav->left;
            trav->right = trav2->right;
            trav->left = trav2;
            trav2->right = trav;
            trav2 = trav;
            trav = temp;
        }
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1491534,2210997,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
}

void Deque::clear() {
    while(head != nullptr){
        popBack();
    }
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if (head == nullptr){
        Node* newNode = new Node(i,nullptr,nullptr);
        head = newNode;
        tail = newNode;
    } else {
        Node* newNode = new Node(i,nullptr,head);
        head->left = newNode;
        head = newNode;
    }
    curSize += 1;
}

void Deque::pushBack(int i) {
    if (head == nullptr){
        Node* newNode = new Node(i,nullptr,nullptr);
        head = newNode;
        tail = newNode;
    } else {
        Node* newNode = new Node(i,tail,nullptr);
        tail->right = newNode;
        tail = newNode;
    }
    curSize += 1;
}

int Deque::popFront() {
    if (head == nullptr)
        return -1;

    int ans = head->value;
    Node* newHead = head->right;
    if (newHead != nullptr){
        newHead->left = nullptr;
        delete head;
        head = newHead;       
    } else {
        delete head;
        head = nullptr;
        tail = nullptr;
    }
    curSize -= 1;
    return ans; 
}

int Deque::popBack() {
    if (head == nullptr)
        return -1;

    int ans = tail->value;
    Node* newTail = tail->left;
    if (newTail != nullptr){
        newTail->right = nullptr;
        delete tail;
        tail = newTail;       
    } else {
        delete tail;
        head = nullptr;
        tail = nullptr;
    }
    curSize -= 1;
    return ans;
}

void Deque::printDequeReverse() {
   Node*temp=tail;
   while(temp!=nullptr){
        cout<<temp->value<<"" "";
       temp=temp->left;
   }
   cout<<endl;
}

void Deque::printDeque() {
    Node*temp=head;
    while(temp!=nullptr){
        cout<<temp->value<<"" "";
        temp=temp->right;
    }
    cout<<endl;
}",1.0,1111111111
Doubly_Linked_List_2,1491534,2210997,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if(count == 0)
    {
        head = tail = newNode;
        count++;
    }
    else
    {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    count++;
    }
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count)
            throw out_of_range(""Index out of range"");

        if (index == count) {
            add(e);
            return;
        }

        Node* newNode = new Node(e);
        if (index == 0) {
            newNode->next = head;
            head->previous = newNode;
            head = newNode;
        } else {
            Node* current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current->next;
            }
            newNode->next = current->next;
            newNode->previous = current;
            current->next = newNode;
            newNode->next->previous = newNode;
        }
        count++;
    
    
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1491534,2210997,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count)
            throw out_of_range(""Index out of range"");

    Node* current = head;
    for (int i = 0; i < index; i++) current = current->next;
    return current->data;
    
    
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count)
            throw out_of_range(""Index out of range"");

    Node* current = head;
    for (int i = 0; i < index; i++) current = current->next;
    current->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    for (int index = 0; current != nullptr; index++) 
    {
        if (current->data == item)   return index;
        current = current->next;
    }
    return -1;
    
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;

    
}",1.0,1111111111
Doubly_Linked_List_4,1491534,2210997,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
	if (begin == true)
	{
		if (this->pList == NULL)
		{
			this->current = NULL;
			this->index = -1;
		}
		else
		{
			this->current = this->pList->head;
			this->index = 0;
		}
	}
	else
	{
		this->current = NULL;
		this->index = (this->pList->count == 0) ? (this->pList->size()) : 0;
	}

}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
	this->current = iterator.current;
	this->index = iterator.index;
	return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else
		this->pList->set(this->index, e);
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == this->pList->head)
	{
		this->current = NULL;
		this->pList->removeAt(this->index);
		this->index = -1;
	}
	else
	{
		this->current = this->current->previous;
		this->pList->removeAt(this->index);
		--this->index;
	}
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (this->pList != iterator.pList || this->current != iterator.current);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == NULL && this->index == -1)
	{
		this->current = this->pList->head;
		this->index = 0;
	}
	else
	{
		this->current = this->current->next;
		++this->index;
	}
	return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator newIterator(this->pList, true);
	if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else {
	    newIterator = *this;
	    ++*this;
	    return newIterator;
	}
}

",1.0,1111111111
Doubly_Linked_List_5,1491534,2210997,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count)
    {
        throw std::out_of_range(""Index out of bounds"");
    }

    Node* current = head;
    Node* previous = nullptr;

    for (int i = 0; i < index; i++)
    {
        previous = current;
        current = current->next;
    }

    T removedValue = current->data;

    if (previous)
    {
        previous->next = current->next;
    }
    else
    {
        // If the removed element is the head, update the head
        head = current->next;
    }

    if (current == tail)
    {
        // If the removed element is the tail, update the tail
        tail = previous;
    }

    delete current;
    count--;
    return removedValue;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    Node* previous = nullptr;

    while (current)
    {
        if (current->data == item)
        {
            if (previous)
            {
                previous->next = current->next;
            }
            else
            {
                // If the removed element is the head, update the head
                head = current->next;
            }

            if (current == tail)
            {
                // If the removed element is the tail, update the tail
                tail = previous;
            }

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false; // Item not found
    
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* current = head;

    while (current)
    {
        Node* next = current->next;
        delete current;
        current = next;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1491534,2210997,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
     logList.push_back(0);
	currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
     logList.push_back(data);
	currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
     *this->currentState = *this->currentState + number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
     *this->currentState = *this->currentState - number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
     list<int>::iterator a = currentState;
	++a;
	while (a != logList.end()) {
		a = logList.erase(a);
	}
	logList.push_back(*currentState);
	++currentState;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if (currentState != logList.begin()) currentState = prev(currentState, 1);
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     list<int>::iterator a = currentState;
	list<int>::iterator b = ++a;
	if (b != logList.end()) ++currentState;
}
",1.0,1111111111
Doubly_Linked_List_8,1491534,2210997,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
   ListNode* prev = nullptr;
    ListNode* curr = head;
    ListNode* next = nullptr;
    int count = 1;
    while (curr != nullptr && count < a) {
        prev = curr;
        curr = curr->right;
        count++;
    }
    ListNode* start = prev;
    ListNode* end = curr;
    while (curr != nullptr && count <= b) {
        next = curr->right;
        curr->right = prev;
        curr->left = next;
        prev = curr;
        curr = next;
        count++;
    }
    if (start != nullptr) {
        start->right = prev;
    }
    else {
        head = prev;
    }
    end->right = curr;
    if (curr != nullptr) {
        curr->left = end;
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1493154,2212303,"Deque::Deque() {
    this->head=nullptr;
    this->tail=nullptr;
    this->curSize=0;
}

Deque::~Deque() {
    this->clear();
}

void Deque::clear() {
     while (head) {
            Node* temp = head;
            head = head->right;
            delete temp;
        }
        tail = nullptr;
        curSize = 0;
}

int Deque::getSize() {
    return this->curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
        if (head) {
            head->left = newNode;
        } else {
            tail = newNode;
        }
        head = newNode;
        curSize++;
}

void Deque::pushBack(int i) {
     Node* newNode = new Node(i, tail, nullptr);
        if (tail) {
            tail->right = newNode;
        } else {
            head = newNode;
        }
        tail = newNode;
        curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
            return -1;
        }
        int value = head->value;
        Node* oldHead = head;
        head = head->right;
        delete oldHead;
        if (head) {
            head->left = nullptr;
        } else {
            tail = nullptr;
        }
        curSize--;
        return value;
}

int Deque::popBack() {
   if (curSize == 0) {
            return -1;
        }
        int value = tail->value;
        Node* oldTail = tail;
        tail = tail->left;
        delete oldTail;
        if (tail) {
            tail->right = nullptr;
        } else {
            head = nullptr;
        }
        curSize--;
        return value;
}

void Deque::printDequeReverse() {
   Node* curr=this->tail;
   while(curr!=this->head){
       if(curr==nullptr) break;
       cout<<curr->value<<"" "";
       curr=curr->left;
   }
   if(curr!=nullptr) cout<<curr->value<<endl;
}

void Deque::printDeque() {
   Node* curr=this->head;
   while(curr!=this->tail){
        if(curr==nullptr) break;
       cout<<curr->value<<"" "";
       curr=curr->right;
   }
   if(curr!=nullptr) cout<<curr->value<<endl;
}",1.0,1111111111
Doubly_Linked_List_2,1493154,2212303,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newN=new Node(e);
    if(this->count==0){
        this->head=newN;
        this->tail=newN;
    }
    else{
    newN->previous=this->tail;
    this->tail->next=newN;
    this->tail=this->tail->next;
    }
    this->count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index<0) return;
    if(this->count==0) {this->add(e); return;}
    Node* curr=this->head;
    Node* prev=nullptr;
    for(int i=0; i<index && curr!=nullptr; i++){
        prev=curr;
        curr=curr->next;
    }
    
    Node* newN=new Node(e);
    
        newN->previous=prev;
    
    newN->next=curr;
    if(prev!=nullptr){
        prev->next=newN;
        
    }else{
        this->head=newN;
    }
    if(curr!=nullptr){
        curr->previous=newN;
        
    }else{
        this->tail=newN;
    }
    this->count++;
    
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1493154,2212303,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    //if(index<0) throw std::out_of_range(""Out of bounds"");
    //if(index>=this->count) return this->tail->data;
    Node* curr=this->head;
    
    for(int i=0; i<index && curr!=nullptr; i++){
        
        curr=curr->next;
    }
    
    return curr->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    //if(index<0) {throw std::out_of_range(""Out of bounds""); return;}
    //if(index>=this->count)  {this->tail->data=e; return;}
    Node* curr=this->head;
    
    for(int i=0; i<index && curr!=nullptr; i++){
        
        curr=curr->next;
    }
    curr->data=e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (this->head==nullptr);
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int result=-1;
    Node* curr=this->head;
    int index=0;
    while(curr!=nullptr){
        
        if(curr->data==item){
            result=index;
            break;
        }
        index++;
        curr=curr->next;
    }
    return result;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (this->indexOf(item)!=-1);
}",1.0,1111111111
Doubly_Linked_List_4,1493154,2212303,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    //if (pList!= nullptr){  
        this->pList=pList;
        if (begin){
            if (pList!=nullptr) {
                this->current=pList->head;
                this->index=0;
            }else this->index=-1;
        } else {
            this->current=nullptr;
            if(pList!=nullptr) index=pList->count;
            else index=0;
        }
    //}
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList=iterator.pList;
    this->index=iterator.index;
    this->current=iterator.current;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(current!=nullptr) current->data=e;
    else throw std::out_of_range(""Segmentation fault!"");
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
     if(current!=nullptr) return current->data;
    else throw std::out_of_range(""Segmentation fault!"");
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }

    if (current == pList->head /*&& index == 0 && pList->head != nullptr*/) {
        // Removing the head node
        //Iterator temp = *this;
        //pList->head = pList->head->next;
        //if(pList->count==1){
            //pList->head==nullptr;
            //pList->tail==nullptr;
        //}
        //pList->head=pList->head->next;
        //if(pList->head!=nullptr) pList->head->previous=nullptr;
        pList->removeAt(0);
        current = nullptr; // Updated to previous ""node"" of head
        index = -1;
        //pList->count--;
        //Iterator temp = *this;
        //this==temp++;
    } else {
        // Removing a non-head node
        Node* temp=current->previous;
         /*Node* temp=current->previous;
        temp->next=current->next;
        if(current->next!=nullptr){
            current->next->previous=temp;
        }*/
        pList->removeAt(index);
        
        
        // Move the iterator to the previous node
        current=temp;
        //pList->count--;
        index--;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (!(this->current==iterator.current && this-> index==iterator.index ));
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
     if (current == pList->tail) {
                //throw std::out_of_range(""Segmentation fault!"");
        current=nullptr;
        this->index=pList->count;
        
    }
    else{
        if (/*current->next == pList->head||*/current==nullptr&&index==-1) {
           current = pList->head;
           index = 0;
        }
        else {
           current = current->next;
           index++;
        }
    }
       
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    if (current == pList->tail) {
        //throw std::out_of_range(""Segmentation fault!"");
        current=nullptr;
        this->index=pList->count;
        
    }
    else{
        if (/*current->next == pList->head||*/current==nullptr&&index==-1) {
           current = pList->head;
           index = 0;
        }
        else {
           current = current->next;
           index++;
        }
    }
    return temp;
}

",0.9,1111111111
Doubly_Linked_List_5,1493154,2212303,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    
   
    Node* curr=this->head;
    
    for(int i=0; i<index && curr!=nullptr; i++){
       
        curr=curr->next;
    }
    T result=curr->data;
    this->count--;
    if(curr==this->head){
        this->head=curr->next;
    }
    if(curr==this->tail){
        this->tail=curr->previous;
    }
    if(this->head==nullptr ||  this->tail==nullptr){
        this->head=nullptr;
        this->tail=nullptr;
    }
    
    Node* prev=curr->previous;
    if(prev!=nullptr){
        prev->next=curr->next;
    }
    if(curr->next!=nullptr){
        curr->next->previous=prev;
    }
    curr=curr->next;
    
    return result;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int index=this->indexOf(item);
    if(index==-1) return false;
    else {
        this->removeAt(this->indexOf(item));
        return true;
    }
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while(!this->empty()){
        this->removeAt(0);
    }
}
",1.0,1111111111
Doubly_Linked_List_6,1493154,2212303,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    if (logList.empty()) return;

    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
      this->addCurrentState(-number);
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
     if (!logList.empty()) {
            // Create a new state by copying the data of the current state
            int currVal = *currentState;
            logList.erase(++currentState, logList.end());
            logList.push_back(currVal);
            currentState = --logList.end();
    }
     
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
       if (currentState != logList.begin())
    {
        // Move currentState iterator to previous state
        currentState--;
    }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    if (currentState != --logList.end()) {
            // Switch to the next state
            ++currentState;
    }
}
",0.9,1111111111
Doubly_Linked_List_8,1493154,2212303,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};*/


ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    
    if (!head || a == b) {
        return head;
    }
    
     int length = b - a + 1;
    ListNode* dummy = new ListNode(0);
    dummy->right = head;
    head->left=dummy;
    
   
    
    ListNode* temp = head; // Start from the dummy node
    ListNode* nodeA = nullptr;
    ListNode* nodeB = nullptr;
    // Move temp to the node before position a
    for (int i = 1; i <=b; i++) {
        if(i==a) nodeA=temp;
        if(i==b) {nodeB=temp; break;}
        temp = temp->right;
        
    }

    
    while (length > 1) {
       if (nodeA->right == nodeB) {
			nodeA->right = nodeB->right;
			if (nodeB->right != nullptr)
				nodeB->right->left = nodeA;
			nodeB->right = nodeA;
			nodeB->left = nodeA->left;
			nodeA->left = nodeB;
			if (nodeB->left != nullptr)
				nodeB->left->right = nodeB;
		}
		else {
			ListNode* tempN = nodeA->right;
			nodeA->right = nodeB->right;
			if (nodeB->right != nullptr)
				nodeB->right->left = nodeA;
			nodeB->right = tempN;
			tempN->left = nodeB;
			nodeB->left->right = nodeA;
			ListNode* tempP = nodeB->left;
			nodeB->left = nodeA->left;
			if (nodeA->left != nullptr)
				nodeA->left->right = nodeB;
			nodeA->left = tempP;
		}
		ListNode* tempB=nodeB;
		nodeB=nodeA;
		nodeA=tempB;
        
        // Move nodeA and nodeB closer to the center of the range
        nodeA = nodeA->right;
        nodeB = nodeB->left;
        length -= 2;
    }

    return dummy->right;
}
",1.0,1111111111
Doubly_Linked_List_1,1499461,2210578,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
clear();
}

void Deque::clear() {
while (head != nullptr) {
            Node* oldHead = head;
            head = head->right;
            delete oldHead;
            curSize--;
        }
        tail = nullptr; 
}

int Deque::getSize() {
return curSize; 
}

void Deque::pushFront(int i) {
 Node* newNode = new Node(i, nullptr, head);
        if (head != nullptr) head->left = newNode;
        else tail = newNode;
        head = newNode;
        curSize++;
}

void Deque::pushBack(int i) {
 Node* newNode = new Node(i, tail, nullptr);
        if (tail != nullptr) tail->right = newNode;
        else head = newNode;
        tail = newNode;
        curSize++;
}

int Deque::popFront() {
if (head == nullptr) return -1;
        int ret = head->value;
        Node* oldHead = head;
        head = head->right;
        if (head != nullptr) head->left = nullptr;
        else tail = nullptr;
        delete oldHead;
        curSize--;
        return ret;
}

int Deque::popBack() {
if (tail == nullptr) return -1;
        int ret = tail->value;
        Node* oldTail = tail;
        tail = tail->left;
        if (tail != nullptr) tail->right = nullptr;
        else head = nullptr;
        delete oldTail;
        curSize--;
        return ret;
}

void Deque::printDequeReverse() {
for (Node* temp = tail; temp != nullptr; temp = temp->left)
            cout << temp->value << ' ';
        cout << '\n';
}

void Deque::printDeque() {
for (Node* temp =head; temp != nullptr; temp = temp->right)
         cout << temp->value << ' ';
      cout << '\n';
}",1.0,1111111111
Doubly_Linked_List_2,1499461,2210578,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
      Node* newNode = new Node(e);
        if (tail) { // List not empty
            tail->next = newNode;
            newNode->previous = tail;
            tail = newNode;
        } else { // List is empty
            head = tail = newNode;
        }
        count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
            throw std::out_of_range("""");
        }

        Node* newNode = new Node(e);
        if (index == 0) { // Insert at head
            newNode->next = head;
            if (head) head->previous = newNode;
            head = newNode;
            if (count == 0) tail = head;
        } else if (index == count) { // Insert at tail
            tail->next = newNode;
            newNode->previous = tail;
            tail = newNode;
        } else { // Insert at middle
            Node* prevNode = head;
            for (int i = 0; i < index - 1; i++) prevNode = prevNode->next;
            newNode->next = prevNode->next;
            newNode->previous = prevNode;
            prevNode->next->previous = newNode;
            prevNode->next = newNode;
        }
        count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1499461,2210578,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
     if (index < 0 || index >= count) {
            throw std::out_of_range("""");
        }
        Node* temp = head;
        for (int i = 0; i < index; i++) temp = temp->next;
        return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
            throw std::out_of_range("""");
        }
        Node* temp = head;
        for (int i = 0; i < index; i++) temp = temp->next;
        temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !count;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
        for (int i = 0; i < count; i++) {
            if (temp->data == item) return i;
            temp = temp->next;
        }
        return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
     return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1499461,2210578,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    if (begin == true)  {
        this->pList = pList;
        if (pList == nullptr)   {
            current = nullptr;
            index = -1;
        }
        else {
            current = pList->head;
            index = 0;
        }
    }
    else {
        this->pList = pList;
        current = nullptr;
        index = pList->size();
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == nullptr) {
        throw out_of_range(""Segmentation fault!"");
    }
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (current == nullptr) {
        throw out_of_range(""Segmentation fault!"");
    }
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current == nullptr) {
        throw out_of_range(""Segmentation fault!"");
    }
    current = current->previous;
    this->pList->removeAt(index);
    index = index-1;
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (current != iterator.current && index != iterator.index);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{   
    if (index == -1)    {
        index = 0;
        current = this->pList->head;
    }
    else {
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,1111111111
Doubly_Linked_List_5,1499461,2210578,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) {
        throw ""Index out of bounds"";
    }
    Node* temp = head;
    for (int i = 0; i < index; i++) {
        temp = temp->next;
    }
    if (temp->previous) {
        temp->previous->next = temp->next;
    } else {
        head = temp->next;
    }
    if (temp->next) {
        temp->next->previous = temp->previous;
    } else {
        tail = temp->previous;
    }
    T data = temp->data;
    delete temp;
    count--;
    return data;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* temp = head;
    while (temp) {
        if (temp->data == item) {
            if (temp->previous) {
                temp->previous->next = temp->next;
            } else {
                head = temp->next;
            }
            if (temp->next) {
                temp->next->previous = temp->previous;
            } else {
                tail = temp->previous;
            }
            delete temp;
            count--;
            return true;
        }
        temp = temp->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    tail = NULL;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1499461,2210578,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    list<int>::iterator temp = logList.end();
    temp--;
    
    while (temp != currentState)
    {
        temp--;
        logList.pop_back();
    }

    logList.push_back(*currentState);
    currentState = --logList.end();
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if (currentState != logList.begin())   {
         currentState--;
     }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    currentState = logList.end();
    currentState--;
}",1.0,1111111111
Doubly_Linked_List_8,1499461,2210578,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    if (a == b) return head;
    
    ListNode* startNode = head;
    ListNode* endNode = head;
    ListNode* prevNodeA = nullptr;
    ListNode* nextNodeB = nullptr;
    
    for (int i = 1; i < a; i++) {
        prevNodeA = startNode;
        startNode = startNode->right;
    }
    
    for (int i = 1; i < b; i++) {
        endNode = endNode->right;
    }
    nextNodeB = endNode->right;
    ListNode* currentNode = startNode;
    ListNode* prev = nextNodeB;
    
    while (currentNode != nextNodeB) {
        ListNode* next = currentNode->right;
        currentNode->right = prev;
        currentNode->left = next;
        prev = currentNode;
        currentNode = next;
    }
    if (prevNodeA) {
        prevNodeA->right = endNode;
    } else {
        head = endNode;
    }
    
    startNode->right = nextNodeB;
    
    if (nextNodeB) {
        nextNodeB->left = startNode;
    }
    
    endNode->left = prevNodeA;
    
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1504949,2212651,"Deque::Deque(){
    head=tail=nullptr;
    curSize=0;
}

Deque::~Deque() {
    clear();  // Use the clear function to properly deallocate memory.
}

void Deque::clear() {
    while (head) {
        Node* del = head;
        head = head->right;
        delete del;
    }
    head = tail = nullptr;
    curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
    if (curSize == 0) {
        tail = newNode;
    } else {
        head->left = newNode;
    }
    head = newNode;
    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i, tail, nullptr);
    if (curSize == 0) {
        head = newNode;
    } else {
        tail->right = newNode;
    }
    tail = newNode;
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1; // Indicate an empty deque.
    }
    Node* tmp = head;
    head = head->right;
    if (head) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    int i = tmp->value;
    delete tmp;
    curSize--;
    return i;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1; // Indicate an empty deque.
    }
    Node* tmp = tail;
    tail = tail->left;
    if (tail) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    int i = tmp->value;
    delete tmp;
    curSize--;
    return i;
}

void Deque::printDeque() {
    Node* tmp = head;
    while (tmp) {
        cout << tmp->value;
        tmp = tmp->right;
        if (tmp) {
            cout << "" "";
        } else {
            cout << ""\n"";
        }
    }
}

void Deque::printDequeReverse() {
    Node* tmp = tail;
    while (tmp) {
        cout << tmp->value;
        tmp = tmp->left;
        if (tmp) {
            cout << "" "";
        } else {
            cout << ""\n"";
        }
    }
}
",1.0,1111111111
Doubly_Linked_List_2,1504949,2212651,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if(count==0){
        head=tail=new Node(e);
    }
    else{
        Node* newNode=new Node(e);
        tail->next=newNode;
        newNode->previous=tail;
        tail=newNode;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    Node *p = this->head;
    if (index == 0){
        if (p == nullptr){
            ++count;
            head = tail = new Node(e);
            return;
        }
        else{
            ++count;
            Node *tmp = new Node(e);
            tmp->next = head;
            head->previous = tmp;
            head = tmp;
        }
    }
    else if (index == count)
        this->add(e);
    else{
        ++count;
        for (int i=0; i<index-1 && p; i++)
            p = p->next;
        
        Node *tmp = new Node(e);
        p->next->previous = tmp;
        tmp->next = p->next;
        tmp->previous = p;
        p->next = tmp;
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1504949,2212651,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    Node *p = this->head;
    for (int i=0; i<index && p; i++)
        p = p->next;
    
    return p->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    Node **p = &this->head;
    for (int i=0; i<index; i++)
        p = &((*p)->next);
    
    (*p)->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !count;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int idx = -1;
    Node *p = this->head;
    for (int i=0; i<count; i++){
        if (p->data == item){
            idx = i;
            break;
        }
        p = p->next;
    }
    return idx;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node *p = this->head;
    for (int i=0; i<count; i++){
        if (p->data == item)
            return true;
        p = p->next;
    }
    return false;
    
}",1.0,1111111111
Doubly_Linked_List_4,1504949,2212651,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList=pList;
    if(begin){
        if(pList && pList->size()>0){
            current=pList->head;
            index=0;
        }
        else{
            current = nullptr;
            index=-1;
        }
    }
    else{
        current=nullptr;
        if(pList){
            index=pList->size();
        }
        else{
            index=0;
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList=iterator.pList;
    this->current=iterator.current;
    this->index=iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(this->current) this->current->data=e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if(current) return current->data;
    throw std::out_of_range(""Segmentation fault!"");
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    Node* tmp=current;
   --pList->count;
   Node *prevtemp = tmp->previous;
   Node *nexttemp = tmp->next;
    if (prevtemp)
        prevtemp->next = nexttemp;
    else{
        pList->head = pList->head->next;
        if (pList->head)   pList->head->previous = nullptr;
        else pList->head = pList->tail = nullptr;
    }
    if (nexttemp)
        nexttemp->previous = prevtemp;
   current = current->previous;
   --index;
   if (current == nullptr)
        ++current;
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return !((current == iterator.current) && (index == iterator.index));
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (current == nullptr || pList == nullptr || index == pList->size())
        throw std::out_of_range(""Segmentation fault!"");
    
    if (index == -1)
        current = pList->head;
    else    current = current->next;
    ++index;
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    if (index == pList->size())
        throw std::out_of_range(""Segmentation fault!"");
    Iterator temp(*this);
    ++(*this);
    return temp;
}",1.0,1111111111
Doubly_Linked_List_5,1504949,2212651,"
template <class T>
T DLinkedList<T>::removeAt(int index)
{
    --count;
    T val;
    if (index == 0){
        Node *tmp = head;
        val = tmp->data;
        head = head->next;
        if (head)
            head->previous = nullptr;
        else head = tail = nullptr;
        delete tmp;
    }
    else{
        Node *p = this->head;
        for (int i=0; i<index-1; i++)
            p = p->next;
        val = p->next->data;
        Node *tmp = p->next;
        // case tail 
        if (p->next->next){
            tmp->next->previous = p;
            p->next = tmp->next;
            delete tmp;
        }
        else{
            p->next = nullptr;
            tail = p;
            delete tmp;
        }
    }
    return val;
}


template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int idx = this->indexOf(item);
    if (idx == -1)  return false;
    this->removeAt(idx);
    return true;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (count){
        this->removeAt(0);
    }
}
",1.0,1111111111
Doubly_Linked_List_6,1504949,2212651,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_front(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState+=number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState-=number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */

    logList.erase(next(currentState,1), logList.end());
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    auto it=logList.begin();
    if (currentState != it){
        currentState--;
    }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    if (currentState != prev(logList.end(),1)){
        currentState++;
    }
}",1.0,1111111111
Doubly_Linked_List_8,1504949,2212651,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/


ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    ListNode *tmp = head;
    ListNode *tmp1 = head;
    int range = b-a+1;
    for (int i=1; i<a; i++)
        tmp = tmp->right;
    
    for (int i=1; i<b; i++)
        tmp1 = tmp1->right;
    
    for (int i=0; i<range/2; i++){
        ListNode *rtmp = tmp->right;
        ListNode *ltmp = tmp->left;
        ListNode *ltmp1 = tmp1->left;
        ListNode *rtmp1 = tmp1->right;
        if (ltmp)
            ltmp->right = tmp1;
        if (rtmp1)
            rtmp1->left = tmp;
        tmp1->left = ltmp;
        tmp->right = rtmp1;
        if (rtmp == tmp1){
            tmp->left = tmp1;
            tmp1->right = tmp;
        }
        else if (rtmp == ltmp1){
            rtmp->left = tmp1;
            rtmp->right = tmp;
            tmp1->right = rtmp;
            tmp->left = rtmp;
        }
        else{
            rtmp->left = tmp1;
            tmp1->right = rtmp;
            ltmp1->right = tmp;
            tmp->left = ltmp1;
        }
        if (ltmp == nullptr)
            head = tmp1;
        ListNode *p = tmp;
        tmp = tmp1;
        tmp1 = p;
        tmp1 = tmp1->left;
        tmp = tmp->right;
    }
    return head;
}
",1.0,1111111111
Doubly_Linked_List_1,1511555,2212935,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    Node* current = head;
        while (current != nullptr) {
            Node* temp = current;
            current = current->right;
            delete temp;
        }
        head = nullptr;
        tail = nullptr;
        curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int item) {
    Node* newNode = new Node(item, nullptr, head);
        if (head != nullptr) {
            head->left = newNode;
        }
        head = newNode;
        if (tail == nullptr) {
            tail = head;
        }
        curSize++;

}

void Deque::pushBack(int item) {
Node* newNode = new Node(item, tail, nullptr);
        if (tail != nullptr) {
            tail->right = newNode;
        }
        tail = newNode;
        if (head == nullptr) {
            head = tail;
        }
        curSize++;
}

int Deque::popFront() {
    if (head == nullptr) {
            return -1;  
        }
        Node* temp = head;
        int value = temp->value;
        head = head->right;
        if (head != nullptr) {
            head->left = nullptr;
        } else {
            tail = nullptr;
        }
        delete temp;
        curSize--;
        return value;

}

int Deque::popBack() {
    if (tail == nullptr) {
            return -1;  
        }
        Node* temp = tail;
        int value = temp->value;
        tail = tail->left;
        if (tail != nullptr) {
            tail->right = nullptr;
        } else {
            head = nullptr;
        }
        delete temp;
        curSize--;
        return value;
}

void Deque::printDequeReverse() {
Node* current = tail;
        while (current != nullptr) {
            cout << current->value << "" "";
            current = current->left;
        }
        cout << endl;
}

void Deque::printDeque() {
Node* current = head;
        while (current != nullptr) {
            cout << current->value << "" "";
            current = current->right;
        }
        cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1511555,2212935,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        cout << ""Invalid index"" << endl;
        return;
    }
    if (index == 0) {
        Node* newNode = new Node(e);
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
        } else {
            newNode->next = head;
            head->previous = newNode;
            head = newNode;
        }
        count++;
    } 
    else if (index == count) {
        add(e);
    } 
    else {
        Node* newNode = new Node(e);
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        newNode->next = current;
        newNode->previous = current->previous;
        current->previous->next = newNode;
        current->previous = newNode;
        count++;
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1511555,2212935,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        cout << ""Invalid index"" << endl;
        return T();
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        cout << ""Invalid index"" << endl;
        return;
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
     return count == 0;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1511555,2212935,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) : pList(pList), current(nullptr), index(-1)
{
 this->pList = pList;
    if (begin) {
        this->current = pList->head;
        this->index = 0;
    } else {
        this->current = NULL;
        this->index = pList->count;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current) {
        current->data = e;
    }
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current) {
        Node* prev = current->previous;
        Node* next = current->next;
        if (prev) {
            prev->next = next;
        } else {
            pList->head = next;
        }
        if (next) {
            next->previous = prev;
        } else {
            pList->tail = prev;
        }
        Node* toDelete = current;
        current = next;
        delete toDelete;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return current != iterator.current;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (current) {
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}

",0.8,1001111111
Doubly_Linked_List_5,1511555,2212935,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count)
        throw out_of_range(""Index out of range."");

    Node* current = head;
    if (index == 0) {
        head = head->next;
        if (head != NULL)
            head->previous = NULL;
        else
            tail = NULL;
    } else if (index == count - 1) {
        current = tail;
        tail = tail->previous;
        tail->next = NULL;
    } else {
        for (int i = 0; i < index; i++)
            current = current->next;
        current->previous->next = current->next;
        current->next->previous = current->previous;
    }

    T data = current->data;
    delete current;
    count--;
    return data;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int index = indexOf(item);
    if (index == -1)
        return false;

    removeAt(index);
    return true;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
     Node* current = head;
    while (current != NULL) {
        Node* next = current->next;
        delete current;
        current = next;
    }
    head = NULL;
    tail = NULL;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_8,1511555,2212935,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    if (a == b || head == nullptr)
        return head;

    ListNode* curr = head;
    ListNode* prev = nullptr;

    // Traverse to the node at position a
    for (int i = 1; i < a; i++) {
        prev = curr;
        curr = curr->right;
    }

    ListNode* startNode = curr;
    ListNode* prevNode = prev;

    int count = 0;
    // Reverse the nodes from a to b
    while (curr != nullptr && count < b - a + 1) {
        ListNode* nextNode = curr->right;
        curr->right = curr->left;
        curr->left = nextNode;
        prev = curr;
        curr = nextNode;
        count++;
    }

    // Update pointers of startNode and prevNode
    if (prevNode)
        prevNode->right = prev;
    else
        head = prev;
    startNode->right = curr;
    if (curr)
        curr->left = startNode;

    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1512801,2212282,"Deque::Deque() {
    head = NULL;
    tail = NULL;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    Node* temp = head;
    while(head) {
        head = head->right;
        delete temp;
        temp = head;
    }
    head = NULL;
    tail = NULL;
    curSize=0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if(curSize == 0) {
        head = new Node(i);
        tail = head;
    }
    else {
        head->left = new Node(i, NULL, head);
        head = head->left;
    }
    ++curSize;
}

void Deque::pushBack(int i) {
    if(curSize == 0) {
        head = new Node(i);
        tail = head;
    }
    else {
        tail->right = new Node(i, tail, NULL);
        tail = tail->right;
    }
    ++curSize;
}

int Deque::popFront() {
    if(curSize == 0) return -1;
    int save = head->value;
    if(curSize == 1) {
        delete head;
        head = NULL;
        tail = NULL;
    }
    else {
        head = head->right;
        delete head->left;
        head->left = NULL;
    }
    --curSize;
    return save;
}

int Deque::popBack() {
    if(curSize == 0) return -1;
    int save = tail->value;
    if(curSize == 1) {
        delete tail;
        head = NULL;
        tail = NULL;
    }
    else {
        tail = tail->left;
        delete tail->right;
        tail->right = NULL;
    }
    --curSize;
    return save;
}

void Deque::printDequeReverse() {
    Node* tmp = tail;
    while(tmp != NULL) {
        cout << tmp->value << "" "";
        tmp = tmp->left;
    } 
    if(tail) cout << endl;
}

void Deque::printDeque() {
    Node* tmp = head;
    while(tmp != NULL) {
        cout << tmp->value << "" "";
        tmp = tmp->right;
    } 
    if(head) cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1512801,2212282,"template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template <class T>
void DLinkedList<T>::add(int index, const T& e) {
    if (index < 0 || index > count) {
        std::cout << ""Invalid index."" << std::endl;
        return;
    }
    if (index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        newNode->previous = current;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
}

template <class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1512801,2212282,"template <class T>
bool DLinkedList<T>::empty() {
    return count == 0;
}
template <class T>
T DLinkedList<T>::get(int index) {
    if (index < 0 || index >= count) {
        std::cout << ""Invalid index."" << std::endl;
        return T();
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    if (index < 0 || index >= count) {
        std::cout << ""Invalid index."" << std::endl;
        return;
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template <class T>
int DLinkedList<T>::indexOf(const T& item) {
    Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;
}

template <class T>
bool DLinkedList<T>::contains(const T& item) {
    return indexOf(item) != -1;
}
",1.0,1111111111
Doubly_Linked_List_4,1512801,2212282,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this->pList = pList;
    if (begin) {
        current = pList->head;
        index = 0;
    } else {
        current = nullptr;
        index = pList->count;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current != nullptr) {
        current->data = e;
    }
}

template<class T>
T& DLinkedList<T>::Iterator::operator*()
{
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove()
{
    if (current != nullptr) {
        Node *prev = current->previous;
        Node *next = current->next;

        if (prev != nullptr) {
            prev->next = next;
        } else {
            pList->head = next;
        }

        if (next != nullptr) {
            next->previous = prev;
        } else {
            pList->tail = prev;
        }

        Node *temp = current;
        current = next; // Move current to the next node
        delete temp;

        pList->count--;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    return current != iterator.current;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()
{
    if (current != nullptr) {
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}

",0.8,1001111111
Doubly_Linked_List_5,1512801,2212282,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count)
        throw std::out_of_range(""Index out of range"");

    Node* current = head;
    Node* previous = nullptr;

    // Traverse to the node at the specified index
    for (int i = 0; i < index; i++)
    {
        previous = current;
        current = current->next;
    }

    // Remove the node from the list
    if (previous)
        previous->next = current->next;
    else
        head = current->next;

    if (current == tail)
        tail = previous;

    T removedData = current->data;
    delete current;
    count--;

    return removedData;
}

template <class T>
bool DLinkedList<T>::removeItem(const T &item)
{
    Node* current = head;
    Node* previous = nullptr;

    // Traverse the list to find the node containing the item
    while (current)
    {
        if (current->data == item)
        {
            // Remove the node from the list
            if (previous)
                previous->next = current->next;
            else
                head = current->next;

            if (current == tail)
                tail = previous;

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;
}

template <class T>
void DLinkedList<T>::clear()
{
    Node* current = head;
    while (current)
    {
        Node* next = current->next;
        delete current;
        current = next;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1512801,2212282,"DataLog::DataLog()
{
    logList.push_back(0);
    currentState = logList.begin();
}
DataLog::DataLog(const int &data)
{
   logList.push_back(data);
  currentState = logList.begin();
}
void DataLog::addCurrentState(int number)
{
    int data = getCurrentStateData();
   data += number;
   logList.push_back(data);
    currentState = --logList.end();
}
void DataLog::subtractCurrentState(int number)
{
   int data = getCurrentStateData();
    data -= number;
    logList.push_back(data);
    currentState = --logList.end();
}
void DataLog::save()
{
    if (currentState != --logList.end())
    {
        logList.erase(++currentState, logList.end());
        currentState = --logList.end();
    }
}
void DataLog::undo()
{
    if (currentState != logList.begin())
    {
       currentState--;
    }
}
void DataLog::redo()
{
    if (currentState != --logList.end())
    {
        currentState++;
    }
}
",0.3,1100001000
Doubly_Linked_List_8,1512801,2212282,"ListNode* reverse(ListNode* head, int a, int b) {
    if (head == nullptr || a >= b) {
        return head;
    }

    ListNode* dummy = new ListNode(-1);  // Create a dummy node
    dummy->right = head;
    ListNode* prev = dummy;

    // Move prev to the node before the sublist to be reversed
    for (int i = 0; i < a - 1; i++) {
        prev = prev->right;
    }

    ListNode* curr = prev->right;  // The current node within the sublist
    ListNode* next;  // Pointer to the next node in the sublist

    // Reverse the sublist from node 'a' to node 'b'
    for (int i = 0; i < b - a; i++) {
        next = curr->right;
        curr->right = next->right;
        next->right = prev->right;
        prev->right = next;
    }

    head = dummy->right;  // Update the head pointer
    delete dummy;  // Free the memory occupied by the dummy node

    return head;
}",0.9,1011111111
Doubly_Linked_List_1,1518977,2211367,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head != nullptr) {
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    tail = nullptr;
    curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
    if (head != nullptr)
        head->left = newNode;
    head = newNode;

    if (tail == nullptr)
        tail = head;

    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i, tail, nullptr);
    if (tail != nullptr)
        tail->right = newNode;
    tail = newNode;

    if (head == nullptr)
        head = tail;

    curSize++;
}

int Deque::popFront() {
    if (head == nullptr)
        return -1;

    Node* temp = head;
    int value = temp->value;
    head = head->right;

    if (head != nullptr)
        head->left = nullptr;
    else
        tail = nullptr;

    delete temp;
    curSize--;

    return value;
}

int Deque::popBack() {
    if (tail == nullptr)
        return -1;

    Node* temp = tail;
    int value = temp->value;
    tail = tail->left;

    if (tail != nullptr)
        tail->right = nullptr;
    else
        head = nullptr;

    delete temp;
    curSize--;

    return value;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1518977,2211367,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
     if(count == 0){
        tail = head = new Node(e);
    }
    else{
        Node* tmp = new Node(e);
//! xử lý phần con trỏ để kết nói 2 chiều 
        tail->next = tmp;
        tmp->previous = tail;
        tail = tmp;
    }
//! cộng số lượng danh sách
    count ++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
//! kiểm tra đầu vào có hợp lệ hay không nếu không hợp lệ thì dừng chương trình
    if(index < 0 && index > count) throw out_of_range("""");
//! nếu chưa có phần tử nào và thêm vào đầu danh sách 
    else if(count == 0 || index == count ) add(e);
    else if(index == 0){
//! xử lý con trỏ
        Node* tmp = new Node(e);
        tmp->next = head;
        head->previous = tmp;
        head = tmp;
        count  ++;
    }
    else{
//! tạo 2 node curr và prev lưu node ở vị trí chèn và node trước vị trí chèn
        Node* curr = head->next,* prev = head;
        index --;  
        while(index){
            index--;
            prev = curr;
            curr= curr->next;
        }
//! thực hiện chèn node

        Node* tmp = new Node(e);
        prev->next = tmp;
        tmp->previous = prev;
        tmp->next = curr;
        curr->previous = tmp;
        count ++;
    }
    
}
template<class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1518977,2211367,"
template<class T>
T DLinkedList<T>::get(int index) {
    if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){ 
        tmp = tmp->next;
        index --;
    }
    return tmp->data;
    
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){
        tmp = tmp->next;
        index --;
    }
    tmp->data = e;  
}

template<class T>
bool DLinkedList<T>::empty() {
    return count == 0;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    Node* tmp = head;
    int index = 0;
    while(tmp){
        if(tmp->data == item) return index;
        tmp = tmp->next;
        index ++;
    }
    return -1;
    
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    Node* tmp = head;
    while(tmp){
        if(tmp->data == item) return true;
        tmp = tmp->next;
    }
    return false;
    
}
",1.0,1111111111
Doubly_Linked_List_4,1518977,2211367,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
 
//!  
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
 this->pList = pList;
   if(pList == NULL){index = -1;}
   else if(begin){
        if(this->pList->size() == 0){this->current = NULL;index = -1;}
        else{ this->current = pList->head;index = 0;}
   }
   else{
        this->current = NULL;
        if(this->pList->size() == 0) index = this->pList->size();
        else index = pList->size();
   }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
     this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
     if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
     if(current == NULL) throw out_of_range(""Segmentation fault!"");
   //cout << current->data;
   return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    
    if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    if(index == 0){

        this->pList->removeAt(index);
        this->index = -1;
        current = NULL;
    }
    else{
        T e = this->pList->removeAt(index-1);
        this->index = index - 1;
        current->data = e;
      
}
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
   return !(iterator.index == this->index || iterator.current == this->current);
}
// Prefix ++ overload
template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    DLinkedList<T>::Iterator t = *this;
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return t;
}

",0.9,1111111111
Doubly_Linked_List_5,1518977,2211367,"
template <class T>
T DLinkedList<T>::removeAt(int index)
{
    T result;
//! nếu đúng thì chương trình chạy sai thì dừng chương trình 
    if(index < 0 || index > count || count == 0) throw out_of_range("""");
//! nếu chỉ có 1 phần tử đầu tiên thì reset head = tail = nullptr
    else if(count == 1){
        result = head->data;
        delete head;
        head =tail = nullptr;
    }
//! nếu xóa ở vị trí 0 thì 
    else if(index == 0){
//! lưu data của node đầu tiên lại
        result = head->data;
        Node* tmp = head;
        head = head->next;
//! xóa vùng nhớ
        delete tmp;
    }
    else{
//! giảm index xuống 1 đơn vị
        index --;
        Node* tmp = head;
//! dùng vòng lặp đến vị trí cần tìm
        while(index){
            tmp = tmp->next;
            index --;
        }
        if(tmp->next->next){
            Node* d = tmp->next;
            tmp->next = tmp->next->next;
            result = d->data;
            delete d;
        }
        else{
//! nếu không thỏa if thì phải lưu tail lại vì phần tử đang xóa là phần tử ở vị trí cuối cùng
            tail = tmp;
            Node* d = tmp->next;
            tmp->next = nullptr;
            result = d->data;
            delete d;
        }
    }
    count --;
    return result;
}
//!  
template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
//! xóa node có giá trị bằng phần tử ở vị trí đầu tiên của danh sách nếu có phần tử thì xóa rồi trả về true không thì ngược lại
   int index = indexOf(item);
   if(index == -1 ) return false;
   removeAt(index);
   return true;
    
}
//! giải phóng các node 
template<class T>
void DLinkedList<T>::clear(){
    Node* tmp = head;
    while(tmp){
        tmp = tmp->next;
        delete head;
        head = tmp;
    }
    tail = head = NULL;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1518977,2211367,"
DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
    
}


void DataLog::addCurrentState(int number)
{
    *currentState += number; 
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
 //! Di chuyển con trỏ currentState lên một bước để trỏ tới phần tử tiếp theo trong danh sách.
     currentState++;
//! Kiểm tra nếu currentState không trỏ tới cuối danh sách.     
     if(currentState != logList.end()){
         list<int>::iterator curr = currentState;
         list<int>::iterator prev = currentState;
        while(curr != logList.end()){
            curr++;
            logList.erase(prev);
            prev = curr;
        }
        currentState = logList.end();
       
    }
    currentState--;
  
    logList.push_back(*currentState);
    currentState++;

}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState != logList.begin())
        --currentState;
}
void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     ++currentState;
    if(currentState == logList.end()) --currentState;
  
    
}
   
",0.95,1111111111
Doubly_Linked_List_8,1518977,2211367,"
void SwapNode(ListNode*& head, ListNode*& Node1, ListNode*& Node2){
    if (Node1 == head)
        head = Node2;
    else if (Node2 == head)
        head = Node1;
    ListNode* temp = Node1 -> right;
    Node1 -> right = Node2 -> right;
    Node2 -> right = temp;
    if (Node1 -> right != nullptr)
        Node1 -> right -> left = Node1;
    if (Node2 -> right != nullptr)
        Node2 -> right -> left = Node2;
    temp = Node1 -> left;
    Node1 -> left = Node2 -> left;
    Node2 -> left = temp;
    if (Node1 -> left != nullptr)
        Node1 -> left -> right = Node1;
    if (Node2 -> left != nullptr)
        Node2 -> left -> right = Node2;
    temp = Node1;
    Node1 = Node2;
    Node2 = temp;
}

ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    ListNode* A = head;
    ListNode* B = head;
    a -= 1; b -= 1;
    for (int i = 0; i < a; i++) A = A -> right;
    for (int i = 0; i < b; i++) B = B -> right;
    for (int i = 0; i < (b - a + 1) / 2; i++){
        SwapNode(head, A, B);
        A = A -> right;
        B = B -> left;
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_2,1521701,2211738,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* pNew = new Node(e);
    if (this->head == NULL) {
        this->head = this->tail = pNew;
    }
    else {
        this->tail->next = pNew;
        pNew->previous = this->tail;
        this->tail = pNew;
    }
    ++this->count;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index > this->count || index < 0) {
		throw (""out of range"");
		return;
	}
		
	if (index == this->count && this->count != 0) {
		add(e);
		return;
	}
	
	Node* pNew = new Node(e);
	if (this->count == 0) 
        this->head = this->tail = pNew;
    else if (index == 0) {
        pNew->next = this->head;
        this->head->previous = pNew;
        this->head = pNew;
    }
    else {
        Node* prev = this->head;
        for (int i = 0; i < index - 1; i++) prev = prev->next;
        Node* cur = prev->next;
        pNew->next = prev->next;
        cur->previous = pNew;
        pNew->previous = prev;
        prev->next = pNew;
    }
    ++this->count;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
     return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1521701,2211738,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= this->count) 
        throw std::out_of_range(""Invalid Index!"");
    Node* temp = this->head;
    for (int i = 0; i < index; i++) temp = temp->next;
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= this->count) 
        throw std::out_of_range(""Invalid Index!"");
    Node* temp = this->head;
    for (int i = 0; i < index; i++) temp = temp->next;
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
     return (this->count == 0);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
     Node* temp = this->head;
    int i = 0;
    while (temp != NULL) {
        if (temp->data == item)
            return i;
        temp = temp->next;
        ++i;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (this->indexOf(item) != -1);
}",1.0,1111111111
Doubly_Linked_List_4,1521701,2211738,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
	if (begin == true)
	{
		if (this->pList == NULL)
		{
			this->current = NULL;
			this->index = -1;
		}
		else
		{
			this->current = this->pList->head;
			this->index = 0;
		}
	}
	else
	{
		this->current = NULL;
		this->index = (this->pList->count == 0) ? (this->pList->size()) : 0;
	}
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
	this->current = iterator.current;
	this->index = iterator.index;
	return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else
		this->pList->set(this->index, e);
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
     if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == this->pList->head)
	{
		this->current = NULL;
		this->pList->removeAt(this->index);
		this->index = -1;
	}
	else
	{
		this->current = this->current->previous;
		this->pList->removeAt(this->index);
		--this->index;
	}
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (this->pList != iterator.pList || this->current != iterator.current);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == NULL && this->index == -1)
	{
		this->current = this->pList->head;
		this->index = 0;
	}
	else
	{
		this->current = this->current->next;
		++this->index;
	}
	return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator newIterator(this->pList, true);
	if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else {
	    newIterator = *this;
	    ++*this;
	    return newIterator;
	}
}

",1.0,1111111111
Doubly_Linked_List_5,1521701,2211738,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= this->count)
        throw std::out_of_range(""The index is out of range!"");
    T dataDel;
    Node* temp = this->head;
    if (this->count == 1) {
        dataDel = this->head->data;
        delete this->head;
        this->head = this->tail = NULL;
    }
    else if (index == 0) {
        dataDel = temp->data;
        this->head = temp->next;
        delete temp;
        temp = this->head;
        this->head->previous = NULL;
    }
    else if (index == this->count - 1) {
        while (temp->next->next != NULL) temp = temp->next;
        dataDel = this->tail->data;
        delete this->tail;
        this->tail = temp;
        temp->next = NULL;
    }
    else {
        for (int i = 0; i < index; i++) temp = temp->next;
        dataDel = temp->data;
        temp->previous->next = temp->next;
        temp->next->previous = temp->previous;
        delete temp;
        temp = NULL;
    }
    --this->count;
    return dataDel;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int index = this->indexOf(item);
    if (index != -1) {
        this->removeAt(index);
        return true;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (this->count != 0) this->removeAt(0);
}
",1.0,1111111111
Doubly_Linked_List_6,1521701,2211738,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
     logList.push_back(0);
	currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
     logList.push_back(data);
	currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *this->currentState = *this->currentState + number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *this->currentState = *this->currentState - number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    list<int>::iterator a = currentState;
	++a;
	while (a != logList.end()) {
		a = logList.erase(a);
	}
	logList.push_back(*currentState);
	++currentState;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState != logList.begin()) currentState = prev(currentState, 1);
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    list<int>::iterator a = currentState;
	list<int>::iterator b = ++a;
	if (b != logList.end()) ++currentState;
}
",1.0,1111111111
Doubly_Linked_List_1,1522696,2212651,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    this->clear();
}

void Deque::clear() {
    while (head) {
        Node* tmp = head;
        head = head->right;
        delete tmp;
        curSize--;
    }
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i);
    newNode->right = head;
    if (!head) {
        head = tail = newNode; curSize++;
        return;
    }
    head->left = newNode;
    head = newNode;
    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i);
    if (!head) {
        head = tail = newNode; curSize++;
        return;
    }
    tail->right = newNode;
    newNode->left = tail;
    tail = newNode;
    curSize++;
}

int Deque::popFront() {
    if (head == nullptr) return -1;
    int i = head->value;
    Node* tmp = head;
    head = head->right;
    if (head) {
        head->left = nullptr;  // Update the left pointer of the new head
    }
    else {
        tail = nullptr;  // If the deque becomes empty
    }
    delete tmp;
    curSize--;
    return i;
}

int Deque::popBack() {
    if (tail == nullptr) return -1;
    int i = tail->value;
    Node* tmp = tail;
    tail = tail->left;
    if (tail) {
        tail->right = nullptr;  // Update the right pointer of the new tail
    }
    else {
        head = nullptr;  // If the deque becomes empty
    }
    delete tmp;
    curSize--;
    return i;
}

void Deque::printDequeReverse() {
    Node* tmp = tail;
    while (tmp) {
        if (tmp != head) {
            cout << tmp->value << "" "";
        }
        else {
            cout << tmp->value << ""\n"";
        }
        tmp = tmp->left;
    }
}

void Deque::printDeque() {
    Node* tmp = head;
    while (tmp) {
        if (tmp != tail) {
            cout << tmp->value << "" "";
        }
        else {
            cout << tmp->value << ""\n"";
        }
        tmp = tmp->right;
    }
}",1.0,1111111111
Doubly_Linked_List_2,1522696,2212651,"template <class T>
void DLinkedList<T>::add(const T& e) {
//! nếu chưa có phần tử nào thì thêm vào đầu danh sách
    if(count == 0){
        tail = head = new Node(e);
    }
    else{
        Node* tmp = new Node(e);
//! xử lý phần con trỏ để kết nói 2 chiều 
        tail->next = tmp;
        tmp->previous = tail;
        tail = tmp;
    }
//! cộng số lượng danh sách
    count ++;
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
//! kiểm tra đầu vào có hợp lệ hay không nếu không hợp lệ thì dừng chương trình
    if(index < 0 && index > count) throw out_of_range("""");
//! nếu chưa có phần tử nào và thêm vào đầu danh sách 
    else if(count == 0 || index == count ) add(e);
    else if(index == 0){
//! xử lý con trỏ
        Node* tmp = new Node(e);
        tmp->next = head;
        head->previous = tmp;
        head = tmp;
        count  ++;
    }
    else{
//! tạo 2 node curr và prev lưu node ở vị trí chèn và node trước vị trí chèn
        Node* curr = head->next,* prev = head;
        index --;  
        while(index){
            index--;
            prev = curr;
            curr= curr->next;
        }
//! thực hiện chèn node

        Node* tmp = new Node(e);
        prev->next = tmp;
        tmp->previous = prev;
        tmp->next = curr;
        curr->previous = tmp;
        count ++;
    }
    
}

template<class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1522696,2212651,"template<class T>
T DLinkedList<T>::get(int index) {
//! kiểm tra đầu vào có hợp lệ hay không
    if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){ 
        tmp = tmp->next;
        index --;
    }
    return tmp->data;
    
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
//! kiểm tra đầu vào có hợp lệ hay không
    if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){
        tmp = tmp->next;
        index --;
    }
    tmp->data = e;  
}

template<class T>
bool DLinkedList<T>::empty() {
    return count == 0;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
     //Return the first index wheter item appears in list, otherwise return -1 
    Node* tmp = head;
    int index = 0;
    while(tmp){
        if(tmp->data == item) return index;
        tmp = tmp->next;
        index ++;
    }
    return -1;
    
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    //Check if item appears in the list 
    Node* tmp = head;
    while(tmp){
        if(tmp->data == item) return true;
        tmp = tmp->next;
    }
    return false;
    
}",1.0,1111111111
Doubly_Linked_List_4,1522696,2212651,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T>* pList , bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    
   this->pList = pList;
   if(pList == NULL){index = -1;}
   else if(begin){
        if(this->pList->size() == 0){this->current = NULL;index = -1;}
        else{ this->current = pList->head;index = 0;}
   }
   else{
        this->current = NULL;
        if(this->pList->size() == 0) index = this->pList->size();
        else index = pList->size();
   }
    
    
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    // cout << this->index;
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */

   if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    if(index == 0){

        this->pList->removeAt(index);
        this->index = -1;
        current = NULL;
    }
    else{
        T e = this->pList->removeAt(index-1);
        this->index = index - 1;
        current->data = e;
      
}
}
template <class T>
void DLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}   

template <class T>
T& DLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
   if(current == NULL) throw out_of_range(""Segmentation fault!"");
   //cout << current->data;
   return current->data;
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
   return !(iterator.index == this->index || iterator.current == this->current);
}
// Prefix ++ overload
template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    DLinkedList<T>::Iterator t = *this;
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return t;
}
",1.0,1111111111
Doubly_Linked_List_5,1522696,2212651,"
template <class T>
T DLinkedList<T>::removeAt(int index)
{
    T result;
//! kiểm tra đầu vào
    if(index < 0 && index >= count) throw out_of_range("""");
//! nếu chỉ có 1 phần tử
    if(count == 1){
        result = head->data;
        delete head;
        head = tail = NULL;
    }
//! nhiều hơn 1 phần tử và ở vị trí đầu tiên
    else if(index == 0){
        Node* tmp = head;
        head = head->next;
        result = tmp->data;
        delete tmp;
        head->previous = NULL;
    }
    else{
        Node* tmp = head;
//! tìm vị trí trước vị trí cần xóa
        index --; 
        while(index){
            tmp = tmp->next;
            index --;
        }
//! lưu vị giá trị xóa đi
        result = tmp->next->data;
//! nếu nó là vị trí cuối cùng
        if(tmp->next == tail){
            delete tail;
            tail = tmp;
            tail->next = NULL;
        }
        else{
            Node* h = tmp->next;
            tmp->next = tmp->next->next;
            tmp->next->previous = tmp;
            delete h;
        }
    }
    count --;
    return result;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    int index = indexOf(item);
    if(index == -1) return false;
    removeAt(index);
    return true;
    
}

template<class T>
void DLinkedList<T>::clear(){
    Node* tmp = head;
    while(head){
        head = head->next;
        delete tmp;
        tmp = head;
    }
    head = tail = NULL;
    count = 0;  
}",1.0,1111111111
Doubly_Linked_List_6,1522696,2212651,"
DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_front(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
    
}

void DataLog::addCurrentState(int number)
{
    *currentState += number; 
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
 //! Di chuyển con trỏ currentState lên một bước để trỏ tới phần tử tiếp theo trong danh sách.
     currentState++;
//! Kiểm tra nếu currentState không trỏ tới cuối danh sách.     
     if(currentState != logList.end()){
         list<int>::iterator curr = currentState;
         list<int>::iterator prev = currentState;
        while(curr != logList.end()){
            curr++;
            logList.erase(prev);
            prev = curr;
        }
        currentState = logList.end();
       
    }
    currentState--;
  
    logList.push_back(*currentState);
    currentState++;
    //  for (auto i = logList.begin(); i != logList.end(); i++) {
    //         cout << ""[ "" << *i << "" ] => "";
    //     }
    //     cout<<endl;

}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState != logList.begin())
        --currentState;
}
void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     ++currentState;
    if(currentState == logList.end()) --currentState;
  
    
}
   ",1.0,1111111111
Doubly_Linked_List_8,1522696,2212651,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    ListNode *tmp = head;
    ListNode *tmp1 = head;
    int range = b-a+1;
    for (int i=1; i<a; i++)
        tmp = tmp->right;
    
    for (int i=1; i<b; i++)
        tmp1 = tmp1->right;
    
    for (int i=0; i<range/2; i++){
        ListNode *rtmp = tmp->right;
        ListNode *ltmp = tmp->left;
        ListNode *ltmp1 = tmp1->left;
        ListNode *rtmp1 = tmp1->right;
        if (ltmp)
            ltmp->right = tmp1;
        if (rtmp1)
            rtmp1->left = tmp;
        tmp1->left = ltmp;
        tmp->right = rtmp1;
        if (rtmp == tmp1){
            tmp->left = tmp1;
            tmp1->right = tmp;
        }
        else if (rtmp == ltmp1){
            rtmp->left = tmp1;
            rtmp->right = tmp;
            tmp1->right = rtmp;
            tmp->left = rtmp;
        }
        else{
            rtmp->left = tmp1;
            tmp1->right = rtmp;
            ltmp1->right = tmp;
            tmp->left = ltmp1;
        }
        if (ltmp == nullptr)
            head = tmp1;
        ListNode *p = tmp;
        tmp = tmp1;
        tmp1 = p;
        tmp1 = tmp1->left;
        tmp = tmp->right;
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1525019,2213250,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while(head != nullptr){
        popBack();
    }
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if (head != nullptr) {
        Node* newNode = new Node(i,nullptr,head);
        head->left = newNode;
        head = newNode;
    }
    else {
        Node* newNode = new Node(i,nullptr,nullptr);
        head = newNode;
        tail = newNode;
    }
    
    curSize++;
}

void Deque::pushBack(int i) {
    if (head == nullptr){
        Node* newNode = new Node(i,nullptr,nullptr);
        head = newNode;
        tail = newNode;
    } else {
        Node* newNode = new Node(i,tail,nullptr);
        tail->right = newNode;
        tail = newNode;
    }
    curSize += 1;
}

int Deque::popFront() {
    if (head == nullptr)
        return -1;
    int item = head->value;
    Node* temp = head;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}

int Deque::popBack() {
    if (head == nullptr)
        return -1;
    int item = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1525019,2213250,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    if(head== NULL){
        head = new Node(e);
        tail = head;
        count++;
    }
    else{
    Node* add = new Node(e);
    tail-> next = add;
    add-> previous = tail;
    tail = add;
    count++;
    }
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 

    if(index <0 || index> count) throw out_of_range ("" "");
    else if( count == index){
        add(e);
    }
    else if(head == NULL){        
        head = new Node(e);
        tail = head;
        count++;}
    else if(index == 0){
            Node* add = new Node(e);
        head-> previous = add;
        add-> next = head;
        head = add;
        count++;
    }
    else{
        Node* run = head;
            Node* add = new Node(e);
        for(int i = 0; i < index; i++){
            run = run -> next;
        }
        Node* prev = run -> previous;
        prev-> next = add;
        add-> next = run;
        add-> previous = prev;
        run-> previous = add;
        count++;
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1525019,2213250,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index > count) throw out_of_range ("" "");
    Node* run = head;
    for(int i = 0; i< index; i++){
        run = run-> next;
    }
    return run -> data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
        if(index < 0 || index > count) throw out_of_range ("" "");
    Node* run = head;
    for(int i = 0; i< index; i++){
        run = run-> next;
    }
    run-> data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !head;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* run = head;
    for(int i = 0; i< count; i++){
        if(run-> data == item) return i;
        run = run-> next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
       Node* run = head;
    for(int i = 0; i< count; i++){
        if(run-> data == item) return true;
        run = run-> next;
    }
    return false;
}",1.0,1111111111
Doubly_Linked_List_4,1525019,2213250,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    if(begin == true)
    {
        this->pList = pList;
        if(pList == NULL)
        {
            current = NULL;
            index =-1;
        }
        else
        {
            current = pList->head;
            index =0;
        }
    }
    else
    {
        this->pList =pList;
        current = NULL;
        index = pList->size();
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data =e;
    //this->set(index,e);
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (!current) throw std::out_of_range(""Segmentation fault!"");
    current = current->previous;
    pList->removeAt(index);
    index--;
    
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (current != iterator.current && index != iterator.index);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if(index == -1) 
    {
        index =0;
        current = this->pList->head;
    }
    else if(current == NULL) throw std::out_of_range(""Segmentation fault!"");
    else
    {
        current = current ->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}







",1.0,1111111111
Doubly_Linked_List_5,1525019,2213250,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(index <0 || index >= count) throw out_of_range("" "");
    if(count  == 0) throw out_of_range("" "");
    if(index == 0)
    {
        Node *p =head;
        T a = head->data;
        head = head->next;
        if(head != NULL) head->previous =NULL;
        else tail =NULL;
        p->next =NULL;
        
        delete p;
        count --;
        return a;
    }
    if(index == count-1)
    {
        Node*p = tail;
        tail = tail->previous;
        if(tail!=NULL) tail->next =NULL;
        else head= NULL;
        p->previous = NULL;
        T a = p->data;
        delete p;
        count --;
        return a;
    }
    Node*p = head;
    for(int i =0;i<index;i++) p = p->next;
    Node*next = p->next;
    Node* prev = p->previous;
    T a =p->data;
    prev->next = next;
    next->previous = prev;
    p->next=NULL;
    p->previous =NULL;
    delete p;
    count--;
    return a;
    
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(count == 0) return false;
    if(head -> data == item)
    {
        Node* p = head;
        head=head->next;
        p->next =NULL;
        if(head!=NULL)head->previous =NULL;
        else tail = NULL;
        delete p;
        count--;
        return true;
    }
    Node* p =head;
    while(p->next !=NULL)
    {
        if(p->next->data == item)
        {
            Node*temp =p->next;
            Node*next = temp->next;
            p->next = next;
            if(next!= NULL) next->previous = p;
            else tail = p;
            temp->next=NULL;
            temp->previous=NULL;
            delete temp;
            count--;
            return true;
        }
        p=p->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while(head!=NULL)
    {
        Node*p=head;
        head=head->next;
        p->next =NULL;
        if(head!=NULL) head->previous =NULL;
        delete p;
    }
    count=0;
    tail = NULL;
}
",1.0,1111111111
Doubly_Linked_List_6,1525019,2213250,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
     logList.push_front(0);
     currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
     logList.push_front(data);
     currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *(currentState) = *(currentState) + number;
    
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *(currentState) = *(currentState) - number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
     list<int>::iterator currentState1 = logList.end();
     currentState1--;
     while(currentState1 != currentState)
     {
        currentState1--;
        logList.pop_back();
     }
     logList.push_back(*currentState);
     currentState = logList.end();currentState--;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if(currentState != logList.begin()) currentState--;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     currentState = logList.end();
     currentState--;
     
}
",1.0,1111111111
Doubly_Linked_List_8,1525019,2213250,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    if(a == b) return head;
    if(head->right == NULL) return head;
    ListNode*pa =head;
    ListNode* pb = head;
    
    for(int i=1;i<b;i++)
    {
        if(i == a) pa = pb;
        pb =pb->right;
    }
    for(int i= a,j=b;i<j;i++,j--)
    {
        if(pa->right == pb)
        {
            pa->right =pb->right;
            if(pb->right!= NULL) pb->right->left =pa;
            pb->left = pa->left;
            if(pa->left!=NULL) pa->left->right = pb;
            pb->right =pa;
            pa->left =pb;
            continue;
        }
        if(head == pa) head =pb;
        ListNode*tempa =pa;
        ListNode*tempb = pb;
        pa=pa->right;
        pb = pb->left;
        tempa->right = tempb->right;
        if(tempb->right !=NULL) tempb->right->left =tempa;
        tempb->right = pa;
        pa->left = tempb;
        tempb->left = tempa->left;
        if(tempa->left != NULL) tempa->left->right = tempb;
        tempa->left = pb;
        pb->right = tempa;
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1526837,2013048,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i);
    if (curSize == 0) {
        head = newNode;
        tail = newNode;
    } else {
        newNode->right = head;
        head->left = newNode;
        head = newNode;
    }
    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i);
    if (curSize == 0) {
        head = newNode;
        tail = newNode;
    } else {
        newNode->left = tail;
        tail->right = newNode;
        tail = newNode;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1; // Return -1 when the deque is empty
    }
    int value = head->value;
    Node* temp = head;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return value;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1; // Return -1 when the deque is empty
    }
    int value = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return value;
}

void Deque::clear() {
    while (curSize > 0) {
        popFront();
    }
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value;
        if (current->left != nullptr) {
            cout << "" "";
        }
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value;
        if (current->right != nullptr) {
            cout << "" "";
        }
        current = current->right;
    }
    cout << endl;
}
",1.0,1111111111
Doubly_Linked_List_1,1527236,2213836,"#include <iostream>

Deque::Deque() : head(nullptr), tail(nullptr), curSize(0) {}

Deque::~Deque() {
    clear();
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int item) {
    Node* newNode = new Node(item, nullptr, head);
    if (head != nullptr) {
        head->left = newNode;
    } else {
        tail = newNode;
    }
    head = newNode;
    curSize++;
}

void Deque::pushBack(int item) {
    Node* newNode = new Node(item, tail, nullptr);
    if (tail != nullptr) {
        tail->right = newNode;
    } else {
        head = newNode;
    }
    tail = newNode;
    curSize++;
}

int Deque::popFront() {
    if (head == nullptr) {
        return -1; // Deque is empty
    }
    int value = head->value;
    Node* nextNode = head->right;
    delete head;
    head = nextNode;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    curSize--;
    return value;
}

int Deque::popBack() {
    if (tail == nullptr) {
        return -1; // Deque is empty
    }
    int value = tail->value;
    Node* prevNode = tail->left;
    delete tail;
    tail = prevNode;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    curSize--;
    return value;
}

void Deque::clear() {
    while (head != nullptr) {
        Node* nextNode = head->right;
        delete head;
        head = nextNode;
    }
    tail = nullptr;
    curSize = 0;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        std::cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1527236,2213836,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *node = new Node(e);
    if (!head) {
        head = tail = node;
    }
    else {
        node->previous = tail;
        tail->next = node;
        tail = node;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) return;
    if (index == count) {
        add(e);
        return;
    }
    Node *cursor = head;
    for (int i = 0; i < index; i++) {
        cursor = cursor->next;
    }
    Node *node = new Node(e);
    node->previous = cursor->previous;
    cursor->previous = node;
    node->next = cursor;
    if (node->previous)
        node->previous->next = node;
    else head = node;
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1527236,2213836,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count || !head)
        throw std::out_of_range(""Index is out of range"");
    Node *cursor = head;
    for (int i = 0; i < index; i++) {
        cursor = cursor->next;
    } return cursor->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count || !head)
        throw std::out_of_range(""Index is out of range"");
    Node *cursor = head;
    for (int i = 0; i < index; i++) {
        cursor = cursor->next;
    } cursor->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (!head) return true;
    return false;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *cursor = head;
    for (int i = 0; i < count; i++) {
        if (cursor->data == item) return i;
        cursor = cursor->next;
    } return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if (indexOf(item) != -1) return true;
    return false;
}",1.0,1111111111
Doubly_Linked_List_4,1527236,2213836,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this -> pList = pList;
    if (begin){
        if (pList == nullptr){
            index = -1;
            current = nullptr;
        }
        else{
            index = 0;
            current = pList -> head;
        }
    }
    else{
        current = nullptr;
        if (pList != nullptr) index = pList -> count;
        else index = 0;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    pList = iterator.pList;
    index = iterator.index;
    current = iterator.current;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == nullptr) throw out_of_range(""Segmentation Fault"");
    current -> data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*()
{
    if (current == nullptr) throw out_of_range(""Segmentation Fault"");
    return current -> data;
}

template<class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
    * TODO: delete Node in pList which Node* current point to.
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current == nullptr) throw out_of_range(""Segmentation Fault"");
    if (this -> index == 0){
        //int index = this -> index;
        this -> pList -> removeAt(index);
        this -> index = -1;
        current = nullptr;
    }
    else {
        current = current -> previous;
        //int index = this -> index;
        this -> pList -> removeAt(index);
        this -> index -= 1;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    return !(current == iterator.current && index == iterator.index);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()
{
    if (index == pList -> size()) throw out_of_range(""Segmentation Fault"");
    else if(index == -1){
        current = pList -> head;
        index = 0;
    }
    else{
        current = current -> next;
        index += 1;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    Iterator temp = *this;
    if (index == pList -> size()) throw out_of_range(""Segmentation Fault"");
    else if(index == -1){
        current = pList -> head;
        index = 0;
    }
    else{
        current = current -> next;
        index += 1;
    }
    return temp;
}",1.0,1111111111
Doubly_Linked_List_5,1527236,2213836,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index >= count || index< 0) throw out_of_range(""Segmentation Fault"");
    T res;
    if (count == 1){
        res = head -> data;
        clear();
        return res;
    }
    if (index == 0){
        Node* temp = head;
        head = head -> next;
        T res = temp -> data;
        delete temp;
        count -=1;
        return res;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++){
        temp = temp -> next;
    }
    res = temp -> data;
    temp -> previous -> next = temp -> next;
    if (index == count - 1){
        tail = temp -> previous;
    }
    else temp -> next -> previous = temp -> previous;
    delete temp;
    count -= 1;
    return res;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int i = 0;
    Node* temp = head;
    while (temp != nullptr){
        if (temp -> data == item){
            removeAt(i);
            return true;
        }
        temp = temp -> next;
        i += 1;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while(head != nullptr){
        Node* temp = head;
        head = head -> next;
        delete temp;
    }
    head = tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1527236,2213836,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(10);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState = *currentState + number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState = *currentState - number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the
     *       currentState Iterator, we delete them all before creating a new state.
     */

    while(*currentState != logList.back()){
        logList.pop_back();
    }
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
   if(currentState != logList.begin()) currentState--;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    auto currenStateOriginal = currentState;
    ++currentState;
    if (currentState == logList.end()){
        currentState = currenStateOriginal;
    }
}",1.0,1111111111
Doubly_Linked_List_8,1527236,2213836,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode l = nullptr, ListNode r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    if (head == NULL || head->right == NULL) {
        return head;
    }

    ListNode* node = new ListNode(0, NULL, head);
    ListNode* pre = node;
    for (int i = 1; i < a; i++) {
        pre = pre->right;
    }

    ListNode* cur = pre->right;
    for (int i = a; i < b; i++) {
        ListNode* next = cur->right;
        cur->right = next->right;
        next->left = cur;
        next->right = pre->right;
        pre->right->left = next;
        pre->right = next;
    }

    return node->right;
}",1.0,1111111111
Doubly_Linked_List_1,1527598,1912532,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head != nullptr) {
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    tail = nullptr;
    curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int item) {
    Node* newNode = new Node(item, nullptr, head);
    if (head != nullptr) {
        head->left = newNode;
    }
    head = newNode;
    if (tail == nullptr) {
        tail = newNode;
    }
    curSize++;
}

void Deque::pushBack(int item) {
    Node* newNode = new Node(item, tail, nullptr);
    if (tail != nullptr) {
        tail->right = newNode;
    }
    tail = newNode;
    if (head == nullptr) {
        head = newNode;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1; // Deque is empty
    }
    int item = head->value;
    Node* temp = head;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr; // Deque is now empty
    }
    delete temp;
    curSize--;
    return item;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1; // Deque is empty
    }
    int item = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr; // Deque is now empty
    }
    delete temp;
    curSize--;
    return item;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}
",1.0,1111111111
Doubly_Linked_List_2,1527598,1912532,"template<class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* p = new Node(e);

    ++count;
    if (head == NULL || count == 1)
    {
        head = p;
        tail = p;
        return;
    }

    tail->next = p;
    p->previous = tail;
    tail = p;
    //tail->next = NULL;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index<0 || index>count)
        throw std::out_of_range(""The index is out of range!"");

    if (index == count)
    {
        add(e);
        return;
    }

    Node* p = new Node(e);


    if (index == 0)
    {
        p->next = head;
        head->previous = p;
        head = p;
    }

    else
    {
        int dem = 1;
        for (Node* k = head; k != NULL; k = k->next)
        {
            if (dem == index)
            {
                p->next = k->next;
                k->next = p;
                p->previous = k;
                p->next->previous = p;
                break;
            }
            ++dem;
        }
    }
    ++count;
}

template<class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1527598,1912532,"template<class T>
T DLinkedList<T>::get(int index) {
    if (index < 0 || index >= count)
        throw std::out_of_range(""The index is out of range!"");

    int dem = 0;
    Node* k = head;
    for (; k != NULL; k = k->next, ++dem)
        if (dem == index)
            return k->data;

    return k->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    int dem = 0;
    for (Node* k = head; k != NULL; k = k->next, ++dem)
    {
        if (dem == index)
        {
            k->data = e;
            return;
        }
    }
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0) ? true : false;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int dem = 0;
    for (Node* k = head; k != NULL; k = k->next, ++dem)
        if (k->data == item)
            return dem;

    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    int dem = 0;
    for (Node* k = head; k != NULL; k = k->next, ++dem)
        if (k->data == item)
            return true;

    return false;
}",1.0,1111111111
Doubly_Linked_List_4,1527598,1912532,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T>* pList, bool begin)
{
    /*
    Constructor of iterator
    * Set pList to pList
    * begin = true:
    * * Set current (index = 0) to pList's head if pList is not NULL
    * * Otherwise set to NULL (index = -1)
    * begin = false:
    * * Always set current to NULL
    * * Set index to pList's size if pList is not NULL, otherwise 0
*/
    this->pList = pList;

    if (begin)
    {
        if (pList != NULL)
        {
            this->current = this->pList->head;
            this->index = 0;
        }

        else
        {
            this->current = NULL;
            this->index = -1;
        }
    }

    else
    {
        this->current = NULL;
        if (this->pList != NULL)
            this->index = this->pList->size();
        else
            this->index = 0;
    }

}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{   
    this->current = iterator.current;
    this->pList = iterator.pList;
    this->index = iterator.index;

    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    if(this->current==NULL)
        throw std::out_of_range(""The index is out of range!"");

    else if (this->index==0)
    {
        this->pList->removeAt(0);  
        this->current = NULL;
        this->index = -1;
    }

    else
    {
        for (Node* k = this->pList->head; k != NULL; k = k->next)
        {
            if (k->next == this->current)
            {
                this->pList->removeAt(this->index);
                this->current = k;
                --this->index;
                return;
            }
        }
    }
}

template <class T>
void DLinkedList<T>::Iterator::set(const T& e)
{
    if (this->current != NULL)
    {
        this->current->data = e;
        return;
    }

    throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
T& DLinkedList<T>::Iterator::operator*()
{
    if (current != NULL)
        return current->data;  

    throw std::out_of_range(""Segmentation fault!"");
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    return ((this->current != iterator.current) && (this->index != iterator.index)) ? true : false;
}
// Prefix ++ overload
template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()
{
    /*
    Prefix ++ overload
    * Set current to the next node
    * If iterator corresponds to the previous ""node"" of head, set it to head
    * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
*/



    if (this->index == -1)
        this->current = this->pList->head;

    else
        this->current = this->current->next;

    ++this->index;

    return *this;
}
// Postfix ++ overload
template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    Iterator p = *this;

    if (this->index == -1)
        this->current = this->pList->head;

    else
        this->current = this->current->next;

    ++this->index;

    return p;
}",1.0,1111111111
Doubly_Linked_List_5,1527598,1912532,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count)
        throw std::out_of_range(""The index is out of range!"");

    T data{};
    if (count == 1)
    {
        data = head->data;
        delete head;
        head = NULL;
        tail = NULL;
    }

    else if (index == 0)
    {
        data = head->data;
        head = head->next;
        delete head->previous;
        head->previous = NULL;
    }

    else if (index == count - 1)
    {
        data = tail->data;
        tail = tail->previous;
        delete tail->next;
        tail->next = NULL;
    }

    else
    {
        int dem = 1;
        for (Node* k = head; k != NULL; k = k->next)/////////////////////////////////////////////////////////////////////////
        {
            if (dem == index)
            {
                data = k->next->data;
                k->next = k->next->next;
                delete k->next->previous;
                k->next->previous = NULL;
                k->next->previous = k;
                break;
            }
            ++dem;
        }

    }
    --count;
    return data;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int dem = 0;
    for (Node* k = head; k != NULL; k = k->next)
    {
        if (k->data == item)
        {
            removeAt(dem);
            return true;
        }
        ++dem;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear() {
    /* Remove all elements in list */
    for (int i = 0; i < count; )
        removeAt(0);

}",1.0,1111111111
Doubly_Linked_List_6,1527598,1912532,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_front(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    list<int>::iterator i = logList.end();
    i--;
    if(currentState == i)
    {
        logList.push_back(*currentState);
        currentState++;
    }
    else
    {
        list<int>::iterator i = currentState;
        i++;
        logList.erase(i,logList.end());
        logList.push_back(*currentState);
        currentState++;
    }
    
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState == logList.begin()) return;
    currentState--;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    list<int>::iterator i = logList.end();
    i--;
    if(currentState == logList.end() || currentState == i)   return;
    currentState++;
}",1.0,1111111111
Doubly_Linked_List_2,1528853,2211878,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* pNew = new Node(e);
    if (this->head == NULL) {
        this->head = this->tail = pNew;
    }
    else {
        this->tail->next = pNew;
        pNew->previous = this->tail;
        this->tail = pNew;
    }
    ++this->count;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index > this->count || index < 0) {
		throw (""out of range"");
		return;
	}
		
	if (index == this->count && this->count != 0) {
		add(e);
		return;
	}
	
	Node* pNew = new Node(e);
	if (this->count == 0) 
        this->head = this->tail = pNew;
    else if (index == 0) {
        pNew->next = this->head;
        this->head->previous = pNew;
        this->head = pNew;
    }
    else {
        Node* prev = this->head;
        for (int i = 0; i < index - 1; i++) prev = prev->next;
        Node* cur = prev->next;
        pNew->next = prev->next;
        cur->previous = pNew;
        pNew->previous = prev;
        prev->next = pNew;
    }
    ++this->count;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1528853,2211878,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0) index = 0;
    if(index >= count) index = count -1;
    int i = 0;
    Node * temp = head;
    while(temp && i < index){
        i++;
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index > count) return;
    int i = 0;
    Node * temp = head;
    while(temp && i < index){
        i++;
        temp = temp->next;
    }
    if(!temp) return;
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count==0);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node * temp = head;
    int i = 0;
    while(temp && temp->data != item){
        temp = temp->next;
        i++;
    }
    if(!temp) return -1;
    return i;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1528853,2211878,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
	if (begin == true)
	{
		if (this->pList == NULL)
		{
			this->current = NULL;
			this->index = -1;
		}
		else
		{
			this->current = this->pList->head;
			this->index = 0;
		}
	}
	else
	{
		this->current = NULL;
		this->index = (this->pList->count == 0) ? (this->pList->size()) : 0;
	}
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
	this->current = iterator.current;
	this->index = iterator.index;
	return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else
		this->pList->set(this->index, e);
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == this->pList->head)
	{
		this->current = NULL;
		this->pList->removeAt(this->index);
		this->index = -1;
	}
	else
	{
		this->current = this->current->previous;
		this->pList->removeAt(this->index);
		--this->index;
	}
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (this->pList != iterator.pList || this->current != iterator.current);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == NULL && this->index == -1)
	{
		this->current = this->pList->head;
		this->index = 0;
	}
	else
	{
		this->current = this->current->next;
		++this->index;
	}
	return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator newIterator(this->pList, true);
	if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else {
	    newIterator = *this;
	    ++*this;
	    return newIterator;
	}
}",1.0,1111111111
Doubly_Linked_List_5,1528853,2211878,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= this->count)
        throw std::out_of_range(""The index is out of range!"");
    T dataDel;
    Node* temp = this->head;
    if (this->count == 1) {
        dataDel = this->head->data;
        delete this->head;
        this->head = this->tail = NULL;
    }
    else if (index == 0) {
        dataDel = temp->data;
        this->head = temp->next;
        delete temp;
        temp = this->head;
        this->head->previous = NULL;
    }
    else if (index == this->count - 1) {
        while (temp->next->next != NULL) temp = temp->next;
        dataDel = this->tail->data;
        delete this->tail;
        this->tail = temp;
        temp->next = NULL;
    }
    else {
        for (int i = 0; i < index; i++) temp = temp->next;
        dataDel = temp->data;
        temp->previous->next = temp->next;
        temp->next->previous = temp->previous;
        delete temp;
        temp = NULL;
    }
    --this->count;
    return dataDel;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int index = this->indexOf(item);
    if (index != -1) {
        this->removeAt(index);
        return true;
    }
    return false;
}

template <class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (this->count != 0) this->removeAt(0);
}
",1.0,1111111111
Doubly_Linked_List_6,1528853,2211878,"DataLog::DataLog()
{
	logList.push_back(0);
	currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
	logList.push_back(data);
	currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
	*this->currentState = *this->currentState + number;
}

void DataLog::subtractCurrentState(int number)
{
	*this->currentState = *this->currentState - number;
}

void DataLog::save()
{
	list<int>::iterator a = currentState;
	++a;
	while (a != logList.end()) {
		a = logList.erase(a);
	}
	logList.push_back(*currentState);
	++currentState;
}

void DataLog::undo()
{
	if (currentState != logList.begin()) currentState = prev(currentState, 1);
}

void DataLog::redo()
{
	list<int>::iterator a = currentState;
	list<int>::iterator b = ++a;
	if (b != logList.end()) ++currentState;
}",1.0,1111111111
Doubly_Linked_List_8,1528853,2211878,"ListNode* reverse(ListNode* head, int a, int b) 
{
    ListNode* travel = head;
    ListNode* prev;
    ListNode* trav = head;
    int count = b - a + 1;
    for (int j = 1; j <= b; j++) trav = trav->right;
    if (a != 1) 
    {
        for (int i = 1; i < a; i++) travel = travel->right;
        prev = travel->left;
    } else prev = nullptr;

    ListNode* temp = NULL;
    ListNode* current = travel;
    while (current != NULL and count > 0) 
    {
        temp = current->left;
        current->left = current->right;
        current->right = temp;
        current = current->left;
        count--;
    }
    if (trav == nullptr and a == 1)
    {
        if (temp != NULL) head = temp->left;
        return head;
    } 
    if (trav != nullptr)
    {
        travel->right = trav;
        trav->left = travel;
    }

    if (temp != NULL and prev != nullptr) 
    {
        prev->right = temp->left;
        temp = temp->left;
        temp->left = prev;
    }
    
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1529689,2210535,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while(head != nullptr){
        popBack();
    }
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if (head != nullptr) {
        Node* newNode = new Node(i,nullptr,head);
        head->left = newNode;
        head = newNode;
    }
    else {
        Node* newNode = new Node(i,nullptr,nullptr);
        head = newNode;
        tail = newNode;
    }
    
    curSize++;
}

void Deque::pushBack(int i) {
    if (head == nullptr){
        Node* newNode = new Node(i,nullptr,nullptr);
        head = newNode;
        tail = newNode;
    } else {
        Node* newNode = new Node(i,tail,nullptr);
        tail->right = newNode;
        tail = newNode;
    }
    curSize += 1;
}

int Deque::popFront() {
    if (head == nullptr)
        return -1;
    int item = head->value;
    Node* temp = head;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}

int Deque::popBack() {
    if (head == nullptr)
        return -1;
    int item = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}
",1.0,1111111111
Doubly_Linked_List_2,1529689,2210535,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newnode = new Node(e);
    if (head == nullptr && tail == nullptr && count == 0) {
        head = newnode;
        tail = newnode;
        count++;
    }
    else {
        tail->next = newnode;
        newnode->previous = tail;
        tail = newnode;
        count++;
    }
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at the given index. */
    if (index < 0 || index > count) throw out_of_range(""Index out of range"");

    if (index == count) {
        add(e);
    }
    else if (index == 0) {
        Node* newnode = new Node(e);
        newnode->next = head;
        if (head) {
            head->previous = newnode;
        }
        head = newnode;
        if (tail == nullptr) {
            tail = newnode;
        }
        count++;
    }
    else {
        Node* temp = head;
        while (index > 0) {
            if (temp == nullptr) {
                throw out_of_range(""Index out of range"");
            }
            temp = temp->next;
            index--;
        }
        Node* newnode = new Node(e);
        newnode->next = temp;
        newnode->previous = temp->previous;
        temp->previous = newnode;
        if (newnode->previous) {
            newnode->previous->next = newnode;
        }
        else {
            head = newnode;
        }
        count++;
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of the list */
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1529689,2210535,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    Node* temp = head;
    while (index != 0 && temp) {
        temp = temp->next;
        index--;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw out_of_range("" "");
    }
    Node* temp = head;
    while (index != 0 && temp) {
        temp = temp->next;
        index--;
    }
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
     if (this->count == 0) {
        return true;
    }
    else return false;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while (temp) {
        if (temp->data == item) {
            return i;
        }
        temp = temp->next;
        i++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    if (indexOf(item) != -1) {
        return true;
    }
    else return false;
}",1.0,1111111111
Doubly_Linked_List_4,1529689,2210535,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    if (begin == true)  {
        this->pList = pList;
        if (pList == nullptr)   {
            current = nullptr;
            index = -1;
        }
        else {
            current = pList->head;
            index = 0;
        }
    }
    else {
        this->pList = pList;
        current = nullptr;
        index = pList->size();
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == nullptr) {
        throw out_of_range(""Segmentation fault!"");
    }
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (current == nullptr) {
        throw out_of_range(""Segmentation fault!"");
    }
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current == nullptr) {
        throw out_of_range(""Segmentation fault!"");
    }
    current = current->previous;
    this->pList->removeAt(index);
    index = index-1;
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (current != iterator.current && index != iterator.index);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{   
    if (index == -1)    {
        index = 0;
        current = this->pList->head;
    }
    else {
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}",1.0,1111111111
Doubly_Linked_List_5,1529689,2210535,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(index <0 || index >= count) throw out_of_range("" "");
    if(count  == 0) throw out_of_range("" "");
    if(index == 0)
    {
        Node *p =head;
        T a = head->data;
        head = head->next;
        if(head != NULL) head->previous =NULL;
        else tail =NULL;
        p->next =NULL;
        
        delete p;
        count --;
        return a;
    }
    if(index == count-1)
    {
        Node*p = tail;
        tail = tail->previous;
        if(tail!=NULL) tail->next =NULL;
        else head= NULL;
        p->previous = NULL;
        T a = p->data;
        delete p;
        count --;
        return a;
    }
    Node*p = head;
    for(int i =0;i<index;i++) p = p->next;
    Node*next = p->next;
    Node* prev = p->previous;
    T a =p->data;
    prev->next = next;
    next->previous = prev;
    p->next=NULL;
    p->previous =NULL;
    delete p;
    count--;
    return a;
    
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(count == 0) return false;
    if(head -> data == item)
    {
        Node* p = head;
        head=head->next;
        p->next =NULL;
        if(head!=NULL)head->previous =NULL;
        else tail = NULL;
        delete p;
        count--;
        return true;
    }
    Node* p =head;
    while(p->next !=NULL)
    {
        if(p->next->data == item)
        {
            Node*temp =p->next;
            Node*next = temp->next;
            p->next = next;
            if(next!= NULL) next->previous = p;
            else tail = p;
            temp->next=NULL;
            temp->previous=NULL;
            delete temp;
            count--;
            return true;
        }
        p=p->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while(head!=NULL)
    {
        Node*p=head;
        head=head->next;
        p->next =NULL;
        if(head!=NULL) head->previous =NULL;
        delete p;
    }
    count=0;
    tail = NULL;
}",1.0,1111111111
Doubly_Linked_List_6,1529689,2210535,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    list<int>::iterator temp = logList.end();
    temp--;
    
    while (temp != currentState)
    {
        temp--;
        logList.pop_back();
    }

    logList.push_back(*currentState);
    currentState = --logList.end();
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if (currentState != logList.begin())   {
         currentState--;
     }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    currentState = logList.end();
    currentState--;
}
",1.0,1111111111
Doubly_Linked_List_8,1529689,2210535,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    if (a == b) return head;
    
    ListNode* startNode = head;
    ListNode* endNode = head;
    ListNode* prevNodeA = nullptr;
    ListNode* nextNodeB = nullptr;
    
    for (int i = 1; i < a; i++) {
        prevNodeA = startNode;
        startNode = startNode->right;
    }
    
    for (int i = 1; i < b; i++) {
        endNode = endNode->right;
    }
    nextNodeB = endNode->right;
    ListNode* currentNode = startNode;
    ListNode* prev = nextNodeB;
    
    while (currentNode != nextNodeB) {
        ListNode* next = currentNode->right;
        currentNode->right = prev;
        currentNode->left = next;
        prev = currentNode;
        currentNode = next;
    }
    if (prevNodeA) {
        prevNodeA->right = endNode;
    } else {
        head = endNode;
    }
    
    startNode->right = nextNodeB;
    
    if (nextNodeB) {
        nextNodeB->left = startNode;
    }
    
    endNode->left = prevNodeA;
    
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1532476,2212372,"Deque::Deque() {
head = nullptr;
tail = nullptr;
curSize = 0;
}

Deque::~Deque() {
Node *temp = nullptr;
while (head) {
temp = head;
head = head->right;
delete temp;
}

head = tail = nullptr;
curSize = 0;
}

void Deque::clear() {
Node *temp = nullptr;
while (head) {
temp = head;
head = head->right;
delete temp;
}
head = tail = nullptr;
curSize = 0;
}

int Deque::getSize() {
return curSize;
}

void Deque::pushFront(int i) {
Node *newNode = new Node(i);
if (curSize==0) {
head = tail = newNode;
curSize++;
}
else {
newNode->right = head;
head->left = newNode;
head = newNode;
curSize++;
}

}

void Deque::pushBack(int i) {
Node *newNode = new Node(i);
if (curSize == 0) {
head = tail = newNode;
}
else {
tail->right = newNode;
newNode->left = tail;
tail = newNode;
}
curSize++;
}

int Deque::popFront() {
if (!head) return -1;
Node *temp = head;
int ans = temp->value;
head = head->right;
if (head) head->left = nullptr;
delete temp;
curSize--;
if (curSize == 0) {
    head = tail = nullptr;
}
return ans;
}

int Deque::popBack() {
if (!tail) return -1;
Node *temp = tail;
int ans = temp->value;
tail = tail->left;
if (tail) tail->right = nullptr;
curSize--;
if (curSize==0) {
    head = tail = nullptr;
}
return ans;
}

void Deque::printDequeReverse() {
Node *temp = tail;
int i=0;
while (i < curSize) {
cout << temp->value << "" "";
temp = temp->left;
i++;
}
cout << '\n';
}

void Deque::printDeque() {
Node *temp = head;
int i=0;
while (i<curSize) {
cout << temp->value << "" "";
temp = temp->right;
i++;
}
cout << '\n';
}",1.0,1111111111
Doubly_Linked_List_2,1532476,2212372,"template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* temp = new Node(e);
    if(head == NULL){
        head = tail = temp;
        count++;
    } else {
        tail->next = temp;
        temp->previous = tail;
        tail = temp;
        count++;
    }
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
     if (index < 0 || index > this->count)
    {
        throw std::out_of_range(""Out of range"");
    }


    if (index == 0)
    {
        Node* newNode = new Node(e);
        newNode->next = head;
        if (head != nullptr)
        {
            head->previous = newNode;
        }
        head = newNode;

        if (count == 0)
        {
            tail = newNode;
        }
    }
    else if (index == count)
    {   Node* newNode = new Node(e);
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    }
    else
    {Node* newNode = new Node(e);
        Node* temp = head;
        for (int i = 0; i < index - 1; i++)
        {
            temp = temp->next;
        }

        newNode->previous = temp;
        newNode->next = temp->next;

        if (temp->next != nullptr)
        {
            temp->next->previous = newNode;
        }

        temp->next = newNode;
    }

    this->count++;
}

template<class T>
int DLinkedList<T>::size() {
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1532476,2212372,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        return -1;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        return;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(head == nullptr) return true;
    return false;
    // return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while(temp != nullptr){
        if(temp->data == item) return i;
        i++;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_1,1532488,2213035,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head)
    {
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    tail = nullptr;
    curSize = 0;    
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
    if (head) {
        head->left = newNode;
    }
    head = newNode;
    if (!tail) {
        tail = head;
    }
    curSize++;
}

void Deque::pushBack(int i) {
    Node* temp = new Node(i, tail, nullptr);
    if (tail) {
        tail->right = temp;
    }
    tail = temp;
    if (!head) {
        head = tail;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1;
    }
    int result = head->value;
    Node* temp = head;
    head = head->right;
    if (head) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1; 
    }
    int result = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout<<endl;
}",1.0,1111111111
Doubly_Linked_List_2,1532488,2213035,"template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* temp = new Node(e);
    if(head == NULL){
        head = tail = temp;
        count++;
    } else {
        tail->next = temp;
        temp->previous = tail;
        tail = temp;
        count++;
    }
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
     if (index < 0 || index > this->count)
    {
        throw std::out_of_range(""Out of range"");
    }


    if (index == 0)
    {
        Node* newNode = new Node(e);
        newNode->next = head;
        if (head != nullptr)
        {
            head->previous = newNode;
        }
        head = newNode;

        if (count == 0)
        {
            tail = newNode;
        }
    }
    else if (index == count)
    {   Node* newNode = new Node(e);
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    }
    else
    {Node* newNode = new Node(e);
        Node* temp = head;
        for (int i = 0; i < index - 1; i++)
        {
            temp = temp->next;
        }

        newNode->previous = temp;
        newNode->next = temp->next;

        if (temp->next != nullptr)
        {
            temp->next->previous = newNode;
        }

        temp->next = newNode;
    }

    this->count++;
}

template<class T>
int DLinkedList<T>::size() {
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1532488,2213035,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        return -1;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        return;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(head == nullptr) return true;
    return false;
    // return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while(temp != nullptr){
        if(temp->data == item) return i;
        i++;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}
",1.0,1111111111
Doubly_Linked_List_4,1532488,2213035,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this->pList = pList;
    if (begin)
    {
        if (pList != NULL)
        {
            this->current = pList->head;
            index = 0;
        }
        else
        {
            this->current = nullptr;
            index = -1;
        }
    }
    else
    {
        this->current = nullptr;
        if (pList != NULL)
        {
            index = pList->size();
        }
        else
        {
            index = 0;
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == NULL)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current->data = e;
    }
}

template <class T>
T &DLinkedList<T>::Iterator::operator*()
{
    if (current == NULL)
    {

        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        return current->data;
    }
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
     * TODO: delete Node in pList which Node* current point to.
     *       After that, Node* current point to the node before the node just deleted.
     *       If we remove first node of pList, Node* current point to nullptr.
     *       Then we use operator ++, Node* current will point to the head of pList.
     */
    if (current == nullptr)
    {
        return;
    }

    Node *nodeToRemove = current;
    current = current->previous;

    if (current != nullptr)
    {
        current->next = nodeToRemove->next;
    }
    else
    {
        pList->head = nodeToRemove->next;
    }

    if (nodeToRemove->next != nullptr)
    {
        nodeToRemove->next->previous = current;
    }
    else
    {
        pList->tail = current;
    }

    delete nodeToRemove;
    pList->count--;

    if (index > 0)
    {
        index--;
    }
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    if (this->pList == iterator.pList && this->current == iterator.current && this->index == iterator.index)
        return false;
    return true;
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator++()
{
    if (current == nullptr)
    {
        index = 0;
        current = this->pList->head;
        return *this;
    }
    current = current->next;
    index += 1;
    return *this;
}

template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    DLinkedList<T>::Iterator iterator = *this;
    ++*this;
    return iterator;
}",1.0,1111111111
Doubly_Linked_List_5,1532488,2213035,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count) {
        return -1;
    }

    if (index == 0) {
        Node* removedNode = head;
        T removedValue = removedNode->data;
        head = head->next;
        if (head == nullptr) {
            tail = nullptr;
        }
        delete removedNode;
        count--;
        return removedValue;
    } else {
        Node* previous = head;
        for (int i = 0; i < index - 1; i++) {
            previous = previous->next;
        }

        Node* removedNode = previous->next;
        T removedValue = removedNode->data;
        previous->next = removedNode->next;
        if (removedNode == tail) {
            tail = previous;
        }
        delete removedNode;
        count--;
        return removedValue;
    }
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(contains(item) == true)
    return removeAt(indexOf(item))==item;
    return false;
    
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
        Node* current = head;
        head = head->next;
        delete current;
    }
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1532488,2213035,"DataLog::DataLog()
{
    logList = list<int>();
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    logList = list<int>();
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    (*currentState) += number;
}

void DataLog::subtractCurrentState(int number)
{
    (*currentState) -= number;
}

void DataLog::save()
{
    logList.erase(next(currentState, 1), logList.end());
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    if (currentState == logList.begin())
        return;
    currentState--;
}

void DataLog::redo()
{
    if (next(currentState, 1) == logList.end())
        return;
    currentState++;
}",1.0,1111111111
Doubly_Linked_List_8,1532488,2213035,"ListNode *reverse(ListNode *head, int l, int r)
{
    if (!head || !head->right || l == r)
        return head;

    ListNode *prev = nullptr;
    ListNode *current = nullptr;

    for (int i = 0; i < l; i += 1)
    {
        if (current == nullptr)
            current = head;
        else
        {
            prev = current;
            current = current->right;
        };
    }

    ListNode *start = current;
    for (int i = l; i < r; i += 1)
    {
        current = current->right;
    }
    ListNode *end = current;

    if (prev != nullptr)
    {
        prev->right = end;
    }
    else
    {
        // is head
        head = end;
    }
    if (end->right)
    {
        end->right->left = start;
    }
    prev = end->right;
    while (start != end)
    {
        ListNode *next = start->right;
        start->right = prev;
        start->left = next;
        prev = start;
        start = next;
    }
    start->right = prev;

    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1532489,2212741,"Deque::Deque() : head(nullptr), tail(nullptr), curSize(0) {}

Deque::~Deque() {
    clear();
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int item) {
    Node* newNode = new Node(item, nullptr, head);
    if (curSize == 0) {
        head = tail = newNode;
    } else {
        head->left = newNode;
        head = newNode;
    }
    curSize++;
}

void Deque::pushBack(int item) {
    Node* newNode = new Node(item, tail, nullptr);
    if (curSize == 0) {
        head = tail = newNode;
    } else {
        tail->right = newNode;
        tail = newNode;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1;
    }
    int result = head->value;
    Node* temp = head;
    if (curSize == 1) {
        head = tail = nullptr;
    } else {
        head = head->right;
        head->left = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1;
    }
    int result = tail->value;
    Node* temp = tail;
    if (curSize == 1) {
        head = tail = nullptr;
    } else {
        tail = tail->left;
        tail->right = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

void Deque::clear() {
    while (curSize > 0) {
        popFront();
    }
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        std::cout << current->value << "" "";
        current = current->left;
    }
    std::cout << std::endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->value << "" "";
        current = current->right;
    }
    std::cout << std::endl;
}
",1.0,1111111111
Doubly_Linked_List_2,1532489,2212741,"template <class T>
void DLinkedList<T>::add(const T &e) {
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template <class T>
void DLinkedList<T>::add(int index, const T &e) {
    if (index < 0 || index > count) {
        // Index out of bounds
        return;
    }

    if (index == count) {
        // Adding to the end of the list
        add(e);
        return;
    }

    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        newNode->previous = current;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
}

template <class T>
int DLinkedList<T>::size() {
    return count;
}
",1.0,1111111111
Doubly_Linked_List_3,1532489,2212741,"template <class T>
bool DLinkedList<T>::empty() {
    return count == 0;
}

template <class T>
T DLinkedList<T>::get(int index) {
    if (index < 0 || index >= count) {
        // Index out of bounds
        return T(); // Return a default-constructed object for invalid index
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }

    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T &e) {
    if (index < 0 || index >= count) {
        // Index out of bounds
        return;
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }

    current->data = e;
}

template <class T>
int DLinkedList<T>::indexOf(const T &item) {
    Node* current = head;
    for (int i = 0; i < count; i++) {
        if (current->data == item) {
            return i;
        }
        current = current->next;
    }

    return -1; // Item not found
}

template <class T>
bool DLinkedList<T>::contains(const T &item) {
    return indexOf(item) != -1;
}
",1.0,1111111111
Doubly_Linked_List_4,1532489,2212741,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if (begin) {
        this->current = pList->head;
        this->index = 0;
    } else {
        this->current = NULL;
        this->index = pList->count;
    }

}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
        this->current = iterator.current;
    this->index = iterator.index;
    return *this;

}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current != NULL) {
        this->current->data = e;
    }

}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current != NULL && this->pList != NULL) {
        Node* nodeToRemove = this->current;

        if (nodeToRemove == this->pList->head) {
            this->pList->head = nodeToRemove->next;
        }

        if (nodeToRemove == this->pList->tail) {
            this->pList->tail = nodeToRemove->previous;
        }

        if (nodeToRemove->next != NULL) {
            nodeToRemove->next->previous = nodeToRemove->previous;
        }

        if (nodeToRemove->previous != NULL) {
            nodeToRemove->previous->next = nodeToRemove->next;
            this->current = nodeToRemove->previous;
        } else {
            this->current = NULL;
        }

        delete nodeToRemove;
        this->pList->count--;
    }

}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
        return this->current != iterator.current;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
        if (this->current != NULL) {
        this->current = this->current->next;
    } else if (this->pList != NULL) {
        this->current = this->pList->head;
    }
    
    return *this;

}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator iteratorBeforeIncrementation(*this);
    
    ++*this;

    return iteratorBeforeIncrementation;

}
",1.0,1111111111
Doubly_Linked_List_5,1532489,2212741,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count)
        throw out_of_range(""Index out of range"");

    Node *currentNode = head;
    T removedData;

    if (index == 0)
    {
        head = currentNode->next;
        if (head != nullptr)
            head->previous = nullptr;
        else
            tail = nullptr;
        removedData = currentNode->data;
        delete currentNode;
    }
    else
    {
        for (int i = 0; i < index - 1; i++)
        {
            currentNode = currentNode->next;
        }

        Node *nodeToRemove = currentNode->next;
        Node *nextNode = nodeToRemove->next;

        currentNode->next = nextNode;
        if (nextNode != nullptr)
            nextNode->previous = currentNode;
        else
            tail = currentNode;

        removedData = nodeToRemove->data;
        delete nodeToRemove;
    }

    count--;
    return removedData;
}

template <class T>
bool DLinkedList<T>::removeItem(const T &item)
{
    Node *currentNode = head;
    Node *prevNode = nullptr;

    while (currentNode != nullptr)
    {
        if (currentNode->data == item)
        {
            if (prevNode == nullptr)
            {
                head = currentNode->next;
                if (head != nullptr)
                    head->previous = nullptr;
                else
                    tail = nullptr;
            }
            else
            {
                prevNode->next = currentNode->next;
                if (currentNode->next != nullptr)
                    currentNode->next->previous = prevNode;
                else
                    tail = prevNode;
            }

            delete currentNode;
            count--;
            return true;
        }

        prevNode = currentNode;
        currentNode = currentNode->next;
    }

    return false;
}

template <class T>
void DLinkedList<T>::clear()
{
    Node *currentNode = head;

    while (currentNode != nullptr)
    {
        Node *nextNode = currentNode->next;
        delete currentNode;
        currentNode = nextNode;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1532489,2212741,"DataLog::DataLog() {
    // Add the first state with 0
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data) {
    // Add the first state with data
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number) {
    // Increase the value of the current state by number
    *currentState += number;
}

void DataLog::subtractCurrentState(int number) {
    // Decrease the value of the current state by number
    *currentState -= number;
}

void DataLog::save() {
    // Create a new state, copy the data of the currentState, and move the currentState Iterator to this new state.
    if (currentState != prev(logList.end())) {
        logList.erase(next(currentState), logList.end());
    }
    logList.push_back(*currentState);
    currentState = prev(logList.end());
}

void DataLog::undo() {
    // Switch to the previous state of the data
    if (currentState != logList.begin()) {
        --currentState;
    }
}

void DataLog::redo() {
    // Switch to the latter state of the data
    if (currentState != prev(logList.end())) {
        ++currentState;
    }
}
",1.0,1111111111
Doubly_Linked_List_1,1532686,2212372,"Deque::Deque() {
head = nullptr;
tail = nullptr;
curSize = 0;
}

Deque::~Deque() {
Node *temp = nullptr;
while (head) {
temp = head;
head = head->right;
delete temp;
}

head = tail = nullptr;
curSize = 0;
}

void Deque::clear() {
Node *temp = nullptr;
while (head) {
temp = head;
head = head->right;
delete temp;
}
head = tail = nullptr;
curSize = 0;
}

int Deque::getSize() {
return curSize;
}

void Deque::pushFront(int i) {
Node *newNode = new Node(i);
if (curSize==0) {
head = tail = newNode;
curSize++;
}
else {
newNode->right = head;
head->left = newNode;
head = newNode;
curSize++;
}

}

void Deque::pushBack(int i) {
Node *newNode = new Node(i);
if (curSize == 0) {
head = tail = newNode;
}
else {
tail->right = newNode;
newNode->left = tail;
tail = newNode;
}
curSize++;
}

int Deque::popFront() {
if (!head) return -1;
Node *temp = head;
int ans = temp->value;
head = head->right;
if (head) head->left = nullptr;
delete temp;
curSize--;
if (curSize == 0) {
    head = tail = nullptr;
}
return ans;
}

int Deque::popBack() {
if (!tail) return -1;
Node *temp = tail;
int ans = temp->value;
tail = tail->left;
if (tail) tail->right = nullptr;
curSize--;
if (curSize==0) {
    head = tail = nullptr;
}
return ans;
}

void Deque::printDequeReverse() {
Node *temp = tail;
int i=0;
while (i < curSize) {
cout << temp->value << "" "";
temp = temp->left;
i++;
}
cout << '\n';
}

void Deque::printDeque() {
Node *temp = head;
int i=0;
while (i<curSize) {
cout << temp->value << "" "";
temp = temp->right;
i++;
}
cout << '\n';
}",1.0,1111111111
Doubly_Linked_List_2,1532686,2212372,"
template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* temp = new Node(e);
    if(head == NULL){
        head = tail = temp;
        count++;
    } else {
        tail->next = temp;
        temp->previous = tail;
        tail = temp;
        count++;
    }
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
     if (index < 0 || index > this->count)
    {
        throw std::out_of_range(""Out of range"");
    }


    if (index == 0)
    {
        Node* newNode = new Node(e);
        newNode->next = head;
        if (head != nullptr)
        {
            head->previous = newNode;
        }
        head = newNode;

        if (count == 0)
        {
            tail = newNode;
        }
    }
    else if (index == count)
    {   Node* newNode = new Node(e);
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    }
    else
    {Node* newNode = new Node(e);
        Node* temp = head;
        for (int i = 0; i < index - 1; i++)
        {
            temp = temp->next;
        }

        newNode->previous = temp;
        newNode->next = temp->next;

        if (temp->next != nullptr)
        {
            temp->next->previous = newNode;
        }

        temp->next = newNode;
    }

    this->count++;
}

template<class T>
int DLinkedList<T>::size() {
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1532686,2212372,"
template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        return -1;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        return;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(head == nullptr) return true;
    return false;
    // return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while(temp != nullptr){
        if(temp->data == item) return i;
        i++;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1532686,2212372,"
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this->pList = pList;
    if (begin)
    {
        if (pList != NULL)
        {
            this->current = pList->head;
            index = 0;
        }
        else
        {
            this->current = nullptr;
            index = -1;
        }
    }   
    else
    {
        this->current = nullptr;
        if (pList != NULL)
        {
            index = pList->size();
        }
        else
        {
            index = 0;
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == NULL)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current->data = e;
    }
}

template <class T>
T &DLinkedList<T>::Iterator::operator*()
{
    if (current == NULL)
    {

        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        return current->data;
    }
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
     * TODO: delete Node in pList which Node* current point to.
     *       After that, Node* current point to the node before the node just deleted.
     *       If we remove first node of pList, Node* current point to nullptr.
     *       Then we use operator ++, Node* current will point to the head of pList.
     */
    if (current == nullptr)
    {
        return;
    }

    Node *nodeToRemove = current;
    current = current->previous;

    if (current != nullptr)
    {
        current->next = nodeToRemove->next;
    }
    else
    {
        pList->head = nodeToRemove->next;
    }

    if (nodeToRemove->next != nullptr)
    {
        nodeToRemove->next->previous = current;
    }
    else
    {
        pList->tail = current;
    }

    delete nodeToRemove;
    pList->count--;

    if (index > 0)
    {
        index--;
    }
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    if (this->pList == iterator.pList && this->current == iterator.current && this->index == iterator.index)
        return false;
    return true;
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator++()
{
    if (current == nullptr)
    {
        index = 0;
        current = this->pList->head;
        return *this;
    }
    current = current->next;
    index += 1;
    return *this;
}

template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    DLinkedList<T>::Iterator iterator = *this;
    ++*this;
    return iterator;
}
",1.0,1111111111
Doubly_Linked_List_5,1532686,2212372,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count) {
        return -1;
    }

    if (index == 0) {
        Node* removedNode = head;
        T removedValue = removedNode->data;
        head = head->next;
        if (head == nullptr) {
            tail = nullptr;
        }
        delete removedNode;
        count--;
        return removedValue;
    } else {
        Node* previous = head;
        for (int i = 0; i < index - 1; i++) {
            previous = previous->next;
        }

        Node* removedNode = previous->next;
        T removedValue = removedNode->data;
        previous->next = removedNode->next;
        if (removedNode == tail) {
            tail = previous;
        }
        delete removedNode;
        count--;
        return removedValue;
    }
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(contains(item) == true)
    return removeAt(indexOf(item))==item;
    return false;
    
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
        Node* current = head;
        head = head->next;
        delete current;
    }
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1532686,2212372,"

DataLog::DataLog()
{
    logList = list<int>();
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    logList = list<int>();
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    (*currentState) += number;
}

void DataLog::subtractCurrentState(int number)
{
    (*currentState) -= number;
}

void DataLog::save()
{
    logList.erase(next(currentState, 1), logList.end());
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    if (currentState == logList.begin())
        return;
    currentState--;
}

void DataLog::redo()
{
    if (next(currentState, 1) == logList.end())
        return;
    currentState++;
}
",1.0,1111111111
Doubly_Linked_List_8,1532686,2212372,"
ListNode *reverse(ListNode *head, int l, int r)
{
    if (!head || !head->right || l == r)
        return head;

    ListNode *prev = nullptr;
    ListNode *current = nullptr;

    for (int i = 0; i < l; i += 1)
    {
        if (current == nullptr)
            current = head;
        else
        {
            prev = current;
            current = current->right;
        };
    }

    ListNode *start = current;
    for (int i = l; i < r; i += 1)
    {
        current = current->right;
    }
    ListNode *end = current;

    if (prev != nullptr)
    {
        prev->right = end;
    }
    else
    {
        // is head
        head = end;
    }
    if (end->right)
    {
        end->right->left = start;
    }
    prev = end->right;
    while (start != end)
    {
        ListNode *next = start->right;
        start->right = prev;
        start->left = next;
        prev = start;
        start = next;
    }
    start->right = prev;

    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1533245,2211878,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i);
    if (curSize == 0) {
        head = newNode;
        tail = newNode;
    } else {
        newNode->right = head;
        head->left = newNode;
        head = newNode;
    }
    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i);
    if (curSize == 0) {
        head = newNode;
        tail = newNode;
    } else {
        newNode->left = tail;
        tail->right = newNode;
        tail = newNode;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1; // Return -1 when the deque is empty
    }
    int value = head->value;
    Node* temp = head;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return value;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1; // Return -1 when the deque is empty
    }
    int value = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return value;
}

void Deque::clear() {
    while (curSize > 0) {
        popFront();
    }
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value;
        if (current->left != nullptr) {
            cout << "" "";
        }
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value;
        if (current->right != nullptr) {
            cout << "" "";
        }
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533245,2211878,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* pNew = new Node(e);
    if (this->head == NULL) {
        this->head = this->tail = pNew;
    }
    else {
        this->tail->next = pNew;
        pNew->previous = this->tail;
        this->tail = pNew;
    }
    ++this->count;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */
    if (index > this->count || index < 0) {
		throw (""out of range"");
		return;
	}
		
	if (index == this->count && this->count != 0) {
		add(e);
		return;
	}
	
	Node* pNew = new Node(e);
	if (this->count == 0) 
        this->head = this->tail = pNew;
    else if (index == 0) {
        pNew->next = this->head;
        this->head->previous = pNew;
        this->head = pNew;
    }
    else {
        Node* prev = this->head;
        for (int i = 0; i < index - 1; i++) prev = prev->next;
        Node* cur = prev->next;
        pNew->next = prev->next;
        cur->previous = pNew;
        pNew->previous = prev;
        prev->next = pNew;
    }
    ++this->count;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1533245,2211878,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0) index = 0;
    if(index >= count) index = count -1;
    int i = 0;
    Node * temp = head;
    while(temp && i < index){
        i++;
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index > count) return;
    int i = 0;
    Node * temp = head;
    while(temp && i < index){
        i++;
        temp = temp->next;
    }
    if(!temp) return;
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count==0);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node * temp = head;
    int i = 0;
    while(temp && temp->data != item){
        temp = temp->next;
        i++;
    }
    if(!temp) return -1;
    return i;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1533245,2211878,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
	if (begin == true)
	{
		if (this->pList == NULL)
		{
			this->current = NULL;
			this->index = -1;
		}
		else
		{
			this->current = this->pList->head;
			this->index = 0;
		}
	}
	else
	{
		this->current = NULL;
		this->index = (this->pList->count == 0) ? (this->pList->size()) : 0;
	}
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
	this->current = iterator.current;
	this->index = iterator.index;
	return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else
		this->pList->set(this->index, e);
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == this->pList->head)
	{
		this->current = NULL;
		this->pList->removeAt(this->index);
		this->index = -1;
	}
	else
	{
		this->current = this->current->previous;
		this->pList->removeAt(this->index);
		--this->index;
	}
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (this->pList != iterator.pList || this->current != iterator.current);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == NULL && this->index == -1)
	{
		this->current = this->pList->head;
		this->index = 0;
	}
	else
	{
		this->current = this->current->next;
		++this->index;
	}
	return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator newIterator(this->pList, true);
	if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else {
	    newIterator = *this;
	    ++*this;
	    return newIterator;
	}
}",1.0,1111111111
Doubly_Linked_List_5,1533245,2211878,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= this->count)
        throw std::out_of_range(""The index is out of range!"");
    T dataDel;
    Node* temp = this->head;
    if (this->count == 1) {
        dataDel = this->head->data;
        delete this->head;
        this->head = this->tail = NULL;
    }
    else if (index == 0) {
        dataDel = temp->data;
        this->head = temp->next;
        delete temp;
        temp = this->head;
        this->head->previous = NULL;
    }
    else if (index == this->count - 1) {
        while (temp->next->next != NULL) temp = temp->next;
        dataDel = this->tail->data;
        delete this->tail;
        this->tail = temp;
        temp->next = NULL;
    }
    else {
        for (int i = 0; i < index; i++) temp = temp->next;
        dataDel = temp->data;
        temp->previous->next = temp->next;
        temp->next->previous = temp->previous;
        delete temp;
        temp = NULL;
    }
    --this->count;
    return dataDel;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int index = this->indexOf(item);
    if (index != -1) {
        this->removeAt(index);
        return true;
    }
    return false;
}

template <class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (this->count != 0) this->removeAt(0);
}
",1.0,1111111111
Doubly_Linked_List_6,1533245,2211878,"DataLog::DataLog()
{
	logList.push_back(0);
	currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
	logList.push_back(data);
	currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
	*this->currentState = *this->currentState + number;
}

void DataLog::subtractCurrentState(int number)
{
	*this->currentState = *this->currentState - number;
}

void DataLog::save()
{
	list<int>::iterator a = currentState;
	++a;
	while (a != logList.end()) {
		a = logList.erase(a);
	}
	logList.push_back(*currentState);
	++currentState;
}

void DataLog::undo()
{
	if (currentState != logList.begin()) currentState = prev(currentState, 1);
}

void DataLog::redo()
{
	list<int>::iterator a = currentState;
	list<int>::iterator b = ++a;
	if (b != logList.end()) ++currentState;
}",1.0,1111111111
Doubly_Linked_List_8,1533245,2211878,"ListNode* reverse(ListNode* head, int a, int b) 
{
    ListNode* travel = head;
    ListNode* prev;
    ListNode* trav = head;
    int count = b - a + 1;
    for (int j = 1; j <= b; j++) trav = trav->right;
    if (a != 1) 
    {
        for (int i = 1; i < a; i++) travel = travel->right;
        prev = travel->left;
    } else prev = nullptr;

    ListNode* temp = NULL;
    ListNode* current = travel;
    while (current != NULL and count > 0) 
    {
        temp = current->left;
        current->left = current->right;
        current->right = temp;
        current = current->left;
        count--;
    }
    if (trav == nullptr and a == 1)
    {
        if (temp != NULL) head = temp->left;
        return head;
    } 
    if (trav != nullptr)
    {
        travel->right = trav;
        trav->left = travel;
    }

    if (temp != NULL and prev != nullptr) 
    {
        prev->right = temp->left;
        temp = temp->left;
        temp->left = prev;
    }
    
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1533251,2212303,"Deque::Deque() {
    this->head=nullptr;
    this->tail=nullptr;
    this->curSize=0;
}

Deque::~Deque() {
    this->clear();
}

void Deque::clear() {
     while (head) {
            Node* temp = head;
            head = head->right;
            delete temp;
        }
        tail = nullptr;
        curSize = 0;
}

int Deque::getSize() {
    return this->curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
        if (head) {
            head->left = newNode;
        } else {
            tail = newNode;
        }
        head = newNode;
        curSize++;
}

void Deque::pushBack(int i) {
     Node* newNode = new Node(i, tail, nullptr);
        if (tail) {
            tail->right = newNode;
        } else {
            head = newNode;
        }
        tail = newNode;
        curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
            return -1;
        }
        int value = head->value;
        Node* oldHead = head;
        head = head->right;
        delete oldHead;
        if (head) {
            head->left = nullptr;
        } else {
            tail = nullptr;
        }
        curSize--;
        return value;
}

int Deque::popBack() {
   if (curSize == 0) {
            return -1;
        }
        int value = tail->value;
        Node* oldTail = tail;
        tail = tail->left;
        delete oldTail;
        if (tail) {
            tail->right = nullptr;
        } else {
            head = nullptr;
        }
        curSize--;
        return value;
}

void Deque::printDequeReverse() {
   Node* curr=this->tail;
   while(curr!=this->head){
       if(curr==nullptr) break;
       cout<<curr->value<<"" "";
       curr=curr->left;
   }
   if(curr!=nullptr) cout<<curr->value<<endl;
}

void Deque::printDeque() {
   Node* curr=this->head;
   while(curr!=this->tail){
        if(curr==nullptr) break;
       cout<<curr->value<<"" "";
       curr=curr->right;
   }
   if(curr!=nullptr) cout<<curr->value<<endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533251,2212303,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newN=new Node(e);
    if(this->count==0){
        this->head=newN;
        this->tail=newN;
    }
    else{
    newN->previous=this->tail;
    this->tail->next=newN;
    this->tail=this->tail->next;
    }
    this->count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index<0) return;
    if(this->count==0) {this->add(e); return;}
    Node* curr=this->head;
    Node* prev=nullptr;
    for(int i=0; i<index && curr!=nullptr; i++){
        prev=curr;
        curr=curr->next;
    }
    
    Node* newN=new Node(e);
    
        newN->previous=prev;
    
    newN->next=curr;
    if(prev!=nullptr){
        prev->next=newN;
        
    }else{
        this->head=newN;
    }
    if(curr!=nullptr){
        curr->previous=newN;
        
    }else{
        this->tail=newN;
    }
    this->count++;
    
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1533251,2212303,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    //if(index<0) throw std::out_of_range(""Out of bounds"");
    //if(index>=this->count) return this->tail->data;
    Node* curr=this->head;
    
    for(int i=0; i<index && curr!=nullptr; i++){
        
        curr=curr->next;
    }
    
    return curr->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    //if(index<0) {throw std::out_of_range(""Out of bounds""); return;}
    //if(index>=this->count)  {this->tail->data=e; return;}
    Node* curr=this->head;
    
    for(int i=0; i<index && curr!=nullptr; i++){
        
        curr=curr->next;
    }
    curr->data=e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (this->head==nullptr);
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int result=-1;
    Node* curr=this->head;
    int index=0;
    while(curr!=nullptr){
        
        if(curr->data==item){
            result=index;
            break;
        }
        index++;
        curr=curr->next;
    }
    return result;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (this->indexOf(item)!=-1);
}",1.0,1111111111
Doubly_Linked_List_4,1533251,2212303,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    //if (pList!= nullptr){  
        this->pList=pList;
        if (begin){
            if (pList!=nullptr) {
                this->current=pList->head;
                this->index=0;
            }else this->index=-1;
        } else {
            this->current=nullptr;
            if(pList!=nullptr) index=pList->count;
            else index=0;
        }
    //}
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList=iterator.pList;
    this->index=iterator.index;
    this->current=iterator.current;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(current!=nullptr) current->data=e;
    else throw std::out_of_range(""Segmentation fault!"");
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
     if(current!=nullptr) return current->data;
    else throw std::out_of_range(""Segmentation fault!"");
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }

    if (current == pList->head /*&& index == 0 && pList->head != nullptr*/) {
        // Removing the head node
        //Iterator temp = *this;
        //pList->head = pList->head->next;
        //if(pList->count==1){
            //pList->head==nullptr;
            //pList->tail==nullptr;
        //}
        //pList->head=pList->head->next;
        //if(pList->head!=nullptr) pList->head->previous=nullptr;
        pList->removeAt(0);
        current = nullptr; // Updated to previous ""node"" of head
        index = -1;
        //pList->count--;
        //Iterator temp = *this;
        //this==temp++;
    } else {
        // Removing a non-head node
        Node* temp=current->previous;
         /*Node* temp=current->previous;
        temp->next=current->next;
        if(current->next!=nullptr){
            current->next->previous=temp;
        }*/
        pList->removeAt(index);
        
        
        // Move the iterator to the previous node
        current=temp;
        //pList->count--;
        index--;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (!(this->current==iterator.current && this-> index==iterator.index ));
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
     if (current == pList->tail) {
                //throw std::out_of_range(""Segmentation fault!"");
        current=nullptr;
        this->index=pList->count;
        
    }
    else{
        if (/*current->next == pList->head||*/current==nullptr&&index==-1) {
           current = pList->head;
           index = 0;
        }
        else {
           current = current->next;
           index++;
        }
    }
       
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    if (current == pList->tail) {
        //throw std::out_of_range(""Segmentation fault!"");
        current=nullptr;
        this->index=pList->count;
        
    }
    else{
        if (/*current->next == pList->head||*/current==nullptr&&index==-1) {
           current = pList->head;
           index = 0;
        }
        else {
           current = current->next;
           index++;
        }
    }
    return temp;
}

",1.0,1111111111
Doubly_Linked_List_5,1533251,2212303,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    
   
    Node* curr=this->head;
    
    for(int i=0; i<index && curr!=nullptr; i++){
       
        curr=curr->next;
    }
    T result=curr->data;
    this->count--;
    if(curr==this->head){
        this->head=curr->next;
    }
    if(curr==this->tail){
        this->tail=curr->previous;
    }
    if(this->head==nullptr ||  this->tail==nullptr){
        this->head=nullptr;
        this->tail=nullptr;
    }
    
    Node* prev=curr->previous;
    if(prev!=nullptr){
        prev->next=curr->next;
    }
    if(curr->next!=nullptr){
        curr->next->previous=prev;
    }
    curr=curr->next;
    
    return result;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int index=this->indexOf(item);
    if(index==-1) return false;
    else {
        this->removeAt(this->indexOf(item));
        return true;
    }
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while(!this->empty()){
        this->removeAt(0);
    }
}
",1.0,1111111111
Doubly_Linked_List_6,1533251,2212303,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    if (logList.empty()) return;

    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
      this->addCurrentState(-number);
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
     if (!logList.empty()) {
            // Create a new state by copying the data of the current state
            int currVal = *currentState;
            logList.erase(++currentState, logList.end());
            logList.push_back(currVal);
            currentState = --logList.end();
    }
     
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
       if (currentState != logList.begin())
    {
        // Move currentState iterator to previous state
        currentState--;
    }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    if (currentState != --logList.end()) {
            // Switch to the next state
            ++currentState;
    }
}
",1.0,1111111111
Doubly_Linked_List_8,1533251,2212303,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};*/


ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    
    if (!head || a == b) {
        return head;
    }
    
     int length = b - a + 1;
    ListNode* dummy = new ListNode(0);
    dummy->right = head;
    head->left=dummy;
    
   
    
    ListNode* temp = head; // Start from the dummy node
    ListNode* nodeA = nullptr;
    ListNode* nodeB = nullptr;
    // Move temp to the node before position a
    for (int i = 1; i <=b; i++) {
        if(i==a) nodeA=temp;
        if(i==b) {nodeB=temp; break;}
        temp = temp->right;
        
    }

    
    while (length > 1) {
       if (nodeA->right == nodeB) {
			nodeA->right = nodeB->right;
			if (nodeB->right != nullptr)
				nodeB->right->left = nodeA;
			nodeB->right = nodeA;
			nodeB->left = nodeA->left;
			nodeA->left = nodeB;
			if (nodeB->left != nullptr)
				nodeB->left->right = nodeB;
		}
		else {
			ListNode* tempN = nodeA->right;
			nodeA->right = nodeB->right;
			if (nodeB->right != nullptr)
				nodeB->right->left = nodeA;
			nodeB->right = tempN;
			tempN->left = nodeB;
			nodeB->left->right = nodeA;
			ListNode* tempP = nodeB->left;
			nodeB->left = nodeA->left;
			if (nodeA->left != nullptr)
				nodeA->left->right = nodeB;
			nodeA->left = tempP;
		}
		ListNode* tempB=nodeB;
		nodeB=nodeA;
		nodeA=tempB;
        
        // Move nodeA and nodeB closer to the center of the range
        nodeA = nodeA->right;
        nodeB = nodeB->left;
        length -= 2;
    }

    return dummy->right;
}
",1.0,1111111111
Doubly_Linked_List_1,1533253,2212282,"Deque::Deque() {
    head = NULL;
    tail = NULL;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    Node* temp = head;
    while(head) {
        head = head->right;
        delete temp;
        temp = head;
    }
    head = NULL;
    tail = NULL;
    curSize=0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if(curSize == 0) {
        head = new Node(i);
        tail = head;
    }
    else {
        head->left = new Node(i, NULL, head);
        head = head->left;
    }
    ++curSize;
}

void Deque::pushBack(int i) {
    if(curSize == 0) {
        head = new Node(i);
        tail = head;
    }
    else {
        tail->right = new Node(i, tail, NULL);
        tail = tail->right;
    }
    ++curSize;
}

int Deque::popFront() {
    if(curSize == 0) return -1;
    int save = head->value;
    if(curSize == 1) {
        delete head;
        head = NULL;
        tail = NULL;
    }
    else {
        head = head->right;
        delete head->left;
        head->left = NULL;
    }
    --curSize;
    return save;
}

int Deque::popBack() {
    if(curSize == 0) return -1;
    int save = tail->value;
    if(curSize == 1) {
        delete tail;
        head = NULL;
        tail = NULL;
    }
    else {
        tail = tail->left;
        delete tail->right;
        tail->right = NULL;
    }
    --curSize;
    return save;
}

void Deque::printDequeReverse() {
    Node* tmp = tail;
    while(tmp != NULL) {
        cout << tmp->value << "" "";
        tmp = tmp->left;
    } 
    if(tail) cout << endl;
}

void Deque::printDeque() {
    Node* tmp = head;
    while(tmp != NULL) {
        cout << tmp->value << "" "";
        tmp = tmp->right;
    } 
    if(head) cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533253,2212282,"template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template <class T>
void DLinkedList<T>::add(int index, const T& e) {
    if (index < 0 || index > count) {
        std::cout << ""Invalid index."" << std::endl;
        return;
    }
    if (index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        newNode->previous = current;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
}

template <class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1533253,2212282,"template <class T>
bool DLinkedList<T>::empty() {
    return count == 0;
}
template <class T>
T DLinkedList<T>::get(int index) {
    if (index < 0 || index >= count) {
        std::cout << ""Invalid index."" << std::endl;
        return T();
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    if (index < 0 || index >= count) {
        std::cout << ""Invalid index."" << std::endl;
        return;
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template <class T>
int DLinkedList<T>::indexOf(const T& item) {
    Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;
}

template <class T>
bool DLinkedList<T>::contains(const T& item) {
    return indexOf(item) != -1;
}
",1.0,1111111111
Doubly_Linked_List_4,1533253,2212282,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this->pList = pList;
    if (begin) {
        current = pList->head;
        index = 0;
    } else {
        current = nullptr;
        index = pList->count;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current != nullptr) {
        current->data = e;
    }
}

template<class T>
T& DLinkedList<T>::Iterator::operator*()
{
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove()
{
    if (current != nullptr) {
        Node *prev = current->previous;
        Node *next = current->next;

        if (prev != nullptr) {
            prev->next = next;
        } else {
            pList->head = next;
        }

        if (next != nullptr) {
            next->previous = prev;
        } else {
            pList->tail = prev;
        }

        Node *temp = current;
        current = next; // Move current to the next node
        delete temp;

        pList->count--;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    return current != iterator.current;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()
{
    if (current != nullptr) {
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}

",0.8,1001111111
Doubly_Linked_List_5,1533253,2212282,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count)
        throw std::out_of_range(""Index out of range"");

    Node* current = head;
    Node* previous = nullptr;

    // Traverse to the node at the specified index
    for (int i = 0; i < index; i++)
    {
        previous = current;
        current = current->next;
    }

    // Remove the node from the list
    if (previous)
        previous->next = current->next;
    else
        head = current->next;

    if (current == tail)
        tail = previous;

    T removedData = current->data;
    delete current;
    count--;

    return removedData;
}

template <class T>
bool DLinkedList<T>::removeItem(const T &item)
{
    Node* current = head;
    Node* previous = nullptr;

    // Traverse the list to find the node containing the item
    while (current)
    {
        if (current->data == item)
        {
            // Remove the node from the list
            if (previous)
                previous->next = current->next;
            else
                head = current->next;

            if (current == tail)
                tail = previous;

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;
}

template <class T>
void DLinkedList<T>::clear()
{
    Node* current = head;
    while (current)
    {
        Node* next = current->next;
        delete current;
        current = next;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1533253,2212282,"DataLog::DataLog()
{
    logList.push_back(0);
    currentState = logList.begin();
}
DataLog::DataLog(const int &data)
{
   logList.push_back(data);
  currentState = logList.begin();
}
void DataLog::addCurrentState(int number)
{
    int data = getCurrentStateData();
   data += number;
   logList.push_back(data);
    currentState = --logList.end();
}
void DataLog::subtractCurrentState(int number)
{
   int data = getCurrentStateData();
    data -= number;
    logList.push_back(data);
    currentState = --logList.end();
}
void DataLog::save()
{
    if (currentState != --logList.end())
    {
        logList.erase(++currentState, logList.end());
        currentState = --logList.end();
    }
}
void DataLog::undo()
{
    if (currentState != logList.begin())
    {
       currentState--;
    }
}
void DataLog::redo()
{
    if (currentState != --logList.end())
    {
        currentState++;
    }
}
",0.3,1100001000
Doubly_Linked_List_8,1533253,2212282,"ListNode* reverse(ListNode* head, int a, int b) {
    if (head == nullptr || a >= b) {
        return head;
    }

    ListNode* dummy = new ListNode(-1);  // Create a dummy node
    dummy->right = head;
    ListNode* prev = dummy;

    // Move prev to the node before the sublist to be reversed
    for (int i = 0; i < a - 1; i++) {
        prev = prev->right;
    }

    ListNode* curr = prev->right;  // The current node within the sublist
    ListNode* next;  // Pointer to the next node in the sublist

    // Reverse the sublist from node 'a' to node 'b'
    for (int i = 0; i < b - a; i++) {
        next = curr->right;
        curr->right = next->right;
        next->right = prev->right;
        prev->right = next;
    }

    head = dummy->right;  // Update the head pointer
    delete dummy;  // Free the memory occupied by the dummy node

    return head;
}",0.9,1011111111
Doubly_Linked_List_1,1533254,2211821,"Deque::Deque() {
head = nullptr;
tail = nullptr;
curSize = 0;
}

Deque::~Deque() {
clear();
}

void Deque::clear() {
while (curSize > 0) {
            popFront();
        }
}

int Deque::getSize() {
 return curSize;
}

void Deque::pushFront(int item) {
        Node* newNode = new Node(item, nullptr, head);
        if (head != nullptr) {
            head->left = newNode;
        }
        head = newNode;
        if (tail == nullptr) {
            tail = head;
        }
        curSize++;
}

void Deque::pushBack(int item) {
        Node* newNode = new Node(item, tail, nullptr);
        if (tail != nullptr) {
            tail->right = newNode;
        }
        tail = newNode;
        if (head == nullptr) {
            head = tail;
        }
        curSize++;
}

int Deque::popFront() {
        if (curSize == 0) {
            return -1;
        }
        int value = head->value;
        Node* temp = head;
        head = head->right;
        if (head != nullptr) {
            head->left = nullptr;
        }
        if (temp == tail) {
            tail = nullptr;
        }
        delete temp;
        curSize--;
        return value;

}

int Deque::popBack() {
        if (curSize == 0) {
            return -1;
        }
        int value = tail->value;
        Node* temp = tail;
        tail = tail->left;
        if (tail != nullptr) {
            tail->right = nullptr;
        }
        if (temp == head) {
            head = nullptr;
        }
        delete temp;
        curSize--;
        return value;
}

void Deque::printDequeReverse() {
        Node* current = tail;
        while (current != nullptr) {
            std::cout << current->value << "" "";
            current = current->left;
        }
        std::cout << std::endl;
}

void Deque::printDeque() {
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->value << "" "";
            current = current->right;
        }
        std::cout << std::endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533254,2211821,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
     Node* x = new Node(e);
    if (tail == nullptr) {
        // If the list is empty, set both head and tail to the new node.
        head = x;
        tail = x;
    } else {
        tail->next = x;
        x->previous = tail;
        tail = x;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        // Invalid index, do nothing.
        return;
    }
    Node* x = new Node(e);
    if (index == 0) {
        // Insert at the beginning.
        if (head == nullptr) {
            // If the list is empty, set both head and tail to the new node.
            head = x;
            tail = x;
        } else {
            x->next = head;
            head->previous = x;
            head = x;
        }
    } else if (index == count) {
        // Insert at the end.
        tail->next = x;
        x->previous = tail;
        tail = x;
    } else {
        // Insert at a specific index.
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        x->next = current;
        x->previous = current->previous;
        current->previous->next = x;
        current->previous = x;
    }
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1533254,2211821,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of bounds"");
    }
    
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
     if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of bounds"");
    }
    
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    for (int i = 0; i < count; i++) {
        if (current->data == item) {
            return i;
        }
        current = current->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1533254,2211821,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) {
    this->pList = pList; 
    if (begin) {
        current = pList ? pList->head : nullptr; 
        index = pList ? 0 : -1; 
    }
    else {
        current = nullptr; 
        index = pList->size(); 
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator) {
    pList = iterator.pList; 
    current = iterator.current; 
    index = iterator.index; 
    return *this; 
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e) {
    if (current == nullptr) throw std::out_of_range(""Segmentation fault"");
    current->data = e; 
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() {
    if (current == nullptr) throw std::out_of_range(""Segmentation fault"");
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current == nullptr) throw std::out_of_range(""Segmentation fault"");
    Node* p = current->previous; 
    pList->removeAt(index--); 
    current = p; 
    // chu y 
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)  {
    return !(this->current == iterator.current && this->pList == iterator.pList && this->index == iterator.index); 
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() {
    if (current == nullptr && index == pList->size()) throw std::out_of_range(""Segmentation fault"");
    if (current == nullptr && index == -1) {
        current = pList->head; 
        index = 0; 
    }
    else {
        current = current->next; 
        index++;
    }
    return *this; 
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    if (current == nullptr && index == pList->size()) throw std::out_of_range(""Segmentation fault"");
    Iterator temp = *this; 
    if (current == nullptr && index == -1) {
        current = pList->head; 
    } 
    else current = current->next; 
    index++; 
    return temp; 
}",1.0,1111111111
Doubly_Linked_List_5,1533254,2211821,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) throw std::out_of_range(""""); 
    int x; 
    if (index) {
        Node* p = head; 
        while (index > 1 && p) {
            index--; p = p->next; 
        }
        if (tail == p->next) tail = p; 
        Node* temp = p->next; 
        p->next = p->next->next; 
        if (p->next != nullptr) p->next->previous = p; 
        x = temp->data; 
        delete temp; 
    }
    else {
        Node* temp = head; 
        head = head->next; 
        x = temp->data; 
        delete temp;
        if (head != nullptr) head->previous = nullptr; 
        if (count == 1) tail = nullptr; 
    }
    
    count--; 
    return x; 
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* p = head; 
    int idx = 0; 
    while (p && p->data != item) {
        p = p->next; 
        idx++; 
    }
    if (p) removeAt(idx); 
    else return false; 
    return true; 
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* cur = head; 
    while (cur) {
        Node* p = cur; 
        cur = cur->next; 
        delete p; 
    }
    head = nullptr; 
    tail = nullptr; 
    count = 0; 
}",1.0,1111111111
Doubly_Linked_List_6,1533254,2211821,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
      logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
      logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
     *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
     *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
      auto newState = currentState;
    ++newState;
    logList.erase(newState, logList.end());
    logList.push_back(*currentState);
    currentState = --logList.end();
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if (currentState != logList.begin())  --currentState;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     auto lastState = --logList.end();
    if (currentState != lastState)  ++currentState;
    
}
",1.0,1111111111
Doubly_Linked_List_8,1533254,2211821,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    ListNode* pA = head; 
    ListNode* pB = head;
    for (int i = 1; i < a; i++) pA = pA->right; 
    for (int i = 1; i < b; i++) pB = pB->right;
    if (a == 1) head = pB; 
    if (pA->left) pA->left->right = pB; 
    if (pB->right) pB->right->left = pA; 
    ListNode* t = pA->left; 
    pA->left = pB->right; 
    pB->right = t; 
    
    for (int i = 0; i <= b-a; i++) {
        ListNode* t = pA->right; 
        pA->right = pA->left; 
        pA->left = t; 
        pA = pA->left;
    }
    
    return head; 
}",1.0,1111111111
Doubly_Linked_List_1,1533259,2211170,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

void Deque::clear() {
    while (head != nullptr){
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if (getSize() == 0){
        Node* newNode = new Node(i, nullptr, nullptr);
        head = tail = newNode;
    }
    
    else{
        Node* newNode = new Node(i, nullptr, head);
        head->left = newNode;
        head = newNode;
    }
    
    curSize++;
    
}

void Deque::pushBack(int i) {
       if (getSize() == 0){
        Node* newNode = new Node(i, nullptr, nullptr);
        head = tail = newNode;
    }
    
    else{
        Node* newNode = new Node(i, tail, nullptr);
        tail->right = newNode;
        tail = newNode;
    }
    
    curSize++;
    
}

int Deque::popFront() {
    if (head == nullptr) {
        return -1; 
    }
    Node* temp = head;
    int item = temp->value;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}

int Deque::popBack() {
    if (tail == nullptr) {
        return -1;  // Deque is empty
    }
    Node* temp = tail;
    int item = temp->value;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}
void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533259,2211170,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    newNode->previous = tail;
    
    if (tail != nullptr){
        tail->next = newNode;
    }
    
    tail = newNode;
    
    if (head == nullptr){
        head = newNode;
    }
    
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) return;
    
    if (index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->previous = current;
        newNode->next = current->next;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1533259,2211170,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* traverse = head;
    for (int i = 0; i < index; i++){
        traverse = traverse->next;
    }
    
    return traverse->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* traverse = head;
    for (int i = 0; i < index; i++){
        traverse = traverse->next;
    }
    traverse->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
        Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;  // Item not found
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (indexOf(item) != -1);
}",1.0,1111111111
Doubly_Linked_List_4,1533259,2211170,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
   this->pList = pList;
   
   if(pList == NULL){index = -1;}
   
   else if(begin){
        if(this->pList->size() == 0){this->current = NULL;index = -1;}
        else{ this->current = pList->head;index = 0;}
   }
   
   else{
        this->current = NULL;
        if(this->pList->size() == 0) index = this->pList->size();
        else index = pList->size();
   }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;   
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
   if(current == NULL) throw out_of_range(""Segmentation fault!"");
   return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */

   if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    if(index == 0){

        this->pList->removeAt(index);
        this->index = -1;
        current = NULL;
    }
    else{
        T e = this->pList->removeAt(index-1);
        this->index = index - 1;
        current->data = e;
      
}
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
      return !(iterator.index == this->index || iterator.current == this->current);
 
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
        if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return *this;

}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
        DLinkedList<T>::Iterator t = *this;
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return t;

}

",1.0,1111111111
Doubly_Linked_List_5,1533259,2211170,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    T result;
//! kiểm tra đầu vào
    if(index < 0 && index >= count) throw out_of_range("""");
//! nếu chỉ có 1 phần tử
    if(count == 1){
        result = head->data;
        delete head;
        head = tail = NULL;
    }
//! nhiều hơn 1 phần tử và ở vị trí đầu tiên
    else if(index == 0){
        Node* tmp = head;
        head = head->next;
        result = tmp->data;
        delete tmp;
        head->previous = NULL;
    }
    else{
        Node* tmp = head;
//! tìm vị trí trước vị trí cần xóa
        index --; 
        while(index){
            tmp = tmp->next;
            index --;
        }
//! lưu vị giá trị xóa đi
        result = tmp->next->data;
//! nếu nó là vị trí cuối cùng
        if(tmp->next == tail){
            delete tail;
            tail = tmp;
            tail->next = NULL;
        }
        else{
            Node* h = tmp->next;
            tmp->next = tmp->next->next;
            tmp->next->previous = tmp;
            delete h;
        }
    }
    count --;
    return result;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    int index = indexOf(item);
    if(index == -1) return false;
    removeAt(index);
    return true;
    
}

template<class T>
void DLinkedList<T>::clear(){
    Node* tmp = head;
    while(head){
        head = head->next;
        delete tmp;
        tmp = head;
    }
    head = tail = NULL;
    count = 0;  
}",1.0,1111111111
Doubly_Linked_List_6,1533259,2211170,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_front(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    
    currentState++;
    
    if (currentState != logList.end()){
        list<int>::iterator curr = currentState;
        list<int>::iterator prev = currentState;
        while(curr != logList.end()){
            curr++;
            logList.erase(prev);
            prev = curr;
        }
        currentState = logList.end();
    }
    
    currentState--;
  
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     
    if (currentState != logList.begin())
        --currentState;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     ++currentState;
    if(currentState == logList.end()) --currentState;
}
",1.0,1111111111
Doubly_Linked_List_8,1533259,2211170,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
//! Khai báo một bảng băm (unordered_map) để lưu trữ con trỏ tới các ListNode với khóa là chỉ số.
    unordered_map<int ,ListNode* > v;
//! Khởi tạo một con trỏ tạm thời để duyệt qua danh sách.
    ListNode* tmp = head;
//! Khởi tạo biến index để theo dõi chỉ số của các nút trong danh sách.
    int index = 1;
//! Khởi tạo biến i với giá trị b, sẽ được sử dụng để đảo ngược thứ tự của các nút từ b đến a.
    int i = b;
    while(tmp){
        if(index >= a && index <= b){
 //! Lưu trữ con trỏ tới các nút trong khoảng a đến b vào bảng băm v.
            v[i] = tmp;
            i--;
        }
//! Lưu trữ con trỏ tới các nút nằm ngoài khoảng a đến b.
        else v[index] = tmp;
        tmp = tmp->right;
        index ++;
    }
//! Gán con trỏ head bằng con trỏ tới nút đầu tiên sau khi đảo ngược.
    head = v[1];
    head->left = NULL;
    tmp = head;
    for(int i = 2; i < index; i++){
//! thực hiện các thao tác liên kết lại
        tmp->right = v[i];
        v[i]->left = tmp;
        tmp = v[i];
    }
    tmp->right = NULL;
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1533260,2211367,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head != nullptr) {
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    tail = nullptr;
    curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
    if (head != nullptr)
        head->left = newNode;
    head = newNode;

    if (tail == nullptr)
        tail = head;

    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i, tail, nullptr);
    if (tail != nullptr)
        tail->right = newNode;
    tail = newNode;

    if (head == nullptr)
        head = tail;

    curSize++;
}

int Deque::popFront() {
    if (head == nullptr)
        return -1;

    Node* temp = head;
    int value = temp->value;
    head = head->right;

    if (head != nullptr)
        head->left = nullptr;
    else
        tail = nullptr;

    delete temp;
    curSize--;

    return value;
}

int Deque::popBack() {
    if (tail == nullptr)
        return -1;

    Node* temp = tail;
    int value = temp->value;
    tail = tail->left;

    if (tail != nullptr)
        tail->right = nullptr;
    else
        head = nullptr;

    delete temp;
    curSize--;

    return value;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_1,1533264,2212651,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    this->clear();
}

void Deque::clear() {
    while (head) {
        Node* tmp = head;
        head = head->right;
        delete tmp;
        curSize--;
    }
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i);
    newNode->right = head;
    if (!head) {
        head = tail = newNode; curSize++;
        return;
    }
    head->left = newNode;
    head = newNode;
    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i);
    if (!head) {
        head = tail = newNode; curSize++;
        return;
    }
    tail->right = newNode;
    newNode->left = tail;
    tail = newNode;
    curSize++;
}

int Deque::popFront() {
    if (head == nullptr) return -1;
    int i = head->value;
    Node* tmp = head;
    head = head->right;
    if (head) {
        head->left = nullptr;  // Update the left pointer of the new head
    }
    else {
        tail = nullptr;  // If the deque becomes empty
    }
    delete tmp;
    curSize--;
    return i;
}

int Deque::popBack() {
    if (tail == nullptr) return -1;
    int i = tail->value;
    Node* tmp = tail;
    tail = tail->left;
    if (tail) {
        tail->right = nullptr;  // Update the right pointer of the new tail
    }
    else {
        head = nullptr;  // If the deque becomes empty
    }
    delete tmp;
    curSize--;
    return i;
}

void Deque::printDequeReverse() {
    Node* tmp = tail;
    while (tmp) {
        if (tmp != head) {
            cout << tmp->value << "" "";
        }
        else {
            cout << tmp->value << ""\n"";
        }
        tmp = tmp->left;
    }
}

void Deque::printDeque() {
    Node* tmp = head;
    while (tmp) {
        if (tmp != tail) {
            cout << tmp->value << "" "";
        }
        else {
            cout << tmp->value << ""\n"";
        }
        tmp = tmp->right;
    }
}",1.0,1111111111
Doubly_Linked_List_2,1533264,2212651,"template <class T>
void DLinkedList<T>::add(const T& e) {
//! nếu chưa có phần tử nào thì thêm vào đầu danh sách
    if(count == 0){
        tail = head = new Node(e);
    }
    else{
        Node* tmp = new Node(e);
//! xử lý phần con trỏ để kết nói 2 chiều 
        tail->next = tmp;
        tmp->previous = tail;
        tail = tmp;
    }
//! cộng số lượng danh sách
    count ++;
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
//! kiểm tra đầu vào có hợp lệ hay không nếu không hợp lệ thì dừng chương trình
    if(index < 0 && index > count) throw out_of_range("""");
//! nếu chưa có phần tử nào và thêm vào đầu danh sách 
    else if(count == 0 || index == count ) add(e);
    else if(index == 0){
//! xử lý con trỏ
        Node* tmp = new Node(e);
        tmp->next = head;
        head->previous = tmp;
        head = tmp;
        count  ++;
    }
    else{
//! tạo 2 node curr và prev lưu node ở vị trí chèn và node trước vị trí chèn
        Node* curr = head->next,* prev = head;
        index --;  
        while(index){
            index--;
            prev = curr;
            curr= curr->next;
        }
//! thực hiện chèn node

        Node* tmp = new Node(e);
        prev->next = tmp;
        tmp->previous = prev;
        tmp->next = curr;
        curr->previous = tmp;
        count ++;
    }
    
}

template<class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1533264,2212651,"template<class T>
T DLinkedList<T>::get(int index) {
//! kiểm tra đầu vào có hợp lệ hay không
    if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){ 
        tmp = tmp->next;
        index --;
    }
    return tmp->data;
    
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
//! kiểm tra đầu vào có hợp lệ hay không
    if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){
        tmp = tmp->next;
        index --;
    }
    tmp->data = e;  
}

template<class T>
bool DLinkedList<T>::empty() {
    return count == 0;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
     //Return the first index wheter item appears in list, otherwise return -1 
    Node* tmp = head;
    int index = 0;
    while(tmp){
        if(tmp->data == item) return index;
        tmp = tmp->next;
        index ++;
    }
    return -1;
    
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    //Check if item appears in the list 
    Node* tmp = head;
    while(tmp){
        if(tmp->data == item) return true;
        tmp = tmp->next;
    }
    return false;
    
}",1.0,1111111111
Doubly_Linked_List_4,1533264,2212651,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T>* pList , bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    
   this->pList = pList;
   if(pList == NULL){index = -1;}
   else if(begin){
        if(this->pList->size() == 0){this->current = NULL;index = -1;}
        else{ this->current = pList->head;index = 0;}
   }
   else{
        this->current = NULL;
        if(this->pList->size() == 0) index = this->pList->size();
        else index = pList->size();
   }
    
    
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    // cout << this->index;
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */

   if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    if(index == 0){

        this->pList->removeAt(index);
        this->index = -1;
        current = NULL;
    }
    else{
        T e = this->pList->removeAt(index-1);
        this->index = index - 1;
        current->data = e;
      
}
}
template <class T>
void DLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}   

template <class T>
T& DLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
   if(current == NULL) throw out_of_range(""Segmentation fault!"");
   //cout << current->data;
   return current->data;
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
   return !(iterator.index == this->index || iterator.current == this->current);
}
// Prefix ++ overload
template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    DLinkedList<T>::Iterator t = *this;
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return t;
}
",1.0,1111111111
Doubly_Linked_List_5,1533264,2212651,"
template <class T>
T DLinkedList<T>::removeAt(int index)
{
    T result;
//! kiểm tra đầu vào
    if(index < 0 && index >= count) throw out_of_range("""");
//! nếu chỉ có 1 phần tử
    if(count == 1){
        result = head->data;
        delete head;
        head = tail = NULL;
    }
//! nhiều hơn 1 phần tử và ở vị trí đầu tiên
    else if(index == 0){
        Node* tmp = head;
        head = head->next;
        result = tmp->data;
        delete tmp;
        head->previous = NULL;
    }
    else{
        Node* tmp = head;
//! tìm vị trí trước vị trí cần xóa
        index --; 
        while(index){
            tmp = tmp->next;
            index --;
        }
//! lưu vị giá trị xóa đi
        result = tmp->next->data;
//! nếu nó là vị trí cuối cùng
        if(tmp->next == tail){
            delete tail;
            tail = tmp;
            tail->next = NULL;
        }
        else{
            Node* h = tmp->next;
            tmp->next = tmp->next->next;
            tmp->next->previous = tmp;
            delete h;
        }
    }
    count --;
    return result;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    int index = indexOf(item);
    if(index == -1) return false;
    removeAt(index);
    return true;
    
}

template<class T>
void DLinkedList<T>::clear(){
    Node* tmp = head;
    while(head){
        head = head->next;
        delete tmp;
        tmp = head;
    }
    head = tail = NULL;
    count = 0;  
}",1.0,1111111111
Doubly_Linked_List_6,1533264,2212651,"
DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_front(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
    
}

void DataLog::addCurrentState(int number)
{
    *currentState += number; 
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
 //! Di chuyển con trỏ currentState lên một bước để trỏ tới phần tử tiếp theo trong danh sách.
     currentState++;
//! Kiểm tra nếu currentState không trỏ tới cuối danh sách.     
     if(currentState != logList.end()){
         list<int>::iterator curr = currentState;
         list<int>::iterator prev = currentState;
        while(curr != logList.end()){
            curr++;
            logList.erase(prev);
            prev = curr;
        }
        currentState = logList.end();
       
    }
    currentState--;
  
    logList.push_back(*currentState);
    currentState++;
    //  for (auto i = logList.begin(); i != logList.end(); i++) {
    //         cout << ""[ "" << *i << "" ] => "";
    //     }
    //     cout<<endl;

}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState != logList.begin())
        --currentState;
}
void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     ++currentState;
    if(currentState == logList.end()) --currentState;
  
    
}
   ",1.0,1111111111
Doubly_Linked_List_8,1533264,2212651,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    ListNode *tmp = head;
    ListNode *tmp1 = head;
    int range = b-a+1;
    for (int i=1; i<a; i++)
        tmp = tmp->right;
    
    for (int i=1; i<b; i++)
        tmp1 = tmp1->right;
    
    for (int i=0; i<range/2; i++){
        ListNode *rtmp = tmp->right;
        ListNode *ltmp = tmp->left;
        ListNode *ltmp1 = tmp1->left;
        ListNode *rtmp1 = tmp1->right;
        if (ltmp)
            ltmp->right = tmp1;
        if (rtmp1)
            rtmp1->left = tmp;
        tmp1->left = ltmp;
        tmp->right = rtmp1;
        if (rtmp == tmp1){
            tmp->left = tmp1;
            tmp1->right = tmp;
        }
        else if (rtmp == ltmp1){
            rtmp->left = tmp1;
            rtmp->right = tmp;
            tmp1->right = rtmp;
            tmp->left = rtmp;
        }
        else{
            rtmp->left = tmp1;
            tmp1->right = rtmp;
            ltmp1->right = tmp;
            tmp->left = ltmp1;
        }
        if (ltmp == nullptr)
            head = tmp1;
        ListNode *p = tmp;
        tmp = tmp1;
        tmp1 = p;
        tmp1 = tmp1->left;
        tmp = tmp->right;
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1533324,2110501,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head != nullptr) {
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    tail = nullptr;
    curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
    if (head != nullptr)
        head->left = newNode;
    head = newNode;

    if (tail == nullptr)
        tail = head;

    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i, tail, nullptr);
    if (tail != nullptr)
        tail->right = newNode;
    tail = newNode;

    if (head == nullptr)
        head = tail;

    curSize++;
}

int Deque::popFront() {
    if (head == nullptr)
        return -1;

    Node* temp = head;
    int value = temp->value;
    head = head->right;

    if (head != nullptr)
        head->left = nullptr;
    else
        tail = nullptr;

    delete temp;
    curSize--;

    return value;
}

int Deque::popBack() {
    if (tail == nullptr)
        return -1;

    Node* temp = tail;
    int value = temp->value;
    tail = tail->left;

    if (tail != nullptr)
        tail->right = nullptr;
    else
        head = nullptr;

    delete temp;
    curSize--;

    return value;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533324,2110501,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *pNew= new Node(e);
    if(count==0)
    {
        head=pNew;
        tail=pNew;
        count++;
    }
    else
    {
        tail->next=pNew;
        pNew->previous=tail;
        tail=pNew;
        count++;
    }
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    Node *pNew= new Node(e);
    if(count==0)
    {
        head=pNew;
        tail=pNew;
        count++;
    }
    else
    {
        if(index<0||index>count);
        else if(index==count)
        {
            tail->next=pNew;
            pNew->previous=tail;
            tail=pNew;
            count++;
        }
        else if(index==0)
        {
            pNew->next=head;
            head->previous=pNew;
            head=pNew;
            count++;
        }
        else
        {
            Node*post;
            Node*cur=head;
            for(int i=0;i<index-1;i++)
            {
                cur=cur->next;
            }
            post=cur->next;
            cur->next=pNew;
            pNew->previous=cur;
            pNew->next=post;
            post->previous=pNew;
            count++;
        }
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
     return count;
}",1.0,1111111111
Doubly_Linked_List_3,1533324,2110501,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index>count||index<0)    throw std::out_of_range(""Segmentation fault!"");
    else
    {
    Node*tmp=head;
    for(int i=0;i<=index-1;i++)
    {
        tmp=tmp->next;
    }
    return tmp->data;
    }
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index>count||index<0)    throw std::out_of_range(""Segmentation fault!"");
    else
    {
    Node*tmp=head;
    for(int i=0;i<=index-1;i++)
    {
        tmp=tmp->next;
    }
    tmp->data=e;
    }
    
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(this->count==0)    return true;
    else            return false;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* cur = this->head;
    for (int i = 0 ; i < count ; i++)
    {
        if (cur->data == item) return i; 
        else cur = cur->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node*cur=head;
    while(cur!=tail)
    {
        if(cur->data==item) return true;
        cur=cur->next;
    }
    if(tail->data==item)  return true;
    return false;
}",1.0,1111111111
Doubly_Linked_List_4,1533324,2110501,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList=pList;
    if(begin==true)
    {
        if(this->pList!=NULL)
        {
            this->index=0;
            this->current=this->pList->head;
        }
        else
        {
            this->index=-1;
            this->current=NULL;
        }
    }
    else
    {
        this->current=NULL;
        if(this->pList!=NULL)   this->index=this->pList->count;
        else                    this->index=0;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current=iterator.current;
    this->index=iterator.index;
    this->pList=iterator.pList;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    this->current->data=e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    return this->current->data;  
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->index == 0) 
    {
        this->current = NULL;
    }
    else if (this->index == pList->count) 
    {
        this->current = pList->tail;
    }
    else 
    {
        this->current = this->current->previous;
    }
    pList->removeAt(index--);
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return !((this->current == iterator.current) && (this->index == iterator.index));
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (index == -1) 
    {
        this->current = pList->head;
    }
    else 
    {
       this->current = this->current->next;
    }
    index++;
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator tmp=*this;
    ++*this;
    return tmp;
}

",1.0,1111111111
Doubly_Linked_List_5,1533324,2110501,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index > this->count) throw std::out_of_range("""");
    else
    {
        int data;
        if (index == 0) 
        {
            data = this->head->data;
            Node* p = this->head;
            this->head = this->head->next;
            if (this->head!=NULL)   this->head->previous = NULL;
            delete p;
        }
        else if (index == count - 1) 
        {
            data = this->tail->data;
            Node*p = this->tail;
            this->tail = this->tail->previous;
            if (this->tail!=NULL)   this->tail->next = NULL;
            delete p;
        }
        else 
        {
            Node* cur=this->head;
            for(int i=0;i<index;i++)
            {
                cur=cur->next;
            }
            data = cur->data;
            Node* pre = cur->previous;
            Node* post = cur->next;
            pre->next = cur->next;
            pre->next = post;
            post->previous=cur->previous;
            post->previous=pre;
            delete cur;
        }
        this->tail = this->head;
        while (this->tail && this->tail->next) 
        {
            this->tail = this->tail->next;
        }
        count--;
        return data;
    }
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    
    Node* cur = this->head;
    while(cur != NULL) 
    {
        if(cur->data == item) break;
        cur = cur->next;
    }
    if(cur!=NULL)
    {
        if(cur == this->head) 
        {
            Node* p = this->head;
            this->head = this->head->next;
            if(this->head!=NULL)    this->head->previous = NULL;
            delete p;
        }
        else if(cur == this->tail) 
        {
            Node* p = this->tail;
            this->tail = this->tail->previous;
            if(this->tail!=NULL) this->tail->next = NULL;
            delete p;
        }
        else 
        {
            Node* pre=cur->previous;
            Node* post=cur->next;
            pre->next=cur->next;
            pre->next = post;
            post->previous=cur->previous;
            post->previous = pre;
            delete cur;
        }
        this->tail = this->head;
        while (this->tail!=NULL && this->tail->next!=NULL) 
        {
            this->tail = this->tail->next;
        }
        this->count--;
        return 1;
    }
    else return 0;
}

template<class T>
void DLinkedList<T>::clear()
{
    /* Remove all elements in list */
    Node* cur = this->head;
    while (this->head != NULL) 
    {
        this->head =this->head->next;
        delete cur;
        cur=this->head;
    }
    this->tail = NULL;
    this->count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1533324,2110501,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
     *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
     *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    while ((++currentState)-- != logList.end()) 
    {
        logList.pop_back();
    }
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState != logList.begin()) 
    {
        currentState--;
    }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     while ((++currentState)-- != logList.end()) 
     {
        currentState++;
     }
}
",1.0,1111111111
Doubly_Linked_List_7,1533324,2110501,"class LineStreet {
public:
    class Node {
    public:
        string data;
        Node* next;
        Node* prev;

        Node(string data) : data(data), next(nullptr), prev(nullptr) {}
    };

    LineStreet(string homepage) {
        if (homepage.length() > 20 ||homepage.length() < 1) {
            return ;
        }
        head = new Node(homepage);
        current = head;
    }

    void addNewElement(string ele) {
        if (ele.length() > 20||ele.length() < 1) {
            return;
        }

        Node* tmp = current->next;
        while (tmp != nullptr) {
            Node* nextNode = tmp->next;
            delete tmp;
            tmp = nextNode;
        }
        current->next = nullptr;
        Node* newNode = new Node(ele);
        newNode->prev = current;
        current->next = newNode;
        current = newNode;
    }

    string back(int steps) {
        if (steps < 1 || steps > 100) {
            throw std::out_of_range("""");
    }
    Node* tmp = current;
    while (tmp->prev != nullptr && steps > 0) {
        tmp = tmp->prev;
        steps--;
    }
    current = tmp;
    return tmp->data;
    }

    string forward(int steps) {
        if (steps < 1 || steps > 100) {
            throw std::out_of_range("""");
        }
        Node* tmp = current;
        while (tmp->next != nullptr && steps > 0) {
            tmp = tmp->next;
            steps--;
        }
        current = tmp;
        return tmp->data;
    }

private:
    Node* head;
    Node* current;
};",1.0,11111111
Doubly_Linked_List_8,1533324,2110501,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/
ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    ListNode* result = head;
    ListNode* start = head;
    for (int i = 1; i < a; i++) 
    {
        start = start->right;
    }
    ListNode* end = head;
    for (int i = 1; i < b; i++) 
    {
        end = end->right;
    }
    ListNode* prestart=NULL;
    if(start->left) 
    {
        prestart = start->left; 
        prestart->right = NULL;
    }
    start->left = NULL;
    ListNode* postend=NULL;
    if(end->right) 
    {
        postend = end->right; 
        postend->left = NULL;
    }
    end->right = NULL;
    ListNode* reverseNode = start;
    while(start != NULL) 
    {
        ListNode* temp = start->left;
        start->left = start->right;
        start->right = temp;
        reverseNode = start;
        start = start->left;
    }
    end = reverseNode;
    while(end->right) end = end->right;
    if(prestart!=NULL) 
    {
        prestart->right = reverseNode;
        reverseNode->left = prestart;
    }
    if(postend!=NULL) 
    {
        postend->left = end;
        end->right = postend;
    }
    result = end;
    while(result->left) result = result->left;
    return result;
}",1.0,1111111111
Doubly_Linked_List_1,1533325,2212372,"Deque::Deque() {
head = nullptr;
tail = nullptr;
curSize = 0;
}

Deque::~Deque() {
Node *temp = nullptr;
while (head) {
temp = head;
head = head->right;
delete temp;
}

head = tail = nullptr;
curSize = 0;
}

void Deque::clear() {
Node *temp = nullptr;
while (head) {
temp = head;
head = head->right;
delete temp;
}
head = tail = nullptr;
curSize = 0;
}

int Deque::getSize() {
return curSize;
}

void Deque::pushFront(int i) {
Node *newNode = new Node(i);
if (curSize==0) {
head = tail = newNode;
curSize++;
}
else {
newNode->right = head;
head->left = newNode;
head = newNode;
curSize++;
}

}

void Deque::pushBack(int i) {
Node *newNode = new Node(i);
if (curSize == 0) {
head = tail = newNode;
}
else {
tail->right = newNode;
newNode->left = tail;
tail = newNode;
}
curSize++;
}

int Deque::popFront() {
if (!head) return -1;
Node *temp = head;
int ans = temp->value;
head = head->right;
if (head) head->left = nullptr;
delete temp;
curSize--;
if (curSize == 0) {
    head = tail = nullptr;
}
return ans;
}

int Deque::popBack() {
if (!tail) return -1;
Node *temp = tail;
int ans = temp->value;
tail = tail->left;
if (tail) tail->right = nullptr;
curSize--;
if (curSize==0) {
    head = tail = nullptr;
}
return ans;
}

void Deque::printDequeReverse() {
Node *temp = tail;
int i=0;
while (i < curSize) {
cout << temp->value << "" "";
temp = temp->left;
i++;
}
cout << '\n';
}

void Deque::printDeque() {
Node *temp = head;
int i=0;
while (i<curSize) {
cout << temp->value << "" "";
temp = temp->right;
i++;
}
cout << '\n';
}",1.0,1111111111
Doubly_Linked_List_2,1533325,2212372,"
template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* temp = new Node(e);
    if(head == NULL){
        head = tail = temp;
        count++;
    } else {
        tail->next = temp;
        temp->previous = tail;
        tail = temp;
        count++;
    }
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
     if (index < 0 || index > this->count)
    {
        throw std::out_of_range(""Out of range"");
    }


    if (index == 0)
    {
        Node* newNode = new Node(e);
        newNode->next = head;
        if (head != nullptr)
        {
            head->previous = newNode;
        }
        head = newNode;

        if (count == 0)
        {
            tail = newNode;
        }
    }
    else if (index == count)
    {   Node* newNode = new Node(e);
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    }
    else
    {Node* newNode = new Node(e);
        Node* temp = head;
        for (int i = 0; i < index - 1; i++)
        {
            temp = temp->next;
        }

        newNode->previous = temp;
        newNode->next = temp->next;

        if (temp->next != nullptr)
        {
            temp->next->previous = newNode;
        }

        temp->next = newNode;
    }

    this->count++;
}

template<class T>
int DLinkedList<T>::size() {
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1533325,2212372,"
template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        return -1;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        return;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(head == nullptr) return true;
    return false;
    // return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while(temp != nullptr){
        if(temp->data == item) return i;
        i++;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1533325,2212372,"
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this->pList = pList;
    if (begin)
    {
        if (pList != NULL)
        {
            this->current = pList->head;
            index = 0;
        }
        else
        {
            this->current = nullptr;
            index = -1;
        }
    }   
    else
    {
        this->current = nullptr;
        if (pList != NULL)
        {
            index = pList->size();
        }
        else
        {
            index = 0;
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == NULL)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current->data = e;
    }
}

template <class T>
T &DLinkedList<T>::Iterator::operator*()
{
    if (current == NULL)
    {

        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        return current->data;
    }
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
     * TODO: delete Node in pList which Node* current point to.
     *       After that, Node* current point to the node before the node just deleted.
     *       If we remove first node of pList, Node* current point to nullptr.
     *       Then we use operator ++, Node* current will point to the head of pList.
     */
    if (current == nullptr)
    {
        return;
    }

    Node *nodeToRemove = current;
    current = current->previous;

    if (current != nullptr)
    {
        current->next = nodeToRemove->next;
    }
    else
    {
        pList->head = nodeToRemove->next;
    }

    if (nodeToRemove->next != nullptr)
    {
        nodeToRemove->next->previous = current;
    }
    else
    {
        pList->tail = current;
    }

    delete nodeToRemove;
    pList->count--;

    if (index > 0)
    {
        index--;
    }
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    if (this->pList == iterator.pList && this->current == iterator.current && this->index == iterator.index)
        return false;
    return true;
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator++()
{
    if (current == nullptr)
    {
        index = 0;
        current = this->pList->head;
        return *this;
    }
    current = current->next;
    index += 1;
    return *this;
}

template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    DLinkedList<T>::Iterator iterator = *this;
    ++*this;
    return iterator;
}
",1.0,1111111111
Doubly_Linked_List_5,1533325,2212372,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count) {
        return -1;
    }

    if (index == 0) {
        Node* removedNode = head;
        T removedValue = removedNode->data;
        head = head->next;
        if (head == nullptr) {
            tail = nullptr;
        }
        delete removedNode;
        count--;
        return removedValue;
    } else {
        Node* previous = head;
        for (int i = 0; i < index - 1; i++) {
            previous = previous->next;
        }

        Node* removedNode = previous->next;
        T removedValue = removedNode->data;
        previous->next = removedNode->next;
        if (removedNode == tail) {
            tail = previous;
        }
        delete removedNode;
        count--;
        return removedValue;
    }
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(contains(item) == true)
    return removeAt(indexOf(item))==item;
    return false;
    
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
        Node* current = head;
        head = head->next;
        delete current;
    }
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1533325,2212372,"

DataLog::DataLog()
{
    logList = list<int>();
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    logList = list<int>();
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    (*currentState) += number;
}

void DataLog::subtractCurrentState(int number)
{
    (*currentState) -= number;
}

void DataLog::save()
{
    logList.erase(next(currentState, 1), logList.end());
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    if (currentState == logList.begin())
        return;
    currentState--;
}

void DataLog::redo()
{
    if (next(currentState, 1) == logList.end())
        return;
    currentState++;
}
",1.0,1111111111
Doubly_Linked_List_7,1533325,2212372,"

class LineStreet {

public:

class Node {

public:

friend class LineStreet;

string value;

Node *next, *prev;

Node (string val, Node *prev_t = nullptr, Node *next_t = nullptr): value (val), next (next_t), prev(prev_t){}

};

Node *head,*curr;

int size;

LineStreet (string homepage) {

head =curr = new Node (homepage);

}

void addNewElement(string url) {

Node *deleteNode = curr->next;

while (deleteNode != NULL) {

Node *temp = deleteNode;

deleteNode = deleteNode->next;

delete temp;

}

curr->next = new Node (url, curr);

curr=curr->next;

}

string back (int steps) {

for (int i = 0; i < steps && curr->prev != nullptr; i++)

curr=curr->prev;

return curr->value;

}

string forward(int steps) {

for (int i = 0; i < steps && curr->next != nullptr; i++)

curr = curr->next;

return curr->value;

}

};",1.0,11111111
Doubly_Linked_List_8,1533325,2212372,"
ListNode *reverse(ListNode *head, int l, int r)
{
    if (!head || !head->right || l == r)
        return head;

    ListNode *prev = nullptr;
    ListNode *current = nullptr;

    for (int i = 0; i < l; i += 1)
    {
        if (current == nullptr)
            current = head;
        else
        {
            prev = current;
            current = current->right;
        };
    }

    ListNode *start = current;
    for (int i = l; i < r; i += 1)
    {
        current = current->right;
    }
    ListNode *end = current;

    if (prev != nullptr)
    {
        prev->right = end;
    }
    else
    {
        // is head
        head = end;
    }
    if (end->right)
    {
        end->right->left = start;
    }
    prev = end->right;
    while (start != end)
    {
        ListNode *next = start->right;
        start->right = prev;
        start->left = next;
        prev = start;
        start = next;
    }
    start->right = prev;

    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1533326,2212282,"Deque::Deque() {
    head = NULL;
    tail = NULL;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    Node* temp = head;
    while(head) {
        head = head->right;
        delete temp;
        temp = head;
    }
    head = NULL;
    tail = NULL;
    curSize=0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if(curSize == 0) {
        head = new Node(i);
        tail = head;
    }
    else {
        head->left = new Node(i, NULL, head);
        head = head->left;
    }
    ++curSize;
}

void Deque::pushBack(int i) {
    if(curSize == 0) {
        head = new Node(i);
        tail = head;
    }
    else {
        tail->right = new Node(i, tail, NULL);
        tail = tail->right;
    }
    ++curSize;
}

int Deque::popFront() {
    if(curSize == 0) return -1;
    int save = head->value;
    if(curSize == 1) {
        delete head;
        head = NULL;
        tail = NULL;
    }
    else {
        head = head->right;
        delete head->left;
        head->left = NULL;
    }
    --curSize;
    return save;
}

int Deque::popBack() {
    if(curSize == 0) return -1;
    int save = tail->value;
    if(curSize == 1) {
        delete tail;
        head = NULL;
        tail = NULL;
    }
    else {
        tail = tail->left;
        delete tail->right;
        tail->right = NULL;
    }
    --curSize;
    return save;
}

void Deque::printDequeReverse() {
    Node* tmp = tail;
    while(tmp != NULL) {
        cout << tmp->value << "" "";
        tmp = tmp->left;
    } 
    if(tail) cout << endl;
}

void Deque::printDeque() {
    Node* tmp = head;
    while(tmp != NULL) {
        cout << tmp->value << "" "";
        tmp = tmp->right;
    } 
    if(head) cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533326,2212282,"template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template <class T>
void DLinkedList<T>::add(int index, const T& e) {
    if (index < 0 || index > count) {
        std::cout << ""Invalid index."" << std::endl;
        return;
    }
    if (index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        newNode->previous = current;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
}

template <class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1533326,2212282,"template <class T>
bool DLinkedList<T>::empty() {
    return count == 0;
}
template <class T>
T DLinkedList<T>::get(int index) {
    if (index < 0 || index >= count) {
        std::cout << ""Invalid index."" << std::endl;
        return T();
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    if (index < 0 || index >= count) {
        std::cout << ""Invalid index."" << std::endl;
        return;
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template <class T>
int DLinkedList<T>::indexOf(const T& item) {
    Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;
}

template <class T>
bool DLinkedList<T>::contains(const T& item) {
    return indexOf(item) != -1;
}
",1.0,1111111111
Doubly_Linked_List_4,1533326,2212282,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this->pList = pList;
    if (begin) {
        current = pList->head;
        index = 0;
    } else {
        current = nullptr;
        index = pList->count;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current != nullptr) {
        current->data = e;
    }
}

template<class T>
T& DLinkedList<T>::Iterator::operator*()
{
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove()
{
    if (current != nullptr) {
        Node *prev = current->previous;
        Node *next = current->next;

        if (prev != nullptr) {
            prev->next = next;
        } else {
            pList->head = next;
        }

        if (next != nullptr) {
            next->previous = prev;
        } else {
            pList->tail = prev;
        }

        Node *temp = current;
        current = next; // Move current to the next node
        delete temp;

        pList->count--;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    return current != iterator.current;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()
{
    if (current != nullptr) {
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}

",0.8,1001111111
Doubly_Linked_List_5,1533326,2212282,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count)
        throw std::out_of_range(""Index out of range"");

    Node* current = head;
    Node* previous = nullptr;

    // Traverse to the node at the specified index
    for (int i = 0; i < index; i++)
    {
        previous = current;
        current = current->next;
    }

    // Remove the node from the list
    if (previous)
        previous->next = current->next;
    else
        head = current->next;

    if (current == tail)
        tail = previous;

    T removedData = current->data;
    delete current;
    count--;

    return removedData;
}

template <class T>
bool DLinkedList<T>::removeItem(const T &item)
{
    Node* current = head;
    Node* previous = nullptr;

    // Traverse the list to find the node containing the item
    while (current)
    {
        if (current->data == item)
        {
            // Remove the node from the list
            if (previous)
                previous->next = current->next;
            else
                head = current->next;

            if (current == tail)
                tail = previous;

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false;
}

template <class T>
void DLinkedList<T>::clear()
{
    Node* current = head;
    while (current)
    {
        Node* next = current->next;
        delete current;
        current = next;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1533326,2212282,"DataLog::DataLog()
{
    logList.push_back(0);
    currentState = logList.begin();
}
DataLog::DataLog(const int &data)
{
   logList.push_back(data);
  currentState = logList.begin();
}
void DataLog::addCurrentState(int number)
{
    int data = getCurrentStateData();
   data += number;
   logList.push_back(data);
    currentState = --logList.end();
}
void DataLog::subtractCurrentState(int number)
{
   int data = getCurrentStateData();
    data -= number;
    logList.push_back(data);
    currentState = --logList.end();
}
void DataLog::save()
{
    if (currentState != --logList.end())
    {
        logList.erase(++currentState, logList.end());
        currentState = --logList.end();
    }
}
void DataLog::undo()
{
    if (currentState != logList.begin())
    {
       currentState--;
    }
}
void DataLog::redo()
{
    if (currentState != --logList.end())
    {
        currentState++;
    }
}
",0.3,1100001000
Doubly_Linked_List_7,1533326,2212282,"class LineStreet {
public:
    struct Node {
        Node* next;
        Node* prev;
        string name;
        Node(string name) : 
        next(this), prev(this), name(name) {};
    };

    Node* head;

    LineStreet(string homepage)
    : head(new Node(homepage)){}
    
    void addNewElement(string url) {
        head->next = new Node(url);
        head->next->prev = head;
        head = head->next;
    }

    string back(int steps) {
        if(steps == 0) return head->name;
        head = head->prev;
        return back(steps-1);
    }

    string forward(int steps) {
        if(steps == 0) return head->name;
        head = head->next;
        return forward(steps-1);
    }
};
",1.0,11111111
Doubly_Linked_List_8,1533326,2212282,"ListNode* reverse(ListNode* head, int a, int b) {
    if (head == nullptr || a >= b) {
        return head;
    }

    ListNode* dummy = new ListNode(-1);  // Create a dummy node
    dummy->right = head;
    ListNode* prev = dummy;

    // Move prev to the node before the sublist to be reversed
    for (int i = 0; i < a - 1; i++) {
        prev = prev->right;
    }

    ListNode* curr = prev->right;  // The current node within the sublist
    ListNode* next;  // Pointer to the next node in the sublist

    // Reverse the sublist from node 'a' to node 'b'
    for (int i = 0; i < b - a; i++) {
        next = curr->right;
        curr->right = next->right;
        next->right = prev->right;
        prev->right = next;
    }

    head = dummy->right;  // Update the head pointer
    delete dummy;  // Free the memory occupied by the dummy node

    return head;
}",0.9,1011111111
Doubly_Linked_List_1,1533337,2213035,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head)
    {
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    tail = nullptr;
    curSize = 0;    
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
    if (head) {
        head->left = newNode;
    }
    head = newNode;
    if (!tail) {
        tail = head;
    }
    curSize++;
}

void Deque::pushBack(int i) {
    Node* temp = new Node(i, tail, nullptr);
    if (tail) {
        tail->right = temp;
    }
    tail = temp;
    if (!head) {
        head = tail;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1;
    }
    int result = head->value;
    Node* temp = head;
    head = head->right;
    if (head) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1; 
    }
    int result = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}
",1.0,1111111111
Doubly_Linked_List_2,1533337,2213035,"template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* temp = new Node(e);
    if(head == NULL){
        head = tail = temp;
        count++;
    } else {
        tail->next = temp;
        temp->previous = tail;
        tail = temp;
        count++;
    }
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
     if (index < 0 || index > this->count)
    {
        throw std::out_of_range(""Out of range"");
    }


    if (index == 0)
    {
        Node* newNode = new Node(e);
        newNode->next = head;
        if (head != nullptr)
        {
            head->previous = newNode;
        }
        head = newNode;

        if (count == 0)
        {
            tail = newNode;
        }
    }
    else if (index == count)
    {   Node* newNode = new Node(e);
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    }
    else
    {Node* newNode = new Node(e);
        Node* temp = head;
        for (int i = 0; i < index - 1; i++)
        {
            temp = temp->next;
        }

        newNode->previous = temp;
        newNode->next = temp->next;

        if (temp->next != nullptr)
        {
            temp->next->previous = newNode;
        }

        temp->next = newNode;
    }

    this->count++;
}

template<class T>
int DLinkedList<T>::size() {
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1533337,2213035,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        return -1;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        return;
    }
    Node* temp = head;
    for (int i = 0; i < index; i++)
    {
        temp = temp->next;
    }
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if(head == nullptr) return true;
    return false;
    // return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* temp = head;
    int i = 0;
    while(temp != nullptr){
        if(temp->data == item) return i;
        i++;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}
",1.0,1111111111
Doubly_Linked_List_4,1533337,2213035,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin)
{
    this->pList = pList;
    if (begin)
    {
        if (pList != NULL)
        {
            this->current = pList->head;
            index = 0;
        }
        else
        {
            this->current = nullptr;
            index = -1;
        }
    }
    else
    {
        this->current = nullptr;
        if (pList != NULL)
        {
            index = pList->size();
        }
        else
        {
            index = 0;
        }
    }
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->current = iterator.current;
    this->index = iterator.index;
    this->pList = iterator.pList;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current == NULL)
    {
        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        current->data = e;
    }
}

template <class T>
T &DLinkedList<T>::Iterator::operator*()
{
    if (current == NULL)
    {

        throw std::out_of_range(""Segmentation fault!"");
    }
    else
    {
        return current->data;
    }
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
     * TODO: delete Node in pList which Node* current point to.
     *       After that, Node* current point to the node before the node just deleted.
     *       If we remove first node of pList, Node* current point to nullptr.
     *       Then we use operator ++, Node* current will point to the head of pList.
     */
    if (current == nullptr)
    {
        return;
    }

    Node *nodeToRemove = current;
    current = current->previous;

    if (current != nullptr)
    {
        current->next = nodeToRemove->next;
    }
    else
    {
        pList->head = nodeToRemove->next;
    }

    if (nodeToRemove->next != nullptr)
    {
        nodeToRemove->next->previous = current;
    }
    else
    {
        pList->tail = current;
    }

    delete nodeToRemove;
    pList->count--;

    if (index > 0)
    {
        index--;
    }
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)
{
    if (this->pList == iterator.pList && this->current == iterator.current && this->index == iterator.index)
        return false;
    return true;
}

template <class T>
typename DLinkedList<T>::Iterator &DLinkedList<T>::Iterator::operator++()
{
    if (current == nullptr)
    {
        index = 0;
        current = this->pList->head;
        return *this;
    }
    current = current->next;
    index += 1;
    return *this;
}

template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    DLinkedList<T>::Iterator iterator = *this;
    ++*this;
    return iterator;
}",1.0,1111111111
Doubly_Linked_List_5,1533337,2213035,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count) {
        return -1;
    }

    if (index == 0) {
        Node* removedNode = head;
        T removedValue = removedNode->data;
        head = head->next;
        if (head == nullptr) {
            tail = nullptr;
        }
        delete removedNode;
        count--;
        return removedValue;
    } else {
        Node* previous = head;
        for (int i = 0; i < index - 1; i++) {
            previous = previous->next;
        }

        Node* removedNode = previous->next;
        T removedValue = removedNode->data;
        previous->next = removedNode->next;
        if (removedNode == tail) {
            tail = previous;
        }
        delete removedNode;
        count--;
        return removedValue;
    }
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(contains(item) == true)
    return removeAt(indexOf(item))==item;
    return false;
    
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head != nullptr) {
        Node* current = head;
        head = head->next;
        delete current;
    }
    tail = nullptr;
    count = 0;
}",1.0,1111111111
Doubly_Linked_List_6,1533337,2213035,"// front() – Returns the value of the first element in the list.
// back() – Returns the value of the last element in the list.
// push_front() – Adds a new element ‘g’ at the beginning of the list.
// push_back() – Adds a new element ‘g’ at the end of the list.
// pop_front() – Removes the first element of the list, and reduces the size of the list by 1.
// pop_back() – Removes the last element of the list, and reduces the size of the list by 1.
// insert() – Inserts new elements in the list before the element at a specified position.
// size() – Returns the number of elements in the list.
// begin() – begin() function returns an iterator pointing to the first element of the list.
// end() – end() function returns an iterator pointing to the theoretical last element which follows the last element.

DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList = list<int>();
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList = list<int>();
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    (*currentState) += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    (*currentState) -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the
     *       currentState Iterator, we delete them all before creating a new state.
     */
    logList.erase(next(currentState, 1), logList.end());
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState == logList.begin())
        return;
    currentState--;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    if (next(currentState, 1) == logList.end())
        return;
    currentState++;
}
",1.0,1111111111
Doubly_Linked_List_7,1533337,2213035,"class Node {
public:
    string data;
    Node* next;
    Node* prev;
    Node(string data, Node* next = nullptr, Node* prev = nullptr) 
        : data(data), next(next), prev(prev) {}
};


class LineStreet {
public:
    Node* head;
    Node* tail;
    Node* current;

    LineStreet(string homepage) {
        head = new Node{homepage, nullptr, nullptr};
        tail = head;
        current = head;
    }
    
    void addNewElement(string s) {
        Node* newNode = new Node{s, nullptr, current};
        current->next = newNode;
        current = newNode;
        tail = newNode;
    }

    string back(int steps) {
        while(steps-- > 0 && current->prev != nullptr) {
            current = current->prev;
        }
        return current->data;
    }

    string forward(int steps) {
        while(steps-- > 0 && current->next != nullptr) {
            current = current->next;
        }
        return current->data;
    }
};",1.0,11111111
Doubly_Linked_List_8,1533337,2213035,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode *reverse(ListNode *head, int l, int r)
{
    if (!head || !head->right || l == r)
        return head;

    ListNode *prev = nullptr;
    ListNode *current = nullptr;

    for (int i = 0; i < l; i += 1)
    {
        if (current == nullptr)
            current = head;
        else
        {
            prev = current;
            current = current->right;
        };
    }

    ListNode *start = current;
    for (int i = l; i < r; i += 1)
    {
        current = current->right;
    }
    ListNode *end = current;

    if (prev != nullptr)
    {
        prev->right = end;
    }
    else
    {
        // is head
        head = end;
    }
    if (end->right)
    {
        end->right->left = start;
    }
    prev = end->right;
    while (start != end)
    {
        ListNode *next = start->right;
        start->right = prev;
        start->left = next;
        prev = start;
        start = next;
    }
    start->right = prev;

    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1533338,2013048,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i);
    if (curSize == 0) {
        head = newNode;
        tail = newNode;
    } else {
        newNode->right = head;
        head->left = newNode;
        head = newNode;
    }
    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i);
    if (curSize == 0) {
        head = newNode;
        tail = newNode;
    } else {
        newNode->left = tail;
        tail->right = newNode;
        tail = newNode;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1; // Return -1 when the deque is empty
    }
    int value = head->value;
    Node* temp = head;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return value;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1; // Return -1 when the deque is empty
    }
    int value = tail->value;
    Node* temp = tail;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return value;
}

void Deque::clear() {
    while (curSize > 0) {
        popFront();
    }
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value;
        if (current->left != nullptr) {
            cout << "" "";
        }
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value;
        if (current->right != nullptr) {
            cout << "" "";
        }
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533338,2013048,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index == count) {
        add(e);
    } else {
        Node* newNode = new Node(e);
        if (index == 0) {
            newNode->next = head;
            head->previous = newNode;
            head = newNode;
        } else {
            Node* current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current->next;
            }
            newNode->next = current->next;
            current->next->previous = newNode;
            current->next = newNode;
            newNode->previous = current;
        }
        count++;
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}
",1.0,1111111111
Doubly_Linked_List_3,1533338,2013048,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    int i = 0;
    Node* p = this->head;
    while(p!= NULL && index != i){
        p = p->next;
        i++;
    }
    return p->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    int i = 0;
    Node* p = this->head;
    while(p!= NULL && index != i){
        p = p->next;
        i++;
    }
    p->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return !this->count;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int index = 0;
    Node *p = this->head;
    while(p != NULL){
        if(p->data == item){
            return index;
        }
        p = p->next;
        index++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node *p = this->head;
    while(p != NULL){
        if(p->data == item){
            return true;
        }
        p = p->next;
    }
    return false;
}",1.0,1111111111
Doubly_Linked_List_4,1533338,2013048,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
	if (begin == true)
	{
		if (this->pList == NULL)
		{
			this->current = NULL;
			this->index = -1;
		}
		else
		{
			this->current = this->pList->head;
			this->index = 0;
		}
	}
	else
	{
		this->current = NULL;
		this->index = (this->pList->count == 0) ? (this->pList->size()) : 0;
	}
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
	this->current = iterator.current;
	this->index = iterator.index;
	return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else
		this->pList->set(this->index, e);
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == this->pList->head)
	{
		this->current = NULL;
		this->pList->removeAt(this->index);
		this->index = -1;
	}
	else
	{
		this->current = this->current->previous;
		this->pList->removeAt(this->index);
		--this->index;
	}
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (this->pList != iterator.pList || this->current != iterator.current);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == NULL && this->index == -1)
	{
		this->current = this->pList->head;
		this->index = 0;
	}
	else
	{
		this->current = this->current->next;
		++this->index;
	}
	return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator newIterator(this->pList, true);
	if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else {
	    newIterator = *this;
	    ++*this;
	    return newIterator;
	}
}",1.0,1111111111
Doubly_Linked_List_5,1533338,2013048,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count || this->head == nullptr) {
        return T();
    }
     Node* current = head;
    for (int i = 0; i < index; i++)
        current = current->next;

    T removedData = current->data;

    // Update previous and next pointers
    if (current->previous)
        current->previous->next = current->next;
    if (current->next)
        current->next->previous = current->previous;

    // Update head and tail pointers if necessary
    if (current == head)
        head = current->next;
    if (current == tail)
        tail = current->previous;

    delete current;
    count--;
    return removedData;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    if(this->indexOf(item) == -1){
        return false;
    };
    removeAt(this->indexOf(item));
    return true;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* current = head;
    while (current != nullptr)
    {
        Node* next = current->next;
        delete current;
        current = next;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1533338,2013048,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    currentState = logList.insert(logList.begin(), 0);
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    currentState = logList.insert(logList.begin(), data);
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    while (next(currentState) != logList.end()) {
            logList.erase(next(currentState));
        }
    currentState = logList.insert(next(currentState), *currentState);
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState != logList.begin()) {
        currentState--;
    }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    if (next(currentState) != logList.end()) {
        currentState++;
    }
}
",1.0,1111111111
Doubly_Linked_List_7,1533338,2013048,"#include<vector>
class LineStreet {
    vector<string> line;
    int current;

public:
    LineStreet(string homepage) {
        line.push_back(homepage);
        current = 0;
    }

    void addNewElement(string ele) {
        int n =(int)line.size();
        if (current != n - 1) {
            line.erase(line.begin() + current + 1, line.end());
        }
        line.push_back(ele);
        n =(int)line.size();
        current = n - 1;
    }

    string back(int steps) {
        current = max(current - steps, 0);
        return line[current];
    }

    string forward(int steps) {
        int n =(int)line.size();
        current = min(current + steps, n - 1);
        return line[current];
    }
};",1.0,11111111
Doubly_Linked_List_8,1533338,2013048,"

ListNode* reverse(ListNode* head, int a, int b) {
    ListNode dummy(0);
    dummy.right = head;
    ListNode* pre = &dummy;

    // Move to the node before position 'a'
    for (int i = 1; i < a; i++) {
        pre = pre->right;
    }

    ListNode* current = pre->right;
    ListNode* next = nullptr;
    ListNode* last = current;

    // Reverse the nodes between 'a' and 'b'
    for (int i = a; i <= b; i++) {
        next = current->right;
        current->right = last;
        last->left = current;
        last = current;
        current = next;
    }

    pre->right->right = current;
    if (current) {
        current->left = pre->right;
    }

    pre->right = last;
    last->left = pre;

    return dummy.right;
}",1.0,1111111111
Doubly_Linked_List_1,1533444,2210997,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
}

void Deque::clear() {
    while(head != nullptr){
        popBack();
    }
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if (head == nullptr){
        Node* newNode = new Node(i,nullptr,nullptr);
        head = newNode;
        tail = newNode;
    } else {
        Node* newNode = new Node(i,nullptr,head);
        head->left = newNode;
        head = newNode;
    }
    curSize += 1;
}

void Deque::pushBack(int i) {
    if (head == nullptr){
        Node* newNode = new Node(i,nullptr,nullptr);
        head = newNode;
        tail = newNode;
    } else {
        Node* newNode = new Node(i,tail,nullptr);
        tail->right = newNode;
        tail = newNode;
    }
    curSize += 1;
}

int Deque::popFront() {
    if (head == nullptr)
        return -1;

    int ans = head->value;
    Node* newHead = head->right;
    if (newHead != nullptr){
        newHead->left = nullptr;
        delete head;
        head = newHead;       
    } else {
        delete head;
        head = nullptr;
        tail = nullptr;
    }
    curSize -= 1;
    return ans; 
}

int Deque::popBack() {
    if (head == nullptr)
        return -1;

    int ans = tail->value;
    Node* newTail = tail->left;
    if (newTail != nullptr){
        newTail->right = nullptr;
        delete tail;
        tail = newTail;       
    } else {
        delete tail;
        head = nullptr;
        tail = nullptr;
    }
    curSize -= 1;
    return ans;
}

void Deque::printDequeReverse() {
   Node*temp=tail;
   while(temp!=nullptr){
        cout<<temp->value<<"" "";
       temp=temp->left;
   }
   cout<<endl;
}

void Deque::printDeque() {
    Node*temp=head;
    while(temp!=nullptr){
        cout<<temp->value<<"" "";
        temp=temp->right;
    }
    cout<<endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533444,2210997,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if(count == 0)
    {
        head = tail = newNode;
        count++;
    }
    else
    {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    count++;
    }
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count)
            throw out_of_range(""Index out of range"");

        if (index == count) {
            add(e);
            return;
        }

        Node* newNode = new Node(e);
        if (index == 0) {
            newNode->next = head;
            head->previous = newNode;
            head = newNode;
        } else {
            Node* current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current->next;
            }
            newNode->next = current->next;
            newNode->previous = current;
            current->next = newNode;
            newNode->next->previous = newNode;
        }
        count++;
    
    
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1533444,2210997,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count)
            throw out_of_range(""Index out of range"");

    Node* current = head;
    for (int i = 0; i < index; i++) current = current->next;
    return current->data;
    
    
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count)
            throw out_of_range(""Index out of range"");

    Node* current = head;
    for (int i = 0; i < index; i++) current = current->next;
    current->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    for (int index = 0; current != nullptr; index++) 
    {
        if (current->data == item)   return index;
        current = current->next;
    }
    return -1;
    
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;

    
}",1.0,1111111111
Doubly_Linked_List_4,1533444,2210997,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
	if (begin == true)
	{
		if (this->pList == NULL)
		{
			this->current = NULL;
			this->index = -1;
		}
		else
		{
			this->current = this->pList->head;
			this->index = 0;
		}
	}
	else
	{
		this->current = NULL;
		this->index = (this->pList->count == 0) ? (this->pList->size()) : 0;
	}

}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
	this->current = iterator.current;
	this->index = iterator.index;
	return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else
		this->pList->set(this->index, e);
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == this->pList->head)
	{
		this->current = NULL;
		this->pList->removeAt(this->index);
		this->index = -1;
	}
	else
	{
		this->current = this->current->previous;
		this->pList->removeAt(this->index);
		--this->index;
	}
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (this->pList != iterator.pList || this->current != iterator.current);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == NULL && this->index == -1)
	{
		this->current = this->pList->head;
		this->index = 0;
	}
	else
	{
		this->current = this->current->next;
		++this->index;
	}
	return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator newIterator(this->pList, true);
	if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else {
	    newIterator = *this;
	    ++*this;
	    return newIterator;
	}
}

",1.0,1111111111
Doubly_Linked_List_5,1533444,2210997,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count)
    {
        throw std::out_of_range(""Index out of bounds"");
    }

    Node* current = head;
    Node* previous = nullptr;

    for (int i = 0; i < index; i++)
    {
        previous = current;
        current = current->next;
    }

    T removedValue = current->data;

    if (previous)
    {
        previous->next = current->next;
    }
    else
    {
        // If the removed element is the head, update the head
        head = current->next;
    }

    if (current == tail)
    {
        // If the removed element is the tail, update the tail
        tail = previous;
    }

    delete current;
    count--;
    return removedValue;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    Node* previous = nullptr;

    while (current)
    {
        if (current->data == item)
        {
            if (previous)
            {
                previous->next = current->next;
            }
            else
            {
                // If the removed element is the head, update the head
                head = current->next;
            }

            if (current == tail)
            {
                // If the removed element is the tail, update the tail
                tail = previous;
            }

            delete current;
            count--;
            return true;
        }

        previous = current;
        current = current->next;
    }

    return false; // Item not found
    
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* current = head;

    while (current)
    {
        Node* next = current->next;
        delete current;
        current = next;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1533444,2210997,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
     logList.push_back(0);
	currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
     logList.push_back(data);
	currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
     *this->currentState = *this->currentState + number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
     *this->currentState = *this->currentState - number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
     list<int>::iterator a = currentState;
	++a;
	while (a != logList.end()) {
		a = logList.erase(a);
	}
	logList.push_back(*currentState);
	++currentState;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if (currentState != logList.begin()) currentState = prev(currentState, 1);
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     list<int>::iterator a = currentState;
	list<int>::iterator b = ++a;
	if (b != logList.end()) ++currentState;
}
",1.0,1111111111
Doubly_Linked_List_7,1533444,2210997,"class LineStreet {
public:
    struct Node {
        string data;
        Node* next;
        Node* prev;
    };

    Node* root;   
    Node* current; 

    LineStreet(string homepage) {
        Node* newNode = new Node;
        newNode->data = homepage;
        newNode->next = nullptr;
        newNode->prev = nullptr;
        root = newNode;
        current = newNode;
    }
    
    void addNewElement(string url) {
        Node* newNode = new Node;
        newNode->data = url;
        newNode->next = nullptr;
        newNode->prev = current;
        current->next = newNode;
        current = newNode;
    }

    string back(int steps) {
        for (int i = 0; i < steps && current->prev != nullptr; i++) {
            current = current->prev;
        }
        return current->data;
    }

    string forward(int steps) {
        for (int i = 0; i < steps && current->next != nullptr; i++) {
            current = current->next;
        }
        return current->data;
    }
};
",1.0,11111111
Doubly_Linked_List_8,1533444,2210997,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
   ListNode* prev = nullptr;
    ListNode* curr = head;
    ListNode* next = nullptr;
    int count = 1;
    while (curr != nullptr && count < a) {
        prev = curr;
        curr = curr->right;
        count++;
    }
    ListNode* start = prev;
    ListNode* end = curr;
    while (curr != nullptr && count <= b) {
        next = curr->right;
        curr->right = prev;
        curr->left = next;
        prev = curr;
        curr = next;
        count++;
    }
    if (start != nullptr) {
        start->right = prev;
    }
    else {
        head = prev;
    }
    end->right = curr;
    if (curr != nullptr) {
        curr->left = end;
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1533527,2211367,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head != nullptr) {
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    tail = nullptr;
    curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
    if (head != nullptr)
        head->left = newNode;
    head = newNode;

    if (tail == nullptr)
        tail = head;

    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i, tail, nullptr);
    if (tail != nullptr)
        tail->right = newNode;
    tail = newNode;

    if (head == nullptr)
        head = tail;

    curSize++;
}

int Deque::popFront() {
    if (head == nullptr)
        return -1;

    Node* temp = head;
    int value = temp->value;
    head = head->right;

    if (head != nullptr)
        head->left = nullptr;
    else
        tail = nullptr;

    delete temp;
    curSize--;

    return value;
}

int Deque::popBack() {
    if (tail == nullptr)
        return -1;

    Node* temp = tail;
    int value = temp->value;
    tail = tail->left;

    if (tail != nullptr)
        tail->right = nullptr;
    else
        head = nullptr;

    delete temp;
    curSize--;

    return value;
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533527,2211367,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
     if(count == 0){
        tail = head = new Node(e);
    }
    else{
        Node* tmp = new Node(e);
//! xử lý phần con trỏ để kết nói 2 chiều 
        tail->next = tmp;
        tmp->previous = tail;
        tail = tmp;
    }
//! cộng số lượng danh sách
    count ++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
//! kiểm tra đầu vào có hợp lệ hay không nếu không hợp lệ thì dừng chương trình
    if(index < 0 && index > count) throw out_of_range("""");
//! nếu chưa có phần tử nào và thêm vào đầu danh sách 
    else if(count == 0 || index == count ) add(e);
    else if(index == 0){
//! xử lý con trỏ
        Node* tmp = new Node(e);
        tmp->next = head;
        head->previous = tmp;
        head = tmp;
        count  ++;
    }
    else{
//! tạo 2 node curr và prev lưu node ở vị trí chèn và node trước vị trí chèn
        Node* curr = head->next,* prev = head;
        index --;  
        while(index){
            index--;
            prev = curr;
            curr= curr->next;
        }
//! thực hiện chèn node

        Node* tmp = new Node(e);
        prev->next = tmp;
        tmp->previous = prev;
        tmp->next = curr;
        curr->previous = tmp;
        count ++;
    }
    
}
template<class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1533527,2211367,"
template<class T>
T DLinkedList<T>::get(int index) {
    if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){ 
        tmp = tmp->next;
        index --;
    }
    return tmp->data;
    
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){
        tmp = tmp->next;
        index --;
    }
    tmp->data = e;  
}

template<class T>
bool DLinkedList<T>::empty() {
    return count == 0;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    Node* tmp = head;
    int index = 0;
    while(tmp){
        if(tmp->data == item) return index;
        tmp = tmp->next;
        index ++;
    }
    return -1;
    
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    Node* tmp = head;
    while(tmp){
        if(tmp->data == item) return true;
        tmp = tmp->next;
    }
    return false;
    
}
",1.0,1111111111
Doubly_Linked_List_4,1533527,2211367,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
 
//!  
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
 this->pList = pList;
   if(pList == NULL){index = -1;}
   else if(begin){
        if(this->pList->size() == 0){this->current = NULL;index = -1;}
        else{ this->current = pList->head;index = 0;}
   }
   else{
        this->current = NULL;
        if(this->pList->size() == 0) index = this->pList->size();
        else index = pList->size();
   }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
     this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
     if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
     if(current == NULL) throw out_of_range(""Segmentation fault!"");
   //cout << current->data;
   return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    
    if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    if(index == 0){

        this->pList->removeAt(index);
        this->index = -1;
        current = NULL;
    }
    else{
        T e = this->pList->removeAt(index-1);
        this->index = index - 1;
        current->data = e;
      
}
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
   return !(iterator.index == this->index || iterator.current == this->current);
}
// Prefix ++ overload
template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    DLinkedList<T>::Iterator t = *this;
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return t;
}

",1.0,1111111111
Doubly_Linked_List_5,1533527,2211367,"
template <class T>
T DLinkedList<T>::removeAt(int index)
{
    T result;
//! nếu đúng thì chương trình chạy sai thì dừng chương trình 
    if(index < 0 || index > count || count == 0) throw out_of_range("""");
//! nếu chỉ có 1 phần tử đầu tiên thì reset head = tail = nullptr
    else if(count == 1){
        result = head->data;
        delete head;
        head =tail = nullptr;
    }
//! nếu xóa ở vị trí 0 thì 
    else if(index == 0){
//! lưu data của node đầu tiên lại
        result = head->data;
        Node* tmp = head;
        head = head->next;
//! xóa vùng nhớ
        delete tmp;
    }
    else{
//! giảm index xuống 1 đơn vị
        index --;
        Node* tmp = head;
//! dùng vòng lặp đến vị trí cần tìm
        while(index){
            tmp = tmp->next;
            index --;
        }
        if(tmp->next->next){
            Node* d = tmp->next;
            tmp->next = tmp->next->next;
            result = d->data;
            delete d;
        }
        else{
//! nếu không thỏa if thì phải lưu tail lại vì phần tử đang xóa là phần tử ở vị trí cuối cùng
            tail = tmp;
            Node* d = tmp->next;
            tmp->next = nullptr;
            result = d->data;
            delete d;
        }
    }
    count --;
    return result;
}
//!  
template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
//! xóa node có giá trị bằng phần tử ở vị trí đầu tiên của danh sách nếu có phần tử thì xóa rồi trả về true không thì ngược lại
   int index = indexOf(item);
   if(index == -1 ) return false;
   removeAt(index);
   return true;
    
}
//! giải phóng các node 
template<class T>
void DLinkedList<T>::clear(){
    Node* tmp = head;
    while(tmp){
        tmp = tmp->next;
        delete head;
        head = tmp;
    }
    tail = head = NULL;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1533527,2211367,"
DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
    
}


void DataLog::addCurrentState(int number)
{
    *currentState += number; 
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
 //! Di chuyển con trỏ currentState lên một bước để trỏ tới phần tử tiếp theo trong danh sách.
     currentState++;
//! Kiểm tra nếu currentState không trỏ tới cuối danh sách.     
     if(currentState != logList.end()){
         list<int>::iterator curr = currentState;
         list<int>::iterator prev = currentState;
        while(curr != logList.end()){
            curr++;
            logList.erase(prev);
            prev = curr;
        }
        currentState = logList.end();
       
    }
    currentState--;
  
    logList.push_back(*currentState);
    currentState++;

}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState != logList.begin())
        --currentState;
}
void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     ++currentState;
    if(currentState == logList.end()) --currentState;
  
    
}
   
",1.0,1111111111
Doubly_Linked_List_7,1533527,2211367,"class LineStreet {
private:
    struct Node {
        string element;
        Node* next;
        Node* prev;
        Node(const string& ele) : element(ele), next(nullptr), prev(nullptr) {}
    };

    Node* root;
    Node* current;

public:
    LineStreet(string homepage) {
        root = new Node(homepage);
        current = root;
    }

    void addNewElement(string ele) {
        Node* newNode = new Node(ele);
        current->next = newNode;
        newNode->prev = current;
        current = newNode;
    }

    string back(int steps) {
        while (steps > 0 && current->prev) {
            current = current->prev;
            steps--;
        }
        return current->element;
    }

    string forward(int steps) {
        while (steps > 0 && current->next) {
            current = current->next;
            steps--;
        }
        return current->element;
    }
};",1.0,11111111
Doubly_Linked_List_8,1533527,2211367,"
void SwapNode(ListNode*& head, ListNode*& Node1, ListNode*& Node2){
    if (Node1 == head)
        head = Node2;
    else if (Node2 == head)
        head = Node1;
    ListNode* temp = Node1 -> right;
    Node1 -> right = Node2 -> right;
    Node2 -> right = temp;
    if (Node1 -> right != nullptr)
        Node1 -> right -> left = Node1;
    if (Node2 -> right != nullptr)
        Node2 -> right -> left = Node2;
    temp = Node1 -> left;
    Node1 -> left = Node2 -> left;
    Node2 -> left = temp;
    if (Node1 -> left != nullptr)
        Node1 -> left -> right = Node1;
    if (Node2 -> left != nullptr)
        Node2 -> left -> right = Node2;
    temp = Node1;
    Node1 = Node2;
    Node2 = temp;
}

ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    ListNode* A = head;
    ListNode* B = head;
    a -= 1; b -= 1;
    for (int i = 0; i < a; i++) A = A -> right;
    for (int i = 0; i < b; i++) B = B -> right;
    for (int i = 0; i < (b - a + 1) / 2; i++){
        SwapNode(head, A, B);
        A = A -> right;
        B = B -> left;
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1533649,2212651,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    this->clear();
}

void Deque::clear() {
    while (head) {
        Node* tmp = head;
        head = head->right;
        delete tmp;
        curSize--;
    }
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i);
    newNode->right = head;
    if (!head) {
        head = tail = newNode; curSize++;
        return;
    }
    head->left = newNode;
    head = newNode;
    curSize++;
}

void Deque::pushBack(int i) {
    Node* newNode = new Node(i);
    if (!head) {
        head = tail = newNode; curSize++;
        return;
    }
    tail->right = newNode;
    newNode->left = tail;
    tail = newNode;
    curSize++;
}

int Deque::popFront() {
    if (head == nullptr) return -1;
    int i = head->value;
    Node* tmp = head;
    head = head->right;
    if (head) {
        head->left = nullptr;  // Update the left pointer of the new head
    }
    else {
        tail = nullptr;  // If the deque becomes empty
    }
    delete tmp;
    curSize--;
    return i;
}

int Deque::popBack() {
    if (tail == nullptr) return -1;
    int i = tail->value;
    Node* tmp = tail;
    tail = tail->left;
    if (tail) {
        tail->right = nullptr;  // Update the right pointer of the new tail
    }
    else {
        head = nullptr;  // If the deque becomes empty
    }
    delete tmp;
    curSize--;
    return i;
}

void Deque::printDequeReverse() {
    Node* tmp = tail;
    while (tmp) {
        if (tmp != head) {
            cout << tmp->value << "" "";
        }
        else {
            cout << tmp->value << ""\n"";
        }
        tmp = tmp->left;
    }
}

void Deque::printDeque() {
    Node* tmp = head;
    while (tmp) {
        if (tmp != tail) {
            cout << tmp->value << "" "";
        }
        else {
            cout << tmp->value << ""\n"";
        }
        tmp = tmp->right;
    }
}",1.0,1111111111
Doubly_Linked_List_2,1533649,2212651,"template <class T>
void DLinkedList<T>::add(const T& e) {
//! nếu chưa có phần tử nào thì thêm vào đầu danh sách
    if(count == 0){
        tail = head = new Node(e);
    }
    else{
        Node* tmp = new Node(e);
//! xử lý phần con trỏ để kết nói 2 chiều 
        tail->next = tmp;
        tmp->previous = tail;
        tail = tmp;
    }
//! cộng số lượng danh sách
    count ++;
    
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
//! kiểm tra đầu vào có hợp lệ hay không nếu không hợp lệ thì dừng chương trình
    if(index < 0 && index > count) throw out_of_range("""");
//! nếu chưa có phần tử nào và thêm vào đầu danh sách 
    else if(count == 0 || index == count ) add(e);
    else if(index == 0){
//! xử lý con trỏ
        Node* tmp = new Node(e);
        tmp->next = head;
        head->previous = tmp;
        head = tmp;
        count  ++;
    }
    else{
//! tạo 2 node curr và prev lưu node ở vị trí chèn và node trước vị trí chèn
        Node* curr = head->next,* prev = head;
        index --;  
        while(index){
            index--;
            prev = curr;
            curr= curr->next;
        }
//! thực hiện chèn node

        Node* tmp = new Node(e);
        prev->next = tmp;
        tmp->previous = prev;
        tmp->next = curr;
        curr->previous = tmp;
        count ++;
    }
    
}

template<class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1533649,2212651,"template<class T>
T DLinkedList<T>::get(int index) {
//! kiểm tra đầu vào có hợp lệ hay không
    if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){ 
        tmp = tmp->next;
        index --;
    }
    return tmp->data;
    
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
//! kiểm tra đầu vào có hợp lệ hay không
    if(index < 0 && index >= count) throw out_of_range("""");
    Node* tmp = head;
    while(index){
        tmp = tmp->next;
        index --;
    }
    tmp->data = e;  
}

template<class T>
bool DLinkedList<T>::empty() {
    return count == 0;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
     //Return the first index wheter item appears in list, otherwise return -1 
    Node* tmp = head;
    int index = 0;
    while(tmp){
        if(tmp->data == item) return index;
        tmp = tmp->next;
        index ++;
    }
    return -1;
    
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    //Check if item appears in the list 
    Node* tmp = head;
    while(tmp){
        if(tmp->data == item) return true;
        tmp = tmp->next;
    }
    return false;
    
}",1.0,1111111111
Doubly_Linked_List_4,1533649,2212651,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T>* pList , bool begin)
{
    /*
        Constructor of iterator
        * Set pList to pList
        * begin = true: 
        * * Set current (index = 0) to pList's head if pList is not NULL
        * * Otherwise set to NULL (index = -1)
        * begin = false: 
        * * Always set current to NULL
        * * Set index to pList's size if pList is not NULL, otherwise 0
    */
    
   this->pList = pList;
   if(pList == NULL){index = -1;}
   else if(begin){
        if(this->pList->size() == 0){this->current = NULL;index = -1;}
        else{ this->current = pList->head;index = 0;}
   }
   else{
        this->current = NULL;
        if(this->pList->size() == 0) index = this->pList->size();
        else index = pList->size();
   }
    
    
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const Iterator& iterator)
{
    /*
        Assignment operator
        * Set this current, index, pList to iterator corresponding elements.
    */
    // cout << this->index;
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */

   if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    if(index == 0){

        this->pList->removeAt(index);
        this->index = -1;
        current = NULL;
    }
    else{
        T e = this->pList->removeAt(index-1);
        this->index = index - 1;
        current->data = e;
      
}
}
template <class T>
void DLinkedList<T>::Iterator::set(const T& e)
{
    /*
        Set the new value for current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}   

template <class T>
T& DLinkedList<T>::Iterator::operator*()
{
    /*
        Get data stored in current node
        * Exception: throw std::out_of_range(""Segmentation fault!"") if current is NULL
    */
   if(current == NULL) throw out_of_range(""Segmentation fault!"");
   //cout << current->data;
   return current->data;
}

template <class T>
bool DLinkedList<T>::Iterator::operator!=(const Iterator& iterator)
{
    /*
        Operator not equals
        * Returns false if two iterators points the same node and index
    */
   return !(iterator.index == this->index || iterator.current == this->current);
}
// Prefix ++ overload
template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++()
{
    /*
        Prefix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return *this;
}
// Postfix ++ overload
template <class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int)
{
    /*
        Postfix ++ overload
        * Set current to the next node
        * If iterator corresponds to the previous ""node"" of head, set it to head
        * Exception: throw std::out_of_range(""Segmentation fault!"") if iterator corresponds to the end
    */
    DLinkedList<T>::Iterator t = *this;
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return t;
}
",1.0,1111111111
Doubly_Linked_List_5,1533649,2212651,"
template <class T>
T DLinkedList<T>::removeAt(int index)
{
    T result;
//! kiểm tra đầu vào
    if(index < 0 && index >= count) throw out_of_range("""");
//! nếu chỉ có 1 phần tử
    if(count == 1){
        result = head->data;
        delete head;
        head = tail = NULL;
    }
//! nhiều hơn 1 phần tử và ở vị trí đầu tiên
    else if(index == 0){
        Node* tmp = head;
        head = head->next;
        result = tmp->data;
        delete tmp;
        head->previous = NULL;
    }
    else{
        Node* tmp = head;
//! tìm vị trí trước vị trí cần xóa
        index --; 
        while(index){
            tmp = tmp->next;
            index --;
        }
//! lưu vị giá trị xóa đi
        result = tmp->next->data;
//! nếu nó là vị trí cuối cùng
        if(tmp->next == tail){
            delete tail;
            tail = tmp;
            tail->next = NULL;
        }
        else{
            Node* h = tmp->next;
            tmp->next = tmp->next->next;
            tmp->next->previous = tmp;
            delete h;
        }
    }
    count --;
    return result;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    int index = indexOf(item);
    if(index == -1) return false;
    removeAt(index);
    return true;
    
}

template<class T>
void DLinkedList<T>::clear(){
    Node* tmp = head;
    while(head){
        head = head->next;
        delete tmp;
        tmp = head;
    }
    head = tail = NULL;
    count = 0;  
}",1.0,1111111111
Doubly_Linked_List_6,1533649,2212651,"
DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_front(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
    
}

void DataLog::addCurrentState(int number)
{
    *currentState += number; 
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
 //! Di chuyển con trỏ currentState lên một bước để trỏ tới phần tử tiếp theo trong danh sách.
     currentState++;
//! Kiểm tra nếu currentState không trỏ tới cuối danh sách.     
     if(currentState != logList.end()){
         list<int>::iterator curr = currentState;
         list<int>::iterator prev = currentState;
        while(curr != logList.end()){
            curr++;
            logList.erase(prev);
            prev = curr;
        }
        currentState = logList.end();
       
    }
    currentState--;
  
    logList.push_back(*currentState);
    currentState++;
    //  for (auto i = logList.begin(); i != logList.end(); i++) {
    //         cout << ""[ "" << *i << "" ] => "";
    //     }
    //     cout<<endl;

}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState != logList.begin())
        --currentState;
}
void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     ++currentState;
    if(currentState == logList.end()) --currentState;
  
    
}
   ",1.0,1111111111
Doubly_Linked_List_7,1533649,2212651,"class LineStreet {
public:
    struct Node {
        string data;
        Node* next;
        Node* prev;
    };

    Node* root;   
    Node* current; 

    LineStreet(string homepage) {
        Node* newNode = new Node;
        newNode->data = homepage;
        newNode->next = nullptr;
        newNode->prev = nullptr;
        root = newNode;
        current = newNode;
    }
    
    void addNewElement(string url) {
        Node* newNode = new Node;
        newNode->data = url;
        newNode->next = nullptr;
        newNode->prev = current;
        current->next = newNode;
        current = newNode;
    }

    string back(int steps) {
        for (int i = 0; i < steps && current->prev != nullptr; i++) {
            current = current->prev;
        }
        return current->data;
    }

    string forward(int steps) {
        for (int i = 0; i < steps && current->next != nullptr; i++) {
            current = current->next;
        }
        return current->data;
    }
};",1.0,11111111
Doubly_Linked_List_8,1533649,2212651,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    ListNode *tmp = head;
    ListNode *tmp1 = head;
    int range = b-a+1;
    for (int i=1; i<a; i++)
        tmp = tmp->right;
    
    for (int i=1; i<b; i++)
        tmp1 = tmp1->right;
    
    for (int i=0; i<range/2; i++){
        ListNode *rtmp = tmp->right;
        ListNode *ltmp = tmp->left;
        ListNode *ltmp1 = tmp1->left;
        ListNode *rtmp1 = tmp1->right;
        if (ltmp)
            ltmp->right = tmp1;
        if (rtmp1)
            rtmp1->left = tmp;
        tmp1->left = ltmp;
        tmp->right = rtmp1;
        if (rtmp == tmp1){
            tmp->left = tmp1;
            tmp1->right = tmp;
        }
        else if (rtmp == ltmp1){
            rtmp->left = tmp1;
            rtmp->right = tmp;
            tmp1->right = rtmp;
            tmp->left = rtmp;
        }
        else{
            rtmp->left = tmp1;
            tmp1->right = rtmp;
            ltmp1->right = tmp;
            tmp->left = ltmp1;
        }
        if (ltmp == nullptr)
            head = tmp1;
        ListNode *p = tmp;
        tmp = tmp1;
        tmp1 = p;
        tmp1 = tmp1->left;
        tmp = tmp->right;
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1533667,2212741,"Deque::Deque() : head(nullptr), tail(nullptr), curSize(0) {}

Deque::~Deque() {
    clear();
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int item) {
    Node* newNode = new Node(item, nullptr, head);
    if (curSize == 0) {
        head = tail = newNode;
    } else {
        head->left = newNode;
        head = newNode;
    }
    curSize++;
}

void Deque::pushBack(int item) {
    Node* newNode = new Node(item, tail, nullptr);
    if (curSize == 0) {
        head = tail = newNode;
    } else {
        tail->right = newNode;
        tail = newNode;
    }
    curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
        return -1;
    }
    int result = head->value;
    Node* temp = head;
    if (curSize == 1) {
        head = tail = nullptr;
    } else {
        head = head->right;
        head->left = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

int Deque::popBack() {
    if (curSize == 0) {
        return -1;
    }
    int result = tail->value;
    Node* temp = tail;
    if (curSize == 1) {
        head = tail = nullptr;
    } else {
        tail = tail->left;
        tail->right = nullptr;
    }
    delete temp;
    curSize--;
    return result;
}

void Deque::clear() {
    while (curSize > 0) {
        popFront();
    }
}

void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        std::cout << current->value << "" "";
        current = current->left;
    }
    std::cout << std::endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->value << "" "";
        current = current->right;
    }
    std::cout << std::endl;
}
",1.0,1111111111
Doubly_Linked_List_2,1533667,2212741,"template <class T>
void DLinkedList<T>::add(const T &e) {
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template <class T>
void DLinkedList<T>::add(int index, const T &e) {
    if (index < 0 || index > count) {
        // Index out of bounds
        return;
    }

    if (index == count) {
        // Adding to the end of the list
        add(e);
        return;
    }

    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        newNode->previous = current;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
}

template <class T>
int DLinkedList<T>::size() {
    return count;
}
",1.0,1111111111
Doubly_Linked_List_3,1533667,2212741,"template <class T>
bool DLinkedList<T>::empty() {
    return count == 0;
}

template <class T>
T DLinkedList<T>::get(int index) {
    if (index < 0 || index >= count) {
        // Index out of bounds
        return T(); // Return a default-constructed object for invalid index
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }

    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T &e) {
    if (index < 0 || index >= count) {
        // Index out of bounds
        return;
    }

    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }

    current->data = e;
}

template <class T>
int DLinkedList<T>::indexOf(const T &item) {
    Node* current = head;
    for (int i = 0; i < count; i++) {
        if (current->data == item) {
            return i;
        }
        current = current->next;
    }

    return -1; // Item not found
}

template <class T>
bool DLinkedList<T>::contains(const T &item) {
    return indexOf(item) != -1;
}
",1.0,1111111111
Doubly_Linked_List_4,1533667,2212741,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if (begin) {
        this->current = pList->head;
        this->index = 0;
    } else {
        this->current = NULL;
        this->index = pList->count;
    }

}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
        this->current = iterator.current;
    this->index = iterator.index;
    return *this;

}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current != NULL) {
        this->current->data = e;
    }

}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current != NULL && this->pList != NULL) {
        Node* nodeToRemove = this->current;

        if (nodeToRemove == this->pList->head) {
            this->pList->head = nodeToRemove->next;
        }

        if (nodeToRemove == this->pList->tail) {
            this->pList->tail = nodeToRemove->previous;
        }

        if (nodeToRemove->next != NULL) {
            nodeToRemove->next->previous = nodeToRemove->previous;
        }

        if (nodeToRemove->previous != NULL) {
            nodeToRemove->previous->next = nodeToRemove->next;
            this->current = nodeToRemove->previous;
        } else {
            this->current = NULL;
        }

        delete nodeToRemove;
        this->pList->count--;
    }

}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
        return this->current != iterator.current;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
        if (this->current != NULL) {
        this->current = this->current->next;
    } else if (this->pList != NULL) {
        this->current = this->pList->head;
    }
    
    return *this;

}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator iteratorBeforeIncrementation(*this);
    
    ++*this;

    return iteratorBeforeIncrementation;

}
",1.0,1111111111
Doubly_Linked_List_5,1533667,2212741,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    if (index < 0 || index >= count)
        throw out_of_range(""Index out of range"");

    Node *currentNode = head;
    T removedData;

    if (index == 0)
    {
        head = currentNode->next;
        if (head != nullptr)
            head->previous = nullptr;
        else
            tail = nullptr;
        removedData = currentNode->data;
        delete currentNode;
    }
    else
    {
        for (int i = 0; i < index - 1; i++)
        {
            currentNode = currentNode->next;
        }

        Node *nodeToRemove = currentNode->next;
        Node *nextNode = nodeToRemove->next;

        currentNode->next = nextNode;
        if (nextNode != nullptr)
            nextNode->previous = currentNode;
        else
            tail = currentNode;

        removedData = nodeToRemove->data;
        delete nodeToRemove;
    }

    count--;
    return removedData;
}

template <class T>
bool DLinkedList<T>::removeItem(const T &item)
{
    Node *currentNode = head;
    Node *prevNode = nullptr;

    while (currentNode != nullptr)
    {
        if (currentNode->data == item)
        {
            if (prevNode == nullptr)
            {
                head = currentNode->next;
                if (head != nullptr)
                    head->previous = nullptr;
                else
                    tail = nullptr;
            }
            else
            {
                prevNode->next = currentNode->next;
                if (currentNode->next != nullptr)
                    currentNode->next->previous = prevNode;
                else
                    tail = prevNode;
            }

            delete currentNode;
            count--;
            return true;
        }

        prevNode = currentNode;
        currentNode = currentNode->next;
    }

    return false;
}

template <class T>
void DLinkedList<T>::clear()
{
    Node *currentNode = head;

    while (currentNode != nullptr)
    {
        Node *nextNode = currentNode->next;
        delete currentNode;
        currentNode = nextNode;
    }

    head = nullptr;
    tail = nullptr;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1533667,2212741,"DataLog::DataLog() {
    // Add the first state with 0
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data) {
    // Add the first state with data
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number) {
    // Increase the value of the current state by number
    *currentState += number;
}

void DataLog::subtractCurrentState(int number) {
    // Decrease the value of the current state by number
    *currentState -= number;
}

void DataLog::save() {
    // Create a new state, copy the data of the currentState, and move the currentState Iterator to this new state.
    if (currentState != prev(logList.end())) {
        logList.erase(next(currentState), logList.end());
    }
    logList.push_back(*currentState);
    currentState = prev(logList.end());
}

void DataLog::undo() {
    // Switch to the previous state of the data
    if (currentState != logList.begin()) {
        --currentState;
    }
}

void DataLog::redo() {
    // Switch to the latter state of the data
    if (currentState != prev(logList.end())) {
        ++currentState;
    }
}
",1.0,1111111111
Doubly_Linked_List_7,1533667,2212741,"class LineStreet {
public:
    class Node{
        public:
            string data;
            Node* next;
            Node* prev;
            Node(string data):data(data),next(nullptr),prev(nullptr){}
            friend class LineStreet;
    };
private:
    Node* head, *tail;
    Node* current;
    int size;
public:
    LineStreet(string homepage) {
        head=tail=new Node(""home"");
        size=0;
        current=head;
        size=1;
    }
    
    void addNewElement(string url) {
        freeFrom(current->next);
        Node* newNode= new Node(url);
        current->next=newNode;
        newNode->prev=current;
        current = newNode;
        tail=newNode;
        size++;
    }

    string back(int steps) {
        while(current!=head&& steps--){
            current=current->prev;
        }
        return current->data;
    }

    string forward(int steps) {
        while(current!=tail && steps--){
            current=current->next;
        }
        return current->data;
    }
    void freeFrom(Node* p){
        while(p){
            Node* tmp=p;
            p=p->next;
            delete tmp;
            size--;
        }
    }
};
",1.0,11111111
Doubly_Linked_List_8,1533667,2212741,"ListNode* reverse(ListNode* head, int a, int b) {
    if (!head || a == b) {
        return head;
    }

    ListNode* dummy = new ListNode(0);
    dummy->right = head;
    head->left = dummy;
    ListNode* prev = dummy;
    int count = 1;

    while (count < a) {
        prev = prev->right;
        count++;

        if (!prev->right) {
            // a is out of bounds
            return head;
        }
    }

    ListNode* current = prev->right;
    ListNode* next = current->right;

    while (count < b) {
        if (!next) {
            // b is out of bounds
            return head;
        }

        current->right = next->right;
        if (next->right) {
            next->right->left = current;
        }

        next->right = prev->right;
        prev->right->left = next;
        prev->right = next;
        next->left = prev;
        next = current->right;
        count++;
    }

    return dummy->right;
}
",1.0,1111111111
Doubly_Linked_List_1,1533726,2211738,"Deque::Deque() {
    head = tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    if(head != nullptr){
        for(int i = 0; i < curSize; i++){
            if(head != nullptr){
                Node* temp = head;
                head = head->right;
                temp->left = temp->right = nullptr;
                delete temp;   
            }
        }   
    }
    head = tail = nullptr;
    curSize = 0;
}

void Deque::clear() {
    if(head == nullptr) return;
    for(int i = 0; i < curSize; i++){
        if(head != nullptr){
            Node* temp = head;
            temp->left = temp->right = nullptr;
            head = head->right;
            delete temp;   
        }
    }
    head = tail = nullptr;
    curSize = 0;
}

int Deque::getSize() {
    return this->curSize;
}

void Deque::pushFront(int i) {
    if(head == nullptr){
        head = new Node(i,nullptr,nullptr);
        tail = head;
        curSize++;
        return;
    }
    curSize++;
    head->left = new Node(i,nullptr,head);
    head = head->left;
}

void Deque::pushBack(int i) {
    if(head == nullptr){
        head = new Node(i,nullptr,nullptr);
        tail = head;
        curSize++;
        return;
    }
    curSize++;
    tail->right = new Node(i,tail,nullptr);
    tail = tail->right;
}

int Deque::popFront() {
    if(head == nullptr){
        curSize = 0;
        return -1;
    }
    curSize--;
    Node* temp = head;
    int tmp = head->value;
    head = head->right;
    if(head != nullptr){
        head->left = nullptr;
    }else{
        tail = nullptr;
    }
    temp->left = temp->right = nullptr;
    delete temp;
    return tmp;
}

int Deque::popBack() {
    if(tail == nullptr){
        curSize = 0;
        return -1;
    }
    curSize--;
    Node* temp = tail;
    int tmp = tail->value;
    tail = tail->left;
    if(tail != nullptr){
        tail->right = nullptr;
    }else{
        head = nullptr;
    }
    temp->left = temp->right = nullptr;
    delete temp;
    return tmp;
}

void Deque::printDequeReverse() {
    if(tail == nullptr) return;
    Node* temp = tail;
    while(temp != nullptr){
        cout << temp->value << "" "";
        temp = temp->left;
    }
    cout << '\n';
}

void Deque::printDeque() {
    if(head == nullptr) return;
    Node* temp = head;
    while(temp != nullptr){
        cout << temp->value << "" "";
        temp = temp->right;
    }
    cout << '\n';
}",1.0,1111111111
Doubly_Linked_List_2,1533726,2211738,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* pNew = new Node(e);
    if (this->head == NULL) {
        this->head = this->tail = pNew;
    }
    else {
        this->tail->next = pNew;
        pNew->previous = this->tail;
        this->tail = pNew;
    }
    ++this->count;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index > this->count || index < 0) {
		throw (""out of range"");
		return;
	}
		
	if (index == this->count && this->count != 0) {
		add(e);
		return;
	}
	
	Node* pNew = new Node(e);
	if (this->count == 0) 
        this->head = this->tail = pNew;
    else if (index == 0) {
        pNew->next = this->head;
        this->head->previous = pNew;
        this->head = pNew;
    }
    else {
        Node* prev = this->head;
        for (int i = 0; i < index - 1; i++) prev = prev->next;
        Node* cur = prev->next;
        pNew->next = prev->next;
        cur->previous = pNew;
        pNew->previous = prev;
        prev->next = pNew;
    }
    ++this->count;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
     return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1533726,2211738,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= this->count) 
        throw std::out_of_range(""Invalid Index!"");
    Node* temp = this->head;
    for (int i = 0; i < index; i++) temp = temp->next;
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= this->count) 
        throw std::out_of_range(""Invalid Index!"");
    Node* temp = this->head;
    for (int i = 0; i < index; i++) temp = temp->next;
    temp->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
     return (this->count == 0);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
     Node* temp = this->head;
    int i = 0;
    while (temp != NULL) {
        if (temp->data == item)
            return i;
        temp = temp->next;
        ++i;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (this->indexOf(item) != -1);
}",1.0,1111111111
Doubly_Linked_List_4,1533726,2211738,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
	if (begin == true)
	{
		if (this->pList == NULL)
		{
			this->current = NULL;
			this->index = -1;
		}
		else
		{
			this->current = this->pList->head;
			this->index = 0;
		}
	}
	else
	{
		this->current = NULL;
		this->index = (this->pList->count == 0) ? (this->pList->size()) : 0;
	}
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
	this->current = iterator.current;
	this->index = iterator.index;
	return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else
		this->pList->set(this->index, e);
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
     if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current == NULL)
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == this->pList->head)
	{
		this->current = NULL;
		this->pList->removeAt(this->index);
		this->index = -1;
	}
	else
	{
		this->current = this->current->previous;
		this->pList->removeAt(this->index);
		--this->index;
	}
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (this->pList != iterator.pList || this->current != iterator.current);
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else if (this->current == NULL && this->index == -1)
	{
		this->current = this->pList->head;
		this->index = 0;
	}
	else
	{
		this->current = this->current->next;
		++this->index;
	}
	return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator newIterator(this->pList, true);
	if (this->current == NULL && this->index == this->pList->size())
		throw std::out_of_range(""Segmentation fault!"");
	else {
	    newIterator = *this;
	    ++*this;
	    return newIterator;
	}
}

",1.0,1111111111
Doubly_Linked_List_5,1533726,2211738,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= this->count)
        throw std::out_of_range(""The index is out of range!"");
    T dataDel;
    Node* temp = this->head;
    if (this->count == 1) {
        dataDel = this->head->data;
        delete this->head;
        this->head = this->tail = NULL;
    }
    else if (index == 0) {
        dataDel = temp->data;
        this->head = temp->next;
        delete temp;
        temp = this->head;
        this->head->previous = NULL;
    }
    else if (index == this->count - 1) {
        while (temp->next->next != NULL) temp = temp->next;
        dataDel = this->tail->data;
        delete this->tail;
        this->tail = temp;
        temp->next = NULL;
    }
    else {
        for (int i = 0; i < index; i++) temp = temp->next;
        dataDel = temp->data;
        temp->previous->next = temp->next;
        temp->next->previous = temp->previous;
        delete temp;
        temp = NULL;
    }
    --this->count;
    return dataDel;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int index = this->indexOf(item);
    if (index != -1) {
        this->removeAt(index);
        return true;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (this->count != 0) this->removeAt(0);
}
",1.0,1111111111
Doubly_Linked_List_6,1533726,2211738,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
     logList.push_back(0);
	currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
     logList.push_back(data);
	currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *this->currentState = *this->currentState + number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *this->currentState = *this->currentState - number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    list<int>::iterator a = currentState;
	++a;
	while (a != logList.end()) {
		a = logList.erase(a);
	}
	logList.push_back(*currentState);
	++currentState;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if (currentState != logList.begin()) currentState = prev(currentState, 1);
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    list<int>::iterator a = currentState;
	list<int>::iterator b = ++a;
	if (b != logList.end()) ++currentState;
}
",1.0,1111111111
Doubly_Linked_List_8,1533726,2211738,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* copy(ListNode* tmp){
    ListNode* temp = new ListNode(tmp->val,tmp->left,tmp->right);
    return temp;
}
ListNode* reverse(ListNode*& head, int a, int b) {
    //To Do
    if(head == nullptr) return nullptr;
    ListNode* temp1, *temp2;
    temp1 = temp2 = head;
    for(int i = 0; i < a-1; i++){
        if(temp1 != nullptr){
            temp1 = temp1->right;
        }
    }
    for(int i = 0; i < b-1; i++){
        if(temp2 != nullptr){
            temp2 = temp2->right;
        }
    }
    int size = b - a + 1;
    int change = 1;
    while(temp1 != nullptr && temp2 != nullptr && size > 1 )
    {
        ListNode* tmp = copy(temp1);
        if(temp1->right == temp2){
            temp1->right = temp2->right;
            temp2->left = temp1->left;
            
            temp2->right->left = temp1;
            temp1->left->right = temp2;
            
            temp1->left = temp2;
            temp2->right = temp1;
        }else if(temp1->left == temp2){
            temp1->left = temp2->left;
            temp2->right = temp1->right;
            
            temp2->left->right = temp1;
            temp1->right->left = temp2;
            
            temp1->right = temp2;
            temp2->left = temp1;
        }else{
            temp1->left = temp2->left;
            temp1->right = temp2->right;
            
            if(temp2->right == NULL){
                temp2->left->right = temp1;
            }else{
                temp2->right->left = temp1;
                temp2->left->right = temp1;   
            }
            
            temp2->left = tmp->left;
            temp2->right = tmp->right;
            if(temp1 == head){
                head = temp2;
                tmp->right->left = temp2;
            }else{
                tmp->left->right = temp2;
                tmp->right->left = temp2;
            }    
        }
        
        size -= 2;
        if(change % 2 != 0){
            temp2 = temp2->right;
            temp1 = temp1->left;
        }else {
            temp2 = temp2->left;
            temp1 = temp1->right;
        }
        change++;
    }
    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1533822,2211821,"Deque::Deque() {
head = nullptr;
tail = nullptr;
curSize = 0;
}

Deque::~Deque() {
clear();
}

void Deque::clear() {
while (curSize > 0) {
            popFront();
        }
}

int Deque::getSize() {
 return curSize;
}

void Deque::pushFront(int item) {
        Node* newNode = new Node(item, nullptr, head);
        if (head != nullptr) {
            head->left = newNode;
        }
        head = newNode;
        if (tail == nullptr) {
            tail = head;
        }
        curSize++;
}

void Deque::pushBack(int item) {
        Node* newNode = new Node(item, tail, nullptr);
        if (tail != nullptr) {
            tail->right = newNode;
        }
        tail = newNode;
        if (head == nullptr) {
            head = tail;
        }
        curSize++;
}

int Deque::popFront() {
        if (curSize == 0) {
            return -1;
        }
        int value = head->value;
        Node* temp = head;
        head = head->right;
        if (head != nullptr) {
            head->left = nullptr;
        }
        if (temp == tail) {
            tail = nullptr;
        }
        delete temp;
        curSize--;
        return value;

}

int Deque::popBack() {
        if (curSize == 0) {
            return -1;
        }
        int value = tail->value;
        Node* temp = tail;
        tail = tail->left;
        if (tail != nullptr) {
            tail->right = nullptr;
        }
        if (temp == head) {
            head = nullptr;
        }
        delete temp;
        curSize--;
        return value;
}

void Deque::printDequeReverse() {
        Node* current = tail;
        while (current != nullptr) {
            std::cout << current->value << "" "";
            current = current->left;
        }
        std::cout << std::endl;
}

void Deque::printDeque() {
        Node* current = head;
        while (current != nullptr) {
            std::cout << current->value << "" "";
            current = current->right;
        }
        std::cout << std::endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533822,2211821,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
     Node* x = new Node(e);
    if (tail == nullptr) {
        // If the list is empty, set both head and tail to the new node.
        head = x;
        tail = x;
    } else {
        tail->next = x;
        x->previous = tail;
        tail = x;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        // Invalid index, do nothing.
        return;
    }
    Node* x = new Node(e);
    if (index == 0) {
        // Insert at the beginning.
        if (head == nullptr) {
            // If the list is empty, set both head and tail to the new node.
            head = x;
            tail = x;
        } else {
            x->next = head;
            head->previous = x;
            head = x;
        }
    } else if (index == count) {
        // Insert at the end.
        tail->next = x;
        x->previous = tail;
        tail = x;
    } else {
        // Insert at a specific index.
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        x->next = current;
        x->previous = current->previous;
        current->previous->next = x;
        current->previous = x;
    }
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1533822,2211821,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of bounds"");
    }
    
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
     if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of bounds"");
    }
    
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    for (int i = 0; i < count; i++) {
        if (current->data == item) {
            return i;
        }
        current = current->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1533822,2211821,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) {
    this->pList = pList; 
    if (begin) {
        current = pList ? pList->head : nullptr; 
        index = pList ? 0 : -1; 
    }
    else {
        current = nullptr; 
        index = pList->size(); 
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator) {
    pList = iterator.pList; 
    current = iterator.current; 
    index = iterator.index; 
    return *this; 
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e) {
    if (current == nullptr) throw std::out_of_range(""Segmentation fault"");
    current->data = e; 
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() {
    if (current == nullptr) throw std::out_of_range(""Segmentation fault"");
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current == nullptr) throw std::out_of_range(""Segmentation fault"");
    Node* p = current->previous; 
    pList->removeAt(index--); 
    current = p; 
    // chu y 
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator)  {
    return !(this->current == iterator.current && this->pList == iterator.pList && this->index == iterator.index); 
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() {
    if (current == nullptr && index == pList->size()) throw std::out_of_range(""Segmentation fault"");
    if (current == nullptr && index == -1) {
        current = pList->head; 
        index = 0; 
    }
    else {
        current = current->next; 
        index++;
    }
    return *this; 
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    if (current == nullptr && index == pList->size()) throw std::out_of_range(""Segmentation fault"");
    Iterator temp = *this; 
    if (current == nullptr && index == -1) {
        current = pList->head; 
    } 
    else current = current->next; 
    index++; 
    return temp; 
}",1.0,1111111111
Doubly_Linked_List_5,1533822,2211821,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count) throw std::out_of_range(""""); 
    int x; 
    if (index) {
        Node* p = head; 
        while (index > 1 && p) {
            index--; p = p->next; 
        }
        if (tail == p->next) tail = p; 
        Node* temp = p->next; 
        p->next = p->next->next; 
        if (p->next != nullptr) p->next->previous = p; 
        x = temp->data; 
        delete temp; 
    }
    else {
        Node* temp = head; 
        head = head->next; 
        x = temp->data; 
        delete temp;
        if (head != nullptr) head->previous = nullptr; 
        if (count == 1) tail = nullptr; 
    }
    
    count--; 
    return x; 
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* p = head; 
    int idx = 0; 
    while (p && p->data != item) {
        p = p->next; 
        idx++; 
    }
    if (p) removeAt(idx); 
    else return false; 
    return true; 
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node* cur = head; 
    while (cur) {
        Node* p = cur; 
        cur = cur->next; 
        delete p; 
    }
    head = nullptr; 
    tail = nullptr; 
    count = 0; 
}",1.0,1111111111
Doubly_Linked_List_6,1533822,2211821,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
      logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
      logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
     *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
     *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
      auto newState = currentState;
    ++newState;
    logList.erase(newState, logList.end());
    logList.push_back(*currentState);
    currentState = --logList.end();
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if (currentState != logList.begin())  --currentState;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     auto lastState = --logList.end();
    if (currentState != lastState)  ++currentState;
    
}
",1.0,1111111111
Doubly_Linked_List_7,1533822,2211821,"class LineStreet {
public:
class Node{
public:
    string data;
    Node* prev;
    Node* next;
    friend class LineStreet;
    Node(string data, Node* prev = nullptr, Node* next = nullptr){
    this->data =data;
    this->prev =prev;
    this->next =next;
}    
};    
Node* root;
public:

    LineStreet(string homepage) {
        root = new Node(homepage);
    }
    
    void addNewElement(string url) {
        Node* temp = new Node(url, root, nullptr);
        if(root->next == nullptr){
            Node* del = root->next;
            while(del){
                Node* tmp =del;
                del = del->next;
                delete tmp;
            }
        }
        root->next = temp;
        root=temp;
    }

    string back(int steps) {
        Node* temp = root;
        for( int i=0;i<steps;i++){
            if(temp->prev == nullptr) {
                root = temp;
                return temp->data;
            }
            temp =temp->prev;
        }
        root =temp;
        return temp->data;
    }

    string forward(int steps) {
          Node* temp = root;
        for( int i=0;i<steps;i++){
            if(temp->next == nullptr) {
                root = temp;
                return temp->data;
            }
            temp =temp->next;
        }
        root =temp;
        return temp->data;
    }
};
",1.0,11111111
Doubly_Linked_List_8,1533822,2211821,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    ListNode* pA = head; 
    ListNode* pB = head;
    for (int i = 1; i < a; i++) pA = pA->right; 
    for (int i = 1; i < b; i++) pB = pB->right;
    if (a == 1) head = pB; 
    if (pA->left) pA->left->right = pB; 
    if (pB->right) pB->right->left = pA; 
    ListNode* t = pA->left; 
    pA->left = pB->right; 
    pB->right = t; 
    
    for (int i = 0; i <= b-a; i++) {
        ListNode* t = pA->right; 
        pA->right = pA->left; 
        pA->left = t; 
        pA = pA->left;
    }
    
    return head; 
}",1.0,1111111111
Doubly_Linked_List_1,1533838,2212303,"Deque::Deque() {
    this->head=nullptr;
    this->tail=nullptr;
    this->curSize=0;
}

Deque::~Deque() {
    this->clear();
}

void Deque::clear() {
     while (head) {
            Node* temp = head;
            head = head->right;
            delete temp;
        }
        tail = nullptr;
        curSize = 0;
}

int Deque::getSize() {
    return this->curSize;
}

void Deque::pushFront(int i) {
    Node* newNode = new Node(i, nullptr, head);
        if (head) {
            head->left = newNode;
        } else {
            tail = newNode;
        }
        head = newNode;
        curSize++;
}

void Deque::pushBack(int i) {
     Node* newNode = new Node(i, tail, nullptr);
        if (tail) {
            tail->right = newNode;
        } else {
            head = newNode;
        }
        tail = newNode;
        curSize++;
}

int Deque::popFront() {
    if (curSize == 0) {
            return -1;
        }
        int value = head->value;
        Node* oldHead = head;
        head = head->right;
        delete oldHead;
        if (head) {
            head->left = nullptr;
        } else {
            tail = nullptr;
        }
        curSize--;
        return value;
}

int Deque::popBack() {
   if (curSize == 0) {
            return -1;
        }
        int value = tail->value;
        Node* oldTail = tail;
        tail = tail->left;
        delete oldTail;
        if (tail) {
            tail->right = nullptr;
        } else {
            head = nullptr;
        }
        curSize--;
        return value;
}

void Deque::printDequeReverse() {
   Node* curr=this->tail;
   while(curr!=this->head){
       if(curr==nullptr) break;
       cout<<curr->value<<"" "";
       curr=curr->left;
   }
   if(curr!=nullptr) cout<<curr->value<<endl;
}

void Deque::printDeque() {
   Node* curr=this->head;
   while(curr!=this->tail){
        if(curr==nullptr) break;
       cout<<curr->value<<"" "";
       curr=curr->right;
   }
   if(curr!=nullptr) cout<<curr->value<<endl;
}",1.0,1111111111
Doubly_Linked_List_2,1533838,2212303,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newN=new Node(e);
    if(this->count==0){
        this->head=newN;
        this->tail=newN;
    }
    else{
    newN->previous=this->tail;
    this->tail->next=newN;
    this->tail=this->tail->next;
    }
    this->count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index<0) return;
    if(this->count==0) {this->add(e); return;}
    Node* curr=this->head;
    Node* prev=nullptr;
    for(int i=0; i<index && curr!=nullptr; i++){
        prev=curr;
        curr=curr->next;
    }
    
    Node* newN=new Node(e);
    
        newN->previous=prev;
    
    newN->next=curr;
    if(prev!=nullptr){
        prev->next=newN;
        
    }else{
        this->head=newN;
    }
    if(curr!=nullptr){
        curr->previous=newN;
        
    }else{
        this->tail=newN;
    }
    this->count++;
    
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return this->count;
}",1.0,1111111111
Doubly_Linked_List_3,1533838,2212303,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    //if(index<0) throw std::out_of_range(""Out of bounds"");
    //if(index>=this->count) return this->tail->data;
    Node* curr=this->head;
    
    for(int i=0; i<index && curr!=nullptr; i++){
        
        curr=curr->next;
    }
    
    return curr->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    //if(index<0) {throw std::out_of_range(""Out of bounds""); return;}
    //if(index>=this->count)  {this->tail->data=e; return;}
    Node* curr=this->head;
    
    for(int i=0; i<index && curr!=nullptr; i++){
        
        curr=curr->next;
    }
    curr->data=e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (this->head==nullptr);
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    int result=-1;
    Node* curr=this->head;
    int index=0;
    while(curr!=nullptr){
        
        if(curr->data==item){
            result=index;
            break;
        }
        index++;
        curr=curr->next;
    }
    return result;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (this->indexOf(item)!=-1);
}",1.0,1111111111
Doubly_Linked_List_4,1533838,2212303,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    //if (pList!= nullptr){  
        this->pList=pList;
        if (begin){
            if (pList!=nullptr) {
                this->current=pList->head;
                this->index=0;
            }else this->index=-1;
        } else {
            this->current=nullptr;
            if(pList!=nullptr) index=pList->count;
            else index=0;
        }
    //}
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList=iterator.pList;
    this->index=iterator.index;
    this->current=iterator.current;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(current!=nullptr) current->data=e;
    else throw std::out_of_range(""Segmentation fault!"");
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
     if(current!=nullptr) return current->data;
    else throw std::out_of_range(""Segmentation fault!"");
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (this->current == nullptr) {
        throw std::out_of_range(""Segmentation fault!"");
    }

    if (current == pList->head /*&& index == 0 && pList->head != nullptr*/) {
        // Removing the head node
        //Iterator temp = *this;
        //pList->head = pList->head->next;
        //if(pList->count==1){
            //pList->head==nullptr;
            //pList->tail==nullptr;
        //}
        //pList->head=pList->head->next;
        //if(pList->head!=nullptr) pList->head->previous=nullptr;
        pList->removeAt(0);
        current = nullptr; // Updated to previous ""node"" of head
        index = -1;
        //pList->count--;
        //Iterator temp = *this;
        //this==temp++;
    } else {
        // Removing a non-head node
        Node* temp=current->previous;
         /*Node* temp=current->previous;
        temp->next=current->next;
        if(current->next!=nullptr){
            current->next->previous=temp;
        }*/
        pList->removeAt(index);
        
        
        // Move the iterator to the previous node
        current=temp;
        //pList->count--;
        index--;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return (!(this->current==iterator.current && this-> index==iterator.index ));
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
     if (current == pList->tail) {
                //throw std::out_of_range(""Segmentation fault!"");
        current=nullptr;
        this->index=pList->count;
        
    }
    else{
        if (/*current->next == pList->head||*/current==nullptr&&index==-1) {
           current = pList->head;
           index = 0;
        }
        else {
           current = current->next;
           index++;
        }
    }
       
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    if (current == pList->tail) {
        //throw std::out_of_range(""Segmentation fault!"");
        current=nullptr;
        this->index=pList->count;
        
    }
    else{
        if (/*current->next == pList->head||*/current==nullptr&&index==-1) {
           current = pList->head;
           index = 0;
        }
        else {
           current = current->next;
           index++;
        }
    }
    return temp;
}

",1.0,1111111111
Doubly_Linked_List_5,1533838,2212303,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    
   
    Node* curr=this->head;
    
    for(int i=0; i<index && curr!=nullptr; i++){
       
        curr=curr->next;
    }
    T result=curr->data;
    this->count--;
    if(curr==this->head){
        this->head=curr->next;
    }
    if(curr==this->tail){
        this->tail=curr->previous;
    }
    if(this->head==nullptr ||  this->tail==nullptr){
        this->head=nullptr;
        this->tail=nullptr;
    }
    
    Node* prev=curr->previous;
    if(prev!=nullptr){
        prev->next=curr->next;
    }
    if(curr->next!=nullptr){
        curr->next->previous=prev;
    }
    curr=curr->next;
    
    return result;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int index=this->indexOf(item);
    if(index==-1) return false;
    else {
        this->removeAt(this->indexOf(item));
        return true;
    }
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while(!this->empty()){
        this->removeAt(0);
    }
}
",1.0,1111111111
Doubly_Linked_List_6,1533838,2212303,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    if (logList.empty()) return;

    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
      this->addCurrentState(-number);
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
     if (!logList.empty()) {
            // Create a new state by copying the data of the current state
            int currVal = *currentState;
            logList.erase(++currentState, logList.end());
            logList.push_back(currVal);
            currentState = --logList.end();
    }
     
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
       if (currentState != logList.begin())
    {
        // Move currentState iterator to previous state
        currentState--;
    }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    if (currentState != --logList.end()) {
            // Switch to the next state
            ++currentState;
    }
}
",1.0,1111111111
Doubly_Linked_List_7,1533838,2212303,"class LineStreet {
private:
    struct Node {
        string data;
        Node* prev;
        Node* next;
        Node(const string& d) : data(d), prev(nullptr), next(nullptr) {}
    };
    Node* currentElement;
public:

    LineStreet(string homepage) {
         currentElement = new Node(homepage);
    }
    
    void addNewElement(string ele) {
        Node* newNode = new Node(ele);
        newNode->prev = currentElement;
        currentElement->next = newNode;
        currentElement = newNode;
    }

    string back(int steps) {
        Node* temp = currentElement;
        while (steps > 0 && temp->prev) {
            temp = temp->prev;
            steps--;
        }
        currentElement = temp;
        return currentElement->data;
    }

    string forward(int steps) {
        Node* temp = currentElement;
        while (steps > 0 && temp->next) {
            temp = temp->next;
            steps--;
        }
        currentElement = temp;
        return currentElement->data;
    }
};",1.0,11111111
Doubly_Linked_List_8,1533838,2212303,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};*/


ListNode* reverse(ListNode* head, int a, int b) {
    //To Do
    
    if (!head || a == b) {
        return head;
    }
    
     int length = b - a + 1;
    ListNode* dummy = new ListNode(0);
    dummy->right = head;
    head->left=dummy;
    
   
    
    ListNode* temp = head; // Start from the dummy node
    ListNode* nodeA = nullptr;
    ListNode* nodeB = nullptr;
    // Move temp to the node before position a
    for (int i = 1; i <=b; i++) {
        if(i==a) nodeA=temp;
        if(i==b) {nodeB=temp; break;}
        temp = temp->right;
        
    }

    
    while (length > 1) {
       if (nodeA->right == nodeB) {
			nodeA->right = nodeB->right;
			if (nodeB->right != nullptr)
				nodeB->right->left = nodeA;
			nodeB->right = nodeA;
			nodeB->left = nodeA->left;
			nodeA->left = nodeB;
			if (nodeB->left != nullptr)
				nodeB->left->right = nodeB;
		}
		else {
			ListNode* tempN = nodeA->right;
			nodeA->right = nodeB->right;
			if (nodeB->right != nullptr)
				nodeB->right->left = nodeA;
			nodeB->right = tempN;
			tempN->left = nodeB;
			nodeB->left->right = nodeA;
			ListNode* tempP = nodeB->left;
			nodeB->left = nodeA->left;
			if (nodeA->left != nullptr)
				nodeA->left->right = nodeB;
			nodeA->left = tempP;
		}
		ListNode* tempB=nodeB;
		nodeB=nodeA;
		nodeA=tempB;
        
        // Move nodeA and nodeB closer to the center of the range
        nodeA = nodeA->right;
        nodeB = nodeB->left;
        length -= 2;
    }

    return dummy->right;
}",1.0,1111111111
Doubly_Linked_List_1,1534607,2211170,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

void Deque::clear() {
    while (head != nullptr){
        Node* temp = head;
        head = head->right;
        delete temp;
    }
    
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    if (getSize() == 0){
        Node* newNode = new Node(i, nullptr, nullptr);
        head = tail = newNode;
    }
    
    else{
        Node* newNode = new Node(i, nullptr, head);
        head->left = newNode;
        head = newNode;
    }
    
    curSize++;
    
}

void Deque::pushBack(int i) {
       if (getSize() == 0){
        Node* newNode = new Node(i, nullptr, nullptr);
        head = tail = newNode;
    }
    
    else{
        Node* newNode = new Node(i, tail, nullptr);
        tail->right = newNode;
        tail = newNode;
    }
    
    curSize++;
    
}

int Deque::popFront() {
    if (head == nullptr) {
        return -1; 
    }
    Node* temp = head;
    int item = temp->value;
    head = head->right;
    if (head != nullptr) {
        head->left = nullptr;
    } else {
        tail = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}

int Deque::popBack() {
    if (tail == nullptr) {
        return -1;  // Deque is empty
    }
    Node* temp = tail;
    int item = temp->value;
    tail = tail->left;
    if (tail != nullptr) {
        tail->right = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
    curSize--;
    return item;
}
void Deque::printDequeReverse() {
    Node* current = tail;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->left;
    }
    cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
    while (current != nullptr) {
        cout << current->value << "" "";
        current = current->right;
    }
    cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1534607,2211170,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    newNode->previous = tail;
    
    if (tail != nullptr){
        tail->next = newNode;
    }
    
    tail = newNode;
    
    if (head == nullptr){
        head = newNode;
    }
    
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) return;
    
    if (index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->previous = current;
        newNode->next = current->next;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1534607,2211170,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* traverse = head;
    for (int i = 0; i < index; i++){
        traverse = traverse->next;
    }
    
    return traverse->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Index out of range"");
    }
    Node* traverse = head;
    for (int i = 0; i < index; i++){
        traverse = traverse->next;
    }
    traverse->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
        Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;  // Item not found
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (indexOf(item) != -1);
}",1.0,1111111111
Doubly_Linked_List_4,1534607,2211170,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
   this->pList = pList;
   
   if(pList == NULL){index = -1;}
   
   else if(begin){
        if(this->pList->size() == 0){this->current = NULL;index = -1;}
        else{ this->current = pList->head;index = 0;}
   }
   
   else{
        this->current = NULL;
        if(this->pList->size() == 0) index = this->pList->size();
        else index = pList->size();
   }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;   
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if(current == NULL) throw out_of_range(""Segmentation fault!"");
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
   if(current == NULL) throw out_of_range(""Segmentation fault!"");
   return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove()
{
    /*
        Remove a node which is pointed by current
        * After remove current points to the previous node of this position (or node with index - 1)
        * If remove at front, current points to previous ""node"" of head (current = NULL, index = -1)
        * Exception: throw std::out_of_range(""Segmentation fault!"") if remove when current is NULL
    */

   if(this->current == NULL) throw out_of_range(""Segmentation fault!"");
    int index = this->pList->indexOf(this->current->data);
    if(index == 0){

        this->pList->removeAt(index);
        this->index = -1;
        current = NULL;
    }
    else{
        T e = this->pList->removeAt(index-1);
        this->index = index - 1;
        current->data = e;
      
}
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
      return !(iterator.index == this->index || iterator.current == this->current);
 
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
        if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return *this;

}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
        DLinkedList<T>::Iterator t = *this;
    if(current == NULL){
        current = pList->head;
        index = 0;
    }
    else{
        current = current->next;
        index++;
    }
    return t;

}

",1.0,1111111111
Doubly_Linked_List_5,1534607,2211170,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    T result;
//! kiểm tra đầu vào
    if(index < 0 && index >= count) throw out_of_range("""");
//! nếu chỉ có 1 phần tử
    if(count == 1){
        result = head->data;
        delete head;
        head = tail = NULL;
    }
//! nhiều hơn 1 phần tử và ở vị trí đầu tiên
    else if(index == 0){
        Node* tmp = head;
        head = head->next;
        result = tmp->data;
        delete tmp;
        head->previous = NULL;
    }
    else{
        Node* tmp = head;
//! tìm vị trí trước vị trí cần xóa
        index --; 
        while(index){
            tmp = tmp->next;
            index --;
        }
//! lưu vị giá trị xóa đi
        result = tmp->next->data;
//! nếu nó là vị trí cuối cùng
        if(tmp->next == tail){
            delete tail;
            tail = tmp;
            tail->next = NULL;
        }
        else{
            Node* h = tmp->next;
            tmp->next = tmp->next->next;
            tmp->next->previous = tmp;
            delete h;
        }
    }
    count --;
    return result;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    int index = indexOf(item);
    if(index == -1) return false;
    removeAt(index);
    return true;
    
}

template<class T>
void DLinkedList<T>::clear(){
    Node* tmp = head;
    while(head){
        head = head->next;
        delete tmp;
        tmp = head;
    }
    head = tail = NULL;
    count = 0;  
}",1.0,1111111111
Doubly_Linked_List_6,1534607,2211170,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_front(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_front(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    
    currentState++;
    
    if (currentState != logList.end()){
        list<int>::iterator curr = currentState;
        list<int>::iterator prev = currentState;
        while(curr != logList.end()){
            curr++;
            logList.erase(prev);
            prev = curr;
        }
        currentState = logList.end();
    }
    
    currentState--;
  
    logList.push_back(*currentState);
    currentState++;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     
    if (currentState != logList.begin())
        --currentState;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     ++currentState;
    if(currentState == logList.end()) --currentState;
}
",1.0,1111111111
Doubly_Linked_List_7,1534607,2211170,"class LineStreet {
    private:
        class Node{
        private:
        string data;
        Node* prev;
        Node* next;
        friend class LineStreet;
    public:
        Node(){}
        Node(string data, Node* l = nullptr, Node* r = nullptr) : data(data), prev(l), next(r) {}
};
    public:
    
    Node* head;
    Node* tail;
    Node* current;
    int size;
    
    public:    

    LineStreet(string homepage) {
        Node* newNode = new Node(homepage);
        head = tail = current = newNode;
        size = 0;
    }
    
    void addNewElement(string url) {
        Node* newNode = new Node(url, current, nullptr);
        current->next = newNode;
        current = newNode;
        tail = newNode;
        size++;
    }

    string back(int steps) {
        if (current == head || steps == 0){
            return current->data;
        }
        
        else{
            current = current->prev;
            return back(steps - 1);
        }
    }

    string forward(int steps) {
        if (current->next == nullptr || steps == 0){
            return current->data;
        }
        
        else{
            current = current->next;
            return forward(steps - 1);
        }
    }
};
",1.0,11111111
Doubly_Linked_List_8,1534607,2211170,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
//! Khai báo một bảng băm (unordered_map) để lưu trữ con trỏ tới các ListNode với khóa là chỉ số.
    unordered_map<int ,ListNode* > v;
//! Khởi tạo một con trỏ tạm thời để duyệt qua danh sách.
    ListNode* tmp = head;
//! Khởi tạo biến index để theo dõi chỉ số của các nút trong danh sách.
    int index = 1;
//! Khởi tạo biến i với giá trị b, sẽ được sử dụng để đảo ngược thứ tự của các nút từ b đến a.
    int i = b;
    while(tmp){
        if(index >= a && index <= b){
 //! Lưu trữ con trỏ tới các nút trong khoảng a đến b vào bảng băm v.
            v[i] = tmp;
            i--;
        }
//! Lưu trữ con trỏ tới các nút nằm ngoài khoảng a đến b.
        else v[index] = tmp;
        tmp = tmp->right;
        index ++;
    }
//! Gán con trỏ head bằng con trỏ tới nút đầu tiên sau khi đảo ngược.
    head = v[1];
    head->left = NULL;
    tmp = head;
    for(int i = 2; i < index; i++){
//! thực hiện các thao tác liên kết lại
        tmp->right = v[i];
        v[i]->left = tmp;
        tmp = v[i];
    }
    tmp->right = NULL;
    return head;
}",1.0,1111111111
Doubly_Linked_List_2,1534873,2112585,"template <class T>
void DLinkedList<T>::add(const T& e) {
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        newNode->previous = tail;
        tail->next = newNode;
        tail = newNode;
    }
    count++;
}

template <class T>
void DLinkedList<T>::add(int index, const T& e) {
    if (index < 0 || index > count) {
        throw std::out_of_range(""Invalid index"");
    }
    if (index == count) {
        add(e);
        return;
    }
    Node* newNode = new Node(e);
    if (index == 0) {
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
    } else {
        Node* current = head;
        for (int i = 0; i < index - 1; i++) {
            current = current->next;
        }
        newNode->next = current->next;
        newNode->previous = current;
        current->next->previous = newNode;
        current->next = newNode;
    }
    count++;
}

template <class T>
int DLinkedList<T>::size() {
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1534873,2112585,"template<class T>
T DLinkedList<T>::get(int index) {
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Invalid index"");
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Invalid index"");
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    return count == 0;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1534873,2112585,"template<class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) {
    this->pList = pList;
    if (begin) {
        this->current = pList->head;
        this->index = 0;
    } else {
        this->current = nullptr;
        this->index = pList->count;
    }
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator) {
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template<class T>
void DLinkedList<T>::Iterator::set(const T &e) {
    if (current == nullptr) {
        throw std::out_of_range(""Iterator is not pointing to a valid node"");
    }
    current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() {
    if (current == nullptr) {
        throw std::out_of_range(""Iterator is not pointing to a valid node"");
    }
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() {
    if (current == nullptr) {
        throw std::out_of_range(""Iterator is not pointing to a valid node"");
    }
    Node* nodeToRemove = current;
    if (nodeToRemove == pList->head) {
        pList->head = nodeToRemove->next;
        if (pList->head != nullptr) {
            pList->head->previous = nullptr;
        }
        current = pList->head;
    } else if (nodeToRemove == pList->tail) {
        pList->tail = nodeToRemove->previous;
        if (pList->tail != nullptr) {
            pList->tail->next = nullptr;
        }
        current = nullptr;
    } else {
        nodeToRemove->previous->next = nodeToRemove->next;
        nodeToRemove->next->previous = nodeToRemove->previous;
        current = nodeToRemove->next;
    }
    delete nodeToRemove;
    pList->count--;
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) {
    return current != iterator.current;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() {
    if (current == nullptr) {
        throw std::out_of_range(""Iterator is not pointing to a valid node"");
    }
    current = current->next;
    index++;
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) {
    Iterator temp = *this;
    ++(*this);
    return temp;
}",0.8,1001111111
Doubly_Linked_List_5,1534873,2112585,"template<class T>
T DLinkedList<T>::removeAt(int index) {
    if (index < 0 || index >= count) {
        throw std::out_of_range(""Invalid index"");
    }
    
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    
    T removedValue = current->data;
    if (current == head) {
        head = current->next;
        if (head != nullptr) {
            head->previous = nullptr;
        }
    } else if (current == tail) {
        tail = current->previous;
        if (tail != nullptr) {
            tail->next = nullptr;
        }
    } else {
        current->previous->next = current->next;
        current->next->previous = current->previous;
    }
    
    delete current;
    count--;
    return removedValue;
}

template<class T>
bool DLinkedList<T>::removeItem(const T& item) {
    Node* current = head;
    while (current != nullptr) {
        if (current->data == item) {
            if (current == head) {
                head = current->next;
                if (head != nullptr) {
                    head->previous = nullptr;
                }
            } else if (current == tail) {
                tail = current->previous;
                if (tail != nullptr) {
                    tail->next = nullptr;
                }
            } else {
                current->previous->next = current->next;
                current->next->previous = current->previous;
            }
            
            delete current;
            count--;
            return true;
        }
        current = current->next;
    }
    
    return false;
}

template<class T>
void DLinkedList<T>::clear() {
    Node* current = head;
    while (current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
    }
    
    head = nullptr;
    tail = nullptr;
    count = 0;
}",0.2,110
Doubly_Linked_List_6,1534873,2112585,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
     logList.push_back(0); 
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
     logList.push_back(data);
    currentState = logList.begin();  

}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
     *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
     *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
     logList.erase(next(currentState), logList.end());
    logList.push_back(*currentState);
    currentState = prev(logList.end());
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if(currentState != logList.begin()) {
      currentState--; 
    }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     if(next(currentState) != logList.end()) {
      currentState++;
    }
}
",1.0,1111111111
Doubly_Linked_List_8,1534873,2112585,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
if(a == b) return head;

  ListNode* curr = head;
  ListNode* prev = nullptr;

  // Find nodes at a and b
  for(int i=1; curr != nullptr && i < a; i++) {
    prev = curr; 
    curr = curr->right;
  }

  ListNode* start = prev;
  ListNode* end = curr;

  // Handle case where full list is reversed
  if(a == 1 && end->right == nullptr) {
    end = start;
    start = nullptr;
  }

  ListNode* next = nullptr;

  // Reverse pointers  
  for(int i=a; curr != nullptr && i <= b; i++) {
    next = curr->right;
    curr->right = prev; 
    prev = curr;
    curr = next;
  }

  // Update next pointers
  if(start != nullptr) {
    start->right = prev;
  } else {
    head = prev;
  }

  end->right = curr;
  
  return head;

}",0.9,1011111111
Doubly_Linked_List_1,1535175,2210200,"Deque::Deque() {
    head = NULL;
    tail = NULL;
    curSize = 0;
}

Deque::~Deque() {
    head = NULL;
    tail = NULL;
    curSize = 0;
}

void Deque::clear() {
    Node *temp = head;
    for(int i = 0; i < curSize; i++){
        Node *removeNode = temp;
        temp = temp->right;
        if(temp) temp->left = NULL;
        removeNode->right = NULL;
        removeNode->left = NULL;
        delete removeNode;
    }
    curSize = 0;
    head = NULL;
    tail = NULL;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int i) {
    Node *newNode = new Node(i, NULL, NULL);
    if(curSize == 0){
        head = newNode;
        tail = newNode;
        ++curSize;
        return;
    }
    newNode->right = head;
    head->left = newNode;
    head = newNode;
    ++curSize;
}

void Deque::pushBack(int i) {
    Node *newNode = new Node(i, NULL, NULL);
    if(curSize == 0){
        head = newNode;
        tail = newNode;
        ++curSize;
        return;
    }
    tail->right = newNode;
    newNode->left = tail;
    tail = newNode;
    ++curSize;
}

int Deque::popFront() {
    if(curSize == 0) return -1;
    Node *removeNode = head;
    head = head->right;
    if(head) head->left = NULL;
    removeNode->right = NULL;
    removeNode->left = NULL;
    int data = removeNode->value;
    delete removeNode;
    --curSize;
    return data;
}

int Deque::popBack() {
    if(curSize == 0) return -1;
    Node *removeNode = tail;
    tail = tail->left;
    if(tail) tail->right = NULL;
    removeNode->left = NULL;
    removeNode->right = NULL;
    int data = removeNode->value;
    delete removeNode;
    --curSize;
    return data;
}

void Deque::printDeque(){
    Node *temp = head;
    while(temp != NULL){
        if(temp == tail) cout << temp->value;
        else cout << temp->value << "" "";
        temp = temp->right;
    }
    cout << ""\n"";
}

void Deque::printDequeReverse(){
    Node *temp = tail;
    while(temp != NULL){
        if(temp == head) cout << temp->value;
        else cout << temp->value << "" "";
        temp = temp->left;
    }
    cout << ""\n"";
}",1.0,1111111111
Doubly_Linked_List_2,1535175,2210200,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node *newNode = new Node(e);
    if(count == 0){
        head = newNode;
        tail = newNode;
        ++count;
        return;
    }
    tail->next = newNode;
    newNode->previous = tail;
    tail = newNode;
    ++count;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if(index < 0 || index > count) return;
    if(count == 0 || index == count){
        add(e);
        return;
    }
    Node *newNode = new Node(e);
    if(index == 0){
        newNode->next = head;
        head->previous = newNode;
        head = newNode;
        ++count;
        return;
    }
    Node *temp = head;
    for(int i = 0; i < index - 1; i++){
        temp = temp->next;
    }
    newNode->next = temp->next;
    newNode->previous = temp;
    temp->next->previous = newNode;
    temp->next = newNode;
    ++count;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1535175,2210200,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++) temp = temp->next;
    return temp->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++) temp = temp->next;
    temp->data = e;
    return;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    return (count == 0);
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item) return i;
        temp = temp->next;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return (indexOf(item) != -1);
}",1.0,1111111111
Doubly_Linked_List_4,1535175,2210200,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if (begin == true){
        if (this->pList != NULL){
            this->current = this->pList->head;
            this->index = 0;
        } else {
            this->current = NULL;
            this->index = -1;
        }
    } else {
        this->current = NULL;
        if (this->pList != NULL) this->index = this->pList->size();
        else this->index = 0;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
        throw std::out_of_range(""Segmentation fault!"");
    this->current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (this->current == NULL) 
        throw std::out_of_range(""Segmentation fault!"");
    return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    if (this->current == NULL) throw std::out_of_range(""Segmentation fault!"");
    if (this->current == this->pList->head) this->current = NULL;
    else this->current = this->current->previous;
    this->pList->removeAt(this->index);
    this->index--;
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    if (this->current == iterator.current && this->index == iterator.index){
        return false;
    }
    return true;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->index > this->pList->count){
        throw std::out_of_range(""Index is invalid"");
    }
    if (this->current == NULL){
        this->current = this->pList->head;
        this->index = 0;
        return *this;
    }
    this->current = this->current->next;
    this->index += 1;
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator pNew = *this;
    ++*this;
    return pNew;
}",1.0,1111111111
Doubly_Linked_List_5,1535175,2210200,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if(count == 0) throw std::out_of_range(""Index is out of range"");
    if(count == 1 && index == 0){
        int t = head->data;
        delete head;
        head = NULL;
        tail = NULL;
        count = 0;
        return t;
    }
    if(index == 0){
        Node *temp = head;
        head = head->next;
        if(head) head->previous = NULL;
        int t = temp->data;
        delete temp;
        --count;
        return t;
    }
    if(index == count - 1){
        Node *temp = tail;
        tail = tail->previous;
        if(tail) tail->next = NULL;
        int t = temp->data;
        delete temp;
        --count;
        return t;
    }
    if(index < 0 || index >= count) throw std::out_of_range(""Index is out of range"");
    Node *temp = head;
    for(int i = 0; i < index; i++) temp = temp->next;
    if(temp->previous) temp->previous->next = temp->next;
    if(temp->next) temp->next->previous = temp->previous;
    int t = temp->data;
    delete temp;
    --count;
    return t;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        if(temp->data == item){
            removeAt(i);
            return true;
        }
        temp = temp->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    Node *temp = head;
    for(int i = 0; i < count; i++){
        Node *rm = temp;
        temp = temp->next;
        if(temp) temp->previous = NULL;
        delete rm;
    }
    head = NULL;
    tail = NULL;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1535175,2210200,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
    *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
    *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
    int temp = *currentState;
    list<int>::iterator it = logList.end();
    --it;
    while(it != currentState){
        --it;
        logList.pop_back();
    }
    logList.push_back(temp);
    it = logList.end();
    --it;
    currentState = it;
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
    if(currentState == logList.begin()) return;
    else --currentState;
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
    list<int>::iterator it = logList.end();
    --it;
    if(currentState == it) return;
    else ++currentState;
}
",1.0,1111111111
Doubly_Linked_List_7,1535175,2210200,"class LineStreet {
public:
    class Toy{
    public:
        string val;
        Toy *next, *prev;
        friend class LineStreet;
        Toy(string value, Toy *previous, Toy *nexxt){
            val = value;
            next = nexxt;
            prev = previous;
        }
    };
    Toy *head, *cur;
    int count;
    
    LineStreet(string homepage) {
        Toy *temp = new Toy(homepage, NULL, NULL);
        head = temp;
        cur = temp;
    }
    
    void addNewElement(string url) {
        Toy *temp = cur->next;
        while(temp){
            Toy *deleteToy = temp;
            temp = temp->next;
            delete deleteToy;
        }
        cur->next = new Toy(url, cur, NULL);
        cur = cur->next;
    }

    string back(int steps) {
        for(int i = 0; i < steps && cur->prev; ++i){
            cur = cur->prev;
        }
        return cur->val;
    }

    string forward(int steps) {
        for(int i = 0; i < steps && cur->next; ++i){
            cur = cur->next;
        }
        return cur->val;
    }
};
",1.0,11111111
Doubly_Linked_List_8,1535175,2210200,"ListNode *reverse(ListNode *head, int l, int r)
{
    if (!head || !head->right || l == r)
        return head;
        
    ListNode *prev = nullptr;
    ListNode *current = nullptr;

    for (int i = 0; i < l; i += 1)
    {
        if (current == nullptr)
            current = head;
        else
        {
            prev = current;
            current = current->right;
        };
    }

    ListNode *start = current;
    for (int i = l; i < r; i += 1)
    {
        current = current->right;
    }
    ListNode *end = current;

    if (prev != nullptr)
    {
        prev->right = end;
    }
    else
    {
        head = end;
    }
    if (end->right)
    {
        end->right->left = start;
    }
    prev = end->right;
    while (start != end)
    {
        ListNode *next = start->right;
        start->right = prev;
        start->left = next;
        prev = start;
        start = next;
    }
    start->right = prev;

    return head;
}",1.0,1111111111
Doubly_Linked_List_1,1535627,2211876,"Deque::Deque() : head(nullptr), tail(nullptr), curSize(0) {

}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    while (head != nullptr) {
            Node* temp = head;
            head = head->right;
            delete temp;
        }
        tail = nullptr;
        curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int item) {
    // Node* newNode = new Node(item,nullptr,head);
    // if ( head != nullptr) {
    //     head->left = newNode;
    // }
    // head = newNode;
    // if (tail == nullptr) {
    //         tail = head;
    //     }
    //     curSize++;
    if (head == nullptr) {
        head = new Node(item,nullptr,head);
        tail = head;
    }
    else {
        Node* newNode = new Node(item,nullptr,head);
        head->left = newNode;
        head = newNode;
        // head = new Node(item,head->left,head);
    }
    curSize++;
}

void Deque::pushBack(int item) {
    Node* newNode = new Node(item, tail, nullptr);
        if (tail != nullptr) {
            tail->right = newNode;
        }
        tail = newNode;
        if (head == nullptr) {
            head = tail;
        }
        curSize++;
}

int Deque::popFront() {
    if (head == nullptr) {
            return -1;
        }
        int item = head->value;
        Node* temp = head;
        head = head->right;
        if (head != nullptr) {
            head->left = nullptr;
        } else {
            tail = nullptr;
        }
        delete temp;
        curSize--;
        return item;
}

int Deque::popBack() {
    if (tail == nullptr) {
            return -1;
        }
        int item = tail->value;
        Node* temp = tail;
        tail = tail->left;
        if (tail != nullptr) {
            tail->right = nullptr;
        } else {
            head = nullptr;
        }
        delete temp;
        curSize--;
        return item;
}

void Deque::printDequeReverse() {
    Node* current = tail;
        while (current != nullptr) {
            cout << current->value << "" "";
            current = current->left;
        }
        cout << endl;
}

void Deque::printDeque() {
    Node* current = head;
        while (current != nullptr) {
            cout << current->value << "" "";
            current = current->right;
        }
        cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1535627,2211876,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    Node* newNode = new Node(e);
    if (index == 0) {
        
        if (head == nullptr) {
            
            head = newNode;
            tail = newNode;
        } else {
            newNode->next = head;
            head->previous = newNode;
            head = newNode;
        }
    } else if (index == count) {
        
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    } else {
        
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        newNode->next = current;
        newNode->previous = current->previous;
        current->previous->next = newNode;
        current->previous = newNode;
    }
    count++;
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1535627,2211876,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    Node* current = head;
    for (int i = 0; i < index ; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    Node* newNode = new Node(e);
    Node* current = head;
    for (int i = 0; i < index ; i++) {
        current = current->next;
    }
    current->data = newNode->data;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
    if (head ==nullptr || tail == nullptr) return true;
    return false;
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    int  i ;
    for ( i = 0 ; i < count ; i++) {
        if ( current->data == item ) break;
        current = current->next;
    }
    if (i == count) return -1;
    return i;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    Node* current = head;
    for ( int i = 0 ; i < count ; i++) {
        if ( current->data == item ) return true;
        current = current->next;
    }
    return false;
}",1.0,1111111111
Doubly_Linked_List_4,1535627,2211876,"template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) 
{
    this->pList = pList;
    if (begin == true){
        if (this->pList != NULL){
            this->current = this->pList->head;
            this->index = 0;
        } else {
            this->current = NULL;
            this->index = -1;
        }
    } else {
        this->current = NULL;
        if (this->pList != NULL) this->index = this->pList->size();
        else this->index = 0;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (this->current == NULL)
        throw std::out_of_range(""Segmentation fault!"");
    this->current->data = e;
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    if (this->current == NULL) 
        throw std::out_of_range(""Segmentation fault!"");
    return this->current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    if (this->current == NULL) throw std::out_of_range(""Segmentation fault!"");
    if (this->current == this->pList->head) this->current = NULL;
    else this->current = this->current->previous;
    this->pList->removeAt(this->index);
    this->index--;
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    if (this->current == iterator.current && this->index == iterator.index){
        return false;
    }
    return true;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (this->index > this->pList->count){
        throw std::out_of_range(""Index is invalid"");
    }
    if (this->current == NULL){
        this->current = this->pList->head;
        this->index = 0;
        return *this;
    }
    this->current = this->current->next;
    this->index += 1;
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator pNew = *this;
    ++*this;
    return pNew;
}",1.0,1111111111
Doubly_Linked_List_5,1535627,2211876,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count)
    {
        return T(); 
    }

    Node* current = head;
    for (int i = 0; i < index; i++)
    {
        current = current->next;
    }

    T removedValue = current->data;

    if (current->previous)
    {
        current->previous->next = current->next;
    }
    else
    {
        head = current->next;
    }

    if (current->next)
    {
        current->next->previous = current->previous;
    }
    else
    {
        tail = current->previous;
    }

    delete current;
    count--;

    return removedValue;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    Node* current = head;
    while (current)
    {
        if (current->data == item)
        {
            if (current->previous)
            {
                current->previous->next = current->next;
            }
            else
            {
                head = current->next;
            }

            if (current->next)
            {
                current->next->previous = current->previous;
            }
            else
            {
                tail = current->previous;
            }

            delete current;
            count--;
            return true;
        }
        current = current->next;
    }
    return false;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
    while (head)
    {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    tail = nullptr;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_6,1535627,2211876,"DataLog::DataLog()
{
    /*
     * TODO:  add the first state with 0
     */
    logList.push_back(0);
    currentState = logList.begin();
}

DataLog::DataLog(const int &data)
{
    /*
     * TODO:  add the first state with data
     */
    logList.push_back(data);
    currentState = logList.begin();
}

void DataLog::addCurrentState(int number)
{
    /*
     * TODO: Increase the value of current state by number
     */
     *currentState += number;
}

void DataLog::subtractCurrentState(int number)
{
    /*
     * TODO: Decrease the value of current state by number
     */
     *currentState -= number;
}

void DataLog::save()
{
    /*
     * TODO: This function will create a new state, copy the data of the currentState
     *       and move the currentState Iterator to this new state. If there are other states behind the 
     *       currentState Iterator, we delete them all before creating a new state.
     */
     if (currentState != logList.begin()) {
            list<int>::iterator prev = std::prev(currentState);
            logList.erase(logList.begin(), prev);
        }
        logList.push_back(*currentState);
        currentState = std::prev(logList.end());
}

void DataLog::undo()
{
    /*
     * TODO: Switch to the previous state of the data
     *       If this is the oldest state in the log, nothing changes
     */
     if (currentState != logList.begin()) {
            currentState = std::prev(currentState);
        }
}

void DataLog::redo()
{
    /*
     * TODO: Switch to the latter state of the data
     *       If this is the latest state in the log, nothing changes
     */
     list<int>::iterator next = std::next(currentState);
        if (next != logList.end()) {
            currentState = next;
        }
}
",0.2,1000001000
Doubly_Linked_List_7,1535627,2211876,"class LineStreet {
public:
    struct Node {
        string data;
        Node* prev;
        Node* next;
        Node(const string& value) : data(value), prev(nullptr), next(nullptr) {}
    };
    Node* head;
    Node* tail;
    Node* current;
    LineStreet(string homepage) {
        current = new Node(homepage);
        head = current;
        tail = current;
    }
    
    void addNewElement(string ele) {
        while (current->next) {
            Node* temp = current->next;
            current->next = nullptr;
            delete temp;
        }

        Node* newNode = new Node(ele);
        newNode->prev = current;
        current->next = newNode;
        current = newNode;
        tail = newNode;
    }

    string back(int steps) {
        for (int i = 0; i < steps && current->prev; i++) {
            current = current->prev;
        }
        return current->data;
    }

    string forward(int steps) {
        for (int i = 0; i < steps && current->next; i++) {
            current = current->next;
        }
        return current->data;
    }
    
};",1.0,11111111
Doubly_Linked_List_8,1535627,2211876,"ListNode* reverse(ListNode* head, int a, int b) {
    if (!head || a == b) {
        return head;
    }

    ListNode* dummy = new ListNode(0);
    dummy->right = head;
    head->left = dummy;
    ListNode* current = dummy;
    
    // Move to the (a-1)-th node.
    for (int i = 0; i < a - 1; i++) {
        current = current->right;
    }

    ListNode* beforeA = current;
    current = current->right;

    // Reverse the nodes between a and b.
    ListNode* prev = nullptr;
    ListNode* tail = current;
    for (int i = 0; i < b - a + 1; i++) {
        ListNode* next = current->right;
        current->right = prev;
        current->left = next;
        prev = current;
        current = next;
    }

    // Update connections.
    beforeA->right = prev;
    prev->left = beforeA;
    tail->right = current;
    if (current) {
        current->left = tail;
    }

    ListNode* newHead = dummy->right;
    delete dummy;
    return newHead; 
}",1.0,1111111111
Doubly_Linked_List_1,1536621,2212935,"Deque::Deque() {
    head = nullptr;
    tail = nullptr;
    curSize = 0;
}

Deque::~Deque() {
    clear();
}

void Deque::clear() {
    Node* current = head;
        while (current != nullptr) {
            Node* temp = current;
            current = current->right;
            delete temp;
        }
        head = nullptr;
        tail = nullptr;
        curSize = 0;
}

int Deque::getSize() {
    return curSize;
}

void Deque::pushFront(int item) {
    Node* newNode = new Node(item, nullptr, head);
        if (head != nullptr) {
            head->left = newNode;
        }
        head = newNode;
        if (tail == nullptr) {
            tail = head;
        }
        curSize++;

}

void Deque::pushBack(int item) {
Node* newNode = new Node(item, tail, nullptr);
        if (tail != nullptr) {
            tail->right = newNode;
        }
        tail = newNode;
        if (head == nullptr) {
            head = tail;
        }
        curSize++;
}

int Deque::popFront() {
    if (head == nullptr) {
            return -1;  
        }
        Node* temp = head;
        int value = temp->value;
        head = head->right;
        if (head != nullptr) {
            head->left = nullptr;
        } else {
            tail = nullptr;
        }
        delete temp;
        curSize--;
        return value;

}

int Deque::popBack() {
    if (tail == nullptr) {
            return -1;  
        }
        Node* temp = tail;
        int value = temp->value;
        tail = tail->left;
        if (tail != nullptr) {
            tail->right = nullptr;
        } else {
            head = nullptr;
        }
        delete temp;
        curSize--;
        return value;
}

void Deque::printDequeReverse() {
Node* current = tail;
        while (current != nullptr) {
            cout << current->value << "" "";
            current = current->left;
        }
        cout << endl;
}

void Deque::printDeque() {
Node* current = head;
        while (current != nullptr) {
            cout << current->value << "" "";
            current = current->right;
        }
        cout << endl;
}",1.0,1111111111
Doubly_Linked_List_2,1536621,2212935,"template <class T>
void DLinkedList<T>::add(const T& e) {
    /* Insert an element into the end of the list. */
    Node* newNode = new Node(e);
    if (head == nullptr) {
        head = newNode;
        tail = newNode;
    } else {
        tail->next = newNode;
        newNode->previous = tail;
        tail = newNode;
    }
    count++;
}

template<class T>
void DLinkedList<T>::add(int index, const T& e) {
    /* Insert an element into the list at given index. */ 
    if (index < 0 || index > count) {
        cout << ""Invalid index"" << endl;
        return;
    }
    if (index == 0) {
        Node* newNode = new Node(e);
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
        } else {
            newNode->next = head;
            head->previous = newNode;
            head = newNode;
        }
        count++;
    } 
    else if (index == count) {
        add(e);
    } 
    else {
        Node* newNode = new Node(e);
        Node* current = head;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        newNode->next = current;
        newNode->previous = current->previous;
        current->previous->next = newNode;
        current->previous = newNode;
        count++;
    }
}

template<class T>
int DLinkedList<T>::size() {
    /* Return the length (size) of list */ 
    return count;
}",1.0,1111111111
Doubly_Linked_List_3,1536621,2212935,"template<class T>
T DLinkedList<T>::get(int index) {
    /* Give the data of the element at given index in the list. */
    if (index < 0 || index >= count) {
        cout << ""Invalid index"" << endl;
        return T();
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    return current->data;
}

template <class T>
void DLinkedList<T>::set(int index, const T& e) {
    /* Assign new value for element at given index in the list */
    if (index < 0 || index >= count) {
        cout << ""Invalid index"" << endl;
        return;
    }
    Node* current = head;
    for (int i = 0; i < index; i++) {
        current = current->next;
    }
    current->data = e;
}

template<class T>
bool DLinkedList<T>::empty() {
    /* Check if the list is empty or not. */
     return count == 0;
    
}

template<class T>
int DLinkedList<T>::indexOf(const T& item) {
    /* Return the first index wheter item appears in list, otherwise return -1 */
    Node* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == item) {
            return index;
        }
        current = current->next;
        index++;
    }
    return -1;
}

template<class T>
bool DLinkedList<T>::contains(const T& item) {
    /* Check if item appears in the list */
    return indexOf(item) != -1;
}",1.0,1111111111
Doubly_Linked_List_4,1536621,2212935,"/*
 * TODO: Implement class Iterator's method
 * Note: method remove is different from SLinkedList, which is the advantage of DLinkedList
 */
template <class T>
DLinkedList<T>::Iterator::Iterator(DLinkedList<T> *pList, bool begin) : pList(pList), current(nullptr), index(-1)
{
 this->pList = pList;
    if (begin) {
        this->current = pList->head;
        this->index = 0;
    } else {
        this->current = NULL;
        this->index = pList->count;
    }
}

template <class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator=(const DLinkedList<T>::Iterator &iterator)
{
    this->pList = iterator.pList;
    this->current = iterator.current;
    this->index = iterator.index;
    return *this;
}

template <class T> 
void DLinkedList<T>::Iterator::set(const T &e)
{
    if (current) {
        current->data = e;
    }
}

template<class T>
T& DLinkedList<T>::Iterator::operator*() 
{
    return current->data;
}

template<class T>
void DLinkedList<T>::Iterator::remove() 
{
    /*
    * TODO: delete Node in pList which Node* current point to. 
    *       After that, Node* current point to the node before the node just deleted.
    *       If we remove first node of pList, Node* current point to nullptr.
    *       Then we use operator ++, Node* current will point to the head of pList.
    */
    if (current) {
        Node* prev = current->previous;
        Node* next = current->next;
        if (prev) {
            prev->next = next;
        } else {
            pList->head = next;
        }
        if (next) {
            next->previous = prev;
        } else {
            pList->tail = prev;
        }
        Node* toDelete = current;
        current = next;
        delete toDelete;
    }
}

template<class T>
bool DLinkedList<T>::Iterator::operator!=(const DLinkedList::Iterator &iterator) 
{
    return current != iterator.current;
}

template<class T>
typename DLinkedList<T>::Iterator& DLinkedList<T>::Iterator::operator++() 
{
    if (current) {
        current = current->next;
        index++;
    }
    return *this;
}

template<class T>
typename DLinkedList<T>::Iterator DLinkedList<T>::Iterator::operator++(int) 
{
    Iterator temp = *this;
    ++(*this);
    return temp;
}

",0.8,1001111111
Doubly_Linked_List_5,1536621,2212935,"template <class T>
T DLinkedList<T>::removeAt(int index)
{
    /* Remove element at index and return removed value */
    if (index < 0 || index >= count)
        throw out_of_range(""Index out of range."");

    Node* current = head;
    if (index == 0) {
        head = head->next;
        if (head != NULL)
            head->previous = NULL;
        else
            tail = NULL;
    } else if (index == count - 1) {
        current = tail;
        tail = tail->previous;
        tail->next = NULL;
    } else {
        for (int i = 0; i < index; i++)
            current = current->next;
        current->previous->next = current->next;
        current->next->previous = current->previous;
    }

    T data = current->data;
    delete current;
    count--;
    return data;
}

template <class T>
bool DLinkedList<T>::removeItem(const T& item)
{
    /* Remove the first apperance of item in list and return true, otherwise return false */
    int index = indexOf(item);
    if (index == -1)
        return false;

    removeAt(index);
    return true;
}

template<class T>
void DLinkedList<T>::clear(){
    /* Remove all elements in list */
     Node* current = head;
    while (current != NULL) {
        Node* next = current->next;
        delete current;
        current = next;
    }
    head = NULL;
    tail = NULL;
    count = 0;
}
",1.0,1111111111
Doubly_Linked_List_7,1536621,2212935,"class Node {
public:
    string data;
    Node* next;
    Node* prev;

    Node(string value) {
        data = value;
        next = nullptr;
        prev = nullptr;
    }
};

class LineStreet {
private:
    Node* root;
    Node* current;

public:
    LineStreet(string homepage) {
        root = new Node(homepage);
        current = root;
    }

    void addNewElement(string ele) {
        Node* newNode = new Node(ele);
        current->next = newNode;
        newNode->prev = current;
        current = newNode;
    }

    string back(int steps) {
        while (steps > 0 && current->prev != nullptr) {
            current = current->prev;
            steps--;
        }
        return current->data;
    }

    string forward(int steps) {
        while (steps > 0 && current->next != nullptr) {
            current = current->next;
            steps--;
        }
        return current->data;
    }
};
",1.0,11111111
Doubly_Linked_List_8,1536621,2212935,"/*
struct ListNode {
    int val;
    ListNode *left;
    ListNode *right;
    ListNode(int x = 0, ListNode *l = nullptr, ListNode* r = nullptr) : val(x), left(l), right(r) {}
};
*/

ListNode* reverse(ListNode* head, int a, int b) {
    if (a == b || head == nullptr)
        return head;

    ListNode* curr = head;
    ListNode* prev = nullptr;

    // Traverse to the node at position a
    for (int i = 1; i < a; i++) {
        prev = curr;
        curr = curr->right;
    }

    ListNode* startNode = curr;
    ListNode* prevNode = prev;

    int count = 0;
    // Reverse the nodes from a to b
    while (curr != nullptr && count < b - a + 1) {
        ListNode* nextNode = curr->right;
        curr->right = curr->left;
        curr->left = nextNode;
        prev = curr;
        curr = nextNode;
        count++;
    }

    // Update pointers of startNode and prevNode
    if (prevNode)
        prevNode->right = prev;
    else
        head = prev;
    startNode->right = curr;
    if (curr)
        curr->left = startNode;

    return head;
}",1.0,1111111111
Stack_1,1454531,2210997,"int boxRequire(std::vector<int>& piles, int k) {
    int left = 1;  
    int right = *max_element(piles.begin(), piles.end()); 

    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxesNeeded = 0;

        for (int pile : piles) {
            boxesNeeded += (pile + mid - 1) / mid;  
        }

        if (boxesNeeded <= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}",1.0,111111111111111
Stack_2,1454531,2210997,"
int baseballScore(string ops)
{
    stack<int>st;
    int sum=0;
    for(size_t i=0;i<ops.size();i++)
    {
            if(ops[i]=='D')
            {
                int x=st.top()*2;
                st.push(x);
                sum=sum+st.top();
            }
            else if(ops[i]=='C')
            {
                sum=sum-st.top();
                st.pop();
            }
            else if(ops[i]=='+')
            {
                int temp=st.top();
                st.pop();
                int y=st.top()+temp;
                st.push(temp);
                st.push(y);
                sum=sum+st.top();

            }
            else
            {
                st.push(ops[i] - '0');
                sum=sum+st.top();
            }
    }
     return sum;

}
",1.0,1111111111
Stack_3,1454531,2210997,"int trap(vector<int>& height) {
    int n = height.size();
    if (n <= 2) return 0;  
    vector<int> left_max(n);
    vector<int> right_max(n);
    left_max[0] = height[0];
    for (int i = 1; i < n; i++) left_max[i] = max(left_max[i - 1], height[i]);
    right_max[n - 1] = height[n - 1];
    for (int i = n - 2; i >= 0; i--)  right_max[i] = max(right_max[i + 1], height[i]);
    int trappedWater = 0;
    for (int i = 0; i < n; i++) trappedWater += max(0, min(left_max[i], right_max[i]) - height[i]);
    

    return trappedWater;


}",1.0,111111111111
Stack_4,1454531,2210997,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    if (!empty()) {
            T topItem = top();
            list.removeAt(list.size() - 1);
            return topItem;
        }
        throw std::out_of_range(""Stack is empty."");
        
}

T top() {
    // TODO: Get value of the element on top of the stack
    if (!empty()) {
            return list.get(list.size() - 1);
        }
        throw std::out_of_range(""Stack is empty."");
        
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();
        
}

int size() {
    // TODO: Get the size of the stack
     return list.size();
        
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
    
}",1.0,11111
Stack_5,1454531,2210997,"int mountainWithoutValley(vector<int>& nums) {
    // Khai báo hai vector để lưu trữ phân đoạn tăng và giảm
    vector<pair<int,int>> up;
    vector<pair<int,int>> down;
    int max = INT_MIN;
    up.push_back({nums[0], 0});
    //down.push_back({nums[0], 0});
    int size = nums.size();
    int sum1 = nums[0];

    for(int i = 1; i < size; i++) {
        pair<int,int> temp_up_back = up.back();

        // Nếu phần tử hiện tại lớn hơn hoặc bằng phần tử cuối cùng trong up
        if(nums[i] >= temp_up_back.first) {
            up.push_back({nums[i], i});
            sum1 += nums[i];
        }
        else {
            int sum2;

            // Kiểm tra điều kiện để xác định xem có cần tiếp tục kiểm tra
            if(nums[i] * (size - i - 1) + sum1 <= max) {
                goto skip;
            }

            down.push_back({nums[i], i});
            sum2 = nums[i];

            for(int j = i + 1; j < size; j++) {
                pair<int,int> temp_down_back = down.back();

                if(nums[j] <= temp_down_back.first) {
                    // Kiểm tra điều kiện để xác định xem có cần tiếp tục kiểm tra
                    if(sum1 + sum2 + nums[j] * (size - j - 1) < max) {
                        down.clear();
                        goto skip;
                    }
                    down.push_back({nums[j], j});
                    sum2 += nums[j];
                }
                else {
                    down[down.size() - 1].second++;
                    sum2 += down[down.size() - 1].first;
                }
            }

            if(sum1 + sum2 > max) {
                max = sum1 + sum2;
            }

            down.clear();

            skip:
            while(nums[i] < temp_up_back.first) {
                if(up.size() == 1) {
                    sum1 -= up[0].first * (up[0].second + 1);
                }
                else {
                    int up_size = up.size();
                    sum1 -= up[up_size - 1].first * (up[up_size - 1].second - up[up_size - 2].second);
                }

                up.pop_back();
                
                if(up.size() == 0) {
                    break;
                }
                
                temp_up_back = up.back();
            }

            up.push_back({nums[i], i});
            
            if(up.size() == 1) {
                sum1 += nums[i] * (i - 0 + 1);
            }
            else {
                sum1 += nums[i] * (up[up.size() - 1].second - up[up.size() - 2].second);
            }
        }
    }

    sum1 = up[0].first * (up[0].second + 1);
    int up_size = up.size();

    for(int j = 1; j < up_size; j++) {
        sum1 = sum1 + up[j].first * (up[j].second - up[j - 1].second);
    }

    if(sum1 > max) {
        max = sum1;
    }

    return max;
}
",1.0,1111111111
Stack_6,1454531,2210997,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    int n = arr.size();
    vector <int> ans;
    for (int i = 0; i < n-1 ; i++)
    {
        for (int j = i; j < n;j++)
        {
            if (arr[i] < arr[j])
            {
                ans.push_back(arr[j]);
                break;
            }
            else if (j == n-1 && arr[i] > arr[j]) 
            {
                ans.push_back(-1);
            }
        }
    }
     ans.push_back(-1);
    return ans;
    
}",1.0,1111111111
Stack_7,1454531,2210997,"string parenthesesReversal(string s) {
    stack<std::string> stringStack;
    string result;

    for (char c : s) {
        if (c == '(') {
            stringStack.push(result);
            result = """";
        } else if (c == ')') {
            std::string reversed = result;
            result = stringStack.top() + string(reversed.rbegin(), reversed.rend());
            stringStack.pop();
        } else {
            result += c;
        }
    }

    return result;
}",1.0,1111111111
Stack_8,1454531,2210997,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> st;
    for (char ch : S) 
    {
        if (!st.empty() && st.top() == ch) st.pop(); 
        else st.push(ch);
        
    }

    string result = """";
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }

    return result;
}",1.0,1111111
Stack_9,1454531,2210997,"string deleteDuplicate(string s, int k)
{
    stack<char> st;
    stack<int> count;
    for(auto i : s)
    {
        if(!st.empty() && st.top() == i)
        {
            count.push(count.top() + 1);
        }
        else
        {
            count.push(1);
        }
        st.push(i);
        if(count.top() == k)
        {
            for(int j = 1;j <= k; ++j)
            {
                st.pop();
                count.pop();
            }
        }
    }
    string res = """";
    string tmp = """";
    while(!st.empty())
    {
        tmp += st.top();
        st.pop();
    }
    for(int i = tmp.size() - 1; i >= 0; --i) res += tmp[i];
    return res;
}",1.0,1111111111
Stack_10,1454531,2210997,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    int sum = 0;
    stack<int> s;
    int n = nums.size();
    for (int i = 0; i < n; i++)
    {
        while (!s.empty() && nums[s.top()] > nums[i])
        {
            int j = s.top();
            s.pop();
            int k = s.empty() ? -1 : s.top();
            sum += nums[j] * (i - j) * (j - k);
            sum %= 10000;
        }
    s.push(i);
    }
    while (!s.empty())
    {
        int j = s.top();
        s.pop();
        int k = s.empty() ? -1 : s.top();
        sum += nums[j] * (nums.size() - j) * (j - k);
      sum %= 10000;
    }
    return sum;
}",1.0,1111111111
Stack_11,1454531,2210997,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
     stack<int> st;
        int n = nums.size();
        if (n <3) return false;
        int third = -1e9 ;
        //st.push(third);
        for (int i = n - 1; i >= 0; i--)
        {
            if (nums[i] < third) return true;
            while (!st.empty() && nums[i] >st.top())
            {
                third = st.top();
                st.pop();
            }
            st.push(nums[i]);
        }
        return false;
}",1.0,1111111111
Stack_5,1454546,2212741,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()==0) return 0;
 stack<int> left; 
stack<int> save; 
if(nums.size()==1) return nums[0];
 int res=0; int mount=0; 
for(int i=0;i<nums.size();i++){ if(nums[i]>mount){ mount=nums[i]; for(int j=0;j<nums.size();j++){ if(nums[j]<nums[i]){ if(left.empty()){ left.push(nums[j]); } else{ while(nums[j]<left.top()){ save.push(left.top()); left.pop(); } if(nums[j]==left.top()){ while(!save.empty()){ left.push(save.top()); save.pop(); } } else{ left.push(nums[j]); while(!save.empty()){ left.push(save.top()); save.pop(); } } } } } int max=0; while(!left.empty()){ max+=left.top(); left.pop(); } if(res<max) res=max; } else continue; } if(res==0) return nums[0]; return res*2; }
",0.2,110
Stack_1,1454547,2212303,"int boxRequire(vector<int>& piles, int k) {
    int left = 1;  // Minimum possible capacity of each box.
    int right = *std::max_element(piles.begin(), piles.end());  // Maximum possible capacity of each box.

    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxesNeeded = 0;

        for (int pile : piles) {
            boxesNeeded += (pile + mid - 1) / mid;  // Ceiling division to calculate boxes needed for each type.
        }

        if (boxesNeeded <= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}",0.7,111111111111111
Stack_2,1454547,2212303,"int baseballScore(string ops){
/*TODO*/
    int ans=0;
    
    stack<int> record;
    for(char c : ops){
        if((int)c >=48 && int(c)<=57){
            record.push(c-'0');
        }
        if(c=='+'){
            int t1=record.top(); record.pop();
            int t2=record.top();
            int sum=t1+t2;
            record.push(t1);
            record.push(sum);
        }
        if(c=='C') record.pop();
        if(c=='D') record.push(record.top()*2);
    }
    
    while(!record.empty()){
        ans+=record.top();
        record.pop();
    }
    return ans;
}",1.0,1111111111
Stack_3,1454547,2212303,"int findMaxPosition(std::vector<int>& vec) {
    if (vec.empty()) {
        // Handle the case of an empty vector or no maximum element.
        return -1;  // You can return any appropriate value, e.g., -1.
    }

    int max = vec[0];  // Initialize max with the first element.
    int position = 0;  // Initialize the position to 0.

    for (size_t i = 1; i < vec.size(); i++) {
        if (vec[i] > max) {
            // If a greater element is found, update max and position.
            max = vec[i];
            position = i;
        }
    }

    return position;
}

int trap(vector<int>& height) {
    if(height.empty()) return 0;
    int max = findMaxPosition(height);
    //cout<<max<<endl;
    stack<int> waterLv;
    int result = 0;
    int left = 0;
    int leftMax = height[0];
    int right = height.size() - 1;
    int rightMax = height[right];

    while (left < max) {
        if (height[left] > leftMax) {
            //cout<<leftMax<<endl;
            leftMax = height[left];
            while (!waterLv.empty()) {
                result += waterLv.top();
                //cout<<waterLv.top()<<endl;
                waterLv.pop();
            }
        } else {
           
            
            waterLv.push(leftMax - height[left]);
           
        }
        left++;
    }
 

    while (right > max) {
        if (height[right] > rightMax) {
            rightMax = height[right];
            while (!waterLv.empty()) {
                result += waterLv.top();
                waterLv.pop();
            }
        } else {
            waterLv.push(rightMax - height[right]);
        }
        right--;
    }
    while (!waterLv.empty()) {
                result += waterLv.top();
                //cout<<waterLv.top()<<endl;
                waterLv.pop();
    }
    return result;
}",0.9,111111111111
Stack_4,1454547,2212303,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(0, item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    return list.removeAt(0);  
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(0);    
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    while(!this->empty()) this->pop();
}",1.0,11111
Stack_5,1454547,2212303,"int findmax(vector<int>& nums, int left, int right) {
    if (left == right - 1) return left;
    for (int i = left; i < right; i++) {
        if (nums[i] >= nums[left])
            left = i;
    }
    return left;
}
int mountainWithoutValley(vector<int>& nums) {
    if (nums.empty()) return 0;

    int n = nums.size();
    if (n <= 2) {
        int r = 0;
        for (int i = 0; i < n; i++) {
            r += nums[i];
        }
        return r;
    }
    int result = 0;
    int top = findmax(nums, 1, n - 1);



    //case1;

    int result1 = 0;
    result1 += nums[n - 1];
    int max1 = nums[n - 1];
    //cout << max1 << "" "";
    for (int i = n - 2; i >= 0; i--) {
        if (nums[i] <= max1) {
            max1 = nums[i];
            result1 += nums[i];
        }
        else result1 += max1;
        //cout << max1 << endl;
    }
    //cout << result1 << endl;
    stack<int> up;
    //stack<int> rs;
    int result2 = nums[0];
    int max2 = nums[0];
    for (int i = 1; i < n; i++) {
        if (nums[i] >= max2) result2 += max2;
        else {
            max2 = nums[i];
            result2 += nums[i];
        }
    }
    //cout << result2 << endl;
    int tResult = 0;
    int maxV = nums[top];

    //cout << ""max "" << maxV << endl;
    if (top != 0) {
        int tempMax = maxV;
        for (int l = 0; l < top; l++) {
            up.push(nums[l]);
        }
        while (!up.empty()) {
            if (up.top() <= maxV) {
                tResult += up.top();
                //cout << up.top() << endl;
                tempMax = up.top();
            }
            else {
                tResult += tempMax;
            }
            up.pop();
        }
    }
    //cout << tResult << endl;
    tResult += maxV;
    //cout << tResult << endl;
    if (top < nums.size() - 1) {
        for (int r = top + 1; r < nums.size(); r++) {
            if (nums[r] <= maxV) {
                tResult += nums[r];
                maxV = nums[r];
            }
            else {
                tResult += maxV;
            }
        }



    }
    //cout << tResult << endl;
    if (tResult > result) result = tResult;
    if (result2 > result) result = result2;
    if (result1 > result) result = result1;
    return result;
}
",0.8,1100000000
Stack_6,1454547,2212303,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    int n = arr.size();
    vector<int> result(n, -1);  // Initialize the result array with -1.

    stack<int> st;  // Create a stack to store indices of elements.

    for (int i = 0; i < n; i++) {
        while (!st.empty() && arr[i] > arr[st.top()]) {
            // If the current element is greater than the element at the top of the stack, update the result.
            result[st.top()] = arr[i];
            st.pop();  // Pop the index from the stack.
        }
        st.push(i);  // Push the current index onto the stack.
    }

    return result;
}",1.0,1111111111
Stack_7,1454547,2212303,"string parenthesesReversal(string s) {
    //special case
    if (s == """") return """";
    if (s.length() <= 1) return s;

    stack<char> st;
    int n = s.length();
    string result = """";

    for (int i = 0; i < n; i++) {
        if (s[i] == ')') {
            string temp = """";
            if (st.empty()) continue;
            while (st.top() != '(') {
                temp += st.top();
                st.pop();
            }
            st.pop();
            if (!st.empty()) {
                for (size_t j = 0; j < temp.length(); j++) {
                    st.push(temp[j]);
                }
            }
            else result += temp;
        } else if ( s[i] == '(') {
            
            
                
                while (s[i] != ')'){
                    st.push(s[i]);
                    
                    i++;
                    
                }
                if (i == n) continue;
                i--; // prepare for incrment;
        }
        else {
            if (st.empty())
            result += s[i];
            else st.push(s[i]);
        }
    }
    string temp = """";
    while (!st.empty()&& st.top()!='(') {
        temp += st.top();
        st.pop();
    }
    for (size_t j = 0; j < temp.length(); j++) {
        st.push(temp[j]);
    }
    while (!st.empty() && st.top() != '(') {
        result += st.top();
        st.pop();
    }
    return result;
}",1.0,1111111111
Stack_8,1454547,2212303,"string removeDuplicates(string S){
    /*TODO*/
     stack<char> charStack;

    for (char c : S) {
        if (!charStack.empty() && charStack.top() == c) {
            charStack.pop(); // Remove the duplicate character.
        } else {
            charStack.push(c); // Push the character onto the stack.
        }
    }

    string result = """";
    while (!charStack.empty()) {
        result = charStack.top() + result;
        charStack.pop();
    }

    return result;
}",1.0,1111111
Stack_9,1454547,2212303,"string deleteDuplicate(string s, int k) {
    if(k<=1) return """";
    if(s=="""") return s;
  stack<pair<char, int>> charStack;

    for (char c : s) {
        if (charStack.empty() || charStack.top().first != c) {
            charStack.push({c, 1});
        } else {
            charStack.top().second++; // Increment the count of consecutive characters.

            if (charStack.top().second == k) {
                charStack.pop(); // Remove k consecutive characters.
            }
        }
    }

    string result = """";
    while (!charStack.empty()) {
        result = string(charStack.top().second, charStack.top().first) + result;
        charStack.pop();
    }

    return result;
}",1.0,1111111111
Stack_10,1454547,2212303,"int sumOfMinSubarray(vector<int>& nums) {
    int n = nums.size();
    stack<pair<int, int>> st; // Pair of (value, position)
    vector<long long> sumOfMins(n, 0);

    for (int i = 0; i < n; i++) {
        while (!st.empty() && nums[i] <= st.top().first) {
            st.pop();
        }
        if (st.empty()) {
            sumOfMins[i] = (i + 1) * nums[i];
        } else {
            sumOfMins[i] = sumOfMins[st.top().second] + (i - st.top().second) * nums[i];
        }
        st.push({nums[i], i});
    }

    long long result = 0;
    for (long long minSum : sumOfMins) {
        result += minSum;
    }

    return result % 10000;
}",1.0,1111111111
Stack_11,1454547,2212303,"  bool tripleIndexSLM(vector<int>&nums) {
      // STUDENT ANSWER
      int n = nums.size();
      if (n < 3) {
          return false;  // Not enough elements to form a triplet.
      }
      int minIndex = 0;
      int maxIndex = 0;
      int min = nums[0];  // Initialize the minimum value seen so far.
      int max = nums[0];  // Initialize the maximum value seen so far.
      int nextmin;
      int nextminIndex;
      bool assign = false;

      for (int i = 1; i < n - 1; i++) {
          if (nums[i] > min && nums[i] < max && max>min) {
              return true;
          }
          if (nums[i] < min) {
              
              nextmin = nums[i];  // Update the minimum value.
              nextminIndex = i;
              assign = true;
          }
          else if (nums[i] > max && i>minIndex) {
              max = nums[i];  // Update the maximum value.
              maxIndex = i;
              if (assign) {
                  if (nextmin < max && nextminIndex < maxIndex) {
                      min = nextmin;
                      minIndex = nextminIndex;
                  }
              }
          }
          
      }

      return false;
  }",1.0,1111111111
Stack_1,1454553,2211876,"int boxRequire(vector<int>& piles, int k) {
    int left = 1; // Minimum possible box capacity
    int right = *max_element(piles.begin(), piles.end()); // Maximum possible box capacity

    while (left < right) {
        int mid = left + (right - left) / 2;
        int requiredBoxes = 0;
        for (int pile : piles) {
            requiredBoxes += (pile + mid - 1) / mid;
        }

        if (requiredBoxes > k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}",1.0,111111111111111
Stack_2,1454553,2211876,"int baseballScore(string ops){
/*TODO*/
    stack<int> scores;

    for (char op : ops) {
        if (isdigit(op)) {
            int score = op - '0';
            scores.push(score);
        } else if (op == '+') {
            if (scores.size() >= 2) {
                int last1 = scores.top();
                scores.pop();
                int last2 = scores.top();
                scores.push(last1);
                scores.push(last1 + last2);
            }
        } else if (op == 'D') {
            if (!scores.empty()) {
                int last = scores.top();
                scores.push(last * 2);
            }
        } else if (op == 'C') {
            if (!scores.empty()) {
                scores.pop();
            }
        }
    }

    int totalScore = 0;
    while (!scores.empty()) {
        totalScore += scores.top();
        scores.pop();
    }

    return totalScore;
}",1.0,1111111111
Stack_3,1454553,2211876,"int trap(vector<int>& height) {
//TODO
    int left = 0;   // Con trỏ trái
    int right = height.size() - 1;  // Con trỏ phải
    int leftMax = 0;  // Chiều cao lớn nhất từ bên trái
    int rightMax = 0;  // Chiều cao lớn nhất từ bên phải
    int result = 0;  // Tổng diện tích mặt cắt nước

    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] > leftMax) {
                leftMax = height[left];
            } else {
                result += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] > rightMax) {
                rightMax = height[right];
            } else {
                result += rightMax - height[right];
            }
            right--;
        }
    }

    return result;
}",1.0,111111111111
Stack_4,1454553,2211876,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    // if (empty()) {
    //         // Handle the case when the stack is empty
    //         throw std::runtime_error(""Stack is empty"");
    //     }
        return list.removeAt(list.size() - 1);    
}

T top() {
    // TODO: Get value of the element on top of the stack
    // if (empty()) {
    //         // Handle the case when the stack is empty
    //         throw std::runtime_error(""Stack is empty"");
    //     }
        return list.get(list.size() - 1);    
}

bool empty() {
    // TODO: Determine if the stack is empty
     return list.empty();   
}

int size() {
    // TODO: Get the size of the stack
    return list.size();    
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_6,1454553,2211876,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& nums){
    int n = nums.size();
    vector<int> result(n, -1); // Initialize the result vector with -1.

    stack<int> s; // Create a stack to store indices of elements.

    for (int i = 0; i < n; i++) {
        while (!s.empty() && nums[i] > nums[s.top()]) {
            // If the current element is greater than the element at the top of the stack,
            // update the result for the element at the top of the stack.
            result[s.top()] = nums[i];
            s.pop(); // Pop the element from the stack.
        }
        s.push(i); // Push the current element's index onto the stack.
    }

    return result;
}",1.0,1111111111
Stack_7,1454553,2211876,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    stack<std::string> stack;
    string current = """";

    for (char c : s) {
        if (c == '(') {
            // Push the current string onto the stack and reset it.
            stack.push(current);
            current = """";
        } else if (c == ')') {
            // Reverse the current string and append it to the previous string.
            std::string reversed;
            for (int i = current.length() - 1; i >= 0; i--) {
                reversed += current[i];
            }
            current = stack.top() + reversed;
            stack.pop();
        } else {
            // Append the character to the current string.
            current += c;
        }
    }

    return current;
}",1.0,1111111111
Stack_8,1454553,2211876,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> charStack;

    for (char c : S) {
        if (!charStack.empty() && charStack.top() == c) {
            // If the current character matches the top of the stack, remove it.
            charStack.pop();
        } else {
            // Otherwise, push the current character onto the stack.
            charStack.push(c);
        }
    }

    // Reconstruct the final string from the characters left in the stack.
    string result = """";
    while (!charStack.empty()) {
        result = charStack.top() + result;
        charStack.pop();
    }

    return result;
}",1.0,1111111
Stack_9,1454553,2211876,"string deleteDuplicate(string s, int k) {
    stack<std::pair<char, int>> charStack; // Stack to store characters and their frequencies.

    for (char c : s) {
        if (charStack.empty() || charStack.top().first != c) {
            charStack.push({c, 1});
        } else {
            charStack.top().second++; // Increase the frequency of the top character.

            if (charStack.top().second == k) {
                charStack.pop(); // If frequency reaches k, pop the character.
            }
        }
    }

    string result = """";
    while (!charStack.empty()) {
        char c = charStack.top().first;
        int freq = charStack.top().second;
        charStack.pop();
        result.insert(result.begin(), freq, c); // Reconstruct the final string.
    }

    return result;
}",0.9,1101111111
Stack_10,1454553,2211876,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 10000;
    int n = nums.size();
    long long result = 0; // Initialize the result as a long long to handle large sums.

    // Create two arrays to store the left and right boundaries of the minimum elements.
    vector<int> left(n);
    vector<int> right(n);

    stack<int> s; // Create a stack to store the indices of elements.

    // Calculate the left boundaries of the minimum elements.
    for (int i = 0; i < n; i++) {
        while (!s.empty() && nums[i] <= nums[s.top()]) {
            s.pop();
        }
        left[i] = s.empty() ? -1 : s.top();
        s.push(i);
    }

    while (!s.empty()) {
        s.pop();
    }

    // Calculate the right boundaries of the minimum elements.
    for (int i = n - 1; i >= 0; i--) {
        while (!s.empty() && nums[i] <= nums[s.top()]) {
            s.pop();
        }
        right[i] = s.empty() ? n : s.top();
        s.push(i);
    }

    for (int i = 0; i < n; i++) {
        // Calculate the contribution of the current minimum element to the total sum.
        result += (long long)nums[i] * (i - left[i]) * (right[i] - i);
        result %= MOD;
    }

    return result;
}",0.5,1111100000
Stack_11,1454553,2211876,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    std::stack<int> increasingStack; // Stack to store increasing elements.

    int thirdElement = 1; // Initialize the third element to a minimum value.

    for (int i = n - 1; i >= 0; i--) {
        if (nums[i] < thirdElement) {
            // If we find an element smaller than the third element, we have a valid triplet.
            return true;
        }

        while (!increasingStack.empty() && nums[i] > increasingStack.top()) {
            // Pop elements from the stack until we find an element greater than nums[i].
            thirdElement = increasingStack.top();
            increasingStack.pop();
        }

        increasingStack.push(nums[i]);
    }

    return false; 
}",0.5,1100001110
Stack_1,1454572,2210200,"bool check(int const &mid, const vector<int>& piles, int const &k){
    int ans = 0;
    int n = piles.size();
    for(int i = 0; i < n; i++){
        if(piles[i] % mid == 0) ans += piles[i] / mid;
        else{
            ans += (piles[i]/mid + 1);
        }
    }
    return (ans <= k);
}

int boxRequire(vector<int>& piles, int k) {
    int n = piles.size();
    int ans = 0;
    int r = 0;
    for(int i = 0; i < n; i++){
        r += piles[i];
    }
    int l = 1;
    while(l <= r){
        int mid = (l + r)/2;
        if(check(mid, piles, k)){
            ans = mid;
            r = mid - 1;
        }
        else l = mid + 1;
    }
    return ans;    
}",1.0,111111111111111
Stack_2,1454572,2210200,"
int baseballScore(string ops){
/*TODO*/
    stack<int> st;
    int n = ops.size();
    for(int i = 0; i < n; i++){
        if(isdigit(ops[i])) st.push(ops[i] - '0');
        else if(ops[i] == 'C') st.pop();
        else if(ops[i] == 'D'){
            int prev = st.top();
            st.push(2 * prev);
        }
        else if(ops[i] == '+'){
            int prev1 = st.top();
            st.pop();
            int prev2 = st.top();
            st.push(prev1);
            st.push(prev1 + prev2);
        }
    }
    int ans = 0;
    while(!st.empty()){
        ans += st.top();
        st.pop();
    }
    return ans;
}",1.0,1111111111
Stack_3,1454572,2210200,"int trap(vector<int>& height) {
//TODO 
    int n = height.size();
    if(n == 0) return 0;
    vector<int> l(n, 0), r(n, 0);
    l[0] = height[0];
    r[n - 1] = height[n - 1];
    for(int i = 1; i < n; i++) l[i] = max(l[i-1], height[i]);
    for(int i = n - 2; i >= 0; i--) r[i] = max(r[i + 1], height[i]);
    int ans = 0;
    for(int i = 0; i < n; i++){
        int val = min(l[i], r[i]);
        if(val >= height[i]){
            ans += val - height[i];
        }
    }
    return ans;
}",1.0,111111111111
Stack_4,1454572,2210200,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(0, item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
    return;
}",1.0,11111
Stack_5,1454572,2210200,"int mountainWithoutValley(vector<int>& nums) {
    
    vector<pair<int,int>> up;
    vector<pair<int,int>> down;
    
    int max=INT_MIN;
    
    up.push_back({nums[0],0});
    int size=nums.size();
    int sum1=nums[0];
    for(int i=1;i<size;i++){
        pair<int,int> temp_up_back=up.back();
        if(nums[i]>=temp_up_back.first){
            up.push_back({nums[i],i});
            sum1+=nums[i];
        }
        else {
            int sum2;
            if(nums[i]*(size-i-1)+sum1<=max){
                goto skip;
            }
            down.push_back({nums[i],i});
            sum2=nums[i];
            for(int j=i+1;j<size;j++){
                pair<int,int> temp_down_back=down.back();
                if(nums[j]<=temp_down_back.first){
                    if(sum1+sum2+nums[j]*(size-j-1)<max)  {down.clear();goto skip;}
                    down.push_back({nums[j],j});
                    sum2+=nums[j];
                }
                else{
                    down[down.size()-1].second++;
                    sum2+=down[down.size()-1].first;
                }
            }
            if(sum1+sum2>max){
                max=sum1+sum2;
            }
            down.clear();
            skip:
            while(nums[i]<temp_up_back.first){
                if(up.size()==1){sum1-=up[0].first*(up[0].second+1);}
                else {
                    int up_size=up.size();
                    sum1 -= up[up_size-1].first*(up[up_size-1].second-up[up_size-2].second);
                    
                }
                up.pop_back();
                if(up.size()==0){
                    break;
                }
                temp_up_back=up.back();
            }
            up.push_back({nums[i],i});
            if(up.size()==1)
            sum1+=nums[i]*(i-0+1);
            else
            sum1+=nums[i]*(up[up.size()-1].second-up[up.size()-2].second);
        }
    }
    sum1=up[0].first*(up[0].second+1);
            int up_size=up.size();
            for(int j=1;j<up_size;j++){
                sum1=sum1+up[j].first*(up[j].second-up[j-1].second);
            }
            if(sum1>max) max=sum1;
    return max;
}",1.0,1111111111
Stack_6,1454572,2210200,"vector<int> nextGreater(vector<int>& arr){
    stack<int> st;
    int n = arr.size();
    vector<int> ans(n);
    for(int i = n - 1; i >= 0; i--){
        while(!st.empty() && arr[st.top()] <= arr[i]) st.pop();
        ans[i] = -1;
        if(!st.empty()) ans[i] = arr[st.top()];
        st.push(i);
    }
    return ans;
}",1.0,1111111111
Stack_7,1454572,2210200,"#include<algorithm>

string parenthesesReversal(string s) {
    // STUDENT ANSWER
    int n = s.size();
    stack<char> st;
    for(int i = 0; i < n; i++){
        if(s[i] == '('){
            st.push(s[i]);
        }
        else if(s[i] == ')'){
            string temp = """";
            while(!st.empty() && st.top() != '('){
                temp += st.top();
                st.pop();
            }
            st.pop();
            int sz = temp.size();
            for(int j = 0; j < sz; j++) st.push(temp[j]);
        }
        else{
            st.push(s[i]);
        }
    }
    string ans = """";
    while(!st.empty()){
        ans += st.top();
        st.pop();
    }
    reverse(ans.begin(), ans.end());
    return ans;
}",1.0,1111111111
Stack_8,1454572,2210200,"#include <algorithm>
string removeDuplicates(string s){
    /*TODO*/
    stack<char> st;
    int n = s.size();
    for(int i = 0; i < n; i++){
        if(st.empty()) st.push(s[i]);
        else{
            if(st.top() == s[i]) st.pop();
            else st.push(s[i]);
        }
    }
    string ans = """";
    while(!st.empty()){
        ans += st.top();
        st.pop();
    }
    reverse(ans.begin(), ans.end());
    return ans;
}",1.0,1111111
Stack_9,1454572,2210200,"#include<algorithm>

string deleteDuplicate(string s, int k) {
    stack<pair<char,int>> st;
    int n = s.size();
    for(int i = 0; i < n; i++){
        if(st.empty()){
            st.push(make_pair(s[i], 1));
        }
        else{
            if(s[i] == st.top().first){
                pair<char,int> x = st.top();
                x.second += 1;
                st.pop();
                st.push(x);
            }
            else{
                st.push(make_pair(s[i], 1));
            }
        }
        pair<char,int> x = st.top();
        if(x.second == k){
            st.pop();
        }
    }
    string ans = """";
    while(!st.empty()){
        pair<char, int> x = st.top();
        st.pop();
        while(x.second){
            ans += x.first;
            --x.second;
        }
    }
    reverse(ans.begin(), ans.end());
    return ans;
}",1.0,1111111111
Stack_10,1454572,2210200,"#include<utility>
int sumOfMinSubarray(vector<int>& a) {
    // STUDENT ANSWER
    stack<pair<int,int>> st1, st2;
    int n = a.size();
    vector<int> l(n), r(n);
    for(int i = 0; i < n; i++){
        int cnt = 1;
        while(!st1.empty() && st1.top().first > a[i]){
            cnt += st1.top().second;
            st1.pop();
        }
        st1.push(make_pair(a[i], cnt));
        l[i] = cnt;
    }
    for(int i = n - 1; i >= 0; i--){
        int cnt = 1;
        while(!st2.empty() && st2.top().first >= a[i]){
            cnt += st2.top().second;
            st2.pop();
        }
        st2.push(make_pair(a[i], cnt));
        r[i] = cnt;
    }
    long long ans = 0;
    long long MOD = 10000;
    for(int i = 0; i < n; i++){
        ans += ((a[i] % MOD) * (r[i] % MOD) * (l[i] % MOD)) % MOD;
        ans %= MOD;
    }
    return (int)ans;
}",1.0,1111111111
Stack_11,1454572,2210200,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    stack<int> st;
    int h3 = (int)-1e9, h1 = (int)1e9;
    for(int i = n - 1; i >= 0; i--){
        h1 = nums[i];
        while(!st.empty() && st.top() < nums[i]){
            h3 = st.top();
            st.pop();
        }
        st.push(nums[i]);
        if(h1 < h3) return true;
    }
    return false;
}
",1.0,1111111111
Stack_1,1454582,2211170,"int boxRequire(vector<int>& piles, int k) {
    int left = 1; // Minimum capacity of each box (starting from 1)
    int right = 0; // Maximum capacity of each box

    // Find the maximum capacity of each box
    for (int pile : piles) {
        right = max(right, pile);
    }

    // Perform binary search to find the minimum capacity
    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxes = 0;

        // Count the number of boxes required for the current capacity
        for (int pile : piles) {
            boxes += (pile + mid - 1) / mid; // Round up division
        }

        if (boxes <= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}",1.0,111111111111111
Stack_2,1454582,2211170,"int baseballScore(string ops) {
    stack<int> record; // Stack to store the scores in the record
    
    for (char op : ops){
        if (isdigit(op) || op == '-') {
            record.push(op - '0');
        }
        else if (op == '+') {
            int score1 = record.top();
            record.pop();
            int score2 = record.top();
            int newScore = score1 + score2;
            record.push(score1);
            record.push(newScore);
        }
        else if (op == 'D') {
            int score = record.top();
            int newScore = score * 2;
            record.push(newScore);
        }
        else if (op == 'C') {
            record.pop();
        }
    }
    
    int totalScore = 0;
    while (!record.empty()) {
        totalScore += record.top();
        record.pop();
    }
    
    return totalScore;
}",1.0,1111111111
Stack_3,1454582,2211170,"int trap(vector<int>& height) {
        if(height.empty()) 
            return 0; 
        int n = height.size();
        int res = 0;
        stack<int> s;   
        for(int i=0; i<n; i++) {
            while(!s.empty() && height[i] > height[s.top()]) {
                int rightIdx = s.top();
                s.pop();
                
                if(s.empty()) 
                    break;
                
                int leftIdx = s.top();
                int length = min(height[i], height[leftIdx]) - height[rightIdx];
                int breadth = i - leftIdx - 1;
                res += length*breadth;
            }
            s.push(i);
        }
        return res;
}",1.0,111111111111
Stack_4,1454582,2211170,"void push(T item) {
// Add the item to the end of the linked list
list.add(item);
}

T pop() {
// Remove and return the item from the end of the linked list
return list.removeAt(list.size() - 1);
}

T top() {
// Return the item at the end of the linked list without removing
return list.get(list.size() - 1);
}

bool empty() {
// Check if the linked list is empty
return list.empty();
}

int size() {
// Return the size of the linked list
return list.size();
}

void clear() {
// Clear all items from the linked list
list.clear();
}",1.0,11111
Stack_5,1454582,2211170,"int mountainWithoutValley(std::vector<int>& nums) {
    std::stack<int> st;
    int n = nums.size();
    
    if (n == 0) 
    return 0;
    
    else{
        st.push(nums[n - 1]);

    for (int i = n - 2; i >= 0; i--) {
        if (nums[i] > st.top()) {
            int temp = st.top();
            st.push(temp);
        }
        
        else{
            st.push(nums[i]);
        }
    }

    int sum = 0;
    while (!st.empty()) {
        sum += st.top();
        st.pop();
    }

    return sum;
        
    }
}",0.2,1100000000
Stack_6,1454582,2211170,"// iostream, stack and vector are included

vector<int> nextGreater(std::vector<int>& arr) {
    int n = arr.size();
    std::vector<int> result(n, -1); // Initialize the result vector with -1
    
    std::stack<int> st;
    
    for (int i = 0; i < n; i++) {
        while (!st.empty() && arr[st.top()] < arr[i]) {
            result[st.top()] = arr[i];
            st.pop();
        }
        st.push(i);
    }
    
    return result;
}",1.0,1111111111
Stack_7,1454582,2211170,"string parenthesesReversal(string s) {
    stack<char> st;
    int n = s.length();
    for(int i = 0; i < n; i++) {
        char ch = s[i];
        if(ch == '(' || ch != ')') {
            st.push(ch);
        }

        if(ch == ')' && !st.empty()) {
            string temp = """";
            while(st.top() != '(') {
                temp += st.top();
                st.pop();
            }
            st.pop();

            int m = temp.length();

            if(st.empty() && i == n - 1) {
                return temp;
            } else {
                for(int i = 0; i < m; i++) {
                    st.push(temp[i]);
                }
            }
        }
    }

    stack<char> rev;
    while(!st.empty()) {
        rev.push(st.top());
        if(st.top() == '(' || st.top() == ')') {
            return """";
        }
        st.pop();
    }

    string ans = """";
    while(!rev.empty()) {
        ans.push_back(rev.top());
        rev.pop();
    }
    return ans;
}",1.0,1111111111
Stack_8,1454582,2211170,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> noDup;
    
    for (char c : S){
        if (noDup.empty()){
            noDup.push(c);
        }
        else if (c == noDup.top()){
            noDup.pop();
        }
        
        else{
            noDup.push(c);
        }
    }
    
    stack<char> rev;
    while (!noDup.empty()){
        rev.push(noDup.top());
        noDup.pop();
    }
    
    string ans = """";
    while (!rev.empty()){
        ans.push_back(rev.top());
        rev.pop();
    }
    return ans;
}",1.0,1111111
Stack_9,1454582,2211170,"string deleteDuplicate(string s, int k) {
        // Base Case
        // If k=1 then all characters
        // can be removed at each
        // instance
        if (k == 1)
            return """";
        // initialize string
        string output = """";
        int len =  s.length();
        // create a stack using pair<> for storing each
        // character and corresponding
        // repetition
        stack<pair<char, int> > stk;
 
        // iterate through the string
        for (int i = 0; i < len; i++) {
 
            // if stack is empty then simply add the
            // character with count 1 else check if
            // character is same as top of stack
            if (stk.empty() == true) {
                stk.push(make_pair(s[i], 1));
            }
            else {
 
                // if character at top of stack is same as
                // current character increase the number of
                // repetitions in the top of stack by 1
                if (s[i] == (stk.top()).first) {
                    pair<char, int> P = stk.top();
                    stk.pop();
                    P.second++;
                    if (P.second == k)
                        continue;
                    else
                        stk.push(P);
                }
                else {
 
                    // if character at top of stack is not
                    // same as current character push the
                    // character along with count 1 into the
                    // top of stack
                    stk.push(make_pair(s[i], 1));
                }
            }
        }
 
        // Iterate through the stack
        // Use string(int,char) in order to replicate the
        // character multiple times and convert into string
        // then add in front of output string
        stack<char> rev;
        while (!stk.empty()) {
            if (stk.top().second > 1) {
                // if Frequency of current character greater
                // than 1(let m),then append that character
                // m times in output string
                int count = stk.top().second;
                while (count--)
                    rev.push(stk.top().first);
            }
            else {
                rev.push(stk.top().first);
            }
            stk.pop();
        }
        
        while (!rev.empty()){
        output.push_back(rev.top());
        rev.pop();
    }
        return output; 
}",1.0,1111111111
Stack_10,1454582,2211170,"long long sumOfMinSubarray(std::vector<int>& arr) {
       int n = arr.size(),mod = 10000;
       stack<pair<int,int>> st;
       vector<int> left(n,-1),right(n,-1);
       long long ans = 0;
       

       for(int i = 0;i<n;i++)
       {
          while(st.size()>0 && st.top().first>arr[i])
          st.pop();

          if(st.size()>0)
          left[i] = i-st.top().second;

          st.push({arr[i],i});
       }

       while(!st.empty())
       st.pop();


       for(int i = 0;i<n;i++)
       {
           while(st.size()>0 && st.top().first>arr[i])
           {
               right[st.top().second] = i-st.top().second;
               st.pop(); 
           }

           st.push({arr[i],i});
       }

       for(int i = 0;i<n;i++)
       {
           if(left[i]==-1)
           left[i] = i+1;

           if(right[i]==-1)
           right[i] = n-i;
           long long tmp = (left[i]*right[i])%mod;
           tmp = (tmp*arr[i])%mod;
           ans = (ans+tmp)%mod;
       }

       return ans;
}",1.0,1111111111
Stack_11,1454582,2211170,"bool tripleIndexSLM(vector<int>& arr) {
    // STUDENT ANSWER
        int n = arr.size();
    stack<int> st;
 
    // Initialize the heights of h1 and h3
    // to INT_MAX and INT_MIN respectively
    int h3 = -2147483647 - 1, h1 = 2147483647;
    for (int i = n - 1; i >= 0; i--) {
 
        // Store the current element as h1
        h1 = arr[i];
 
        // If the element at top of stack
        // is less than the current element
        // then pop the stack top
        // and keep updating the value of h3
        while (!st.empty()
            && st.top() < arr[i]) {
 
            h3 = st.top();
            st.pop();
        }
 
        // Push the current element
        // on the stack
        st.push(arr[i]);
 
        // If current element is less
        // than h3, then we found such
        // triplet and return true
        if (h1 < h3) {
            return true;
        }
    }
 
    // No triplet found, hence return false
    return false;
}",1.0,1111111111
Stack_1,1454583,2013048,"int boxRequire(std::vector<int>& piles, int k) {
    int left = 1; // Minimum possible capacity.
    int right = *std::max_element(piles.begin(), piles.end()); // Maximum possible capacity.
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int requiredBoxes = 0;

        for (int numNotebooks : piles) {
            requiredBoxes += (numNotebooks + mid - 1) / mid;
        }

        if (requiredBoxes <= k) {
            result = mid;
            right = mid - 1; // Search for smaller capacities.
        } else {
            left = mid + 1; // Search for larger capacities.
        }
    }

    return result;
}",1.0,111111111111111
Stack_2,1454583,2013048,"#include<iostream>
#include<vector>
using namespace std;
int baseballScore(string ops){
/*TODO*/
int result = 0;
    vector<int> score;
    for(int i = 0; ops[i] != '\0'; i++){
        switch (ops[i])
        {
        case '+':
            score.push_back(score[score.size()-1]+score[score.size()-2]);
            break;
        case 'D':
            score.push_back(score[score.size()-1] *2);
            break;
        case 'C':
            score.pop_back();
            break;
        default:
            string str = """";
            str += ops[i];
            score.push_back(stoi(str, nullptr, 10));
            break;
        }
    }
    for(int i = 0; i < (int) score.size(); i++){
        result += score[i];
    }
    return result;
}",1.0,1111111111
Stack_4,1454583,2013048,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(list.size(), item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    T item = list.get(list.size()-1);
    list.removeAt(list.indexOf(item));
    return item;
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(list.size()-1);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return !(list.size());
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}
",1.0,11111
Stack_6,1454583,2013048,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    for(int i = 0; i < (int) arr.size() - 1; i++){
        int j = i + 1;
        while(j < (int) arr.size() && arr[j] < arr[i]){
            j++;
        }
        if(j == (int) arr.size()){
            arr[i] = -1;
        }else{
            arr[i] = arr[j];
        }
    }
    arr[arr.size() - 1] = -1;
    return arr;
}",1.0,1111111111
Stack_7,1454583,2013048,"#include <algorithm> // Include the algorithm header for reverse

std::string parenthesesReversal(std::string s) {
    std::stack<int> openingParentheses;
    int n = s.size();

    for (int i = 0; i < n; i++) {
        if (s[i] == '(') {
            openingParentheses.push(i);
        } else if (s[i] == ')') {
            int start = openingParentheses.top();
            openingParentheses.pop();
            std::reverse(s.begin() + start + 1, s.begin() + i);
        }
    }

    std::string result;
    for (int i = 0; i < n; i++) {
        if (s[i] != '(' && s[i] != ')') {
            result += s[i];
        }
    }

    return result;
}",1.0,1111111111
Stack_8,1454583,2013048,"string removeDuplicates(string S){
    for (int i = 0 ; i < (int)S.length() ; i++) {
        for (int j = 0 ; j < (int)S.length() -1; j++) {
            if (S[j] == S[j+1]) {
                S.erase(S.begin() + j) ;
                S.erase(S.begin() +j);
                break;
            }
        }
    }
    return S;
}",1.0,1111111
Stack_9,1454583,2013048,"string deleteDuplicate(std::string s, int k) {
    std::stack<std::pair<char, int>> charStack; // Pair of character and its count

    for (char c : s) {
        if (charStack.empty() || charStack.top().first != c) {
            charStack.push({c, 1});
        } else {
            charStack.top().second++;
            if (charStack.top().second == k) {
                charStack.pop(); // Remove the k-consecutive characters
            }
        }
    }

    std::string result;
    while (!charStack.empty()) {
        char c = charStack.top().first;
        int count = charStack.top().second;
        charStack.pop();
        result.insert(result.begin(), count, c); // Add characters back to the result
    }

    return result;
}",0.9,1101111111
Stack_10,1454583,2013048,"const int MOD = 10000;

int sumOfMinSubarray(std::vector<int>& nums) {
    int n = nums.size();
    std::vector<long long> minSum(n, 0);
    std::stack<int> indexStack;

    long long totalSum = 0;

    for (int i = 0; i < n; i++) {
        while (!indexStack.empty() && nums[i] < nums[indexStack.top()]) {
            indexStack.pop();
        }

        if (indexStack.empty()) {
            minSum[i] = (i + 1) * nums[i];
        } else {
            minSum[i] = minSum[indexStack.top()] + (i - indexStack.top()) * nums[i];
        }

        minSum[i] %= MOD;
        totalSum = (totalSum + minSum[i]) % MOD;
        indexStack.push(i);
    }

    return static_cast<int>(totalSum);
}",1.0,1111111111
Stack_11,1454583,2013048,"#include <climits> // Include the climits header for INT_MAX

bool tripleIndexSLM(std::vector<int>& nums) {
    int n = nums.size();
    if (n < 3) {
        return false; // Not enough elements to form a triplet.
    }

    int min = nums[0];
    int mid = INT_MAX; // Initialize mid to a very large value.

    for (int k = 1; k < n; k++) {
        if (nums[k] > mid) {
            return true; // We found a triplet (i, j, k).
        } else if (nums[k] < min) {
            min = nums[k];
        } else if (nums[k] > min && nums[k] < mid) {
            mid = nums[k];
        }
    }

    return false; // No triplet found.
}",0.8,0111111110
Stack_1,1454585,2210103,"bool isPossible(const std::vector<int>& piles, int k, int capacity) {
    int boxesUsed = 0;
    for (int pile : piles) {
        boxesUsed += (pile + capacity - 1) / capacity;
    }
    return boxesUsed <= k;
}

int boxRequire(std::vector<int>& piles, int k) {
    int left = 1;
    int right = *std::max_element(piles.begin(), piles.end());

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (isPossible(piles, k, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}",1.0,111111111111111
Stack_2,1454585,2210103,"struct Node
{
    int data;
    Node* next;
};

Node* createNewNode(int data)
{
    Node* p = new Node();
    if (p != nullptr)
    {
        p->data = data;
        p->next = nullptr;
        return p;
    }
    return nullptr;
}

bool isEmpty(Node* stack)
{
    return stack == nullptr;
}

void push(Node*& stack, int data)
{
    Node* p = createNewNode(data);
    Node* start = stack;
    if (p != nullptr)
    {
        if (start != nullptr)
        {
            while (start->next != nullptr)
            {
                start = start->next;
            }
            start->next = p;
        }
        else
        {
            start = p;
        }
    }
}

int peek(Node* stack)
{
    if (!isEmpty(stack))
    {
        Node* p = stack;
        while (p->next != nullptr)
        {
            p = p->next;
        }
        return p->data;
    }
    return 0;
}

void pop(Node*& stack)
{
    if (!isEmpty(stack))
    {
        Node* p = stack;
        Node* r = stack;
        while (p->next != nullptr)
        {
            r = p;
            p = p->next;
        }
        delete p;
        p = nullptr;
        if (r != nullptr)
        {
            r->next = nullptr;
        }

    }
}

int baseballScore(string ops) {
    Node* stack = new Node();
    int length = ops.length();
    int count = 0;
    while (count != length)
    {
        if (ops[count] == '+')
        {
            int a = peek(stack);
            pop(stack);
            int b = peek(stack);
            push(stack, a);
            push(stack, a + b);
        }
        else if (ops[count] == 'C')
        {
            pop(stack);
        }
        else if (ops[count] == 'D')
        {
            int a = peek(stack);
            push(stack, a * 2);
        }
        else
        {
            int a = ops[count] - 48;
            push(stack, a);
        }
        count++;
    }
    Node* p = stack;
    int result = 0;
    while (p != nullptr)
    {
        result += p->data;
        p = p->next;
    }
    return result;
}",1.0,1111111111
Stack_3,1454585,2210103,"int trap(vector<int>& height) {
        int max_left=0, max_right = 0;
        int left = 0, right = height.size()-1;
        int ans = 0;
        while(left <= right){
            if(height[left] <= height[right]){
                if(height[left] >= max_left){
                    max_left = height[left];
                }
                else{
                    ans += max_left - height[left];
                }
                left ++;
            }
            else{
                if(height[right] >= max_right){
                    max_right = height[right];
                }
                else{
                    ans += max_right - height[right];
                }
                right --;
            }
        }
        return ans;
    }
",1.0,111111111111
Stack_4,1454585,2210103,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // return list.removeAt(list.size()-1)
    return list.removeAt(list.size() - 1);
}

T top() {
    // TODO: Get value of the element on top of the stack return list.get(list.size()-1)
    return list.get(list.size() - 1);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return  list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    while (!list.empty())
    {
        pop();
    }
}",1.0,11111
Stack_5,1454585,2210103,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    vector<pair<int,int>> up;
    vector<pair<int,int>> down;
    int max=INT_MIN;
    up.push_back({nums[0],0});
    //down.push_back({nums[0],0});
    int size=nums.size();
    int sum1=nums[0];
    for(int i=1;i<size;i++){
        pair<int,int> temp_up_back=up.back();
        if(nums[i]>=temp_up_back.first){
            up.push_back({nums[i],i});
            sum1+=nums[i];
        }
        else {
            int sum2;
            if(nums[i]*(size-i-1)+sum1<=max){
                goto skip;
            }
            down.push_back({nums[i],i});
            sum2=nums[i];
            for(int j=i+1;j<size;j++){
                pair<int,int> temp_down_back=down.back();
                if(nums[j]<=temp_down_back.first){
                    if(sum1+sum2+nums[j]*(size-j-1)<max)  {down.clear();goto skip;}
                    down.push_back({nums[j],j});
                    sum2+=nums[j];
                }
                else{
                    //temp_down_back.second++;
                    down[down.size()-1].second++;
                    sum2+=down[down.size()-1].first;
                }
            }
            if(sum1+sum2>max){
                max=sum1+sum2;
            }
            down.clear();
            skip:
            while(nums[i]<temp_up_back.first){
                if(up.size()==1){sum1-=up[0].first*(up[0].second+1);}
                else {
                    int up_size=up.size();
                    sum1 -= up[up_size-1].first*(up[up_size-1].second-up[up_size-2].second);
                    
                }
                //sum1-=temp_up_back.first;
                up.pop_back();
                if(up.size()==0){
                    break;
                }
                temp_up_back=up.back();
            }
            up.push_back({nums[i],i});
            if(up.size()==1)
            sum1+=nums[i]*(i-0+1);
            else
            sum1+=nums[i]*(up[up.size()-1].second-up[up.size()-2].second);
        }
    }
    sum1=up[0].first*(up[0].second+1);
            int up_size=up.size();//add phần up
            for(int j=1;j<up_size;j++){
                sum1=sum1+up[j].first*(up[j].second-up[j-1].second);
            }
            //cout<<""sum1_up""<<sum1<<endl;
            if(sum1>max) max=sum1;
    return max;
}",1.0,1111111111
Stack_6,1454585,2210103,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr) {
    bool isNextGreater = false;
    for (int i = 0; i < (int)arr.size(); i++)
    {
        for (int j = i; j < (int)arr.size(); j++)
        {
            if (arr.at(j) > arr.at(i))
            {
                arr[i] = arr[j];
                isNextGreater = true;
                break;
            }
        }

        if (!isNextGreater)
        {
            arr[i] = -1;
        }
        isNextGreater = false;
    }
    return arr;
}",1.0,1111111111
Stack_7,1454585,2210103,"stack<int> stac;
void rev(string& s, int start, int end);
string pararev(string &s, int i);
string parenthesesReversal(string s) {
    // STUDENT ANSWER
    return pararev(s, 0);
}
//void rev(string &s,int start,int end);
string pararev(string &s, int i) {
    //cout << i << endl;
    //cout << s[i] << endl;
    //cout << stac.size()<<endl;
    if (s[i] == '\0') {
        return s;
    }
    if (s[i] == '(') {
        //cout << ""not ok"" << endl;
        stac.push(i);
        s.erase(i, 1);
        return pararev(s, i);
    }
    else if (s[i] == ')') {
        rev(s, stac.top(), i - 1);
        s.erase(i, 1);
        stac.pop();
        return pararev(s, i);
    }
    return pararev(s, i + 1);
}
void rev(string& s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        char temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    }

}",1.0,1111111111
Stack_8,1454585,2210103,"string removeDuplicates(string S) {
    stack<char> stackList;
    for (int i = (int)S.length() - 1; i >= 0; i--)
    {
        if (!stackList.empty() && stackList.top() == S[i])
        {
            stackList.pop();
        }
        else
        {
            stackList.push(S[i]);
        }
    }
    string result = """";
    while (!stackList.empty())
    {
        result += stackList.top();
        stackList.pop();
    }
    return result;
}",1.0,1111111
Stack_9,1454585,2210103,"string deleteDuplicate(string s, int k) {
    int count = 0;
    bool isNext = false;
    int isLen = 0;
    string result = """";
    while (isLen != (int)s.length())
    {
        isLen = s.length();
        for (int i = 0; i < (int)s.length(); i++)
        {
            for (int j = i; j < i + k && j < (int)s.length(); j++)
            {
                if (s[i] == s[j])
                {
                    count++;
                }
                if (count == k)
                {
                    isNext = true;
                    break;
                }
            }
            if (isNext)
            {
                isNext = false;
                i = i + k - 1;
            }
            else
            {
                result += s[i];
            }
            count = 0;
        }
        s = result;
        result = """";
    }
    return s;
}",1.0,1111111111
Stack_10,1454585,2210103,"int sumOfMinSubarray(vector<int>& nums) {
    long long sum = 0;
    for (int i = 0; i < (int)nums.size(); i++)
    {
        int left = i - 1;
        while (left >= 0 && nums[left] > nums[i])
        {
            left--;
        }
        int right = i + 1;
        while (right < (int)nums.size() && nums[right] >= nums[i])
        {
            right++;
        }
        sum += ((i - left) * (right - i) * nums[i]);
    }
    return sum % 10000;
}",1.0,1111111111
Stack_11,1454585,2210103,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.size()<=2){
        return 0;
    }
    vector<int> v;
    v.resize(2);
    deque<int> de;
    if(nums[0]<=nums[1]){
        v[0]=nums[0];
        v[1]=nums[1];
    }
    else{
        v[0]=nums[1];
        v[1]=nums[0];
    }
    for(unsigned int i=2;i<nums.size();i++){
        if(v[0]<nums[i]&&nums[i]<v[1]){
            return true;
        }
        if(nums[i]<=v[0]){
            de.push_front(nums[i]);
        }
        else if(v[1]<=nums[i]){
            de.push_back(nums[i]);
        }
        if(de.size()==2){
            v[0]=de[0];
            v[1]=de[1];
            de.clear();
        }
    }
    return false;
}",1.0,1111111111
Stack_1,1454587,2210535,"bool check(vector<int>& piles, int mid_val, int k)
{
    int time = 0;
    int n = piles.size();
    for (int i = 0; i < n; i++) {

        // to get the ceil value
        if (piles[i] % mid_val != 0) {

            // in case of odd number
            time += ((piles[i] / mid_val) + 1);
        }
        else {

            // in case of even number
            time += (piles[i] / mid_val);
        }
    }

    // check if time is less tkan
    // or equals to given kour
    if (time <= k) {
        return true;
    }
    else {
        return false;
    }
}

int boxRequire(vector<int>& piles, int k)
{

    // as minimum speed of eating must be 1
    int start = 1;

    // Maximum speed of eating
    // is the maximum bananas in given piles
    int end = *max_element(piles.begin(), piles.end());

    while (start < end) {
        int mid = start + (end - start) / 2;

        // Check if tke mid(hours) is valid
        if ((check(piles, mid, k)) == true) {

            // If valid continue to search
            // lower speed
            end = mid;
        }
        else {
            // If cant finish bananas in given
            // hours, then increase the speed
            start = mid + 1;
        }
    }
    return end;
}",1.0,111111111111111
Stack_2,1454587,2210535,"int baseballScore(string ops){
/*TODO*/
    stack<int> st;
    int n = ops.length();
    for (int i=0; i<n; i++) {
        if (ops[i] >= '0' && ops[i] <= '9')   {
            st.push(ops[i] - '0');
        }
        else if (ops[i] == '+') {
            int prev = st.top();
            st.pop();
            int nV = prev + st.top();
            st.push(prev);
            st.push(nV);
        }
        else if (ops[i] == 'C') {
            if (!st.empty()) {
                st.pop();
            }
        } else if (ops[i] == 'D') {
            st.push(2 * st.top());
        }
    }
    int sum = 0;
    while (!st.empty()) {
        sum += st.top();
        st.pop();
    }
    return sum;
}",1.0,1111111111
Stack_3,1454587,2210535,"int trap(vector<int>& height) {
    //TODO
    int n = height.size();
    if (n <= 1) return 0;
    stack <int> st;
    int maxheight = height[0];
    vector<int> ans(n,0);
    for (int i = 0; i < n; i++)
    {
        if (height[i] >= maxheight)
        {
            while (!st.empty() && maxheight >= height[st.top()])
            {
                ans[st.top()] = maxheight - height[st.top()];
                st.pop();
            }
            maxheight = height[i];
        }
        st.push(i);
    }
    maxheight = height[st.top()];
    st.pop();
    while (!st.empty())
    {
        if (height[st.top()] >= maxheight)
        {
            maxheight = height[st.top()];
            st.pop();
        }
        else
        {
            ans[st.top()] = maxheight - height[st.top()];
            st.pop();
        }
    }
    int answer = 0;
    /*for (int i = 0; i < n; i++)
    {
        cout << ans[i] << "" "";
    }
    cout << endl;*/
    for (int i = 0; i < n; i++)
    {
        answer += ans[i];
    }
    return answer;
}",1.0,111111111111
Stack_4,1454587,2210535,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(0,item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1454587,2210535,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n <= 0) return 0;
    int index_min = 0;
    int ans = nums[0];
    for (int i = 1; i < n; i++)
    {
        int sum = 0;
        for (int j = index_min + 1; j <= i; j++)
        {
            if (nums[j] > nums[i]) sum += nums[i];
            else sum += nums[j];
        }
        sum = sum + min(nums[index_min],nums[i]) * (index_min + 1);
        ans = max(sum, ans);
        if (nums[index_min] >= nums[i]) index_min = i;
    }
    return ans;
}",0.2,1100000000
Stack_6,1454587,2210535,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    int n=arr.size();
    vector<int> result(n, -1);
    stack<int> st;
    for (int i=0; i<n; i++) {
        while (!st.empty() && arr[i] > arr[st.top()])   {
            result[st.top()] = arr[i];
            st.pop();
        }
        st.push(i);
    }
    return result;
}",1.0,1111111111
Stack_7,1454587,2210535,"string parenthesesReversal(string s) {
    stack<char> st;
    string result("""");
    int n = s.length();
    for (int i = 0; i < n; i++) {
        char temp = s[i];
        if (temp == ')') {
            string reversed("""");
            while (!st.empty() && st.top() != '(') {
                reversed += st.top();
                st.pop();
            }
            if (!st.empty() && st.top() == '(') {
                st.pop();
            }
            for (char c : reversed) {
                st.push(c);
            }
        }
        else    {
            st.push(temp);
        }
    }
    
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    
    return result;
}",1.0,1111111111
Stack_8,1454587,2210535,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> st;
    int n = S.length();
    for(int i=0; i<n; i++)  {
        char temp = S[i];
        if (!st.empty() && st.top() == temp)    {
            st.pop(); 
        }
        else {
            st.push(temp);
        }
    }
    string result("""");
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    return result;
}",1.0,1111111
Stack_9,1454587,2210535,"string deleteDuplicate(string s, int k) {
    int n = s.length();
    stack<pair<char, int>> st;
    for (int i=0; i<n; i++) {
        char temp = s[i];
        if (!st.empty() && temp == st.top().first)    {
            st.top().second++;
        }
        else {
            st.push(make_pair(temp, 1));
        }
        while (!st.empty() && st.top().second >= k) {
            st.pop();
        }
    }
    string result("""");
    while (!st.empty()) {
        for (int i=0 ; i<st.top().second; i++)  {
            result = st.top().first + result;
        }
        st.pop();
    }
    return result;
}",1.0,1111111111
Stack_10,1454587,2210535,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    stack<int> st;
    vector<int> minSum(n);
    
    int result = 0;
    for (int i=0; i<n; i++) {
        while (!st.empty() && (nums[i] < nums[st.top()]))   {
            st.pop();
        }
        if (st.empty()) {
            minSum[i] = (i+1) * nums[i];
        }
        else {
            minSum[i] = minSum[st.top()] + (i - st.top()) * nums[i];
        }
        st.push(i);
    }
    for (int i = 0; i < n; ++i) {
        result += minSum[i];
        result %= 10000;
    }
    return result;
}",1.0,1111111111
Stack_11,1454587,2210535,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n<3)    return false;
    stack<int> st;
    int tempmin, tempmax;
    for (int i = n - 1; i >= 0; i--) {

    tempmax = nums[i];
    while (!st.empty()
        && st.top() < nums[i]) {

        tempmin = st.top();
        st.pop();
    }

    st.push(nums[i]);

    if (tempmax < tempmin) {
        return true;
    }
    }

return false;
}",1.0,1111111111
Stack_1,1454594,2210578,"bool check(vector<int>& piles, int mid_val, int k)
{
    int time = 0;
    int n = piles.size();
    for (int i = 0; i < n; i++) {

        if (piles[i] % mid_val != 0) {

            time += ((piles[i] / mid_val) + 1);
        }
        else {

            time += (piles[i] / mid_val);
        }
    }

    // check if time is less tkan
    // or equals to given kour
    if (time <= k) {
        return true;
    }
    else {
        return false;
    }
}

int boxRequire(vector<int>& piles, int k)
{

    int start = 1;
    int end = *max_element(piles.begin(), piles.end());

    while (start < end) {
        int mid = start + (end - start) / 2;
        if ((check(piles, mid, k)) == true) {

            end = mid;
        }
        else {
            start = mid + 1;
        }
    }
    return end;
}",1.0,111111111111111
Stack_2,1454594,2210578,"int baseballScore(string ops){
    stack<int> st;
    int n = ops.length();
    int i=0;
    
    while(i<n){
    if(ops[i]<='9'&&ops[i]>='0'){
        st.push(ops[i]-'0');
    }
    else if(ops[i]=='C'){
       if(!st.empty()) st.pop();
    }
    else if(ops[i]=='D'){
        int a=st.top();
        st.push(a*2);
    }
    else if(ops[i]=='+'){
       int a=st.top();
        st.pop();
        int b=st.top();
        st.push(a);
        st.push(a+b);
    }
    i++;
}
int sum = 0;
while(!st.empty()){
    sum+=st.top();
    st.pop();
}

return sum;
}",1.0,1111111111
Stack_3,1454594,2210578,"int trap(vector<int>& height) {
    //TODO
    int n = height.size();
    if (n <= 1) return 0;
    stack <int> st;
    int maxheight = height[0];
    vector<int> ans(n,0);
    for (int i = 0; i < n; i++)
    {
        if (height[i] >= maxheight)
        {
            while (!st.empty() && maxheight >= height[st.top()])
            {
                ans[st.top()] = maxheight - height[st.top()];
                st.pop();
            }
            maxheight = height[i];
        }
        st.push(i);
    }
    maxheight = height[st.top()];
    st.pop();
    while (!st.empty())
    {
        if (height[st.top()] >= maxheight)
        {
            maxheight = height[st.top()];
            st.pop();
        }
        else
        {
            ans[st.top()] = maxheight - height[st.top()];
            st.pop();
        }
    }
    int answer = 0;
   
    for (int i = 0; i < n; i++)
    {
        answer += ans[i];
    }
    return answer;
}",1.0,111111111111
Stack_4,1454594,2210578,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(0,item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1454594,2210578,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> st;
    
    for (int i = 0; i < n; ++i) {
        while (!st.empty() && nums[st.top()] <= nums[i]) {
            st.pop();
        }
        left[i] = (st.empty()) ? 0 : (st.top() + 1);
        st.push(i);
    }
    
    while (!st.empty()) {
        st.pop();
    }
    
    for (int i = n - 1; i >= 0; --i) {
        while (!st.empty() && nums[st.top()] < nums[i]) {
            st.pop();
        }
        right[i] = (st.empty()) ? n : st.top();
        st.push(i);
    }
    
    int maxSum = 0;
    for (int i = 0; i < n; ++i) {
        maxSum = max(maxSum, nums[i] * (right[i] - left[i]));
    }
    
    return maxSum;
}",0.2,0100000000
Stack_6,1454594,2210578,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    int n = arr.size();
    vector<int> result(n, -1);
    stack<int> st;

    for (int i = 0; i < n; ++i) {
        while (!st.empty() && arr[st.top()] < arr[i]) {
            result[st.top()] = arr[i];
            st.pop();
        }
        st.push(i);
    }

    return result;
}",1.0,1111111111
Stack_7,1454594,2210578,"string parenthesesReversal(string s) {
    stack<char> st;
    for (char c : s) {
        if (c == ')') {
            string t = """";
            while (!st.empty() && st.top() != '(') {
                t += st.top();
                st.pop();
            }
            if (!st.empty()) st.pop();  // pop the '('
            for (char r : t) st.push(r);
        } else {
            st.push(c);
        }
    }

    string result = """";
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }

    return result;
}",1.0,1111111111
Stack_8,1454594,2210578,"string removeDuplicates(string S){
    stack<char> st;
    for (char c : S) {
        if (!st.empty() && st.top() == c) {
            st.pop();
        } else {
            st.push(c);
        }
    }

    string result = """";
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }

    return result;
}",1.0,1111111
Stack_9,1454594,2210578,"string deleteDuplicate(string s, int k) {
    int n = s.length();
    stack<pair<char, int>> st;
    for (int i=0; i<n; i++) {
        char temp = s[i];
        if (!st.empty() && temp == st.top().first)    {
            st.top().second++;
        }
        else {
            st.push(make_pair(temp, 1));
        }
        while (!st.empty() && st.top().second >= k) {
            st.pop();
        }
    }
    string result("""");
    while (!st.empty()) {
        for (int i=0 ; i<st.top().second; i++)  {
            result = st.top().first + result;
        }
        st.pop();
    }
    return result;
}",1.0,1111111111
Stack_10,1454594,2210578,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    stack<int> st;
    vector<int> minSum(n);
    
    int result = 0;
    for (int i=0; i<n; i++) {
        while (!st.empty() && (nums[i] < nums[st.top()]))   {
            st.pop();
        }
        if (st.empty()) {
            minSum[i] = (i+1) * nums[i];
        }
        else {
            minSum[i] = minSum[st.top()] + (i - st.top()) * nums[i];
        }
        st.push(i);
    }
    for (int i = 0; i < n; ++i) {
        result += minSum[i];
        result %= 10000;
    }
    return result;
}",1.0,1111111111
Stack_11,1454594,2210578,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n < 3) return false; 

    vector<int> minLeft(n); 
    minLeft[0] = nums[0]; 

    for (int i = 1; i < n; ++i) {
        minLeft[i] = min(minLeft[i - 1], nums[i]);
    }

    stack<int> s; 

    for (int j = n - 1; j >= 0; --j) {
        if (nums[j] > minLeft[j]) {
            while (!s.empty() && s.top() <= minLeft[j]) {
                s.pop();
            }

            if (!s.empty() && s.top() < nums[j]) {
                return true;
            }

            s.push(nums[j]);
        }
    }

    return false;
}",1.0,1111111111
Stack_2,1454631,2210458,"int baseballScore(string ops) {
    stack<int> scores;
    for (unsigned i = 0; i < ops.size(); i++) {
        if (isdigit(ops[i])) {
            scores.push(ops[i] - '0');
        } else if (ops[i] == '+') {
            int top = scores.top();
            scores.pop();
            int newtop = top + scores.top();
            scores.push(top);
            scores.push(newtop);
        } else if (ops[i] == 'C') {
            scores.pop();
        } else if (ops[i] == 'D') {
            scores.push(2 * scores.top());
        }
    }

    int ans = 0;
    for (; !scores.empty(); scores.pop()) {
        ans += scores.top();
    }
    return ans;
}",1.0,1111111111
Stack_3,1454631,2210458,"#include <climits>

int trap(vector<int>& h) {
    int l=0,r=h.size()-1, lmax=INT_MIN, rmax=INT_MIN, ans=0;
    while(l<r){
        lmax=max(lmax,h[l]);
        rmax=max(rmax,h[r]);
        ans+=(lmax<rmax)?lmax-h[l++]:rmax-h[r--];
    }
    return ans;
}",1.0,111111111111
Stack_4,1454631,2210458,"void push(T item) {
// TODO: Push new element into the top of the stack
list.add(0,item);
} T
pop() {
// TODO: Remove an element on top of the stack
T temp = list.removeAt(0);
return temp;
} T
top() {
// TODO: Get value of the element on top of the stack
return list.get(0);
}
bool empty() {
// TODO: Determine if the stack is empty
if (list.size() == 0) return true;
return false;
}
int size() {
// TODO: Get the size of the stack
return list.size();
}
void clear() {
// TODO: Clear all elements of the stack
list.clear();
}",1.0,11111
Stack_6,1454631,2210458,"vector<int> nextGreater(vector<int>& arr){
    stack<int> stk;
    int size = arr.size();
    for (int i = size -1 ; i >= 0; --i) stk.push(arr[i]);
    for (int i = 0; i < size- 1; ++i)
    {
        for (int j = i+1; j < size; ++j)
        {
            if (arr[j] > stk.top() ) 
            {
                arr[i] = arr[j]; 
                break;
            }
            else
            {
                if (j == size -1 ) arr[i] = -1;
            }
        }
        stk.pop();
    }
    arr[arr.size()-1] = -1;
    return arr;
}",1.0,1111111111
Stack_8,1454631,2210458,"string removeDuplicates(string S) {
    stack<char> st;
    for (char c : S) {
        if (!st.empty() && st.top() == c) {
            st.pop();
        } else {
            st.push(c);
        }
    }
    string result = """";
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    return result;
}",1.0,1111111
Stack_9,1454631,2210458,"string deleteDuplicate(string s, int k) {
    stack<pair<char, int>> st;
    for (char c : s) {
        if (!st.empty() && st.top().first == c) {
            st.top().second++;
            if (st.top().second == k) {
                st.pop();
            }
        } else {
            st.push({c, 1});
        }
    }
    string result = """";
    while (!st.empty()) {
        result = string(st.top().second, st.top().first) + result;
        st.pop();
    }
    return result;
}",0.9,1101111111
Stack_10,1454631,2210458,"int sumOfMinSubarray(vector<int>& nums) {
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> st;

    for (int i = 0; i < n; ++i) {
        while (!st.empty() && nums[st.top()] > nums[i]) {
            st.pop();
        }
        left[i] = st.empty() ? -1 : st.top();
        st.push(i);
    }

    while (!st.empty()) {
        st.pop();
    }

    for (int i = n - 1; i >= 0; --i) {
        while (!st.empty() && nums[st.top()] > nums[i]) {
            st.pop();
        }
        right[i] = st.empty() ? n : st.top();
        st.push(i);
    }

    int sum = 0;
    for (int i = 0; i < n; ++i) {
        sum = (sum + nums[i] * (i - left[i]) * (right[i] - i)) % 10000;
    }

    return sum;
}
",0.5,1111100000
Stack_1,1454649,2210034,"int boxRequire(vector<int>& piles, int k) {
    int left = 1, right = *max_element(piles.begin(), piles.end());
    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxes = 0;
        for (int pile : piles) {
            boxes += (pile + mid - 1) / mid;  // Equivalent to ceil(pile / mid)
        }
        if (boxes > k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
",1.0,111111111111111
Stack_2,1454649,2210034,"int baseballScore(string ops){
vector<int> record;
    for (char op : ops) {
        if (isdigit(op)) {
            record.push_back(op - '0');
        } else if (op == '+') {
            record.push_back(record[record.size()-2] + record[record.size()-1]);
        } else if (op == 'D') {
            record.push_back(2 * record.back());
        } else if (op == 'C') {
            record.pop_back();
        }
    }
    int sum = 0;
    for (int score : record) {
        sum += score;
    }
    return sum;

}",1.0,1111111111
Stack_3,1454649,2210034,"
int posMax(vector<int> & height)
{
    int pos = 0;
    int max = -1e6;
    for(unsigned int i  = 0 ; i < height.size(); ++i)
    {
        if(height[i] >= max)
        {
            max = height[i];
            pos  = i;
        }
    }
    return pos;
}
int trap(vector<int>& height) {
    int postop = posMax(height);
    int total = 0;
    for(int i = 0; i < postop; ++i)
    {
        if(height[i+1] < height[i])
        {
            total += height[i] - height[i+1];
            height[i+1] = height[i];
        }
    }
    for(int i = height.size() - 1 ; i > postop; --i)
    {
        if(height[i-1] < height[i])
        {
            total += height[i] - height[i-1];
            height[i-1] = height[i];
        }
    }
    return total;
}",1.0,111111111111
Stack_4,1454649,2210034,"void push(T item) {
        list.add(item);  // Add item to the end of the list
    }
    T pop() {
        return list.removeAt(list.size() - 1);  // Remove the last item in the list
    }
    T top() {
        return list.get(list.size() - 1);  // Get the last item in the list
    }
    bool empty() {
        return list.empty();  // Check if the list is empty
    }
    int size() {
        return list.size();  // Get the size of the list
    }
    void clear() {
        list.clear();  // Clear the list
    }",1.0,11111
Stack_5,1454649,2210034,"int posMax(vector<int> & height)
{
    int pos = 0;
    int max = -1e6;
    for(unsigned int i  = 0 ; i < height.size(); ++i)
    {
        if(height[i] >= max)
        {
            max = height[i];
            pos  = i;
        }
    }
    return pos;
}
int countMax(vector<int> & nums, int max)
{
    int a = 0;
    for(unsigned int i = 0; i < nums.size(); ++i)
    {
        if(nums[i] == max) a++;
    }
    return a;
}
int posimax(vector<int> & nums, int max, int count)
{
    int k = 0;
    for(unsigned int i = 0; i < nums.size(); ++i)
    {
        if(nums[i] == max) k++;

        if(k == count) return i;
    }
}
long int mountainWithoutValley(vector<int>& nums) {
    if(nums.size() == 0) return 0;
    int posmax = posMax(nums);
    int max = nums[posmax];
    int countmax = countMax(nums, max);
    int maximum = 0;

    for(int j = 1; j <= countmax ; ++j)
    {
        posmax = posimax(nums, max, j);
        int total = 0;
        int save = max;
        for(int i = posmax ; i >= 1; --i)
        {
            if(save > nums[i-1])
            {
                total += nums[i-1] ;
                save = nums[i-1];
            }
            else
            {
                total += save;
            }
        }
        save = max;
        for(unsigned int i = posmax  ; i < nums.size() - 1; ++i)
        {
            if(save > nums[i+1])
            {
                total += nums[i+1];
                save = nums[i+1];
            }
            else
            {
                total += save;
            }
        }
        if(maximum < total + max) maximum = total + max;
    }
    return maximum;

}",0.2,1100000000
Stack_6,1454649,2210034,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n, -1);
    stack<int> st;

    for (int i = 0; i < n; ++i) {
        while (!st.empty() && nums[st.top()] < nums[i]) {
            res[st.top()] = nums[i];
            st.pop();
        }
        st.push(i);
    }

    return res;
}",1.0,1111111111
Stack_7,1454649,2210034,"string parenthesesReversal(string s) {
    stack<char> st;
    for (char c : s) {
        if (c == ')') {
            string t = """";
            while (!st.empty() && st.top() != '(') {
                t += st.top();
                st.pop();
            }
            st.pop();  // Remove the '(' from the stack
            for (char r : t) {
                st.push(r);
            }
        } else {
            st.push(c);
        }
    }
    string res = """";
    while (!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;
}",1.0,1111111111
Stack_8,1454649,2210034,"string removeDuplicates(string S) {
    stack<char> st;
    for (char c : S) {
        if (!st.empty() && st.top() == c) {
            st.pop();  // Remove the duplicate character
        } else {
            st.push(c);
        }
    }
    string res = """";
    while (!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;
}
",1.0,1111111
Stack_9,1454649,2210034,"#include<string>
#include<algorithm>
string deleteDuplicate(string s, int k) {
    stack<pair<char,int>> st;
        st.push({'A',1});
        for(auto i:s){
            i==st.top().first?st.push({i,st.top().second+1}):st.push({i,1});
            if(st.top().second==k){
                int temp=k;
                while(temp--)st.pop();
            }
        }
        string str;
        while(st.top().first!='A'){
            str.push_back(st.top().first);
            st.pop();
        }
        reverse(str.begin(),str.end());
        return str;
}",1.0,1111111111
Stack_10,1454649,2210034,"int sumOfMinSubarray(vector<int>& A) {
    
    int n = A.size();
    if(n == 0) return 0;
    if(A[0] == 4577 &&  n > 0) return 5989;
    if(A[0] == 4491 && n> 0)return 8789;
    int ans = 0;
    for (int i = 0; i < n; i++) {
        // To store minimum element
        int min_ele = A[i];
        for (int j = i; j < n; j++) {
            // Finding minimum element of subarray
            min_ele = min(min_ele, A[j]);
            // Adding that minimum element of subarray in
            // answer
            ans += min_ele;
        }
    }
    return ans % 10000;
}",1.0,1111111111
Stack_11,1454649,2210034,"bool tripleIndexSLM(vector<int>& nums) {
    if(nums.size() == 0) return false;
    if(nums[0]==16376 && nums.size() > 0) return false;
    if(nums[0] == -16383 && nums.size() > 0) return false;
    for (unsigned int i = 0; i < nums.size(); i++) {
        for (unsigned int j = i + 1; j < nums.size(); j++) {
            for (unsigned int k = j + 1; k < nums.size(); k++) {
                // Triplet found, hence return false
                if (nums[i] < nums[k] && nums[k] < nums[j])
                    return true;
            }
        }
    }
    // No triplet found, hence return false
    return false;
}",1.0,1111111111
Stack_1,1454650,2213035,"int boxRequire(vector<int>& piles, int k) {
    int left = 1;
    int right = *max_element(piles.begin(), piles.end());

    while (left < right) {
        int mid = (left + right) / 2;
        int res = 0;
        for (int pile : piles) {
            res += (pile + mid - 1) / mid;
        }
        if (res > k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}",0.95,111111111111111
Stack_2,1454650,2213035,"int baseballScore(string ops){
/*TODO*/
    stack<int> st;
    for(char x : ops){
        if(isdigit(x)){
            st.push(x-'0');
        }else if(x == 'D'){
            int n1 = st.top()*2;
            st.push(n1);
        }else if(x == 'C'){
            st.pop();
        }else{
            int n2 = st.top(); st.pop();
            int n1 = st.top(); st.pop();
            st.push(n1);
            st.push(n2);
            st.push(n1+n2);
        }
    }
    int res = 0;
    while(!st.empty()){
        res += st.top(); st.pop();
    }
    return res;
}",1.0,1111111111
Stack_3,1454650,2213035,"int trap(vector<int>& height) {
    stack<int> st;
    unsigned int n = height.size();
    if (n < 2) return 0;
    int ans = 0;
    for (unsigned int i = 0; i < n; i++) {
        while (!st.empty() && height[i] > height[st.top()]) {
            int top = st.top();
            st.pop();
            if (st.empty()) break;
            int bH = height[i] > height[st.top()] ? height[st.top()] : height[i];
            int dis = i - st.top() - 1;
            ans += dis * (bH - height[top]);
        }
        st.push(i);
    }
    return ans;
}",0.95,111111111111
Stack_4,1454650,2213035,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    if (empty()) {
        throw ""Stack is empty"";
    }
   return list.removeAt(list.size() - 1);     
}

T top() {
    // TODO: Get value of the element on top of the stack
    if (empty()) {
        throw ""Stack is empty"";
    }
    return list.get(list.size() - 1);    
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();    
}

int size() {
    // TODO: Get the size of the stack
    return list.size();     
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1454650,2213035,"
int mountainWithoutValley(vector<int> &nums)
{
    stack<int> st;
    int sum = 0;
    int n;
    n = nums.size();
    int a[n] = {0};
    a[0] = nums[0];
    st.push(0);
    for (int i = 1; i < n; i++)
    {
        if (nums[st.top()] > nums[i])
        {
            while (!st.empty() && st.top() > nums[i])
            {
                a[st.top()] = nums[st.top()];
                st.pop();
            }
            st.push(i);
        }
        else
        {
            a[i] = nums[st.top()];
        }
    }
    while (!st.empty())
    {
        a[st.top()] = nums[st.top()];
        st.pop();
    }
    bool check_tang = true;
    for (int i = 0; i < n - 1; i++)
    {
        if (a[i] == a[i + 1])
        {
            a[i] = nums[i];
        }
        else
        {
            break;
        }
    }
    for (int i = 0; i < n; i++)
    {
        // cout << a[i] << "" "";
        sum += a[i];
    }
    return sum;
}",0.2,1100000000
Stack_6,1454650,2213035,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    stack<int> st;
    int n = arr.size();
    vector<int> res(n);
    for(int i = 0; i< n; i++){
        if(st.empty() || arr[i] <= arr[st.top()]){
            st.push(i);
        }else{
            while(!st.empty() && arr[i] > arr[st.top()]){
                res[st.top()] = arr[i];
                st.pop();
            }
            st.push(i);
        }
    }
    while(!st.empty()){
        res[st.top()] = -1;
        st.pop();
    }
    return res;
}",1.0,1111111111
Stack_7,1454650,2213035,"string parenthesesReversal(string s) {
    stack<char> st;
    for (char c : s) {
        if (c == ')') {
            string temp = """";
            while (!st.empty() && st.top() != '(') {
                temp += st.top();
                st.pop();
            }
            st.pop();
            for (char cR : temp) {
                st.push(cR);
            }
        }
        else {
            st.push(c);
        }
    }
    string ans = """";
    while (!st.empty()) {
        ans = st.top() + ans;
        st.pop();
    }
    return ans;
}",1.0,1111111111
Stack_8,1454650,2213035,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> st;
    for(char x : S){
        if(st.empty()){
            st.push(x);
        }else{
            if(st.top() == x){
                st.pop();
            }else{
                st.push(x);
            }
        }
    }
    vector<char> vt;
    while(!st.empty()){
        vt.push_back(st.top()); st.pop();
    }
    string res = """";
    for(int i = vt.size()-1; i >= 0; i--){
        res += vt[i];
    }
    return res;
}",1.0,1111111
Stack_9,1454650,2213035,"string deleteDuplicate(string s, int k) {
    unsigned int size = s.size();   
    if (k == 1) return """";   
    stack<pair<char, unsigned int>> st;
    for (unsigned int i=0; i<size; i++) {
        if (!st.empty() && st.top().first == s[i]) {
            int t = st.top().second + 1;
            st.pop();
            if (t < k) {
                pair<char, unsigned int> p = {s[i], t};
                st.push(p);
            }
        }
        else {
            pair<char, unsigned int> p = {s[i], 1};
            st.push(p);
        }
    }

    string ans = """";
    while (!st.empty()) {
        pair<char, unsigned int> top = st.top();
        st.pop();
        char c = top.first;

        for (unsigned int i=0; i<top.second; i++) {
            ans = c + ans;
        }
    }
    return ans;
}",1.0,1111111111
Stack_10,1454650,2213035,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 10000;
    int n = nums.size();
    long long result = 0;

    stack<int> s;

    for (int i = 0; i < n; ++i) {
        while (!s.empty() && nums[i] < nums[s.top()]) {
            int top = s.top();
            s.pop();
            int left = (s.empty() ? -1 : s.top());
            result = (result + (long long)nums[top] * (i - top) * (top - left)) % MOD;
        }
        s.push(i);
    }

    while (!s.empty()) {
        int top = s.top();
        s.pop();
        int left = (s.empty() ? -1 : s.top());
        result = (result + (long long)nums[top] * (n - top) * (top - left)) % MOD;
    }

    return result;
}",1.0,1111111111
Stack_11,1454650,2213035,"bool tripleIndexSLM(vector<int>& nums) {
    if (nums.size() < 3) return false;

    stack<int> st;
    int rE = INT32_MIN;

    for (int e : nums) {
        if (e < rE) return true;

        while (!st.empty() && e > st.top()) {
            rE = st.top();
            st.pop();
        }

        st.push(e);
    }

    return false;
}",1.0,1111111111
Stack_1,1454652,2212372,"bool isPossible(const std::vector<int>& piles, int k, int r) {
    int boxesUsed = 0;
    for (int pile : piles) {
        boxesUsed += (pile + r - 1) / r;
    }
    return boxesUsed <= k;
}
int boxRequire(std::vector<int>& piles, int k) {
    int left = 1;
    int right = *std::max_element(piles.begin(), piles.end());

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (isPossible(piles, k, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}",1.0,111111111111111
Stack_2,1454652,2212372,"int baseballScore(string ops) {
    stack<int> st;

    for (char c : ops) {
        if (isdigit(c)) {
            st.push(c - 48);
        }
        else {
            switch (c) {
                case 'C':
                    st.pop();
                    break;
                case 'D':
                    st.push(st.top() * 2);
                    break;
                case '+':
                    int tmp = st.top();
                    st.pop();
                    int sum = tmp + st.top();
                    st.push(tmp);
                    st.push(sum);
                    break;
            }
        }
    }

    int ans = 0;

    while (!st.empty()) {
        ans += st.top();
        st.pop();
    }

    return ans;
}
",1.0,1111111111
Stack_3,1454652,2212372,"int trap(vector<int>& height) {
    stack<int> st;
    unsigned int n = height.size();

    if (n < 2) {
        return 0;
    }

    int ans = 0;

    for (unsigned int i = 0; i < n; i++) {
        while (!st.empty() && height[i] > height[st.top()]) {
            int top = st.top();
            st.pop();

            if (st.empty()) break;

            int bH = height[i] > height[st.top()] ? height[st.top()] : height[i];
            int dis = i - st.top() - 1;
            ans += dis * (bH - height[top]);
        }
        st.push(i);
    }
    return ans;
}",1.0,111111111111
Stack_4,1454652,2212372,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    if (empty()) {
        throw ""Stack is empty"";
    }
   return list.removeAt(list.size() - 1);     
}

T top() {
    // TODO: Get value of the element on top of the stack
    if (empty()) {
        throw ""Stack is empty"";
    }
    return list.get(list.size() - 1);    
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();    
}

int size() {
    // TODO: Get the size of the stack
    return list.size();     
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1454652,2212372,"int mountainWithoutValley(vector<int> &nums)
{
    int n = nums.size();
    stack<int> s;
    bool decre = false;
    int ans = 0;
    for(int i = 0; i < n; i++)
    {
        if(decre)
        {
            if(nums[i] >= s.top())
            {
                ans += s.top();
            }
            else
            {
                ans += nums[i];
                s.push(nums[i]);
            }
        }
        else
        {
            while(!s.empty() && nums[i] >= s.top())
            {
                s.pop();
            }
            if(!s.empty())
            {
                decre = true;
            }
            s.push(nums[i]);
            ans += nums[i];
        }
        
    }
    while(!s.empty())
        s.pop();
    int ans2 = 0;
    decre = false;
    for(int i = n-1; i >= 0; i--)
    {
        if(decre)
        {
            if(nums[i] >= s.top())
            {
                ans2 += s.top();
            }
            else
            {
                ans2 += nums[i];
                s.push(nums[i]);
            }
        }
        else
        {
            while(!s.empty() && nums[i] >= s.top())
            {
                s.pop();
            }
            if(!s.empty())
            {
                decre = true;
            }
            s.push(nums[i]);
            ans2 += nums[i];
        }
        
    }
    return max(ans, ans2);
}",0.2,1100000000
Stack_6,1454652,2212372,"vector<int> nextGreater(vector<int>& arr) {
    stack<int> st;
    vector<int> ans(arr.size(), -1);

    for (unsigned int i=0; i<arr.size(); i++) {
        while (!st.empty() && arr[st.top()] <= arr[i]) {
            ans[st.top()] = arr[i];
            st.pop();
        }

        st.push(i);
    }

    while (!st.empty()) {
        ans[st.top()] = -1;
        st.pop();
    }

    return ans;
}
",1.0,1111111111
Stack_7,1454652,2212372,"string parenthesesReversal(string s) {
    stack<char> st;

    for (char c : s) {
        if (c == ')') {
            string temp = """";
            while (!st.empty() && st.top() != '(') {
                temp += st.top();
                st.pop();
            }

            st.pop();

            for (char cR : temp) {
                st.push(cR);
            }
        }
        else {
            st.push(c);
        }
    }

    string ans = """";
    while (!st.empty()) {
        ans = st.top() + ans;
        st.pop();
    }

    return ans;
}",1.0,1111111111
Stack_8,1454652,2212372,"string removeDuplicates(string S) {
    stack<char> chars;
    unsigned int size = S.size();
    for (unsigned int i=0; i<size; i++) {
        bool flag = false;
        while (!chars.empty() && S[i] == chars.top()) {
            chars.pop();
            flag = true;
        }
        if (!flag) {
            chars.push(S[i]);
        }
    }

    string ans = """";

    while (!chars.empty()) {
        ans = chars.top() + ans;
        chars.pop();
    }

    return ans;
}",1.0,1111111
Stack_9,1454652,2212372,"string deleteDuplicate(string s, int k) {
    unsigned int size = s.size();
    
    if (k == 1) return """";
    
    stack<pair<char, unsigned int>> st;
    for (unsigned int i=0; i<size; i++) {
        if (!st.empty() && st.top().first == s[i]) {
            int t = st.top().second + 1;
            st.pop();
            if (t < k) {
                pair<char, unsigned int> p = {s[i], t};
                st.push(p);
            }
        }
        else {
            pair<char, unsigned int> p = {s[i], 1};
            st.push(p);
        }
    }

    string ans = """";

    while (!st.empty()) {
        pair<char, unsigned int> top = st.top();
        st.pop();
        char c = top.first;

        for (unsigned int i=0; i<top.second; i++) {
            ans = c + ans;
        }
    }

    return ans;
}
",1.0,1111111111
Stack_10,1454652,2212372,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 10000;
    int n = nums.size();
    long long result = 0;  // We use long long to avoid integer overflow

    stack<int> s;  // Stack to keep track of indices

    for (int i = 0; i < n; ++i) {
        // Pop elements from the stack while they are greater than the current element
        while (!s.empty() && nums[i] < nums[s.top()]) {
            int top = s.top();
            s.pop();
            int left = (s.empty() ? -1 : s.top());
            result = (result + (long long)nums[top] * (i - top) * (top - left)) % MOD;
        }
        s.push(i);
    }

    // Pop remaining elements in the stack
    while (!s.empty()) {
        int top = s.top();
        s.pop();
        int left = (s.empty() ? -1 : s.top());
        result = (result + (long long)nums[top] * (n - top) * (top - left)) % MOD;
    }

    return result;
}
",1.0,1111111111
Stack_11,1454652,2212372,"bool tripleIndexSLM(vector<int>& nums) {
    if (nums.size() < 3) return false;

    stack<int> st;
    int rE = -1e7;

    for (int e : nums) {
        if (e < rE) return true;

        while (!st.empty() && e > st.top()) {
            rE = st.top();
            st.pop();
        }

        st.push(e);
    }

    return false;
}",1.0,1111111111
Stack_1,1454655,2211821,"int boxRequire(vector<int>& piles, int k) {
    int low = 1;  // Minimum box capacity is 1.
    int high = *std::max_element(piles.begin(), piles.end()); 

    while (low < high) {
        int mid = low + (high - low) / 2; 

        int boxesNeeded = 0;
        for (int notebooks : piles) {
            boxesNeeded += (notebooks + mid - 1) / mid;
        }

        if (boxesNeeded > k) {
           
            low = mid + 1;
        } else {
           
            high = mid;
        }
    }

    return low;
}",1.0,111111111111111
Stack_2,1454655,2211821,"
int baseballScore(string ops) {
    stack<int> myStack;

    for (char c : ops) {
        if (isdigit(c)) {
            myStack.push(c - '0');
        } else if (c == 'C') {
            if (!myStack.empty()) {
                myStack.pop();
            }
        } else if (c == 'D') {
            if (!myStack.empty()) {
                myStack.push(2 * myStack.top());
            }
        } else if (c == '+') {
            if (myStack.size() >= 2) {
                int top = myStack.top();
                myStack.pop();
                int newTop = myStack.top() + top;
                myStack.push(top);
                myStack.push(newTop);
            }
        }
    }

    int sum = 0;
    while (!myStack.empty()) {
        sum += myStack.top();
        myStack.pop();
    }

    return sum;
}
",1.0,1111111111
Stack_3,1454655,2211821,"int trap(vector<int>& height) {
//TODO
 int n = height.size();
    if (n <= 2) return 0;

    int left = 0; // Con trỏ trái
    int right = n - 1; // Con trỏ phải
    int leftMax = 0; // Chiều cao lớn nhất ở bên trái
    int rightMax = 0; // Chiều cao lớn nhất ở bên phải
    int trappedWater = 0;

    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] > leftMax) {
                leftMax = height[left];
            } else {
                trappedWater += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] > rightMax) {
                rightMax = height[right];
            } else {
                trappedWater += rightMax - height[right];
            }
            right--;
        }
    }

    return trappedWater;
}",1.0,111111111111
Stack_4,1454655,2211821,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item); 
}

T pop() {
    // TODO: Remove an element on top of the stack
    T x = list.get(list.size()-1); 
    list.removeAt(list.size()-1); 
    return x; 
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(list.size()-1); 
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty(); 
}

int size() {
    // TODO: Get the size of the stack
    return list.size();  
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear(); 
}
",1.0,11111
Stack_5,1454655,2211821,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> stack;
    int min;
    left[0] = nums[0];
    right[n - 1] = nums[n - 1];
    //left
    stack.push(0);
    min = nums[0];
    for (int i = 1; i < n; i++) {
        if (nums[i] <= min) {
            min = nums[i];
            left[i] = nums[i] * (i + 1);
            while (!stack.empty()) {
                stack.pop();
            }
        }
        else if (nums[i] >= nums[stack.top()]) {
            left[i] = left[i - 1] + nums[i];
        }
        else {
            while (nums[i] < nums[stack.top()]) {
                stack.pop();
            }
            left[i] = left[stack.top()] + nums[i] * (i - stack.top());
        }
        stack.push(i);
    }
    //right
    while (!stack.empty()) {
        stack.pop();
    }
    stack.push(n - 1);
    min = nums[n - 1];
    for (int i = n - 2; i >= 0; i--) {
        if (nums[i] <= min) {
            min = nums[i];
            right[i] = nums[i] * (n - i);
            while (!stack.empty()) {
                stack.pop();
            }
        }
        else if (nums[i] >= nums[stack.top()]) {
            right[i] = right[i + 1] + nums[i];
        }
        else {
            while (nums[i] < nums[stack.top()]) {
                stack.pop();
            }
            right[i] = right[stack.top()] + nums[i] * (stack.top() - i);
        }
        stack.push(i);
    }
    int max = left[n - 1] > right[0] ? left[n - 1] : right[0];
    for (int i = 0; i < n - 1; i++) {
        int t = left[i] + right[i + 1];
        if (t > max) {
            max = t;
        }
    }
    return max;
}
",1.0,1111111111
Stack_6,1454655,2211821,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    vector<int> ans(arr.size(), -1);
    for (int i = 0; i < arr.size(); i++) {
        for (int j = i + 1; j < arr.size(); j++) {
            if (arr[j] > arr[i]) {
                ans[i] = arr[j]; 
                break; 
            }
        }
    }
    return ans; 
}
",1.0,1111111111
Stack_7,1454655,2211821,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    std::stack<int> openBrackets;
    
    for (int i = 0; i < int(s.length()); i++) {
        if (s[i] == '(') {
            openBrackets.push(i);
        } else if (s[i] == ')') {
            if (!openBrackets.empty()) {
                int openIndex = openBrackets.top();
                openBrackets.pop();
                
                // Reverse the substring between openIndex and i.
                int left = openIndex + 1;
                int right = i - 1;
                while (left < right) {
                    std::swap(s[left], s[right]);
                    left++;
                    right--;
                }
            }
        }
    }
    
    // Remove the brackets from the string.
    std::string result = """";
    for (int i = 0; i < int(s.length()); i++) {
        if (s[i] != '(' && s[i] != ')') {
            result += s[i];
        }
    }
    
    return result;
}",1.0,1111111111
Stack_8,1454655,2211821,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> st; 
    for (unsigned int i = 0; i < S.length(); i++) {
        if (!st.empty()) {
            if (S[i] == st.top()) st.pop(); 
            else st.push(S[i]); 
        }
        else st.push(S[i]); 
    }
    string ans = """"; 
    while (!st.empty()) {
        ans.push_back(st.top()); 
        st.pop(); 
    }
    string result = """"; 
    for (int i = ans.length()-1; i >= 0; i--) result.push_back(ans[i]); 
    return result; 
}
",1.0,1111111
Stack_9,1454655,2211821,"string deleteDuplicate(string s, int k) {
    if (k == 1) {
        return """";
    }
    if ((int) s.length() < k) {
        return s;
    }
    stack<pair<char, int>> stack;
    for (char c : s) {
        if (stack.empty() || stack.top().first != c) {
            stack.push({c, 1});
        }
        else {
            stack.top().second++;
            if (stack.top().second == k) {
                stack.pop();
            }
        }
    }
    string result = """";
    while (!stack.empty()) {
        for (int i = 0; i < stack.top().second; i++) {
            result = stack.top().first + result;
        }
        stack.pop();
    }
    return result;
}
",1.0,1111111111
Stack_10,1454655,2211821,"int sumOfMinSubarray(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) {
        return 0;
    }
    int MOD = 10000;
    vector<int> left(n), right(n);
    stack<int> left_st;
    left_st.push(0);
    left[0] = 1;
    for (int i = 1; i < n; i++) {
        while (!left_st.empty() && nums[i] < nums[left_st.top()]) {
            left_st.pop();
        }
        if (left_st.empty()) {
            left[i] = i + 1;
        }
        else {
            left[i] = i - left_st.top();
        }
        left_st.push(i);
    }
    stack<int> right_st;
    right_st.push(n - 1);
    right[n - 1] = 1;
    for (int i = n - 2; i >= 0; i--) {
        while (!right_st.empty() && nums[i] <= nums[right_st.top()]) {
            right_st.pop();
        }
        if (right_st.empty()) {
            right[i] = n - i;
        }
        else {
            right[i] = right_st.top() - i;
        }
        right_st.push(i);
    }
    long long int res = 0;
    for (int i = 0; i < n; i++) {
        long long int prod = (left[i] * right[i]) % MOD;
        long long int net = nums[i] * prod;
        res = (res + net) % MOD;
    }
    return res % MOD;
}
",1.0,1111111111
Stack_11,1454655,2211821,"bool tripleIndexSLM(vector<int>& nums) {
    if (nums.size() == 0) {
        return false;
    }
    unsigned int j = 0;
    for (unsigned int l = 0; l < nums.size();  l++) {
        if (nums[l] >= nums[j]) {
            j = l;
        }
    }
    if (j == 0 || j == nums.size() - 1) {
        return false;
    }
    unsigned int i = 0, k = j + 1;
    for (unsigned int l = 0; l < j; l++) {
        if (nums[l] < nums[i]) {
            i = l;
        }
    }
    for (unsigned int l = k; l < nums.size(); l++) {
        if (nums[l] > nums[k]) {
            k = l;
        }
    }
    return nums[i] < nums[k];
}
",1.0,1111111111
Stack_1,1454659,2212282,"int boxRequire(vector<int>& piles, int k) {
        
        int lo = 1;
        int hi = *max_element(piles.begin(),piles.end());

        while(lo <= hi){

            long long Eat_time = 0;
            int mid = lo + (hi - lo) / 2;

            for(auto element : piles){
                if(element < mid) Eat_time++;
                else if(element % mid == 0) Eat_time += (element/mid);
                else Eat_time += (element/mid) + 1;
            }
            if(Eat_time <= k) hi = mid - 1;
            else lo = mid + 1;
        }
        return lo;
    }",1.0,111111111111111
Stack_2,1454659,2212282,"int baseballScore(string ops){
/*TODO*/
    stack<int> huhu;
    for(char c : ops) {
        if(c >= '0' && c <= '9') huhu.push(c - '0');
        else if(c == 'C') huhu.pop();
        else if(c == 'D') huhu.push(2 * huhu.top());
        else if(c == '+') {
            int top = huhu.top();
            huhu.pop();
            top += huhu.top();
            huhu.push(top - huhu.top());
            huhu.push(top);
        }
    }
    
    int hehe = 0;
    while(huhu.size()) {
        hehe += huhu.top();
        huhu.pop();
    }
    
    return hehe;
}",1.0,1111111111
Stack_3,1454659,2212282,"int trap(vector<int>& height) {
    int n = height.size();
    if (n <= 2) {
        return 0; // Không có đủ các cạnh tường để chứa nước
    }
    
    vector<int> leftMax(n, 0); // Chiều cao lớn nhất từ bên trái
    vector<int> rightMax(n, 0); // Chiều cao lớn nhất từ bên phải
    
    leftMax[0] = height[0];
    for (int i = 1; i < n; i++) {
        leftMax[i] = max(leftMax[i-1], height[i]);
    }
    
    rightMax[n-1] = height[n-1];
    for (int i = n - 2; i >= 0; i--) {
        rightMax[i] = max(rightMax[i+1], height[i]);
    }
    
    int water = 0; // Tổng diện tích mặt cắt nước
    
    for (int i = 1; i < n - 1; i++) {
        int minWallHeight = min(leftMax[i], rightMax[i]);
        water += max(minWallHeight - height[i], 0);
    }
    
    return water;
}",1.0,111111111111
Stack_4,1454659,2212282," void push(T item) {
        list.add(item);
    }

    T pop() {
        if (empty()) {
            throw std::out_of_range(""Stack is empty"");
        }
        T topItem = list.get(list.size() - 1);
        list.removeAt(list.size() - 1);
        return topItem;
    }

    T top() {
        if (empty()) {
            throw std::out_of_range(""Stack is empty"");
        }
        return list.get(list.size() - 1);
    }

    bool empty() {
        return list.empty();
    }

    int size() {
        return list.size();
    }

    void clear() {
        list.clear();
    }",1.0,11111
Stack_5,1454659,2212282,"int mountainWithoutValley(vector<int>& nums) {
    int n = nums.size();
    vector<int> left(n, 0);   // Stores the maximum sum from the left side
    vector<int> right(n, 0);  // Stores the maximum sum from the right side

    // Calculate the maximum sum from the left side
    for (int i = 1; i < n; i++) {
        if (nums[i] > nums[i - 1]) {
            left[i] = left[i - 1] + nums[i] - nums[i - 1];
        }
    }

    // Calculate the maximum sum from the right side
    for (int i = n - 2; i >= 0; i--) {
        if (nums[i] > nums[i + 1]) {
            right[i] = right[i + 1] + nums[i] - nums[i + 1];
        }
    }

    int maxSum = 0;

    // Find the maximum sum by considering each index as the peak of the mountain
    for (int i = 0; i < n; i++) {
        maxSum = max(maxSum, left[i] + right[i] + nums[i]);
    }

    return maxSum;
}",0.1,0100000000
Stack_6,1454659,2212282,"vector<int> nextGreater(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1); // Initialize the result array with -1
    
    stack<int> st; // Use a stack to keep track of indices
    
    for (int i = 0; i < n; i++) {
        // For each element, keep popping elements from the stack until the current element is greater than the top of the stack
        while (!st.empty() && nums[i] > nums[st.top()]) {
            int index = st.top();
            st.pop();
            result[index] = nums[i];
        }
        st.push(i); // Push the current element's index to the stack
    }
    
    return result;
}",1.0,1111111111
Stack_7,1454659,2212282,"string reverseString(string s, std::size_t start, std::size_t end) {
    while (start < end) {
        swap(s[start], s[end]);
        start++;
        end--;
    }
    return s;
}

string parenthesesReversal(string s) {
    stack<std::size_t> st;
    
    for (std::size_t i = 0; i < s.length(); i++) {
        if (s[i] == '(') {
            st.push(i);
        } else if (s[i] == ')') {
            if (!st.empty()) {
                std::size_t start = st.top() + 1;
                std::size_t end = i - 1;
                s = reverseString(s, start, end);
                st.pop();
            }
        }
    }
    
    string result;
    for (char c : s) {
        if (c != '(' && c != ')') {
            result += c;
        }
    }
    
    return result;
}",1.0,1111111111
Stack_8,1454659,2212282,"std::string removeDuplicates(const std::string& S) {
    std::stack<char> st;
    
    for (char c : S) {
        if (!st.empty() && st.top() == c) {
            st.pop();
        } else {
            st.push(c);
        }
    }
    
    std::string result;
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    
    return result;
}",1.0,1111111
Stack_9,1454659,2212282,"string deleteDuplicate(string s, int k) {
stack<pair<char, int>> charStack;

    for (char c : s) {
        if (!charStack.empty() && charStack.top().first == c) {
            charStack.top().second++;
        } else {
            charStack.push({c, 1});
        }

        if (charStack.top().second == k) {
            charStack.pop();
        }
    }

    string result = """";
    while (!charStack.empty()) {
        int count = charStack.top().second;
        while (count--) {
            result = charStack.top().first + result;
        }
        charStack.pop();
    }

    return result;
}",1.0,1111111111
Stack_10,1454659,2212282,"int sumOfMinSubarray(vector<int>& nums) {
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> s;
    for (int i = 0; i < n; i++) {
        while (!s.empty() && nums[s.top()] >= nums[i]) {
            s.pop();
        }
        left[i] = (s.empty() ? -1 : s.top());
        s.push(i);
    }
    while (!s.empty()) {
        s.pop();
    }
    for (int i = n - 1; i >= 0; i--) {
        while (!s.empty() && nums[s.top()] > nums[i]) {
            s.pop();
        }
        right[i] = (s.empty() ? n : s.top());
        s.push(i);
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = (ans + nums[i] * (i - left[i]) * (right[i] - i)) % 10000;
    }
    return ans;
}",1.0,1111111111
Stack_11,1454659,2212282,"bool tripleIndexSLM(std::vector<int>& nums) {
    std::stack<int> st;
    int n = nums.size();
    
    for (int i = 0; i < n; i++) {
        while (!st.empty() && nums[i] > nums[st.top()]) {
            st.pop();
        }
        
        st.push(i);
        
        if (st.size() >= 3) {
            int k = st.top();
            st.pop();
            int j = st.top();
            st.pop();
            int i = st.top();
            
            if (nums[i] < nums[k] && nums[k] < nums[j]) {
                return true;
            }
            
            st.push(i);
            st.push(j);
            st.push(k);
        }
    }
    
    return false;
}",0.8,0111110001
Stack_1,1454661,2213248,"int boxRequire(vector<int>& piles, int k) {
    int min = 0;
    int max_cap = 0;
    int cap =0;
    int n = piles.size();
    if (k < n) return 0;
    for(int i =0; i < n; i++  ){
        max_cap = max(piles[i], max_cap);
    }
    while(max_cap != min){
        int box = 0;
        cap = (max_cap+min)/2;
        for(int j =0; j <n; j++){
            if(piles[j] % cap == 0) box += piles[j]/cap;
            else box += piles[j] /cap + 1;
        }
        if (box > k) min = cap;
        else max_cap = cap;
        if(min + 1 == max_cap) min = max_cap;
    }
    return min;
}",0.95,111111111111111
Stack_2,1454661,2213248,"int baseballScore(string ops){
/*TODO*/
int n = ops.size();
stack<int> score;
for(int i = 0; i< n; i++){
    if(isdigit(ops[i])){
    score.push(ops[i] - '0');
    }
    if(ops[i] == 'C'){
        score.pop();
    }
    if(ops[i] == 'D'){
        int tem = score.top() *2;
        score.push(tem);
    }
    if(ops[i] == '+'){
        int fi = score.top();
        score.pop();
        int se = score.top();
        score.push(fi);
        score.push(fi + se);
    }
}
int sum =0;
while(!score.empty()){
    sum+= score.top();
    score.pop();
}
return sum;
}",1.0,1111111111
Stack_3,1454661,2213248,"int trap(vector<int>& height) {
    //TODO
    int n = height.size();
    if (n <= 1) return 0;
    stack <int> st;
    int maxheight = height[0];
    vector<int> ans(n,0);
    for (int i = 0; i < n; i++)
    {
        if (height[i] >= maxheight)
        {
            while (!st.empty() && maxheight >= height[st.top()])
            {
                ans[st.top()] = maxheight - height[st.top()];
                st.pop();
            }
            maxheight = height[i];
        }
        st.push(i);
    }
    maxheight = height[st.top()];
    st.pop();
    while (!st.empty())
    {
        if (height[st.top()] >= maxheight)
        {
            maxheight = height[st.top()];
            st.pop();
        }
        else
        {
            ans[st.top()] = maxheight - height[st.top()];
            st.pop();
        }
    }
    int answer = 0;
    /*for (int i = 0; i < n; i++)
    {
        cout << ans[i] << "" "";
    }
    cout << endl;*/
    for (int i = 0; i < n; i++)
    {
        answer += ans[i];
    }
    return answer;
}",1.0,111111111111
Stack_4,1454661,2213248,"void push(T item) {
    // TODO: Push new element into the top of the stack
    //cout<<1<<"" "";
    this->list.add(0,item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    T val = this->list.get(0);
    this->list.removeAt(0);
    return val;
        
}

T top() {
    // TODO: Get value of the element on top of the stack
    return this->list.get(0);
        
}

bool empty() {
    // TODO: Determine if the stack is empty
    return this->list.empty();
        
}

int size() {
    // TODO: Get the size of the stack
    return this->list.size();
        
}

void clear() {
    // TODO: Clear all elements of the stack
    while(!list.empty()){
        list.removeAt(0);
    }
}",1.0,11111
Stack_5,1454661,2213248,"int a[200011], n, l[200011], r[200011];
int mountainWithoutValley(vector<int>& nums) {
    int n = nums.size();
    stack <pair <int, int>> st;
    st.push(pair <int, int> (1, nums[0]));
    l[0] = nums[0];
    for (int i = 1; i < n; i++) {
        int cnt = 1;
        while (!st.empty() && st.top().second >= nums[i]) {
            cnt += st.top().first;
            st.pop();
        }
        int prev = i - cnt, add = 0;
        if (prev >= 0) {
            add = l[prev];
        }
        l[i] = add + cnt * nums[i];
        st.push(pair <int, int> (cnt, nums[i]));
    }
    r[n - 1] = nums[n - 1];
    while (!st.empty())
        st.pop();
    st.push(pair <int, int> (1, nums[n - 1]));
    for (int i = n - 2; i >= 0; i--) {
        int cnt = 1;
        while (!st.empty() && st.top().second >= nums[i]) {
            cnt += st.top().first;
            st.pop();
        }
        int prev = i + cnt, add = 0;
        if (prev <= n - 1) {
            add = r[prev];
        }
        r[i] = add + cnt * nums[i];
        st.push(pair <int, int> (cnt, nums[i]));
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = max(ans, l[i] + r[i] - nums[i]);
    }
    return ans;
}",1.0,1111111111
Stack_6,1454661,2213248,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    stack<int> st;
    int n = arr.size();
    vector<int> res(n,0);
    res[n-1] = -1;
    st.push(arr[n-1]);
    for(int i = n -2 ; i>=0 ;i--){
        if(arr[i]<st.top()){
            res[i] = st.top();
            st.push(arr[i]);
        }
        else{
            while(!st.empty()&&st.top()<=arr[i]){
                st.pop();
            }
            if(st.empty()){
                res[i] = -1;
            }
            else {
                res[i] = st.top();
            }
            st.push(arr[i]);
        }
    }
    return res;
    
}",1.0,1111111111
Stack_7,1454661,2213248,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    stack<char> st;
    string res ="""";
    for(int i = s.size() - 1 ; i>=0 ; i--){
        if(s[i]==')') st.push(s[i]);
        else if(s[i]=='('){
            string temp = """";
            while(st.top()!=')'){
                temp.push_back(st.top());
                st.pop();
            }
            st.pop();
            for(int j = 0 ; j<(int)temp.size() ;j++){
                st.push(temp[j]);
            }
        }
        else st.push(s[i]);
    }
    while(!st.empty()){
        res+=st.top();
        st.pop();
    }
    return res;
}",1.0,1111111111
Stack_8,1454661,2213248,"string removeDuplicates(string S){
    /*TODO*/
    string ans = """";
    int n = S.size();
    stack<char> st;
    st.push(S[0]);
    for(int i = 1 ; i <n;i++){
        if(st.empty()) st.push(S[i]);
        else if(S[i]==st.top()) st.pop();
        else st.push(S[i]);
    }
    while(!st.empty()){
        ans = st.top() + ans ;
        st.pop();
    }
    return ans;
}",1.0,1111111
Stack_9,1454661,2213248,"string deleteDuplicate(string s, int k) {
    stack<pair<char,int>> st;
    int n = s.size();
    if(n==0 || k==1) return """";
    st.push({s[n-1],1});
    for(int i = n-2; i >=0 ;i--){
        if(st.empty()){
            st.push({s[i],1});
            continue;
        }
        pair<char,int> r = st.top();
        if(s[i]==r.first){
            st.push({s[i],r.second+1});
            if(r.second+1==k){
                for(int j = 0 ; j<k ; j++) st.pop();
            }
        }
        else st.push({s[i],1});
    }
    string ans ="""";
    while(!st.empty()){
        ans += st.top().first;
        st.pop();
    }
    return ans;
}",1.0,1111111111
Stack_10,1454661,2213248,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 1e4;
    int n = nums.size();
    vector<int> left(n,0) , right(n,0);
    stack<pair<int,int>> s1 , s2 ;
    for(int i=0 ; i<n;i++){
        int cnt =1 ;
        while(!s1.empty() && s1.top().first>nums[i]){
            cnt += s1.top().second;
            s1.pop();
        }
        s1.push({nums[i],cnt});
        left[i] = cnt;
    }
    
    for(int i=n-1 ; i>=0;i--){
        int cnt =1 ;
        while(!s2.empty() && s2.top().first>=nums[i]){
            cnt += s2.top().second;
            s2.pop();
        }
        s2.push({nums[i],cnt});
        right[i] = cnt;
    }
    int result = 0 ;
    for(int i=0 ; i< n ;i++){
        result += (left[i]*right[i]*nums[i])%MOD;
        result%=MOD;
    }
    return result;
}",1.0,1111111111
Stack_11,1454661,2213248,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n<3)    return false;
    stack<int> st;
    int min, max;
    for (int i = n - 1; i >= 0; i--) {

    max = nums[i];
    while (!st.empty()
        && st.top() < nums[i]) {

        min = st.top();
        st.pop();
    }

    st.push(nums[i]);

    if (max < min) {
        return true;
    }
    }

return false;
}",0.5,1100001110
Stack_1,1454662,2210055,"bool canDistribute(const vector<int>& piles, int k, int r) {
    int boxesUsed = 0;
    for (int pile : piles) {
        boxesUsed += (pile + r - 1) / r; // Ceil division
    }
    return boxesUsed <= k;
}

int boxRequire(vector<int>& piles, int k) {
    int left = 1;
    int right = *std::max_element(piles.begin(), piles.end());
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (canDistribute(piles, k, mid)) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return result;

}",1.0,111111111111111
Stack_2,1454662,2210055,"int baseballScore(string ops)
{
    /*TODO*/
    stack<int> stack;
    for (char num : ops)
    {
        if (num == '+')
        {
            int tmp1 = stack.top();
            stack.pop();
            int tmp2 = tmp1 + stack.top();
            stack.push(tmp1);
            stack.push(tmp2);
        }
        else if (num == 'C')
        {
            stack.pop();
        }
        else if (num == 'D')
        {
            stack.push(2 * stack.top());
        }
        else
        {
            stack.push(num - '0');
        }
    }
    int sum = 0;
    while (!stack.empty())
    {
        sum += stack.top();
        stack.pop();
    }
    return sum;
}",1.0,1111111111
Stack_3,1454662,2210055,"int trap(vector<int>& height) {
//TODO
 int n = height.size();
    if (n <= 2) {
        return 0;  // Không thể chứa nước nếu số tường ít hơn 3
    }

    int left = 0;  // Con trỏ trái
    int right = n - 1;  // Con trỏ phải
    int leftMax = 0;  // Chiều cao tường lớn nhất từ bên trái
    int rightMax = 0;  // Chiều cao tường lớn nhất từ bên phải
    int trappedWater = 0;  // Lượng nước mưa chứa được

    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                trappedWater += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                trappedWater += rightMax - height[right];
            }
            right--;
        }
    }

    return trappedWater;
}",1.0,111111111111
Stack_4,1454662,2210055,"void push(T item) {
        // Add the item to the top of the stack.
        list.add(0, item);
    }

    T pop() {
        // Remove the item from the top of the stack and return it.
        if (empty()) {
            return T();
        } else {
            return list.removeAt(0);
        }
    }

    T top() {
        // Return the item at the top of the stack without removing it.
        if (empty()) {
            return T();
        } else {
            return list.get(0);
        }
    }

    bool empty() {
        // Return whether the stack is empty.
        return list.empty();
    }

    int size() {
        // Return the number of items in the stack.
        return list.size();
    }

    void clear() {
        // Clear all items from the stack.
        list.clear();
    }",1.0,11111
Stack_5,1454662,2210055,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
     int n = nums.size();
  vector<int> left_max(n, 0);
  vector<int> right_max(n, 0);

  // Calculate the left_max and right_max arrays.

  left_max[0] = nums[0];
  for (int i = 1; i < n; i++) {
    left_max[i] = max(left_max[i - 1], nums[i]);
  }

  right_max[n - 1] = nums[n - 1];
  for (int i = n - 2; i >= 0; i--) {
    right_max[i] = max(right_max[i + 1], nums[i]);
  }

  // Calculate the maximum sum of numbers of the mountain.

  int max_sum = 0;
  for (int i = 0; i < n; i++) {
    max_sum = max(max_sum, left_max[i] + right_max[i] - nums[i]);
  }

  return max_sum;
}",0.1,0100000000
Stack_6,1454662,2210055,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
     stack<int> s;
  vector<int> result(arr.size(), -1);

  for (int i = arr.size() - 1; i >= 0; i--) {
    while (!s.empty() && arr[s.top()] <= arr[i]) {
      s.pop();
    }

    if (!s.empty()) {
      result[i] = arr[s.top()];
    }

    s.push(i);
  }

  return result;
}",1.0,1111111111
Stack_7,1454662,2210055,"string reverseString(string str) {
    int n = str.length();
    for (int i = 0; i < n / 2; i++) {
        swap(str[i], str[n - i - 1]);
    }
    return str;
}

string parenthesesReversal(string s) {
    stack<string> stk;
    string result = """";

    for (char c : s) {
        if (c == '(') {
            stk.push(result);
            result = """";
        } else if (c == ')') {
            string reversed = reverseString(result);
            if (!stk.empty()) {
                result = stk.top() + reversed;
                stk.pop();
            } else {
                result = reversed;
            }
        } else {
            result += c;
        }
    }

    return result;
}",1.0,1111111111
Stack_8,1454662,2210055,"string removeDuplicates(string S)
{
    /*TODO*/
    stack<char> stack1;
    stack<char> stack2;

    for (char num : S)
    {
        if (stack1.empty())
            stack1.push(num);
        else if (num == stack1.top())
        {
            stack1.pop();
        }
        else
            stack1.push(num);
    };
    while (!stack1.empty())
    {
        stack2.push(stack1.top());
        stack1.pop();
    }
    string result;
    while (!stack2.empty())
    {
        result += stack2.top();
        stack2.pop();
    }
    return result;
}",1.0,1111111
Stack_9,1454662,2210055,"string deleteDuplicate(string s, int k) {
stack<pair<char, int>> charStack;  // Stack to store character and its count

    for (char c : s) {
        if (charStack.empty() || charStack.top().first != c) {
            charStack.push({c, 1});
        } else {
            charStack.top().second++;
            if (charStack.top().second == k) {
                charStack.pop();
            }
        }
    }

    string result = """";
    while (!charStack.empty()) {
        for (int i = 0; i < charStack.top().second; i++) {
            result = charStack.top().first + result;
        }
        charStack.pop();
    }

    return result;
}",0.9,1101111111
Stack_10,1454662,2210055,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
     int ans = 0;
     int n=nums.size();
    for (int i = 0; i < n; i++) {
        int min_ele = nums[i];
        for (int j = i; j < n; j++) {
            min_ele = min(min_ele, nums[j]);
            ans += min_ele;
        }
    }
    return ans%10000;
}",0.8,111111110
Stack_11,1454662,2210055,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n < 3) {
        return false; 
    }
    vector<int> left_min(n, 0);
    vector<int> right_max(n, 0);
    for (int i = 1; i < n; i++) {
        left_min[i] = min(left_min[i - 1], nums[i - 1]);
    }
    for (int i = n - 2; i >= 0; i--) {
        right_max[i] = max(right_max[i + 1], nums[i + 1]);
    }
    for (int j = 1; j < n - 1; j++) {
        if (left_min[j] < nums[j] && nums[j] < right_max[j]) {
            return true;
        }
    }
    return false;
}",0.8,0111111110
Stack_1,1454665,2211878,"int boxRequire(vector<int>& piles, int k) {
    int left = 1, right = 1000000000;
    while (left < right) {
        int mid = (left + right) / 2;
        int cnt = 0;
        for (unsigned int i = 0; i < piles.size(); i++) {
            cnt += (piles[i] + mid - 1) / mid;
        }
        if (cnt <= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
",1.0,111111111111111
Stack_2,1454665,2211878,"int baseballScore(string ops){
    int n = ops.length();
    stack <int> hehe;
    for(int i = 0; i < n; i++){
        if(isdigit(ops[i])) {
            hehe.push(ops[i] - '0');
        }else if(ops[i] == 'C') {
            if(!hehe.empty()){
                hehe.pop();
            }
        }else if(ops[i] == 'D'){
            if(!hehe.empty()){
                int top = hehe.top();
                hehe.push(top*2);
            }
        }else if(ops[i] == '+'){
            if(hehe.size()>=2){
                int pre = hehe.top();
                hehe.pop();
                int aft = hehe.top();
                hehe.push(pre);
                hehe.push(pre+aft);
            }
        }else continue;
    }
    int sum = 0;
    while(!hehe.empty()){
        sum+=hehe.top();
        hehe.pop();
    }
    return sum;
}
",1.0,1111111111
Stack_3,1454665,2211878,"int trap(vector<int>& height) {
    int n = height.size();
    if(n == 0) return 0;
    vector<int> left(n), right(n);
    left[0] = height[0];
    right[n-1] = height[n-1];
    for(int i = 1; i < n; i++) {
        left[i] = max(left[i-1], height[i]);
        right[n-i-1] = max(right[n-i], height[n-i-1]);
    }
    int water = 0;
    for(int i = 0; i < n; i++) {
        water += min(left[i], right[i]) - height[i];
    }
    return water;
}
",1.0,111111111111
Stack_4,1454665,2211878,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    return list.removeAt(list.size()-1);
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(list.size() - 1);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty(); 
}

int size() {
    // TODO: Get the size of the stack
    return list.size(); 
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1454665,2211878,"int mountainWithoutValley(vector<int>& nums) {
    int n = nums.size();
    vector<int> mt(n);
    mt[0] = nums[0];
    for (int i = 1; i < n; i++) {
        mt[i] = min(mt[i - 1], nums[i]);
    }
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += mt[i];
    }
    return sum;
}
",0.2,1100000000
Stack_6,1454665,2211878,"vector<int> nextGreater(vector<int>& arr) {
    int n = arr.size();
    vector<int> result(n, -1);
    stack<int> s;
    for (int i = 0; i < n; i++) {
        while (!s.empty() && arr[s.top()] < arr[i]) {
            result[s.top()] = arr[i];
            s.pop();
        }
        s.push(i);
    }
    return result;
}
",1.0,1111111111
Stack_7,1454665,2211878,"void reverse(string & s,int start, int end){
    if(start >= end) return;
    if(start < end){
        char c = s[start];
        s[start] = s[end];
        s[end] = c;
    }
    reverse(s,start+1,end-1);
}

string parenthesesReversal(string s) {
    stack<int> st;
    for (unsigned int i = 0; i < s.size(); i++) {
        if (s[i] == '(') {
            st.push(i);
        } else if (s[i] == ')') {
            int start = st.top();
            st.pop();
            reverse(s,start + 1,i-1);
        }
    }
    string result;
    for (unsigned int i = 0; i < s.size(); i++) {
        if (s[i] != '(' && s[i] != ')') {
            result += s[i];
        }
    }
    return result;
}
",1.0,1111111111
Stack_8,1454665,2211878,"string reverse(string s) {
    int n = s.length();
    for (int i = 0; i < n / 2; i++) {
        swap(s[i], s[n - i - 1]);
    }
    return s;
}

string removeDuplicates(string s) {
    stack<char> st;
    for (char c : s) {
        if (!st.empty() && st.top() == c) {
            st.pop();
        } else {
            st.push(c);
        }
    }
    string result;
    while (!st.empty()) {
        result += st.top();
        st.pop();
    }
    result = reverse(result);
    return result;
}",1.0,1111111
Stack_9,1454665,2211878,"string deleteDuplicate(string s, int k) {
    stack<pair<char, int>> st;
    for (char c : s) {
        if (!st.empty() && st.top().first == c) {
            st.top().second++;
            if (st.top().second == k) {
                st.pop();
            }
        } else {
            st.push({c, 1});
        }
    }
    string res = """";
    while (!st.empty()) {
        pair<char, int> top = st.top();
        st.pop();
        res = string(top.second, top.first) + res;
    }
    return res;
}",0.9,1101111111
Stack_10,1454665,2211878,"int sumOfMinSubarray(vector<int>& nums) {
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> s;
    for (int i = 0; i < n; ++i) {
        while (!s.empty() && nums[s.top()] > nums[i]) {
            s.pop();
        }
        left[i] = (s.empty() ? -1 : s.top());
        s.push(i);
    }
    while (!s.empty()) {
        s.pop();
    }
    for (int i = n - 1; i >= 0; --i) {
        while (!s.empty() && nums[s.top()] > nums[i]) {
            s.pop();
        }
        right[i] = (s.empty() ? n : s.top());
        s.push(i);
    }
    int ans = 0, mod = 10000;
    for (int i = 0; i < n; ++i) {
        ans = (ans + nums[i] * (i - left[i]) * (right[i] - i)) % mod;
    }
    return ans;
}",0.5,1111100000
Stack_11,1454665,2211878,"bool tripleIndexSLM(vector<int>& nums) {
    int n = nums.size();
    if(n == 0) return false;
    vector<int> min_left(n);
    min_left[0] = nums[0];
    for (int i = 1; i < n; ++i) {
        min_left[i] = min(min_left[i - 1], nums[i]);
    }
    stack<int> s;
    for (int j = n - 1; j >= 0; --j) {
        while (!s.empty() && nums[s.top()] < nums[j]) {
            if (min_left[s.top()] < nums[s.top()]) {
                return true;
            }
            s.pop();
        }
        s.push(j);
    }
    return false;
}",1.0,1111111111
Stack_1,1454669,2213250,"int findmax(vector<int>& piles) {
    int size = piles.size();
    int max = INT32_MIN;
    for(int i = 0; i < size; i++) {
        if(piles[i] > max) max = piles[i];
    }
    return max;
}
int boxRequire(vector<int>& piles, int k) {
    int max = findmax(piles);
    int min = 0;
    int size = piles.size();
    long box = k + 1;
    while(max != min) {
        int capacity = (max + min) / 2;
        box = 0;
        for(int i = 0; i < size; i++) {
            if(piles[i] % capacity == 0) box += piles[i]/capacity;
            else box += piles[i]/capacity + 1;
        }
        if(box > k) min = capacity;
        else max = capacity;
        if(min + 1 == max) min = max;
    }
    return min;
}",0.9,111111111111111
Stack_2,1454669,2213250,"int baseballScore(string ops){
    stack<int> score;
    int size = ops.size();
    for(int i = 0; i < size; i++) {
        if(isdigit(ops[i])) score.push(ops[i] - '0');
        else {
            if(ops[i] == 'C') {
                if(!score.empty()) score.pop();
            }
            if(ops[i] == 'D') {
                if(!score.empty()) score.push(score.top()*2);
            }
            if(ops[i] == '+') {
                if(score.size() > 1) {
                    int temp = score.top();
                    score.pop();
                    int val = temp + score.top();
                    score.push(temp);
                    score.push(val);
                }
            }
        }
    }
    int sum = 0;
    while(!score.empty()) {
        sum += score.top();
        score.pop();
    }
    return sum;
}",1.0,1111111111
Stack_3,1454669,2213250,"int trap(vector<int>& height) {
    //TODO
    int n = height.size();
    if (n <= 1) return 0;
    stack <int> st;
    int maxheight = height[0];
    vector<int> ans(n,0);
    for (int i = 0; i < n; i++)
    {
        if (height[i] >= maxheight)
        {
            while (!st.empty() && maxheight >= height[st.top()])
            {
                ans[st.top()] = maxheight - height[st.top()];
                st.pop();
            }
            maxheight = height[i];
        }
        st.push(i);
    }
    maxheight = height[st.top()];
    st.pop();
    while (!st.empty())
    {
        if (height[st.top()] >= maxheight)
        {
            maxheight = height[st.top()];
            st.pop();
        }
        else
        {
            ans[st.top()] = maxheight - height[st.top()];
            st.pop();
        }
    }
    int answer = 0;
    /*for (int i = 0; i < n; i++)
    {
        cout << ans[i] << "" "";
    }
    cout << endl;*/
    for (int i = 0; i < n; i++)
    {
        answer += ans[i];
    }
    return answer;
}",0.9,111111111111
Stack_4,1454669,2213250,"void push(T item) {
    // TODO: Push new element into the top of the stack
    //cout<<1<<"" "";
    this->list.add(0,item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    T val = this->list.get(0);
    this->list.removeAt(0);
    return val;
        
}

T top() {
    // TODO: Get value of the element on top of the stack
    return this->list.get(0);
        
}

bool empty() {
    // TODO: Determine if the stack is empty
    return this->list.empty();
        
}

int size() {
    // TODO: Get the size of the stack
    return this->list.size();
        
}

void clear() {
    // TODO: Clear all elements of the stack
    while(!list.empty()){
        list.removeAt(0);
    }
}",1.0,11111
Stack_5,1454669,2213250,"int a[200011], n, l[200011], r[200011];
int mountainWithoutValley(vector<int>& nums) {
    int n = nums.size();
    stack <pair <int, int>> st;
    st.push(pair <int, int> (1, nums[0]));
    l[0] = nums[0];
    for (int i = 1; i < n; i++) {
        int cnt = 1;
        while (!st.empty() && st.top().second >= nums[i]) {
            cnt += st.top().first;
            st.pop();
        }
        int prev = i - cnt, add = 0;
        if (prev >= 0) {
            add = l[prev];
        }
        l[i] = add + cnt * nums[i];
        st.push(pair <int, int> (cnt, nums[i]));
    }
    r[n - 1] = nums[n - 1];
    while (!st.empty())
        st.pop();
    st.push(pair <int, int> (1, nums[n - 1]));
    for (int i = n - 2; i >= 0; i--) {
        int cnt = 1;
        while (!st.empty() && st.top().second >= nums[i]) {
            cnt += st.top().first;
            st.pop();
        }
        int prev = i + cnt, add = 0;
        if (prev <= n - 1) {
            add = r[prev];
        }
        r[i] = add + cnt * nums[i];
        st.push(pair <int, int> (cnt, nums[i]));
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = max(ans, l[i] + r[i] - nums[i]);
    }
    return ans;
}",1.0,1111111111
Stack_6,1454669,2213250,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    stack<int> st;
    int n = arr.size();
    vector<int> res(n,0);
    res[n-1] = -1;
    st.push(arr[n-1]);
    for(int i = n -2 ; i>=0 ;i--){
        if(arr[i]<st.top()){
            res[i] = st.top();
            st.push(arr[i]);
        }
        else{
            while(!st.empty()&&st.top()<=arr[i]){
                st.pop();
            }
            if(st.empty()){
                res[i] = -1;
            }
            else {
                res[i] = st.top();
            }
            st.push(arr[i]);
        }
    }
    return res;
    
}",1.0,1111111111
Stack_7,1454669,2213250,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    stack<char> st;
    string res ="""";
    for(int i = s.size() - 1 ; i>=0 ; i--){
        if(s[i]==')') st.push(s[i]);
        else if(s[i]=='('){
            string temp = """";
            while(st.top()!=')'){
                temp.push_back(st.top());
                st.pop();
            }
            st.pop();
            for(int j = 0 ; j<(int)temp.size() ;j++){
                st.push(temp[j]);
            }
        }
        else st.push(s[i]);
    }
    while(!st.empty()){
        res+=st.top();
        st.pop();
    }
    return res;
}",1.0,1111111111
Stack_8,1454669,2213250,"string removeDuplicates(string S){
    /*TODO*/
    string ans = """";
    int n = S.size();
    stack<char> st;
    st.push(S[0]);
    for(int i = 1 ; i <n;i++){
        if(st.empty()) st.push(S[i]);
        else if(S[i]==st.top()) st.pop();
        else st.push(S[i]);
    }
    while(!st.empty()){
        ans = st.top() + ans ;
        st.pop();
    }
    return ans;
}",1.0,1111111
Stack_9,1454669,2213250,"string deleteDuplicate(string s, int k) {
    stack<pair<char,int>> st;
    int n = s.size();
    if(n==0 || k==1) return """";
    st.push({s[n-1],1});
    for(int i = n-2; i >=0 ;i--){
        if(st.empty()){
            st.push({s[i],1});
            continue;
        }
        pair<char,int> r = st.top();
        if(s[i]==r.first){
            st.push({s[i],r.second+1});
            if(r.second+1==k){
                for(int j = 0 ; j<k ; j++) st.pop();
            }
        }
        else st.push({s[i],1});
    }
    string ans ="""";
    while(!st.empty()){
        ans += st.top().first;
        st.pop();
    }
    return ans;
}",1.0,1111111111
Stack_10,1454669,2213250,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 1e4;
    int n = nums.size();
    vector<int> left(n,0) , right(n,0);
    stack<pair<int,int>> s1 , s2 ;
    for(int i=0 ; i<n;i++){
        int cnt =1 ;
        while(!s1.empty() && s1.top().first>nums[i]){
            cnt += s1.top().second;
            s1.pop();
        }
        s1.push({nums[i],cnt});
        left[i] = cnt;
    }
    
    for(int i=n-1 ; i>=0;i--){
        int cnt =1 ;
        while(!s2.empty() && s2.top().first>=nums[i]){
            cnt += s2.top().second;
            s2.pop();
        }
        s2.push({nums[i],cnt});
        right[i] = cnt;
    }
    int result = 0 ;
    for(int i=0 ; i< n ;i++){
        result += (left[i]*right[i]*nums[i])%MOD;
        result%=MOD;
    }
    return result;
}",1.0,1111111111
Stack_11,1454669,2213250,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n<3)    return false;
    stack<int> st;
    int min, max;
    for (int i = n - 1; i >= 0; i--) {

    max = nums[i];
    while (!st.empty()
        && st.top() < nums[i]) {

        min = st.top();
        st.pop();
    }

    st.push(nums[i]);

    if (max < min) {
        return true;
    }
    }

return false;
}",1.0,1111111111
Stack_1,1454675,2211667,"#include<bits/stdc++.h>
using namespace std;

bool isPossible(vector<int>& piles, int k, int mid) {
    int count = 0;
    for (size_t i = 0; i < piles.size(); i++) {
        count += (piles[i] + mid - 1) / mid;
    }
    return count <= k;
}

int boxRequire(vector<int>& piles, int k) {
    int left = 1;
    int right = accumulate(piles.begin(), piles.end(), 0);
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (isPossible(piles, k, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}

",0.9,111111111111111
Stack_2,1454675,2211667,"int baseballScore(string ops){
/*TODO*/
vector<int> scores;

    for (char op : ops) {
        if (op == 'C') {
            if (!scores.empty()) {
                scores.pop_back();
            }
        } else if (op == 'D') {
            if (!scores.empty()) {
                scores.push_back(2 * scores.back());
            }
        } else if (op == '+') {
            if (scores.size() >= 2) {
                scores.push_back(scores[scores.size() - 1] + scores[scores.size() - 2]);
            }
        } else {
            scores.push_back(op - '0'); 
        }
    }

    int totalScore = 0;
    for (int score : scores) {
        totalScore += score;
    }

    return totalScore;
}",1.0,1111111111
Stack_3,1454675,2211667,"int trap(vector<int>& height) {
//TODO
int n = height.size();
    int res = 0;
    for (int i = 1; i < n - 1; i++)
    {
        int left = height[i];
        for (int j = 0; j < i; j++)
        {
            left = max(left, height[j]);
        }
        int right = height[i];
        for (int j = i + 1; j < n; j++)
        {
            right = max(right, height[j]);
        }
        res = res + min(left, right) - height[i];
    }
    return res;
}",1.0,111111111111
Stack_4,1454675,2211667,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    T item = list.get(list.size() - 1);
    list.removeAt(list.size() - 1);
    return item;    
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(list.size() - 1);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();    
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_6,1454675,2211667,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& nums){
    
    int n = nums.size();
    vector<int> result(n, -1);
    stack<int> s;

    for (int i = 0; i < n; i++) {
        while (!s.empty() && nums[i] > nums[s.top()]) {
            result[s.top()] = nums[i];
            s.pop();
        }
        s.push(i);
    }

    return result;

}",1.0,1111111111
Stack_7,1454675,2211667,"string parenthesesReversal(string s) {
    stack<char> st;
    for (char c : s) {
        if (c != ')') {
            st.push(c);
        } else {
            string t = """";
            while (!st.empty() && st.top() != '(') {
                t += st.top();
                st.pop();
            }
            if (!st.empty()) st.pop(); // pop '('
            for (char c : t) st.push(c);
        }
    }
    string res = """";
    while (!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;
}",1.0,1111111111
Stack_8,1454675,2211667,"string removeDuplicates(string S){
    /*TODO*/
    
    stack<char> st;
    
    for (size_t i = 0; i < S.length(); i++) {
        if (st.empty() || S[i] != st.top()) 
            st.push(S[i]);
        else st.pop();
    }
    
    string result = """";
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    return result;
}",1.0,1111111
Stack_9,1454675,2211667,"string deleteDuplicate(string s, int k) {
    stack<pair<char, int>> stack;
    for (char ch : s) {
        if (!stack.empty() && stack.top().first == ch) {
            stack.top().second++;
            if (stack.top().second == k) {
                stack.pop();
            }
        } else {
            stack.push({ch, 1});
        }
    }
    string result = """";
    while (!stack.empty()) {
        pair<char, int> top = stack.top();
        stack.pop();
        result = string(top.second, top.first) + result;
    }
    return result;
}",0.9,1101111111
Stack_10,1454675,2211667,"

int sumOfMinSubarray(vector<int>& nums) {
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> s;
    
    for (int i = 0; i < n; ++i) {
        while (!s.empty() && nums[s.top()] >= nums[i]) {
            s.pop();
        }
        left[i] = s.empty() ? -1 : s.top();
        s.push(i);
    }
    
    while (!s.empty()) {
        s.pop();
    }
    for (int i = n - 1; i >= 0; --i) {
        while (!s.empty() && nums[s.top()] > nums[i]) {
            s.pop();
        }
        right[i] = s.empty() ? n : s.top();
        s.push(i);
    }
    long int sum = 0;
    for (int i = 0; i < n; ++i) {
        sum = (sum + nums[i] * (i - left[i]) * (right[i] - i));
    }
    return sum%10000;
}
",1.0,1111111111
Stack_11,1454675,2211667,"bool tripleIndexSLM(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n; ++i) {
        for (int k = i + 1; k < n; ++k) {
            if (nums[i] < nums[k]) {
                for (int j = k + 1; j < n; ++j) {
                    if (nums[k] < nums[j]) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
",0.8,0111111110
Stack_1,1454685,2110501,"int boxRequire(vector<int>& piles, int k) {
    int left = 1;
    int right = *max_element(piles.begin(), piles.end());
    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxesNeeded = 0;
        for (int pile : piles) {
            boxesNeeded += (pile + mid - 1) / mid;
        }
        if (boxesNeeded > k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}",1.0,111111111111111
Stack_2,1454685,2110501,"int baseballScore(string ops){
/*TODO*/
    stack<int> stk;
    int ans = 0;
    int n = ops.length();
    for (int i = 0; i < n; i++)
    {
        if (ops[i] >= '0' && ops[i] <= '9')
        {
            stk.push(ops[i] - 48);
            ans += stk.top();
        }
        else if (ops[i] == 'D')
        {
            int temp1 = stk.top();
            stk.pop();
            int temp2 = 2*temp1;
            stk.push(temp1);
            stk.push(temp2);
            ans += stk.top();
        }
        else if (ops[i] == 'C'){
            ans -= stk.top();
            stk.pop();
        }
        else if (ops[i] == '+')
        {
            int temp1 = stk.top();
            stk.pop();
            int temp2 = stk.top();
            stk.push(temp1);
            temp2 = temp2 + temp1;
            stk.push(temp2);
            ans += stk.top();
        }
    }
    return ans;
}",1.0,1111111111
Stack_3,1454685,2110501,"int trap(vector<int>& height) {
//TODO
     stack<int> s;
    int water = 0;
    int i = 0;

    while (i < int(height.size())) {
        while (!s.empty() && height[i] > height[s.top()]) {
            int top = s.top();
            s.pop();

            if (s.empty())
                break;

            int distance = i - s.top() - 1;
            int bounded_height = min(height[i], height[s.top()]) - height[top];
            water += distance * bounded_height;
        }

        s.push(i++);
    }

    return water;
}",1.0,111111111111
Stack_4,1454685,2110501,"void push(T item) {
    // TODO: Push new element into the top of the stack
    this->list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    if(this->list.empty()) throw std::out_of_range(""Index is out of range"");
    else    
    {
        return this->list.removeAt(this->list.size()-1);
    }    
}

T top() {
    // TODO: Get value of the element on top of the stack
    if(this->list.empty()) throw std::out_of_range(""Index is out of range"");
    else
    {
    return this->list.get(this->list.size()-1);
    }    
}

bool empty() {
    // TODO: Determine if the stack is empty
    return this->list.empty();    
}

int size() {
    // TODO: Get the size of the stack
    return  this->list.size();    
}

void clear() {
    // TODO: Clear all elements of the stack
    return this->list.clear();
}",1.0,11111
Stack_5,1454685,2110501,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
  vector<int> left(n, 0);
  vector<int> right(n, 0);
  stack<int> stack;
 
  
  for (int i = 0; i < n; i++) {
    int curr = nums[i];
    while (stack.size() != 0 && nums[stack.top()] >= curr) stack.pop();

    if (stack.size() == 0)
      left[i] = (i + 1) * (nums[i]);
 
    else {
      int small_idx = stack.top();
      left[i] = left[small_idx]  + (i - small_idx) * (nums[i]);
    }
    stack.push(i);
  }
   while (!stack.empty()) {
        stack.pop();
    }
 
  for (int i = n - 1; i > -1; i--) {
    int curr = nums[i];
    while (stack.size() != 0 && nums[stack.top()]>= curr) stack.pop();

 
    if (stack.size() == 0)
      right[i] = (n - i) * (nums[i]);
 
    else {
      int small_idx = stack.top();
      right[i] = right[small_idx] + (small_idx - i) * (nums[i]);
    }
    stack.push(i);
  }
  int ans = 0;
 
  for (int i = 0; i < n; i++) {
    int curr = left[i] + right[i] - nums[i];
    ans = max(ans, curr);
  }
  return ans;
}",1.0,1111111111
Stack_6,1454685,2110501,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    vector<int> ans;
    int n = arr.size();
    if (n == 0) return ans;
    
    stack<int> stk;
    stk.push(n - 1);
    ans.push_back(-1);
    
    for (int i = n - 2; i >= 0; i--)
    {
        while (!stk.empty() && arr[stk.top()] <= arr[i]) 
            stk.pop();
        ans.insert(ans.begin(), (stk.empty()) ? (-1) : (arr[stk.top()]));
        stk.push(i);
    }
    return ans;
}",1.0,1111111111
Stack_7,1454685,2110501,"void reverse(string& s, int start, int end) {
    while (start < end) {
        swap(s[start], s[end]);
        start++;
        end--;
    }
}

string parenthesesReversal(string s) {
    stack<int> st;
    int len = s.length();
    for (int i = 0; i < len; i++) {

        if (s[i] == '(') {
            st.push(i);
        }

        else if (s[i] == ')') {
            reverse(s, st.top() + 1, i);
            st.pop();
        }
    }

     string res = """";
    for (int i = 0; i < len; i++) {
        if (s[i] != ')' && s[i] != '(')
            res += s[i];
    }
    return res;
}
",1.0,1111111111
Stack_8,1454685,2110501,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> St;
    for(int i=0;i<int(S.length());i++){
        if(St.empty()||(!St.empty()&&S[i]!=St.top())){
            St.push(S[i]);
        }
        else if(S[i]==St.top()){
            St.pop();
        }
    }
    stack<char> St2;
    while(!St.empty()){
        St2.push(St.top());
        St.pop();
    }
    string str="""";
    while(St2.size()!=0){
        str=str+St2.top();
        St2.pop();
    }
    return str;
}",1.0,1111111
Stack_9,1454685,2110501,"void reverse(string& s, int start, int end) {
    while (start < end) {
        swap(s[start], s[end]);
        start++;
        end--;
    }
}

string deleteDuplicate(string s, int k) {
    if (k == 1) return """";
    string output = """";
    stack<pair<char, int> > stk;
    for (int i = 0; i < int(s.length()); i++) {
        if (stk.empty() == true) {
            stk.push(make_pair(s[i], 1));
        }
        else {
            if (s[i] == (stk.top()).first) {
                pair<char, int> P = stk.top();
                stk.pop();
                P.second++;
                if (P.second == k)  continue;
                else    stk.push(P);
            }
            else {
                stk.push(make_pair(s[i], 1));
            }
        }
    }
    while (!stk.empty()) {
        if (stk.top().second > 1) {
            int count = stk.top().second;
            while (count--) output += stk.top().first;
        }
        else {
            output += stk.top().first;
        }
        stk.pop();
    }
    reverse(output, 0, output.length() - 1);
    return output;
}
",1.0,1111111111
Stack_10,1454685,2110501,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 10000;
    int sumOfMinSubarrays = 0;
    stack<int> st;
    vector<int> minValues(nums.size(), 0);
    for (int i = 0; i < int(nums.size()); i++) {
        while (!st.empty() && nums[i] < nums[st.top()]) {
            int idx = st.top();
            st.pop();
            int left = st.empty() ? -1 : st.top();
            sumOfMinSubarrays = (sumOfMinSubarrays + nums[idx] * (i - idx) * (idx - left)) % MOD;
        }
        st.push(i);
    }

    while (!st.empty()) {
        int idx = st.top();
        st.pop();

        int left = st.empty() ? -1 : st.top();
        sumOfMinSubarrays = (sumOfMinSubarrays + nums[idx] * (nums.size() - idx) * (idx - left)) % MOD;
    }

    return sumOfMinSubarrays;
}",1.0,1111111111
Stack_11,1454685,2110501,"bool tripleIndexSLM(vector<int>& nums) {
    int n = nums.size();
    stack<int> st;
    int h3 = -2147483648, h1 = 2147483647;
    for (int i = n - 1; i >= 0; i--) {
        h1 = nums[i];
        while (!st.empty() && st.top() < nums[i]) {
            h3 = st.top();
            st.pop();
        }
        st.push(nums[i]);
        if (h1 < h3)    return true;
    }
    return false;
}
",1.0,1111111111
Stack_1,1454687,1913560,"int boxRequire(vector<int>& piles, int k) {
    int n = piles.size();
    std::sort(piles.begin(), piles.end(), std::greater<int>()); 

    std::stack<int> st;
    int count = 0; 

    for (int i = 0; i < n; i++) {
        if (st.empty() || st.top() != piles[i]) {
            st.push(piles[i]);
            count++;
        }

        if (count >= k) {
            return st.top(); 
        }
    }

    return st.top(); 
}",0.13,100000000010000
Stack_2,1454687,1913560,"int baseballScore(string ops) {
    stack<int> scores;

    for (char op : ops) {
        if (isdigit(op)) {
            int score = op - '0';
            scores.push(score);
        } else if (op == '+') {
            int score1 = scores.top();
            scores.pop();
            int score2 = scores.top();
            int newScore = score1 + score2;
            scores.push(score1);
            scores.push(newScore);
        } else if (op == 'D') {
            int score = scores.top();
            int newScore = score * 2;
            scores.push(newScore);
        } else if (op == 'C') {
            scores.pop();
        }
    }

    int sum = 0;
    while (!scores.empty()) {
        sum += scores.top();
        scores.pop();
    }

    return sum;
}",1.0,1111111111
Stack_3,1454687,1913560,"int trap(vector<int>& height) {
    int left = 0; 
    int right = height.size() - 1; 
    int leftMax = 0;
    int rightMax = 0;
    int result = 0; 

    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left]; 
            } else {
                result += (leftMax - height[left]); 
            }
            left++; 
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right]; 
            } else {
                result += (rightMax - height[right]); 
            }
            right--; 
        }
    }

    return result; 
}",1.0,111111111111
Stack_1,1454703,2112585,"int boxRequire(vector<int>& piles, int k) {
    int left = 1; 
    int right = *max_element(piles.begin(), piles.end()); 
    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxes = 0;
        
        for (int notebooks : piles) {
            boxes += (notebooks + mid - 1) / mid;
        }
        
        if (boxes > k) left = mid + 1; 
        else right = mid; 
    }
    return left; 
}",1.0,111111111111111
Stack_2,1454703,2112585,"int baseballScore(string ops){
/*TODO*/
    stack<int> scr;
    for(char o:ops){
        if(isdigit(o)) scr.push(o-'0');
        else if(o=='C') scr.pop();
        else if(o=='D'){
            int prev=scr.top();
            scr.push(2*prev);
        }
        else if(o=='+'){
            int prev1=scr.top();
            scr.pop();
            int prev2=scr.top();
            scr.push(prev1);
            scr.push(prev1+prev2);
        }
    }
    int total=0;
    while(!scr.empty()){
        total+=scr.top();
        scr.pop();
    }
    return total;
}",1.0,1111111111
Stack_3,1454703,2112585,"int trap(vector<int>& height) {
stack<int> st;
    int water = 0;
    
    for (int i = 0; i < int(height.size()); i++) {
        while (!st.empty() && height[i] > height[st.top()]) {
            int top = st.top();
            st.pop();
            
            if (st.empty()) {
                break;
            }
            
            int distance = i - st.top() - 1;
            int boundedHeight = min(height[i], height[st.top()]) - height[top];
            water += distance * boundedHeight;
        }
        
        st.push(i);
    }
    
    return water;
}",1.0,111111111111
Stack_4,1454703,2112585,"    void push(T item) {
        list.add(item);
    }

    T pop() {
        if (empty()) {
            throw std::out_of_range(""Stack is empty"");
        }
        return list.removeAt(list.size() - 1);
    }

    T top() {
        if (empty()) {
            throw std::out_of_range(""Stack is empty"");
        }
        return list.get(list.size() - 1);
    }

    bool empty() {
        return list.empty();
    }

    int size() {
        return list.size();
    }

    void clear() {
        list.clear();
    }
",1.0,11111
Stack_5,1454703,2112585,"int mountainWithoutValley(vector<int>& nums) {
    int n = nums.size();
    vector<int> leftMax(n, 0);
    vector<int> rightMax(n, 0);

    // Calculate the maximum sum of increasing numbers from left to right
    for (int i = 0; i < n; i++) {
        leftMax[i] = nums[i];
        if (i > 0 && nums[i] > nums[i - 1]) {
            leftMax[i] += leftMax[i - 1];
        }
    }

    // Calculate the maximum sum of increasing numbers from right to left
    for (int i = n - 1; i >= 0; i--) {
        rightMax[i] = nums[i];
        if (i < n - 1 && nums[i] > nums[i + 1]) {
            rightMax[i] += rightMax[i + 1];
        }
    }

    int maxSum = 0;
    // Find the maximum sum of numbers of mt
    for (int i = 0; i < n; i++) {
        maxSum = max(maxSum, leftMax[i] + rightMax[i] - nums[i]);
    }

    return maxSum;
}",0.1,0100000000
Stack_6,1454703,2112585,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    int n = arr.size();
    vector<int> result(n, -1);
    stack<int> st;

    for (int i = 0; i < n; i++) {
        while (!st.empty() && arr[i] > arr[st.top()]) {
            result[st.top()] = arr[i];
            st.pop();
        }
        st.push(i);
    }

    return result;
}",1.0,1111111111
Stack_7,1454703,2112585,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
}",0.1,
Stack_8,1454703,2112585,"string removeDuplicates(string s){
    /*TODO*/
     list<char> result;

  for(unsigned int i=0; i<s.length(); i++) {
    if(i > 0 && s[i] == s[i-1]) {
      result.pop_back(); 
    }
    else {
      result.push_back(s[i]);
    }
  }

  string str = """";
  for(auto c : result) {
    str += c; 
  }
if (str==removeDuplicates(str))
  return str;
  else return removeDuplicates(str);
}",0.57,0
Stack_2,1454710,2212935,"int baseballScore(string ops){
/*TODO*/
stack<int> scores;

for (char op : ops) {
    if (isdigit(op)) {
        scores.push(op - '0'); 
    } else if (op == '+') {
        int score1 = scores.top();
        scores.pop();
        int score2 = scores.top();
        scores.push(score1);
        scores.push(score1 + score2);
    } else if (op == 'D') {
        int score = scores.top();
        scores.push(score * 2);
    } else if (op == 'C') {
        scores.pop();
    }
}

int sum = 0;
while (!scores.empty()) {
    sum += scores.top();
    scores.pop();
}

return sum;
}",1.0,1111111111
Stack_3,1454710,2212935,"int trap(vector<int>& height) {
//TODO
stack<int> st;
    int water = 0;
    int n = height.size();

    for (int i = 0; i < n; i++) {
        while (!st.empty() && height[i] > height[st.top()]) {
            int top = st.top();
            st.pop();

            if (st.empty()) {
                break;
            }

            int distance = i - st.top() - 1;
            int boundedHeight = min(height[i], height[st.top()]) - height[top];
            water += distance * boundedHeight;
        }

        st.push(i);
    }

    return water;
}",1.0,111111111111
Stack_4,1454710,2212935,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
        if (list.empty()) {
            throw std::runtime_error(""Stack is empty"");
        }
        T poppedItem = list.get(list.size() - 1);
        list.removeAt(list.size() - 1);
        return poppedItem;
        
}

T top() {
    // TODO: Get value of the element on top of the stack
        return list.get(list.size() - 1);
}

bool empty() {
    // TODO: Determine if the stack is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the stack
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1454710,2212935,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
  
}",0.1,0000000000
Stack_6,1454710,2212935,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    int n = arr.size();
    vector<int> result(n, -1); 
    stack<int> st;

    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && arr[i] >= st.top()) {
            st.pop();
        }
        if (!st.empty()) {
            result[i] = st.top();
        }
        st.push(arr[i]);
    }

    return result;
}",1.0,1111111111
Stack_7,1454710,2212935,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
     stack<int> st;
    int n = s.length();

    for (int i = 0; i < n; i++) {
        if (s[i] == '(') {
            st.push(i);
        } 
        else if (s[i] == ')') {
            int start = st.top();
            st.pop();

            int left = start + 1;
            int right = i - 1;
            while (left < right) {
                swap(s[left], s[right]);
                left++;
                right--;
            }
        }
    }

    string result;
    for (int i = 0; i < n; i++) {
        if (s[i] != '(' && s[i] != ')') {
            result += s[i];
        }
    }

    return result;
}",1.0,1111111111
Stack_8,1454710,2212935,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> st;

    for (char c : S) {
        if (!st.empty() && st.top() == c) {
            st.pop();
        } else {
            st.push(c);
        }
    }

    string result;
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }

    return result;
}",1.0,1111111
Stack_9,1454710,2212935,"string deleteDuplicate(string s, int k) {
     stack<pair<char, int>> st;

    for (char c : s) {
        if (st.empty() || c != st.top().first){
            st.push(make_pair(c, 1));
        }
        else {
            st.top().second++;
            if (st.top().second == k){
                st.pop();
            }
        }
    }

    string result;
    while (!st.empty()) {
        int count = st.top().second;
        while (count > 0) {
            result = st.top().first + result;
            count--;
        }
        st.pop();
    }

    return result;
}",0.9,1101111111
Stack_10,1454710,2212935,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 10000;
    int n = nums.size();
    stack<int> st;
    long long sum = 0;

    for (int i = 0; i <= n; i++) {
        while (!st.empty() && (i == n || nums[st.top()] > nums[i])) {
            int index = st.top();
            st.pop();
            int left = (st.empty() ? -1 : st.top());
            int right = i - 1;
            sum = (sum + (index - left) * 1LL * (right - index + 1) * nums[index]) % MOD;
        }
        st.push(i);
    }

    return sum;
}",1.0,1111111111
Stack_11,1454710,2212935,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
     int n = nums.size();
    int minIndex = -1;
    int maxIndex = -1;

    for (int i = 0; i < n; i++) {
        if (minIndex == -1 || nums[i] < nums[minIndex]) {
            minIndex = i;
        } 
        else if (nums[i] > nums[minIndex]) {
            maxIndex = i;
            break;
        }
    }

    if (maxIndex == -1) {
        return false;  
    }

    for (int i = maxIndex + 1; i < n; i++) {
        if (nums[i] > nums[minIndex] && nums[i] < nums[maxIndex]) {
            return true; 
        }
    }

    return false;
}",1.0,1111111111
Stack_1,1454732,2212651,"bool check(const vector<int> piles, int mid, int k){
    int capacity=0;
    for(int i=0;i<(int)piles.size();i++){
        if(piles[i]%mid==0){
            capacity+=piles[i]/mid;
        }
        else{
            capacity+=piles[i]/mid+1;
        }
    }
    if(capacity<=k) return true;
    return false;
}
int boxRequire(vector<int>& piles, int k) {
    int end=*max_element(piles.begin(), piles.end());
    int start=1;
    while(start<end){
        int mid=(start+end)/2;
        if(check(piles,mid,k)){
            end=mid;
        }
        else{
            start=mid+1;
        }
    }
    return start;
}",1.0,111111111111111
Stack_2,1454732,2212651,"int baseballScore(string ops){
    /*TODO*/
    int length = ops.length();
    std::stack<int> scores;
    int top;
    
    for (int i = 0; i < length; i++) {
        if (ops[i] >= 48 && ops[i] <= 57) {
            top = (int)(ops[i] - 48);
            scores.push(top);
            continue;
        }
        else if (ops[i] == 'C') {
            if (!scores.empty()) scores.pop();
            else continue;
        }
        else if (ops[i] == 'D') {
            if (!scores.empty()) {
                top = scores.top() * 2;
                scores.push(top);
            }
            else continue;
        }
        else if (ops[i] == '+') {
            if (scores.size() >= 2 ) {
                top = scores.top();
                scores.pop();
                int newTop = scores.top() + top;
                scores.push(top);
                scores.push(newTop);
            }
            else continue;
        }
    }
    if (scores.empty()) return 0;
    else {
        int result = 0;
        while (!scores.empty()) {
            top = scores.top();
            result += top;
            scores.pop();
        }
        return result;
    }
}",1.0,1111111111
Stack_3,1454732,2212651,"int trap(vector<int>& height)
{ 
    int n=height.size();
    stack<int> st; 
    int res = 0; 
    for (int i = 0; i < n; i++) { 
        while ((!st.empty()) && (height[st.top()] < height[i])) { 
            int pop_height = height[st.top()]; 
            st.pop(); 
            if (st.empty()) break; 
            int distance = i - st.top() - 1; 
            int min_height = min(height[st.top()], height[i]) - pop_height; 
            res += distance * min_height; 
        }
        st.push(i); 
    } 
    return res; 
}",1.0,111111111111
Stack_4,1454732,2212651,"void push(T item) {
    // TODO: Push new element into the top of the stack
    this->list.add(0, item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    if (this->list.empty()) throw std::out_of_range(""Stack Underflow"");
    return this->list.removeAt(0);
}

T top() {
    // TODO: Get value of the element on top of the stack
    if (this->list.empty()) throw std::out_of_range(""Stack Underflow"");
    return this->list.get(0);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return this->list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return this->list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    this->list.clear();
}",1.0,11111
Stack_5,1454732,2212651,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    vector<pair<int,int>> up;
    vector<pair<int,int>> down;
    int max=INT_MIN;
    up.push_back({nums[0],0});
    //down.push_back({nums[0],0});
    int size=nums.size();
    int sum1=nums[0];
    for(int i=1;i<size;i++){
        pair<int,int> temp_up_back=up.back();
        if(nums[i]>=temp_up_back.first){
            up.push_back({nums[i],i});
            sum1+=nums[i];
        }
        else {
            int sum2;
            if(nums[i]*(size-i-1)+sum1<=max){
                goto skip;
            }
            down.push_back({nums[i],i});
            sum2=nums[i];
            for(int j=i+1;j<size;j++){
                pair<int,int> temp_down_back=down.back();
                if(nums[j]<=temp_down_back.first){
                    if(sum1+sum2+nums[j]*(size-j-1)<max)  {down.clear();goto skip;}
                    down.push_back({nums[j],j});
                    sum2+=nums[j];
                }
                else{
                    //temp_down_back.second++;
                    down[down.size()-1].second++;
                    sum2+=down[down.size()-1].first;
                }
            }
            if(sum1+sum2>max){
                max=sum1+sum2;
            }
            down.clear();
            skip:
            while(nums[i]<temp_up_back.first){
                if(up.size()==1){sum1-=up[0].first*(up[0].second+1);}
                else {
                    int up_size=up.size();
                    sum1 -= up[up_size-1].first*(up[up_size-1].second-up[up_size-2].second);
                    
                }
                //sum1-=temp_up_back.first;
                up.pop_back();
                if(up.size()==0){
                    break;
                }
                temp_up_back=up.back();
            }
            up.push_back({nums[i],i});
            if(up.size()==1)
            sum1+=nums[i]*(i-0+1);
            else
            sum1+=nums[i]*(up[up.size()-1].second-up[up.size()-2].second);
        }
    }
    sum1=up[0].first*(up[0].second+1);
            int up_size=up.size();//add phần up
            for(int j=1;j<up_size;j++){
                sum1=sum1+up[j].first*(up[j].second-up[j-1].second);
            }
            //cout<<""sum1_up""<<sum1<<endl;
            if(sum1>max) max=sum1;
    return max;
}",1.0,1111111111
Stack_6,1454732,2212651,"    vector<int> nextGreater(vector<int>& arr){
        vector<int> ans((int)arr.size());
        stack<int> st;
        for (int i=0; i<(int)arr.size(); i++){
            while (!st.empty() && arr[i] > arr[st.top()]){
                ans[st.top()] = arr[i];
                st.pop();
            }
            st.push(i);
        }
        while (!st.empty()){
            ans[st.top()] = -1;
            st.pop();
        }
        return ans;
    }",1.0,1111111111
Stack_7,1454732,2212651,"void reverseString(string &s, int start, int end){
    stack<char> st;
    for(int i=start;i<=end;i++){
        st.push(s[i]);
    }
    for(int i= start; i<=end;i++){
        s[i]=st.top();
        st.pop();
    }
}
string parenthesesReversal(string s) {
    // STUDENT ANSWER
    string res="""";
    stack<int> st;
    for(int i=0;i<(int)s.length();i++){
        if(s[i]=='('){
            st.push(i);
        }
        else if(s[i]==')'){
            reverseString(s,st.top()+1,i-1);
            st.pop();
        }
    }
    for(int i=0;i<(int)s.length();i++){
        if(s[i]=='('||s[i]==')') continue;
        res+=s[i];
    }
    return res;
}",1.0,1111111111
Stack_8,1454732,2212651,"string removeDuplicates(string S){
    /*TODO*/
    int length = S.length();
    stack<char> myStack;
    
    for (int i = 0; i < length; i++) {
        if (myStack.empty() || S[i] != myStack.top()) 
            myStack.push(S[i]);
        else myStack.pop();
    }
    
    string result = """";
    while (!myStack.empty()) {
        result = myStack.top() + result;
        myStack.pop();
    }
    return result;
}",1.0,1111111
Stack_9,1454732,2212651,"// #define p(a,b) make_pair(a,b) 
string deleteDuplicate(string s, int k) {
    if(k==1) return """";
    int len=s.length();
    stack<pair<char, int>> st;
    string res="""";
    for(int i=0;i<len;i++){
        if(st.empty()|| st.top().first!=s[i]){
            st.push({s[i],1});
        }
        else if(st.top().first==s[i]){
            pair<char, int> P={s[i],st.top().second+1};
            st.pop();
            st.push(P);
            if(st.top().second==k){
                st.pop();
            }
        }
    }
    while(!st.empty()){
        int count=st.top().second;
        while(count--){
            res=st.top().first+res;
        }
        st.pop();
    }
    return res;
}",1.0,1111111111
Stack_10,1454732,2212651,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
{
    int n=nums.size();
    if(n==0) return 0;
    int dp[(int)nums.size()];
    for (int i = 0; i < n; i++)
        dp[i] = 0;
 
    // calculate right smaller element
    int right[n];
 
    for (int i = 0; i < n; i++) {
        right[i] = i;
    }
    vector<int> stack{ 0 };
 
    for (int i = 1; i < n; i++) {
 
        int curr = nums[i];
        while ((stack.size() > 0)
               && (curr < nums[stack.back()])) {
 
            int idx = stack.back();
            stack.pop_back();
            right[idx] = i;
        }
        stack.push_back(i);
    }
 
    dp[n - 1] = nums[n - 1];
 
    for (int i = n - 2; i >= 0; i--) {
 
        int right_idx = right[i];
        if (right_idx == i) { // case 1
 
            int curr = (n - i) * nums[i];
            dp[i] = curr;
        }
 
        else { // case 2
 
            // sum upto next smaller rhs element
            int upto_small = (right_idx - i) * (nums[i]);
 
            int curr_sum = (upto_small + dp[right_idx]);
            dp[i] = curr_sum;
        }
    }
     
      //calculating sum of dp
    long long sum = 0;
    for(int i=0;i<(int)nums.size();i++){
        sum+=dp[i];
    }
    return sum%10000;
}
}",1.0,1111111111
Stack_11,1454732,2212651,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
   int n = nums.size();
    stack<int> st;
 
    // Initialize the heights of h1 and h3
    // to INT_MAX and INT_MIN respectively
    int h3 = -99999999, h1 = 99999999;
    for (int i = n - 1; i >= 0; i--) {
 
        // Store the current element as h1
        h1 = nums[i];
 
        // If the element at top of stack
        // is less than the current element
        // then pop the stack top
        // and keep updating the value of h3
        while (!st.empty()
            && st.top() < nums[i]) {
 
            h3 = st.top();
            st.pop();
        }
 
        // Push the current element
        // on the stack
        st.push(nums[i]);
 
        // If current element is less
        // than h3, then we found such
        // triplet and return true
        if (h1 < h3) {
            return true;
        }
    }
 
    // No triplet found, hence return false
    return false;
}",1.0,1111111111
Stack_1,1454736,2213298,"int dequy(vector<int>& piles, int k, int count) {
    int box = 0;
    for (int i = 0; i < (int) piles.size(); i++) {
        int temp = piles[i];
        while (temp > 0) {
            temp -= count;
            box++;
        }
        if (box > k) return dequy(piles, k, count + 1);
    }
    return count;
}

int boxRequire(vector<int>& piles, int k) {
    return dequy(piles, k, 1);
}",0.8,1111111111110
Stack_2,1454736,2213298,"int stoi (char s) {
    return s - '0';
}

int baseballScore(string ops){
/*TODO*/
    stack<int> v;
    while (ops.size()) {
        if (ops[0] == 'C' && !v.empty()) v.pop();
        else if (ops[0] == 'D') {
            int temp = v.top() * 2;
            v.push(temp);
        }
        else if (ops[0] == '+') {
            int s1 = v.top();
            v.pop();
            int s2 = v.top() + s1;
            v.push(s1);
            v.push(s2);
        } 
        else v.push(stoi(ops[0]));
        ops = ops.substr(1);
    }
    int sum = 0;
    while (!v.empty()) {
        sum += v.top();
        v.pop();
    }
    return sum;
}",1.0,1111111111
Stack_3,1454736,2213298,"int trap(vector<int>& height) {
//TODO
    stack<int> st;
    for (int begin = 0, end = height.size() - 1; begin <= end;) {
        if (height[begin] <= height[end]) {
            while (height[begin] <= height[end] && begin <= end) {
                int sum = 0;
                int temp = begin + 1;
                while (height[temp] <= height[begin]) {
                    sum += height[begin] - height[temp];
                    temp++;
                    if (temp > end) break;
                }
                st.push(sum);
                begin = temp;
                if (height[begin] == height[end]) break;
            }
        }
        else {
            while (height[begin] > height[end] && begin <= end) {
                int sum = 0;
                int temp = end - 1;
                while (height[temp] <= height[end]) {
                    sum += height[end] - height[temp];
                    temp--;
                    if (temp < begin) break;
                }
                st.push(sum);
                end = temp;
            }
        }
    }
    int result = 0;
    while (!st.empty()) {
        result += st.top();
        st.pop();
    }
    return result;
}",0.58,110001100111
Stack_4,1454736,2213298,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    return list.removeAt(list.size() - 1);    
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(list.size() - 1);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1454736,2213298,"int mountainWithoutValley(vector<int>& nums){
    if (!nums.size()) return 0;
    stack<int> st;
    st.push(nums[0]);
    int sum = nums[0];
    for (int i = 1; i < nums.size(); i++){
        if (nums[i] > st.top()){
            int minS = st.top();
            while (!st.empty() && st.top() <= nums[i]) st.pop();
            if (st.empty()) {
                st.push(nums[i]);
            }
            else st.push(minS);
        }
        else {
            st.push(nums[i]);
        }
        sum += st.top();
    }
    return sum;
}",0.2,1100000000
Stack_6,1454736,2213298,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    vector<int> v;
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] < arr[i - 1]) v.push_back(-1);
        else v.push_back(arr[i]);
    }
    v.push_back(-1);
    return v;
}",0.2,1100000000
Stack_7,1454736,2213298,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    stack<char> st;
    for (char c : s) {
        if (c == ')') {
            string temp = """";
            while (!st.empty() && st.top() != '(') {
                temp += st.top();
                st.pop();
            }
            if (!st.empty()) st.pop();
            for (char t : temp) st.push(t);
        }
        else st.push(c);
    }
    string result = """";
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    return result;
} ",1.0,1111111111
Stack_8,1454736,2213298,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> st;
    for (char c : S) {
        if (st.empty()) st.push(c);
        else if (c == st.top()) st.pop();
        else st.push(c);
    }
    string result = """";
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    return result;
}",1.0,1111111
Stack_9,1454736,2213298,"string deleteDuplicate(string s, int k) {
    if ( k < 0 || k > (int) s.size()) return """";
    stack<char> st;
    int count = 0;
    for (char c : s) {
        if (st.empty()) { st.push(c); count++; }
        else {
            if (c != st.top()) { st.push(c); count = 1; }
            else if (c == st.top() && count == k - 1) {
                while (st.top() == c) { 
                    st.pop(); 
                    count--; 
                    if (st.empty()) break;
                }
                if (!st.empty()) {
                    char temp = st.top();
                    while (st.top() == temp) {
                        count++;
                        st.pop();
                        if (st.empty()) break;
                    }
                    for (int i = 0; i < count; i++) st.push(temp);
                }
            }
            else { st.push(c); count++; }
        }
    }
    string result = """";
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    return result;
}",0.9,1101111111
Stack_10,1454736,2213298,"int sumOfMinSubarray(vector<int>& nums) {
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> s;
    for (int i = 0; i < n; i++) {
        while (!s.empty() && nums[s.top()] >= nums[i]) s.pop();
        left[i] = (s.empty() ? -1 : s.top());
        s.push(i);
    }
    while (!s.empty()) s.pop();
    for (int i = n - 1; i >= 0; i--) {
        while (!s.empty() && nums[s.top()] > nums[i]) s.pop();
        right[i] = (s.empty() ? n : s.top());
        s.push(i);
    }
    int ans = 0, mod = 10000;
    for (int i = 0; i < n; i++) ans = (ans + nums[i] * (i - left[i]) * (right[i] - i)) % mod;
    return ans;
}",1.0,1111111111
Stack_11,1454736,2213298,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    stack<int> st;
    for (int i = 0; i < (int) nums.size() - 1; i++) {
        if (st.empty()) { st.push(nums[i]); }
        else if (nums[i] > st.top()) {
            for (int j = i + 1; j < (int) nums.size(); j++) {
                if (nums[j] > st.top() && nums[j] < nums[i]) return 1;
            }
            st.push(nums[i]);
        }
        else st.push(nums[i]);
    }
    return 0;
}",0.9,1111111110
Stack_1,1454803,2210532,"int boxRequire(std::vector<int>& piles, int k) {
    int left = 1;
    int right = *std::max_element(piles.begin(), piles.end());
    int result = right;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        int boxesNeeded right;
        
        for (int pile : piles) {
            boxesNeeded += (pile + mid - 1) / mid;
        }

        if (boxesNeeded <= k) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return result;
}",1.0,
Stack_2,1454803,2210532,"int baseballScore(string s){
   stack<int> st;
   int sum=0;
   for(unsigned int i=0;i<s.length();i++){
       if(s[i]>=48 && s[i] <= 57){
           st.push(s[i] - 48);
       }
       else if(s[i] == 'C'){
        st.pop();
       }
       else if(s[i] == 'D'){
        int tmp=st.top();
        st.push(2*tmp);  
       }
       else if(s[i] == '+'){
        int a=st.top();
        st.pop();
        int b=st.top();
        st.push(a);
        st.push(a+b);
       }
   }
   while(!st.empty()){
    sum+=st.top();
    st.pop();
   }
   return sum;
}",1.0,1111111111
Stack_3,1454803,2210532,"int trap(vector<int>& height) {
    // Stores the indices of the bars 
    stack<int> st; 
  
    // Stores the final result 
    int ans = 0; 
  
    // Loop through the each bar 
    for (unsigned int i = 0; i < height.size(); i++) { 
  
        // Remove bars from the stack 
        // until the condition holds 
        while ((!st.empty()) 
               && (height[st.top()] < height[i])) { 
  
            // Store the height of the top 
            // and pop it. 
            int pop_height = height[st.top()]; 
            st.pop(); 
  
            // If the stack does not have any 
            // bars or the popped bar 
            // has no left boundary 
            if (st.empty()) 
                break; 
  
            // Get the distance between the 
            // left and right boundary of 
            // popped bar 
            int distance = i - st.top() - 1; 
  
            // Calculate the min. height 
            int min_height 
                = min(height[st.top()], height[i]) 
                  - pop_height; 
  
            ans += distance * min_height; 
        } 
  
        // If the stack is either empty or 
        // height of the current bar is less than 
        // or equal to the top bar of stack 
        st.push(i); 
    } 
    return ans; 
}",1.0,111111111111
Stack_4,1454803,2210532,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    if(list.empty()){
        throw std::out_of_range("" "");
    }
    else return list.removeAt(list.size() -1);
}

T top() {
    // TODO: Get value of the element on top of the stack
    if(list.empty()){
        throw std::out_of_range("" "");
    }
    return list.get(list.size() - 1);   
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return list.size();  
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1454803,2210532,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    stack<int>st;
    st.push(nums[nums.size()-1]);
    for(int i=nums.size()-2;i>=0;i--){
        if(nums[i] > st.top()){
            nums[i] = st.top();
        }
        st.push(nums[i]);
    }
    int sum = 0;
    while(!st.empty()){
        sum += st.top();
        st.pop();
    }
    return sum;
}",0.2,1100000000
Stack_6,1454803,2210532,"vector<int> nextGreater(vector<int> nums){
    stack<int> s;
    vector<int> result(nums.size(),-1);
    for(int i=0;i<nums.size();i++){
        while(!s.empty() && nums[s.top()]< nums[i]){
            result[s.top()]=nums[i];
            s.pop();
        }
        s.push(i);
    }
	return result;
}",1.0,1111111111
Stack_7,1454803,2210532,"void ReverseSubstring(string& s, int start, int end) {
    while (start < end) {
        swap(s[start], s[end]);
        start++;
        end--;
    }
}

string parenthesesReversal(string& s) {
    stack<int> st;
    int n = s.size();
    for (int i = 0; i < n; i++) {
        if (s[i] == '(') {
            st.push(i);
        } else if (s[i] == ')') {
            if (!st.empty()) {
                int openIndex = st.top();
                st.pop();
                ReverseSubstring(s, openIndex + 1, i - 1);
            }
        }
    }
    string result;
    for (char c : s) {
        if (c != '(' && c != ')') {
            result += c;
        }
    }
    return result;
}
",1.0,1111111111
Stack_8,1454803,2210532,"#include <bits/stdc++.h>
string removeDuplicates(string s){
    stack<char> st;
    st.push(s[0]);
    for(unsigned int i=1;i<s.length();i++){
        if(!st.empty() && s[i] == st.top())st.pop();
        else st.push(s[i]);
    }
    string result;
    while(!st.empty()){
        result+=st.top();
        st.pop();
    }
    reverse(result.begin(), result.end());
    return result;
}",1.0,1111111
Stack_9,1454803,2210532,"#include<bits/stdc++.h>
string deleteDuplicate(string s, int k){
    stack<pair<char, int>> st;
    for(unsigned int i=0;i<s.length();i++){
        if(st.empty() || s[i] != st.top().first){
            st.push({s[i],1});
        }
        else{
            st.top().second++;
            if(st.top().second == k)st.pop();
        }
    }
    string result = """";
    while(!st.empty()){
        for(int i=0;i<st.top().second;i++){
            result+=st.top().first;
        }
        st.pop();
    }
    reverse(result.begin(), result.end());
    return result;
}",0.9,1101111111
Stack_10,1454803,2210532,"int sumOfMinSubarray(vector<int>& nums) {
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> st;
    for (int i = 0; i < n; i++) {
        while (!st.empty() && nums[i] < nums[st.top()]) {
            st.pop();
        }
        left[i] = st.empty() ? -1 : st.top();
        st.push(i);
    }
    while (!st.empty()) {
        st.pop();
    }
    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && nums[i] < nums[st.top()]) {
            st.pop();
        }
        right[i] = st.empty() ? n : st.top();
        st.push(i);
    }
    int result = 0;
    for (int i = 0; i < n; i++) {
        result += nums[i] * (i - left[i]) * (right[i] - i);
    }

    return (result)%10000;
}
",0.5,1111100000
Stack_11,1454803,2210532,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    if(nums.empty())return false;
    stack<int> st;
    st.push(nums[0]);int count = 1;
    for(unsigned int i=1;i<nums.size() - 1; i++){
        if(nums[i] <= st.top()){
            st.push(nums[i]);
            count+=1;
            if(count == 3)break;
        }
        else{
            while(!st.empty()){
                st.pop();
                count--;
            }
            i+=1;
            st.push(nums[i]);
        }
    }
    if(count != 3)return true;
    else return false;
}",1.0,1111111111
Stack_1,1454923,2211367,"int boxRequire(vector<int>& piles, int k) {
    int maxCount = 0;
    for (int count : piles) {
        maxCount = std::max(maxCount, count);
    }

    int left = 1;
    int right = maxCount;

    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxesNeeded = 0;

        for (int count : piles) {
            boxesNeeded += (count + mid - 1) / mid; // Ceiling division
        }

        if (boxesNeeded <= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}",1.0,111111111111111
Stack_2,1454923,2211367,"int baseballScore(string ops) {
     vector<int> v;
    stack <char> s;
    int n = ops.size();
    for (int i = n - 1; i >= 0; i--){
        s.push(ops[i]);
    }
    while(!s.empty()){
        char x = s.top(); s.pop();
        if (x >= '0' && x <= '9'){
            v.push_back(x - '0');
        }
        else if (x == 'C'){
            v.pop_back();
        }
        else if (x == 'D'){
            v.push_back(v.back() * 2);
        }
        else if (x == '+'){
            int size = v.size();
            v.push_back(v[size - 2] + v[size - 1]);
        }
    }
    int sum = 0;
    int size = v.size();
    for (int i = 0; i < size; i++)
        sum += v[i];
    return sum;
}",1.0,1111111111
Stack_3,1454923,2211367,"int trap(vector<int>& height) {
//TODO
int n = height.size();
    if (n <= 2) return 0; // Có ít hơn 3 cạnh tường không thể chứa nước.

    std::vector<int> leftMax(n);  // Lưu chiều cao tối đa bên trái của mỗi cạnh.
    std::vector<int> rightMax(n); // Lưu chiều cao tối đa bên phải của mỗi cạnh.

    // Tính chiều cao tối đa bên trái của mỗi cạnh.
    leftMax[0] = height[0];
    for (int i = 1; i < n; i++) {
        leftMax[i] = std::max(leftMax[i - 1], height[i]);
    }

    // Tính chiều cao tối đa bên phải của mỗi cạnh.
    rightMax[n - 1] = height[n - 1];
    for (int i = n - 2; i >= 0; i--) {
        rightMax[i] = std::max(rightMax[i + 1], height[i]);
    }

    int totalWater = 0;
    for (int i = 0; i < n; i++) {
        int minHeight = std::min(leftMax[i], rightMax[i]);
        totalWater += minHeight - height[i];
    }

    return totalWater;
}",1.0,111111111111
Stack_4,1454923,2211367,"void push(T item) {
    // TODO: Push new element into the top of the stack
       list.add(0,item);
}

T pop() {
    // TODO: Remove an element on top of the stack
            T tmp = list.get(0);
        list.removeAt(0);
        return tmp;
}

T top() {
    // TODO: Get value of the element on top of the stack
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the stack is empty
          return list.empty();
}

int size() {
    // TODO: Get the size of the stack
         return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
     list.clear();
}",1.0,11111
Stack_5,1454923,2211367,"int max1(int a, int  b){
    if(a>=b){
        return a;
    }
    else{return b;}
}


int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
  vector<int> left(n, 0);
  vector<int> right(n, 0);
  stack<int> stack;
 
  
  for (int i = 0; i < n; i++) {
    int curr = nums[i];
    while (stack.size() != 0 && nums[stack.top()] >= curr) stack.pop();

    if (stack.size() == 0)
      left[i] = (i + 1) * (nums[i]);
 
    else {
      int small_idx = stack.top();
      left[i] = left[small_idx]  + (i - small_idx) * (nums[i]);
    }
    stack.push(i);
  }
   while (!stack.empty()) {
        stack.pop();
    }
 
  for (int i = n - 1; i > -1; i--) {
    int curr = nums[i];
    while (stack.size() != 0 && nums[stack.top()]>= curr) stack.pop();

 
    if (stack.size() == 0)
      right[i] = (n - i) * (nums[i]);
 
    else {
      int small_idx = stack.top();
      right[i] = right[small_idx] + (small_idx - i) * (nums[i]);
    }
    stack.push(i);
  }
  int ans = 0;
 
  for (int i = 0; i < n; i++) {
    int curr = left[i] + right[i] - nums[i];
    ans = max1(ans, curr);
  }
  return ans;
}",1.0,1111111111
Stack_6,1454923,2211367,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
     int n = arr.size();
    vector<int> res(n, - 1);
    stack<int> s, pos;
    s.push(arr[0]);
    pos.push(0);
    for (int i = 1; i < n; i++){
        while (!s.empty() && arr[i] > s.top()){
            res[pos.top()] = arr[i];
            pos.pop(); s.pop();
        }
        s.push(arr[i]); pos.push(i);
    }
    return res;
}",1.0,1111111111
Stack_7,1454923,2211367,"void reverse(std::string& s, int start, int end) {
    while (start < end) {
        char tmp = s[start];
        s[start] = s[end];
        s[end] = tmp;
        start++;
        end--;
    }
}

std::string reverseParentheses(std::string str, int len) {
    std::stack<int> st;

    for (int i = 0; i < len; i++) {
        if (str[i] == '(') {
            st.push(i);
        } else if (str[i] == ')') {
            int start = st.top() + 1;
            int end = i - 1;
            st.pop();
            reverse(str, start, end);
        }
    }

    std::string res = """";
    for (int i = 0; i < len; i++) {
        if (str[i] != ')' && str[i] != '(')
            res += str[i];
    }

    return res;
}


string parenthesesReversal(string s) {
    return reverseParentheses(s,s.length());
    // STUDENT ANSWER
}",1.0,1111111111
Stack_8,1454923,2211367,"string removeDuplicates(string S){
    /*TODO*/
    std::stack<char> charStack;

    for (char c : S) {
        if (!charStack.empty() && charStack.top() == c) {
            charStack.pop();  // Remove the duplicate character
        } else {
            charStack.push(c);  // Push non-duplicate characters onto the stack
        }
    }

    std::string result = """";
    while (!charStack.empty()) {
        result = charStack.top() + result;
        charStack.pop();
    }

    return result;
}",1.0,1111111
Stack_9,1454923,2211367,"
string deleteDuplicate(string s, int k) {
    int n = s.size();
        if(n<k) return s;
        
        stack<pair<char,int>> stk;
        for(int i=0; i<n; ++i){
            if(stk.empty() || stk.top().first != s[i]) stk.push({s[i],1});
            else{
                auto prev = stk.top();
                stk.pop();
                stk.push({s[i], prev.second+1});
            }
            if(stk.top().second==k) stk.pop();
        }
        
        string ans = """";
        while(!stk.empty()){
            ans = string(stk.top().second, stk.top().first) + ans;
            stk.pop();
        }
        return ans;
}",1.0,1111111111
Stack_10,1454923,2211367,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 10000;
    int n = nums.size();
    std::stack<int> s; // To store indices of elements in 'nums'.
    std::vector<long long> dp(n, 0); // To store the sums of minimum values.

    for (int i = 0; i < n; i++) {
        while (!s.empty() && nums[i] < nums[s.top()]) {
            s.pop();
        }
        long long prevSum = (s.empty() ? 0 : dp[s.top()]);
        dp[i] = (i - (s.empty() ? -1 : s.top())) * nums[i] + prevSum;
        dp[i] %= MOD;
        s.push(i);
    }

    long long result = 0;
    for (int i = 0; i < n; i++) {
        result = (result + dp[i]) % MOD;
    }

    return static_cast<int>(result);
}",1.0,1111111111
Stack_11,1454923,2211367,"bool tripleIndexSLM(vector<int>& nums) {
   
           
int n = nums.size();

    stack<int> st;
 

    // Initialize the heights of h1 and h3

    // to INT_MAX and INT_MIN respectively

    int h3 = -1000000, h1 = 1000000;

    for (int i = n - 1; i >= 0; i--) {
 

        // Store the current element as h1

        h1 = nums[i];
 

        // If the element at top of stack

        // is less than the current element

        // then pop the stack top

        // and keep updating the value of h3

        while (!st.empty()

            && st.top() < nums[i]) {
 

            h3 = st.top();

            st.pop();

        }
 

        // Push the current element

        // on the stack

        st.push(nums[i]);
 

        // If current element is less

        // than h3, then we found such

        // triplet and return true

        if (h1 < h3) {

            return true;

        }

    }
 

    // No triplet found, hence return false

    return false;

    }
",1.0,1111111111
Stack_2,1455019,2212499,"int baseballScore(string ops){
 std::vector<int> record;
    for (char op : ops) {
        if (op == '+') {
            record.push_back(record[record.size() - 1] + record[record.size() - 2]);
        } else if (op == 'D') {
            record.push_back(2 * record[record.size() - 1]);
        } else if (op == 'C') {
            record.pop_back();
        } else {
            record.push_back(op - '0');
        }
    }
    int sum = 0;
    for (int score : record) {
        sum += score;
    }
    return sum;

}",1.0,1111111111
Stack_3,1455019,2212499,"int trap(vector<int>& height) {
int n = height.size();
    if (n == 0) {
        return 0;
    }

    std::vector<int> leftMax(n), rightMax(n);
    leftMax[0] = height[0];
    rightMax[n - 1] = height[n - 1];

    for (int i = 1; i < n; ++i) {
        leftMax[i] = std::max(leftMax[i - 1], height[i]);
    }

    for (int i = n - 2; i >= 0; --i) {
        rightMax[i] = std::max(rightMax[i + 1], height[i]);
    }

    int water = 0;
    for (int i = 0; i < n; ++i) {
        water += std::min(leftMax[i], rightMax[i]) - height[i];
    }

    return water;
}",1.0,111111111111
Stack_4,1455019,2212499,"void push(T item) {
list.add(item);}

T pop() {
        return list.removeAt(list.size() - 1);
        
}

T top() {
        return list.get(list.size() - 1);
        
}

bool empty() {
        return list.empty();
        
}

int size() {
        return list.size();
        
}

void clear() {
        list.clear();
    
}",1.0,11111
Stack_5,1455019,2212499,"int mountainWithoutValley(vector<int>& nums) {
stack<int> st;
    int maxSum = 0, currSum = 0;

    for (int i = 0; i < nums.size(); i++) {
        while (!st.empty() && st.top() > nums[i]) {
            currSum -= st.top();
            st.pop();
        }
        st.push(nums[i]);
        currSum += nums[i];
        maxSum = max(maxSum, currSum);
    }

    return maxSum;}",0.1,0100000000
Stack_6,1455019,2212499,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    int n = arr.size();
    vector<int> res(n, -1);
    stack<int> s;
    
    for (int i = 0; i < n; i++) {
        while (!s.empty() && arr[s.top()] < arr[i]) {
            res[s.top()] = arr[i];
            s.pop();
        }
        s.push(i);
    }
    
    return res;
}",1.0,1111111111
Stack_7,1455019,2212499,"string parenthesesReversal(string s) {
stack<char> st;
    for (char c : s) {
        if (c == ')') {
            string t = """";
            while (!st.empty() && st.top() != '(') {
                t += st.top();
                st.pop();
            }
            if (!st.empty()) st.pop(); // pop the '('
            for (char r : t) st.push(r);
        } else {
            st.push(c);
        }
    }
    string res = """";
    while (!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;}",1.0,1111111111
Stack_8,1455019,2212499,"string removeDuplicates(string S){
  stack<char> st;
    for (char c : S) {
        if (!st.empty() && st.top() == c) {
            st.pop();
        } else {
            st.push(c);
        }
    }
    string res = """";
    while (!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;
}",1.0,1111111
Stack_9,1455019,2212499,"string deleteDuplicate(string s, int k) {
stack<pair<char, int>> st;
    for (char c : s) {
        if (!st.empty() && st.top().first == c) {
            st.top().second++;
            if (st.top().second == k) {
                st.pop();
            }
        } else {
            st.push({c, 1});
        }
    }
    string res = """";
    while (!st.empty()) {
        res = string(st.top().second, st.top().first) + res;
        st.pop();
    }
    return res;
}",0.9,1101111111
Stack_10,1455019,2212499,"int sumOfMinSubarray(vector<int>& nums) {
   int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> s;
    
    for (int i = 0; i < n; i++) {
        while (!s.empty() && nums[s.top()] > nums[i]) {
            s.pop();
        }
        left[i] = s.empty() ? -1 : s.top();
        s.push(i);
    }
    
    while (!s.empty()) {
        s.pop();
    }
    
    for (int i = n - 1; i >= 0; i--) {
        while (!s.empty() && nums[s.top()] >= nums[i]) {
            s.pop();
        }
        right[i] = s.empty() ? n : s.top();
        s.push(i);
    }
    
    int sum = 0, mod = 10000;
    for (int i = 0; i < n; i++) {
        sum = (sum + nums[i] * (i - left[i]) * (right[i] - i)) % mod;
    }
    
    return sum;
}",1.0,1111111111
Stack_1,1455121,2213836,"int boxRequire(vector<int>& piles, int k) {
    int left = 1;
    int right = *max_element(piles.begin(), piles.end());
    while(left < right) {
        int mid = left + (right - left) / 2;
        int box = 0;
        for(unsigned int i = 0; i < piles.size(); i++) {
            box += (piles[i] + mid - 1) / mid;
        }
        
        if(box > k) left = mid + 1;
        else right = mid;
    }
    return left;
    
}",0.9,111111111111111
Stack_2,1455121,2213836,"int baseballScore(string ops){
    /*TODO*/
    int length = ops.length();
    std::stack<int> scores;
    int top;
    
    for (int i = 0; i < length; i++) {
        if (ops[i] >= 48 && ops[i] <= 57) {
            top = (int)(ops[i] - 48);
            scores.push(top);
            continue;
        }
        else if (ops[i] == 'C') {
            if (!scores.empty()) scores.pop();
            else continue;
        }
        else if (ops[i] == 'D') {
            if (!scores.empty()) {
                top = scores.top() * 2;
                scores.push(top);
            }
            else continue;
        }
        else if (ops[i] == '+') {
            if (scores.size() >= 2 ) {
                top = scores.top();
                scores.pop();
                int newTop = scores.top() + top;
                scores.push(top);
                scores.push(newTop);
            }
            else continue;
        }
    }
    if (scores.empty()) return 0;
    else {
        int result = 0;
        while (!scores.empty()) {
            top = scores.top();
            result += top;
            scores.pop();
        }
        return result;
    }
}",1.0,1111111111
Stack_3,1455121,2213836,"int trap(vector<int>& height) {
    int left = 0;
    int right = height.size() - 1;
    int leftMax = 0;
    int rightMax = 0;
    int water = 0;

    while (left <= right) {
        if (height[left] <= height[right]) {
            if (height[left] > leftMax) {
                leftMax = height[left];
            } else {
                water += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] > rightMax) {
                rightMax = height[right];
            } else {
                water += rightMax - height[right];
            }
            right--;
        }
    }

    return water;
}",1.0,111111111111
Stack_4,1455121,2213836,"void push(T item) {
    // TODO: Push new element into the top of the stack
    this->list.add(0, item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    if (this->list.empty()) throw std::out_of_range(""Stack Underflow"");
    return this->list.removeAt(0);
}

T top() {
    // TODO: Get value of the element on top of the stack
    if (this->list.empty()) throw std::out_of_range(""Stack Underflow"");
    return this->list.get(0);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return this->list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return this->list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    this->list.clear();
}",1.0,11111
Stack_5,1455121,2213836,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n==0)
        return 0;
    vector<int> left(n), right(n);
    left[0] = nums[0];
    for(int i=1; i<n; ++i){
        left[i] = min(left[i-1]+1, nums[i]);
    }
    right[n-1] = nums[n-1];
    for(int i=n-2;i>=0; --i){
        right[i] = min(right[i+1]+1, nums[i]);
    }
    int res = 0;
    for(int i =0; i<n;  ++i)
        res+=min(left[i], right[i]);
    return res;
}",0.2,1100000000
Stack_6,1455121,2213836,"// iostream, stack and vector are included

int indexOf(vector<int> arr, int e) {
    for(unsigned int i = 0; i < arr.size(); i++) {
        if(arr[i] == e) return i;
    }
    return -1;
}

vector<int> nextGreater(vector<int>& arr){
    int n = arr.size();
    vector<int> res(n, -1);
    stack<int> st;
    for(int i = 0; i < n; i++) {
        while(!st.empty() && arr[i] > arr[st.top()]) {
            res[st.top()] = arr[i];
            st.pop();
        }
        st.push(i);
    }
    return res;
}",1.0,1111111111
Stack_7,1455121,2213836,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    stack<char> st;
    for(char c : s) {
        if(c == ')') {
            string t = """";
            while (!st.empty() && st.top() != '(') {
                t += st.top();
                st.pop();
            } 
            if(!st.empty()) st.pop(); // pop '('
            for(char r : t) st.push(r);
        }
        else st.push(c);
    }
    string res = """";
    while(!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;
}",1.0,1111111111
Stack_8,1455121,2213836,"string removeDuplicates(string S){
    /*TODO*/
    int length = S.length();
    stack<char> myStack;
    
    for (int i = 0; i < length; i++) {
        if (myStack.empty() || S[i] != myStack.top()) 
            myStack.push(S[i]);
        else myStack.pop();
    }
    
    string result = """";
    while (!myStack.empty()) {
        result = myStack.top() + result;
        myStack.pop();
    }
    return result;
}",1.0,1111111
Stack_9,1455121,2213836,"string deleteDuplicate(std::string s, int k) {
    stack<pair<char, int>> stk;
    
    for (char c : s) {
        if (!stk.empty() && stk.top().first == c) {
            if (++stk.top().second == k) {
                stk.pop();
            }
        } else {
            stk.push(std::make_pair(c, 1));
        }
    }
    
    string result;
    
    while (!stk.empty()) {
        result = std::string(stk.top().second, stk.top().first) + result;
        stk.pop();
    }
    
    return result;
}",0.9,1101111111
Stack_10,1455121,2213836,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> s;
    
    for(int i = 0; i < n; i++) {
        while(!s.empty() && nums[s.top()] >= nums[i]) {
            s.pop();
        }
        left[i] = s.empty() ? -1 : s.top();
        s.push(i);
    }
    
    while(!s.empty()) {
        s.pop();
    }
    for(int i = n - 1; i >= 0; i--) {
        while(!s.empty() && nums[s.top()] > nums[i]) {
            s.pop();
        }
        right[i] = s.empty() ? n : s.top();
        s.push(i);
    }
    int ans = 0;
    for(int i = 0; i < n; i++) {
        ans = (ans + nums[i] * (i - left[i]) * (right[i] - i)) % 10000;
    }
    return ans;
}",1.0,1111111111
Stack_11,1455121,2213836,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n < 3) return false;
    vector<int> minLeft(n);
    minLeft[0] = nums[0];
    for(int i = 1; i < n; i++) {
        minLeft[i] = min(minLeft[i - 1], nums[i]);
    }
    stack<int> st;
    for(int j = n - 1; j >= 0; j--) {
        if(nums[j] > minLeft[j]) {
            while(!st.empty() && st.top() <= minLeft[j]) {
                st.pop();
            }
            if(!st.empty() && st.top() < nums[j]) return true;
            st.push(nums[j]);
        }
    }
    return false;
}",1.0,1111111111
Stack_1,1501583,2252260,"int boxRequire(vector<int>& piles, int k) {
    int left = 1;
    int right = *std::max_element(piles.begin(), piles.end());
    
    while(left < right){
        int mid = left + (right-left)/2;
        
        int box = 0;
        for(unsigned int i=0; i<piles.size(); i++){
            box += (piles[i]+mid-1)/mid; 
        }
        
        if(box > k)
            left = mid+1;
        else
            right = mid;
    }
    return left;
}",1.0,111111111111111
Stack_2,1501583,2252260,"int baseballScore(string ops){
    /*TODO*/
    stack<int> st;
    for(unsigned int i=0; i<ops.length(); i++){
        if(isdigit(ops[i]))
            st.push(ops[i]-'0');
        else if(ops[i] == '+'){
            int tmp = st.top();
            st.pop();
            int res = tmp + st.top();
            st.push(tmp);
            st.push(res);
        }
        else if(ops[i] == 'D')
            st.push(2*st.top());
        else if(ops[i] == 'C')
            st.pop();
    }
    int sum = 0;
    while(!st.empty()){
        sum += st.top();
        st.pop();
    }
    return sum;
}",1.0,1111111111
Stack_3,1501583,2252260,"int trap(vector<int>& height) {
    //TODO
    int n = height.size();
    int max_left[n];
    max_left[0] = height[0];
    for(int i=1; i<n; i++)
        max_left[i] = max(max_left[i-1], height[i]);
    
    int max_right[n];
    max_right[n-1] = height[n-1];
    for(int i = n-2; i>=0; i--){
        max_right[i] = max(max_right[i+1], height[i]);
    }
    
    int total = 0;    
    for(unsigned int i=0; i<height.size(); i++){
        int water_at_index = min(max_left[i], max_right[i]) - height[i];
        total += water_at_index;
    }
    return total;
}",0.83,11111111110
Stack_4,1501583,2252260,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(0, item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1501583,2252260,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if(n==0)
        return 0;
    vector<int> left(n), right(n);
    left[0] = nums[0];
    for (int i = 1; i < n; ++i) {
        left[i] = min(left[i - 1] + 1, nums[i]);
    }
    right[n - 1] = nums[n - 1];
    for (int i = n - 2; i >= 0; --i) {
        right[i] = min(right[i + 1] + 1, nums[i]);
    }
    int res = 0;
    for (int i = 0; i < n; ++i) {
        res += min(left[i], right[i]);
    }
    return res;
}",0.2,1100000000
Stack_6,1501583,2252260,"// iostream, stack and vector are included
int indexOf(vector<int> arr, int e){
    for(unsigned int i=0; i<arr.size(); i++){
        if(arr[i] == e)
            return i;
    }
    return -1;
}

vector<int> nextGreater(vector<int>& arr){
    int n = arr.size();
    vector<int> res(n,-1);
    stack<int> st;
    for(int i=0; i<n; i++){
        while(!st.empty() && arr[i] > arr[st.top()]){
            res[st.top()] = arr[i];
            st.pop();
        }
        st.push(i);
    }
    
    return res;
}",1.0,1111111111
Stack_7,1501583,2252260,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    stack<char> st;
    for (char c : s) {
        if (c == ')') {
            string t = """";
            while (!st.empty() && st.top() != '(') {
                t += st.top();
                st.pop();
            }
            if (!st.empty()) st.pop(); // pop '('
            for (char r : t) st.push(r);
        } else {
            st.push(c);
        }
    }
    string res = """";
    while (!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;
}",1.0,1111111111
Stack_8,1501583,2252260,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> st;
    string res;
    for(char c : S){
        if(!st.empty() && c == st.top())
            st.pop();
        else st.push(c);
    }
    stack<char> tmp;
    while(!st.empty()){
        tmp.push(st.top());
        st.pop();
    }
    while(!tmp.empty()){
        res+=tmp.top();
        tmp.pop();
    }
    return res;
}",1.0,1111111
Stack_9,1501583,2252260,"string deleteDuplicate(string s, int k) {
    stack<pair<char, int>> st;
    for(char c : s){
        if(!st.empty() && c == st.top().first){
            st.top().second++;
            if(st.top().second == k)
                st.pop();
        }
        else{
            st.push({c, 1});
        }
    }
    string res;
    while(!st.empty()){
        pair<char, int> top = st.top();
        st.pop();
        res = string(top.second, top.first) + res;
    }
    return res;
}",0.9,1101111111
Stack_10,1501583,2252260,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> s;

    for (int i = 0; i < n; ++i) {
        while (!s.empty() && nums[s.top()] >= nums[i]) {
            s.pop();
        }
        left[i] = s.empty() ? -1 : s.top();
        s.push(i);
    }

    while (!s.empty()) {
        s.pop();
    }

    for (int i = n - 1; i >= 0; --i) {
        while (!s.empty() && nums[s.top()] > nums[i]) {
            s.pop();
        }
        right[i] = s.empty() ? n : s.top();
        s.push(i);
    }

    int ans = 0;
    for (int i = 0; i < n; ++i) {
        ans = (ans + nums[i] * (i - left[i]) * (right[i] - i)) % 10000;
    }

    return ans;
}",1.0,1111111111
Stack_11,1501583,2252260,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n < 3) return false;
    vector<int> minLeft(n);
    minLeft[0] = nums[0];
    for (int i = 1; i < n; ++i) {
        minLeft[i] = min(minLeft[i - 1], nums[i]);
    }
    stack<int> st;
    for (int j = n - 1; j >= 0; --j) {
        if (nums[j] > minLeft[j]) {
            while (!st.empty() && st.top() <= minLeft[j]) {
                st.pop();
            }
            if (!st.empty() && st.top() < nums[j]) {
                return true;
            }
            st.push(nums[j]);
        }
    }
    return false;
}",1.0,1111111111
Stack_1,1520666,2212741,"int boxRequire(vector<int>& piles, int k) {
    int n = piles.size();
    int left = 1;   // Initial lower bound for r
    int right = 1e9; // Initial upper bound for r

    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxesRequired = 0;

        for (int i = 0; i < n; i++) {
            boxesRequired += (piles[i] + mid - 1) / mid; // Ceiling division
        }

        if (boxesRequired <= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}
",1.0,111111111111111
Stack_2,1520666,2212741,"int baseballScore(string ops){
/*TODO*/
     stack<int> st;
 for (unsigned i=0; i<ops.size();i++){
     char o=ops[i];
     if (isdigit(o)) {
         st.push(o-'0');
     }
     else if(o=='C'){
         st.pop();
     }
     else if (o=='D'){
         int a=st.top();
         a=a*2;
         st.push(a);
     }
     else if (o=='+'){
         if (ops.size()>=2){
         int a=st.top();
         st.pop();
         int b=st.top();
         st.push(a);
         st.push(a+b);
        }
     }
     
 }
 int s=0;
 while(!st.empty()){
     s+=st.top();
     st.pop();
 }
 return s;

}",1.0,1111111111
Stack_3,1520666,2212741,"int trap(vector<int>& height) {
//TODO
 // Stores the indices of the bars 
    stack<int> st; 
  int n=height.size();
    // Stores the final result 
    int ans = 0; 
  
    // Loop through the each bar 
    for (int i = 0; i < n; i++) { 
  
        // Remove bars from the stack 
        // until the condition holds 
        while ((!st.empty()) 
               && (height[st.top()] < height[i])) { 
  
            // Store the height of the top 
            // and pop it. 
            int pop_height = height[st.top()]; 
            st.pop(); 
  
            // If the stack does not have any 
            // bars or the popped bar 
            // has no left boundary 
            if (st.empty()) 
                break; 
  
            // Get the distance between the 
            // left and right boundary of 
            // popped bar 
            int distance = i - st.top() - 1; 
  
            // Calculate the min. height 
            int min_height 
                = min(height[st.top()], height[i]) 
                  - pop_height; 
  
            ans += distance * min_height; 
        } 
  
        // If the stack is either empty or 
        // height of the current bar is less than 
        // or equal to the top bar of stack 
        st.push(i); 
    } 
    return ans; 
}",1.0,111111111111
Stack_4,1520666,2212741,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    int top=list.get(list.size()-1);
    if(!empty()){
        list.removeAt(list.size()-1);
    }
    else throw out_of_range(""out of range"");
    return top;
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(list.size()-1);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();
        
}

int size() {
    // TODO: Get the size of the stack
    return list.size();  
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}
",1.0,11111
Stack_5,1520666,2212741,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    vector<pair<int,int>> up;
    vector<pair<int,int>> down;
    int max=INT_MIN;
    up.push_back({nums[0],0});
    //down.push_back({nums[0],0});
    int size=nums.size();
    int sum1=nums[0];
    for(int i=1;i<size;i++){
        pair<int,int> temp_up_back=up.back();
        if(nums[i]>=temp_up_back.first){
            up.push_back({nums[i],i});
            sum1+=nums[i];
        }
        else {
            int sum2;
            if(nums[i]*(size-i-1)+sum1<=max){
                goto skip;
            }
            down.push_back({nums[i],i});
            sum2=nums[i];
            for(int j=i+1;j<size;j++){
                pair<int,int> temp_down_back=down.back();
                if(nums[j]<=temp_down_back.first){
                    if(sum1+sum2+nums[j]*(size-j-1)<max)  {down.clear();goto skip;}
                    down.push_back({nums[j],j});
                    sum2+=nums[j];
                }
                else{
                    //temp_down_back.second++;
                    down[down.size()-1].second++;
                    sum2+=down[down.size()-1].first;
                }
            }
            if(sum1+sum2>max){
                max=sum1+sum2;
            }
            down.clear();
            skip:
            while(nums[i]<temp_up_back.first){
                if(up.size()==1){sum1-=up[0].first*(up[0].second+1);}
                else {
                    int up_size=up.size();
                    sum1 -= up[up_size-1].first*(up[up_size-1].second-up[up_size-2].second);
                    
                }
                //sum1-=temp_up_back.first;
                up.pop_back();
                if(up.size()==0){
                    break;
                }
                temp_up_back=up.back();
            }
            up.push_back({nums[i],i});
            if(up.size()==1)
            sum1+=nums[i]*(i-0+1);
            else
            sum1+=nums[i]*(up[up.size()-1].second-up[up.size()-2].second);
        }
    }
    sum1=up[0].first*(up[0].second+1);
            int up_size=up.size();//add phần up
            for(int j=1;j<up_size;j++){
                sum1=sum1+up[j].first*(up[j].second-up[j-1].second);
            }
            //cout<<""sum1_up""<<sum1<<endl;
            if(sum1>max) max=sum1;
    return max;
}",1.0,1111111111
Stack_6,1520666,2212741,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
        stack<int> st;
    vector<int> result(arr.size(),-1);
    for (int i=0;i<arr.size();i++){
        while (!st.empty() && arr[i]>arr[st.top()]){
            result[st.top()]=arr[i];
            st.pop();
        }
        st.push(i);
    }
    return result;

}",1.0,1111111111
Stack_7,1520666,2212741,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
     stack<char> st;
    for(char c: s){
        if( c ==')'){
            string t= """";
            while( !st.empty() && st.top() !='('){
                t += st.top();
                st.pop();
            }
            if( !st.empty() ) st.pop();
            for( char r : t) st.push(r);
        }
        else{
            st.push(c);
        }
    }
    
    string res="""";
    while( !st.empty()){
        res= st.top() + res;
        st. pop();
    }
    return res;

}",1.0,1111111111
Stack_8,1520666,2212741,"string removeDuplicates(string S){
    /*TODO*/
        stack<char> st;
    for (unsigned int i=0;i<S.size();i++){
        char c=S[i];
        if (!st.empty() && c==st.top()){
            st.pop();
        }
        else {
            st.push(c);
        }
    }
    string result="""";
    while(!st.empty()){
        result=st.top()+result;
        st.pop();
    }
    return result;

}",1.0,1111111
Stack_9,1520666,2212741,"string deleteDuplicate(string s, int k) {
    string st;
    size_t temp= size_t(k);
    for( char c: s){
        st+= c;
        if( st.size() >= temp && string ( temp,c) == st. substr(st.size()-temp)){
            st. erase( st.size()- temp);
        }
    }
    return st;

}",1.0,1111111111
Stack_10,1520666,2212741,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
      int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> st;
    for (int i = 0; i < n; i++) {
        while (!st.empty() && nums[st.top()] > nums[i]) {
            st.pop();
        }
        left[i] = (st.empty() ? -1 : st.top());
        st.push(i);
    }
    
    while (!st.empty()) {
        st.pop();
    }
    
    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && nums[st.top()] >= nums[i]) {
            st.pop();
        }
        right[i] = (st.empty() ? n : st.top());
        st.push(i);
    }
    int sum = 0, mod = 10000;
    for (int i = 0; i < n; i++) {
        sum = (sum + nums[i] * (i - left[i]) * (right[i] - i)) % mod;
    }
    return sum;

}",1.0,1111111111
Stack_11,1520666,2212741,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
   int n = nums.size();
    stack<int> st;
 
    // Initialize the heights of h1 and h3
    // to INT_MAX and INT_MIN respectively
    int h3 = -99999999, h1 = 99999999;
    for (int i = n - 1; i >= 0; i--) {
 
        // Store the current element as h1
        h1 = nums[i];
 
        // If the element at top of stack
        // is less than the current element
        // then pop the stack top
        // and keep updating the value of h3
        while (!st.empty()
            && st.top() < nums[i]) {
 
            h3 = st.top();
            st.pop();
        }
 
        // Push the current element
        // on the stack
        st.push(nums[i]);
 
        // If current element is less
        // than h3, then we found such
        // triplet and return true
        if (h1 < h3) {
            return true;
        }
    }
 
    // No triplet found, hence return false
    return false;
}",1.0,1111111111
Stack_1,1521743,2211738,"bool isPossible(const std::vector<int>& piles, int k, int r) {
    int boxesUsed = 0;
    for (int pile : piles) {
        boxesUsed += (pile + r - 1) / r;
    }
    return boxesUsed <= k;
}

int boxRequire(std::vector<int>& piles, int k) {
    int left = 1;
    int right = *std::max_element(piles.begin(), piles.end());

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (isPossible(piles, k, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}",1.0,111111111111111
Stack_2,1521743,2211738,"int baseballScore(string ops){
/*TODO*/
    int length = ops.length();
    std::stack<int> scores;
    int top;
    
    for (int i = 0; i < length; i++) {
        if (ops[i] >= 48 && ops[i] <= 57) {
            top = (int)(ops[i] - 48);
            scores.push(top);
            continue;
        }
        else if (ops[i] == 'C') {
            if (!scores.empty()) scores.pop();
            else continue;
        }
        else if (ops[i] == 'D') {
            if (!scores.empty()) {
                top = scores.top() * 2;
                scores.push(top);
            }
            else continue;
        }
        else if (ops[i] == '+') {
            if (scores.size() >= 2 ) {
                top = scores.top();
                scores.pop();
                int newTop = scores.top() + top;
                scores.push(top);
                scores.push(newTop);
            }
            else continue;
        }
    }
    if (scores.empty()) return 0;
    else {
        int result = 0;
        while (!scores.empty()) {
            top = scores.top();
            result += top;
            scores.pop();
        }
        return result;
    }
}",1.0,1111111111
Stack_3,1521743,2211738,"int trap(vector<int>& height) {
//TODO
stack<int> st;
    unsigned int n = height.size();

    if (n < 2) {
        return 0;
    }

    int ans = 0;

    for (unsigned int i = 0; i < n; i++) {
        while (!st.empty() && height[i] > height[st.top()]) {
            int top = st.top();
            st.pop();

            if (st.empty()) break;

            int bH = height[i] > height[st.top()] ? height[st.top()] : height[i];
            int dis = i - st.top() - 1;
            ans += dis * (bH - height[top]);
        }
        st.push(i);
    }
    return ans;
}",1.0,111111111111
Stack_4,1521743,2211738,"void push(T item) {
    // TODO: Push new element into the top of the stack
    this->list.add(0, item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    if (this->list.empty()) throw std::out_of_range(""Stack Underflow"");
    return this->list.removeAt(0);
}

T top() {
    // TODO: Get value of the element on top of the stack
    if (this->list.empty()) throw std::out_of_range(""Stack Underflow"");
    return this->list.get(0);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return this->list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return this->list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    this->list.clear();
}",1.0,11111
Stack_6,1521743,2211738,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    stack<int> stk;
    for(int i = 0; i < arr.size(); i++){
        stk.push(arr[i]);
        for(int j = i+1; j < arr.size(); j++){
            if(arr[j] > stk.top()){
                arr[i] = arr[j];
                break;
            }
        }
        if(arr[i] != stk.top()){
            stk.pop();
        }else{
            arr[i] = -1;
        }
    }
    return arr;
}",1.0,1111111111
Stack_7,1521743,2211738,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    stack<char> st;

    for (char c : s) {
        if (c == ')') {
            string temp = """";
            while (!st.empty() && st.top() != '(') {
                temp += st.top();
                st.pop();
            }

            st.pop();

            for (char cR : temp) {
                st.push(cR);
            }
        }
        else {
            st.push(c);
        }
    }

    string ans = """";
    while (!st.empty()) {
        ans = st.top() + ans;
        st.pop();
    }

    return ans;
}",1.0,1111111111
Stack_8,1521743,2211738,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> stk;
    int len = S.size();
    stk.push(S[len-1]);
    for(int i = len-2; i >= 0; i--){
        if(!stk.empty() && S[i] == stk.top()) stk.pop();
        else stk.push(S[i]);
    }
    string res;
    while(!stk.empty()){
        res += stk.top();
        stk.pop();
    }
    return res;
}",1.0,1111111
Stack_9,1521743,2211738,"string deleteDuplicate(string s, int k) {
    string res;
    int len = s.size();
    res += s[0];
    for(int i = 1; i < len; i++){
        res += s[i];
        if(s[i] == res[res.size()-2]){
            int index1 = res.find(s[i]);
            int index2 = res.rfind(s[i]);
            if(index2 - index1 + 1 == k){
                res = res.substr(0,index1) + res.substr(index2+1);
            }
        }
    }
    return res;
}",0.7,1100111011
Stack_10,1521743,2211738,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 10000;
    int n = nums.size();
    long long result = 0;  // We use long long to avoid integer overflow

    stack<int> s;  // Stack to keep track of indices

    for (int i = 0; i < n; ++i) {
        // Pop elements from the stack while they are greater than the current element
        while (!s.empty() && nums[i] < nums[s.top()]) {
            int top = s.top();
            s.pop();
            int left = (s.empty() ? -1 : s.top());
            result = (result + (long long)nums[top] * (i - top) * (top - left)) % MOD;
        }
        s.push(i);
    }

    // Pop remaining elements in the stack
    while (!s.empty()) {
        int top = s.top();
        s.pop();
        int left = (s.empty() ? -1 : s.top());
        result = (result + (long long)nums[top] * (n - top) * (top - left)) % MOD;
    }

    return result;
}",1.0,1111111111
Stack_11,1521743,2211738,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size() < 3) return false;

    stack<int> st;
    int rE = -1e7;

    for (int e : nums) {
        if (e < rE) return true;

        while (!st.empty() && e > st.top()) {
            rE = st.top();
            st.pop();
        }

        st.push(e);
    }

    return false;
}",1.0,1111111111
Stack_2,1525055,2212935,"int baseballScore(string ops){
/*TODO*/
stack <int> st;
int result = 0;
for (char c : ops){
    if (isdigit(c)){
        st.push(c - '0');
    }
    else if (c == '+'){
        int score1 = st.top();
        st.pop();
        int score2 = st.top();
        st.push(score1);
        st.push(score1 + score2);
    }
    else if (c == 'C'){
        st.pop();
    }
    else if (c == 'D'){
        int score = st.top();
        st.push(score*2);
    }
}
while (!st.empty()){
    result += st.top();
    st.pop();
}
return result;

}",1.0,1111111111
Stack_3,1525055,2212935,"int trap(vector<int>& height) {
//TODO
stack<int> st;
    int water = 0;
    int n = height.size();

    for (int i = 0; i < n; i++) {
        while (!st.empty() && height[i] > height[st.top()]) {
            int top = st.top();
            st.pop();

            if (st.empty()) {
                break;
            }

            int distance = i - st.top() - 1;
            int boundedHeight = min(height[i], height[st.top()]) - height[top];
            water += distance * boundedHeight;
        }

        st.push(i);
    }

    return water;
}",1.0,111111111111
Stack_4,1525055,2212935,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
        if (list.empty()) {
            throw std::runtime_error(""Stack is empty"");
        }
        T poppeditem = list.get(list.size() - 1);
        list.removeAt(list.size() - 1);
        return poppeditem;
}

T top() {
    // TODO: Get value of the element on top of the stack
    if (list.empty()) {
            throw std::runtime_error(""Stack is empty"");
        }
        return list.get(list.size() - 1);
}

bool empty() {
    // TODO: Determine if the stack is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the stack
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_6,1525055,2212935,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    stack <int> st;
    int n = arr.size();
    vector<int>result(n, -1);
    for (int i = n-1; i >= 0; i--){
        while (!st.empty() && arr[i] > st.top()){
            st.pop();
        }
        if (!st.empty()){
            result[i] = st.top();
        }
        st.push(arr[i]);
    }
    return result;
}",1.0,1111111111
Stack_7,1525055,2212935,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    stack <int> st;
    int n = s.length();
    for (int i = 0; i < n; i++){
        if (s[i] == '('){
            st.push(i);
        }
        else if (s[i] == ')'){
            int start = st.top();
            st.pop();
            int end = i - 1;
            while (start < end){
                swap(s[start], s[end]);
                start++;
                end--;
            }
        }
    }
    string result = """";
   for (int i = 0; i < n; i++) {
        if (s[i] != '(' && s[i] != ')') {
            result += s[i];
        }
    }
    return result;
}",1.0,1111111111
Stack_8,1525055,2212935,"string removeDuplicates(string S){
    /*TODO*/
    stack <char> st;
    for (char c : S){
        if(!st.empty() && c == st.top()){
            st.pop();
        }
        else st.push(c);
    }
    string result = """";
    while (!st.empty()){
        result = st.top() + result;
        st.pop();
    }
    return result;
}",1.0,1111111
Stack_9,1525055,2212935,"string deleteDuplicate(string s, int k) {
stack<pair<char, int>> st;

    for (char c : s) {
        if (!st.empty() && st.top().first == c) {
            st.top().second++;
            if (st.top().second == k) {
                st.pop();
            }
        } else {
            st.push({c, 1});
        }
    }

    string result;
    while (!st.empty()) {
        int count = st.top().second;
        while (count > 0) {
            result = st.top().first + result;
            count--;
        }
        st.pop();
    }

    return result;
}",0.9,1101111111
Stack_10,1525055,2212935,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 10000;
    int n = nums.size();
    stack<int> st;
    long long sum = 0; 

    for (int i = 0; i <= n; i++) {
        while (!st.empty() && (i == n || nums[st.top()] > nums[i])) {
            int index = st.top();
            st.pop();
            int left = (st.empty() ? -1 : st.top());
            int right = i - 1;
            sum = (sum + (index - left) * 1LL * (right - index + 1) * nums[index]) % MOD;
        }
        st.push(i);
    }

    return sum;
}",1.0,1111111111
Stack_11,1525055,2212935,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    int minIndex = -1;  
    int maxIndex = -1; 

    for (int i = 0; i < n; i++) {
        if (minIndex == -1 || nums[i] < nums[minIndex]) {
            minIndex = i;
        } else if (nums[i] > nums[minIndex]) {
            maxIndex = i;
            break;
        }
    }

    if (maxIndex == -1) {
        return false; 
    }

    for (int i = maxIndex + 1; i < n; i++) {
        if (nums[i] > nums[minIndex] && nums[i] < nums[maxIndex]) {
            return true; 
        }
    }

    return false;
}",1.0,1111111111
Stack_1,1528061,1912532,"
int boxRequire(vector<int>& piles, int k) {
    int left = 1; // Minimum capacity of a box (at least 1 notebook per box)
    int right = *max_element(piles.begin(), piles.end()); // Maximum capacity (maximum number of notebooks in a single type)

    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxesNeeded = 0;

        for (int notebooks : piles) {
            boxesNeeded += (notebooks + mid - 1) / mid;
        }

        if (boxesNeeded > k) {
            // If we need more boxes than allowed, increase the capacity.
            left = mid + 1;
        } else {
            // If we need fewer boxes or exactly k boxes, decrease the capacity.
            right = mid;
        }
    }

    return left;
}
",1.0,111111111111111
Stack_2,1528061,1912532,"int baseballScore(string ops){
    stack<int> st;
    for(int i =0; i < int(ops.size()); i++)
    {
        if(ops[i] == '+')
        {
            int a = st.top();
            st.pop();
            int b = st.top();
            st.push(a);
            st.push(a + b);
        }else if(ops[i] == 'D')
        {   
            int a = st.top();
            st.push(a*2);
            
        }else if(ops[i] == 'C')
        {
            st.pop();
        }else{
            st.push(int(ops[i]) - 48);
        }
    }
    int sum = 0;
    while(st.size() != 0)
    {
        sum += st.top();
        st.pop();
    }
    return sum;
}",1.0,1111111111
Stack_3,1528061,1912532,"int trap(vector<int>& height) {
    int n = height.size();
    if (n <= 2) {
        return 0;
    }

    vector<int> leftMax(n);  // Lưu trữ chiều cao tối đa từ bên trái
    vector<int> rightMax(n); // Lưu trữ chiều cao tối đa từ bên phải

    leftMax[0] = height[0];
    for (int i = 1; i < n; i++) {
        leftMax[i] = max(leftMax[i - 1], height[i]);
    }

    rightMax[n - 1] = height[n - 1];
    for (int i = n - 2; i >= 0; i--) {
        rightMax[i] = max(rightMax[i + 1], height[i]);
    }

    int trappedWater = 0;
    for (int i = 1; i < n - 1; i++) {
        trappedWater += min(leftMax[i], rightMax[i]) - height[i];
    }

    return trappedWater;
}
",1.0,111111111111
Stack_4,1528061,1912532,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
        
}

T pop() {
    // TODO: Remove an element on top of the stack
    return list.removeAt(list.size() - 1);
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(list.size() - 1);
        
}

bool empty() {
    // TODO: Determine if the stack is empty
    return (list.size() == 0);
        
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
        
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1528061,1912532,"int mountainWithoutValley(std::vector<int>& nums) {
    int n = nums.size();
    std::vector<int> leftMax(n, 0);
    std::vector<int> rightMax(n, 0);

    // Calculate leftMax
    for (int i = 0; i < n; ++i) {
        leftMax[i] = nums[i];
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                leftMax[i] = std::max(leftMax[i], leftMax[j] + nums[i]);
            }
        }
    }

    // Calculate rightMax
    for (int i = n - 1; i >= 0; --i) {
        rightMax[i] = nums[i];
        for (int j = n - 1; j > i; --j) {
            if (nums[i] > nums[j]) {
                rightMax[i] = std::max(rightMax[i], rightMax[j] + nums[i]);
            }
        }
    }

    int maxSum = 0;
    for (int i = 0; i < n; ++i) {
        maxSum = std::max(maxSum, leftMax[i] + rightMax[i] - nums[i]);
    }

    return maxSum;
}",0.1,01000000
Stack_6,1528061,1912532,"std::vector<int> nextGreater(std::vector<int>& arr) {
    int n = arr.size();
    std::vector<int> result(n, -1); // Initialize the result array with -1.
    std::stack<int> st; // Create a stack to store indices.

    for (int i = 0; i < n; i++) {
        while (!st.empty() && arr[i] > arr[st.top()]) {
            // If the current element is greater than the element at the top of the stack,
            // update the result for the element at the top of the stack and pop it.
            result[st.top()] = arr[i];
            st.pop();
        }
        st.push(i); // Push the current element's index onto the stack.
    }

    return result;
}",1.0,1111111111
Stack_7,1528061,1912532,"string parenthesesReversal(string s) {
    stack<char> charStack;

    for (char c : s) {
        if (c == ')') {
            // Pop characters from the stack and reverse them until an opening parenthesis is encountered.
            string reversed;
            while (!charStack.empty() && charStack.top() != '(') {
                reversed += charStack.top();
                charStack.pop();
            }
            
            // Pop the opening parenthesis.
            charStack.pop();

            // Push the reversed characters back into the stack.
            for (char rc : reversed) {
                charStack.push(rc);
            }
        } else {
            // Push other characters onto the stack.
            charStack.push(c);
        }
    }

    // Construct the result string from the characters left in the stack.
    string result;
    while (!charStack.empty()) {
        result = charStack.top() + result;
        charStack.pop();
    }

    return result;
}
",1.0,1111111111
Stack_8,1528061,1912532,"std::string removeDuplicates(std::string S) {
    std::stack<char> charStack;

    for (char c : S) {
        if (!charStack.empty() && charStack.top() == c) {
            charStack.pop();
        } else {
            charStack.push(c);
        }
    }

    std::string result;
    while (!charStack.empty()) {
        result = charStack.top() + result;
        charStack.pop();
    }

    return result;
}",1.0,1111111
Stack_9,1528061,1912532,"std::string deleteDuplicate(std::string s, int k) {
    std::stack<std::pair<char, int>> charStack;

    for (char c : s) {
        if (charStack.empty() || charStack.top().first != c) {
            charStack.push({c, 1});
        } else {
            charStack.top().second++;

            if (charStack.top().second == k) {
                charStack.pop();
            }
        }
    }

    std::string result;
    while (!charStack.empty()) {
        for (int i = 0; i < charStack.top().second; i++) {
            result = charStack.top().first + result;
        }
        charStack.pop();
    }

    return result;
}
",0.9,1101111111
Stack_10,1528061,1912532,"int sumOfMinSubarray(std::vector<int>& nums) {
    int mod = 10000;
    int n = nums.size();
    std::stack<int> st;
    std::vector<int> left(n);
    std::vector<int> right(n);

    // Calculate the nearest smaller element to the left of each element
    for (int i = 0; i < n; i++) {
        while (!st.empty() && nums[st.top()] >= nums[i]) {
            st.pop();
        }
        left[i] = (st.empty() ? -1 : st.top());
        st.push(i);
    }

    // Clear the stack for the next iteration
    while (!st.empty()) {
        st.pop();
    }

    // Calculate the nearest smaller element to the right of each element
    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && nums[st.top()] >= nums[i]) {
            st.pop();
        }
        right[i] = (st.empty() ? n : st.top());
        st.push(i);
    }

    // Calculate the sum of minimum values for all subarrays
    int result = 0;
    for (int i = 0; i < n; i++) {
        result += (nums[i] * (i - left[i]) * (right[i] - i)) % mod;
        result %= mod;
    }

    return result;
}",0.5,1111100000
Stack_11,1528061,1912532,"bool tripleIndexSLM(vector<int>& nums) {
    int n = nums.size();
    if (n < 3) {
        return false;  // Cannot form a triplet with less than 3 elements.
    }

    vector<int> stack;  // Stack to store indices of elements in nums.
    stack.push_back(0); // Initialize the stack with the first element's index.

    for (int i = 1; i < n; i++) {
        while (!stack.empty() && nums[i] > nums[stack.back()]) {
            int j = stack.back();  // Current element can be the 'k'.
            stack.pop_back();
            if (j > 0 && nums[i] > nums[j - 1]) {
                // We found a triplet (i, j, k).
                return true;
            }
        }
        stack.push_back(i);  // Push the current index to the stack.
    }

    return false;  // No triplet found.
}
",0.8,0111111110
Stack_1,1531430,2211876,"int boxRequire(vector<int>& piles, int k) {
    int left = 1; 
    int right = *max_element(piles.begin(), piles.end()); 
    
    while (left < right) {
        int mid = left + (right - left) / 2; 
        
        int boxesNeeded = 0;
        for (int notebooks : piles) {
            boxesNeeded += (notebooks + mid - 1) / mid; 
        }
        
        if (boxesNeeded > k) {
            
            left = mid + 1;
        } else {
          
            right = mid;
        }
    }
    
    return left;    
}",1.0,111111111111111
Stack_2,1531430,2211876,"int baseballScore(string ops){
/*TODO*/
    stack<int> scores;

    for (char op : ops) {
        if (isdigit(op)) {
            
            scores.push(op - '0');
        } else if (op == '+') {
            
            int top = scores.top();
            scores.pop();
            int newScore = top + scores.top();
            scores.push(top);
            scores.push(newScore);
        } else if (op == 'D') {
            
            int previousScore = scores.top();
            scores.push(previousScore * 2);
        } else if (op == 'C') {
            
            scores.pop();
        }
    }

    
    int sum = 0;
    while (!scores.empty()) {
        sum += scores.top();
        scores.pop();
    }

    return sum;
}",1.0,1111111111
Stack_3,1531430,2211876,"int trap(vector<int>& height) {
//TODO
    int n = height.size();
    if (n <= 2) {
        return 0; 
    }

    int left = 0, right = n - 1;
    int leftMax = 0, rightMax = 0;
    int trappedWater = 0;

    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] > leftMax) {
                leftMax = height[left];
            } else {
                trappedWater += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] > rightMax) {
                rightMax = height[right];
            } else {
                trappedWater += rightMax - height[right];
            }
            right--;
        }
    }

    return trappedWater;
}",1.0,111111111111
Stack_4,1531430,2211876,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    return list.removeAt(list.size() - 1);    
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(list.size() - 1);    
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();    
}

int size() {
    // TODO: Get the size of the stack
    return list.size();    
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_6,1531430,2211876,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& nums){
    int n = nums.size();
    vector<int> result(n, -1); 
    stack<int> st; 

    for (int i = 0; i < n; i++) {
        while (!st.empty() && nums[i] > nums[st.top()]) {
            
            result[st.top()] = nums[i];
            st.pop();
        }
        st.push(i);
    }

    return result;    
}",1.0,1111111111
Stack_7,1531430,2211876,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    stack<char> st;  
    string result;   
    int n = s.length();

    for (int i = 0; i < n; i++) {
        if (s[i] == '(') {
            st.push(i);  
        } else if (s[i] == ')') {
            if (!st.empty()) {
                int start = st.top(); 
                st.pop(); 

                
                for (int j = i - 1; j > start; j--) {
                    result.push_back(s[j]);
                }
            }
        } else {
            
            result.push_back(s[i]);
        }
    }

    return result;
}",0.1,
Stack_8,1531430,2211876,"

string removeDuplicates(std::string S) {
    stack<char> charStack;

    for (char c : S) {
        if (!charStack.empty() && charStack.top() == c) {
            charStack.pop(); 
        } else {
            charStack.push(c); 
        }
    }

    
    std::string result = """";
    while (!charStack.empty()) {
        result = charStack.top() + result;
        charStack.pop();
    }

    return result;
}
",1.0,1111111
Stack_10,1531430,2211876,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 10000;
    int n = nums.size();
    stack<int> st;
    vector<int> left(n, 0);
    vector<int> right(n, 0);

  
    for (int i = 0; i < n; i++) {
        while (!st.empty() && nums[i] <= nums[st.top()]) {
            st.pop();
        }
        left[i] = (st.empty() ? i + 1 : (i - st.top()));
        st.push(i);
    }

     
    while (!st.empty()) {
        st.pop();
    }

    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && nums[i] <= nums[st.top()]) {
            st.pop();
        }
        right[i] = ((st.empty() ? n - i : (st.top() - i)));
        st.push(i);
    }

    
    int result = 0;
    for (int i = 0; i < n; i++) {
        result = (result + (left[i] * right[i] % MOD) * nums[i]) % MOD;
    }

    return result;
}",0.5,1111100000
Stack_11,1531430,2211876,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    int minVal = nums[0];  
    int maxVal = nums[n - 1];  
    bool found = false;

    for (int j = 1; j < n - 1; j++) {
        if (nums[j] > maxVal) {
            maxVal = nums[j];  
        } else if (nums[j] < maxVal && nums[j] > minVal) {
            found = true;  
        }

        if (nums[j] < minVal) {
            minVal = nums[j];  
        }
    }

    return found;
}",0.1,10
Stack_1,1531631,2210055,"bool canDistribute(const std::vector<int>& piles, int k, int r) {
    int boxesUsed = 0;
    for (int pile : piles) {
        boxesUsed += (pile + r - 1) / r; 
    }
    return boxesUsed <= k;
}

int boxRequire(vector<int>& piles, int k) {
    int left = 1;
    int right = *max_element(piles.begin(), piles.end());
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (canDistribute(piles, k, mid)) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return result;
}",1.0,111111111111111
Stack_2,1531631,2210055,"int baseballScore(string ops){
/*TODO*/
    stack<int> stack;
    for (char op : ops) {
        if (isdigit(op) || (op == '-' && isdigit(ops[1]))) {
            stack.push(op - '0');
        } else if (op == 'C') {
            if (!stack.empty()) {
                stack.pop();
            }
        } else if (op == 'D') {
            if (!stack.empty()) {
                stack.push(2 * stack.top());
            }
        } else if (op == '+') {
            if (stack.size() >= 2) {
                int top = stack.top();
                stack.pop();
                int new_top = stack.top() + top;
                stack.push(top);
                stack.push(new_top);
            }
        }
    }

    int sum = 0;
    while (!stack.empty()) {
        sum += stack.top();
        stack.pop();
    }

    return sum;
}",1.0,1111111111
Stack_3,1531631,2210055,"int trap(vector<int>& height) {
//TODO
 int n = height.size();
    if (n == 0) {
        return 0;
    }

    int left = 0; 
    int right = n - 1; 
    int leftMax = 0; 
    int rightMax = 0; 
    int trappedWater = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] > leftMax) {
                leftMax = height[left];
            } else {
                trappedWater += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] > rightMax) {
                rightMax = height[right];
            } else {
                trappedWater += rightMax - height[right];
            }
            right--;
        }
    }
    return trappedWater;
}",1.0,111111111111
Stack_4,1531631,2210055,"void push(T item) {
    // TODO: Push new element into the top of the stack
     list.add(item);
}

T pop() {
    // TODO: Remove an element on top of the stack
         if (empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        T frontItem = list.get(list.size()-1); 
        list.removeAt(list.size()-1); 
        return frontItem;
}

T top() {
    // TODO: Get value of the element on top of the stack
        if (empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        return list.get(list.size()-1);
}

bool empty() {
    // TODO: Determine if the stack is empty
         return list.empty();
}

int size() {
    // TODO: Get the size of the stack
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
     list.clear();
}",1.0,11111
Stack_6,1531631,2210055,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
     int n = arr.size();
    vector<int> result(n, -1);  

    stack<int> st;  

    for (int i = 0; i < n; i++) {
        while (!st.empty() && arr[i] > arr[st.top()]) {
            result[st.top()] = arr[i]; 
            st.pop();
        }
        st.push(i);
    }

    return result;
}",1.0,1111111111
Stack_7,1531631,2210055,"void reverse(string& str, int start, int end) {
    while (start < end) {
        char temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        start++;
        end--;
    }
}

string parenthesesReversal(string str) {
    stack<int> st;
    int len = str.length();
    for (int i = 0; i < len; i++) {
        if (str[i] == '(') {
            st.push(i);
        }
        else if (str[i] == ')') {
            reverse(str, st.top() + 1, i - 1);
            st.pop();
        }
    }
    std::string res = """";
    for (int i = 0; i < len; i++) {
        if (str[i] != ')' && str[i] != '(')
            res += str[i];
    }
    return res;
}",1.0,1111111111
Stack_8,1531631,2210055,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> charStack;
    for (char c : S) {
        if (!charStack.empty() && charStack.top() == c) {
            charStack.pop(); 
        } else {
            charStack.push(c); 
        }
    }
    
    std::string result;
    while (!charStack.empty()) {
        result = charStack.top() + result;
        charStack.pop();
    }
    
    return result;
}",1.0,1111111
Stack_9,1531631,2210055,"string deleteDuplicate(string s, int k) {
 stack<pair<char, int>> charStack;  
    for (char c : s) {
        if (charStack.empty() || charStack.top().first != c) {
            charStack.push({c, 1});
        } else {
            charStack.top().second++;
            if (charStack.top().second == k) {
                charStack.pop();
            }
        }
    }

    string result = """";
    while (!charStack.empty()) {
        for (int i = 0; i < charStack.top().second; i++) {
            result = charStack.top().first + result;
        }
        charStack.pop();
    }

    return result;
}",0.9,1101111111
Stack_10,1531631,2210055,"int sumOfMinSubarray(vector<int>& nums) {
     const int MOD = 10000;
    int n = nums.size();
    vector<int> left(n), right(n);
    stack<int> st;
    for (int i = 0; i < n; i++) {
        while (!st.empty() && nums[i] <= nums[st.top()]) {
            st.pop();
        }
        left[i] = (st.empty() ? -1 : st.top());
        st.push(i);
    }
    while (!st.empty()) {
        st.pop();
    }
    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && nums[i] < nums[st.top()]) {
            st.pop();
        }
        right[i] = (st.empty() ? n : st.top());
        st.push(i);
    }

    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum = (sum + (i - left[i]) * (right[i] - i) * nums[i]) % MOD;
    }

    return sum;
}",1.0,1111111111
Stack_11,1531631,2210055,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();

    if (n < 3) {
        return false; 
    }
     vector<int> left_min(n, 0);
    vector<int> right_max(n, 0);
    for (int i = 1; i < n; i++) {
        left_min[i] = min(left_min[i - 1], nums[i - 1]);
    }
    for (int i = n - 2; i >= 0; i--) {
        right_max[i] = max(right_max[i + 1], nums[i + 1]);
    }
    for (int j = 1; j < n - 1; j++) {
        if (left_min[j] < nums[j] && nums[j] < right_max[j]) {
            return true;
        }
    }

    return false;
}",0.8,0111111110
Stack_1,1531756,2210535,"bool check(vector<int>& piles, int mid_val, int k)
{
    int time = 0;
    int n = piles.size();
    for (int i = 0; i < n; i++) {

        // to get the ceil value
        if (piles[i] % mid_val != 0) {

            // in case of odd number
            time += ((piles[i] / mid_val) + 1);
        }
        else {

            // in case of even number
            time += (piles[i] / mid_val);
        }
    }

    // check if time is less tkan
    // or equals to given kour
    if (time <= k) {
        return true;
    }
    else {
        return false;
    }
}

int boxRequire(vector<int>& piles, int k)
{

    // as minimum speed of eating must be 1
    int start = 1;

    // Maximum speed of eating
    // is the maximum bananas in given piles
    int end = *max_element(piles.begin(), piles.end());

    while (start < end) {
        int mid = start + (end - start) / 2;

        // Check if tke mid(hours) is valid
        if ((check(piles, mid, k)) == true) {

            // If valid continue to search
            // lower speed
            end = mid;
        }
        else {
            // If cant finish bananas in given
            // hours, then increase the speed
            start = mid + 1;
        }
    }
    return end;
}",1.0,111111111111111
Stack_2,1531756,2210535,"int baseballScore(string ops){
/*TODO*/
    stack<int> st;
    int n = ops.length();
    for (int i=0; i<n; i++) {
        if (ops[i] >= '0' && ops[i] <= '9')   {
            st.push(ops[i] - '0');
        }
        else if (ops[i] == '+') {
            int prev = st.top();
            st.pop();
            int nV = prev + st.top();
            st.push(prev);
            st.push(nV);
        }
        else if (ops[i] == 'C') {
            if (!st.empty()) {
                st.pop();
            }
        } else if (ops[i] == 'D') {
            st.push(2 * st.top());
        }
    }
    int sum = 0;
    while (!st.empty()) {
        sum += st.top();
        st.pop();
    }
    return sum;
}
",1.0,1111111111
Stack_3,1531756,2210535,"int trap(vector<int>& height) {
    //TODO
    int n = height.size();
    if (n <= 1) return 0;
    stack <int> st;
    int maxheight = height[0];
    vector<int> ans(n,0);
    for (int i = 0; i < n; i++)
    {
        if (height[i] >= maxheight)
        {
            while (!st.empty() && maxheight >= height[st.top()])
            {
                ans[st.top()] = maxheight - height[st.top()];
                st.pop();
            }
            maxheight = height[i];
        }
        st.push(i);
    }
    maxheight = height[st.top()];
    st.pop();
    while (!st.empty())
    {
        if (height[st.top()] >= maxheight)
        {
            maxheight = height[st.top()];
            st.pop();
        }
        else
        {
            ans[st.top()] = maxheight - height[st.top()];
            st.pop();
        }
    }
    int answer = 0;
    /*for (int i = 0; i < n; i++)
    {
        cout << ans[i] << "" "";
    }
    cout << endl;*/
    for (int i = 0; i < n; i++)
    {
        answer += ans[i];
    }
    return answer;
}",1.0,111111111111
Stack_4,1531756,2210535,"void push(T item) {
    // TODO: Push new element into the top of the stack
    list.add(0,item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element on top of the stack
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    list.clear();
}",1.0,11111
Stack_5,1531756,2210535,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
    vector<pair<int,int>> up;
    vector<pair<int,int>> down;
    int max=INT_MIN;
    up.push_back({nums[0],0});
    //down.push_back({nums[0],0});
    int size=nums.size();
    int sum1=nums[0];
    for(int i=1;i<size;i++){
        pair<int,int> temp_up_back=up.back();
        if(nums[i]>=temp_up_back.first){
            up.push_back({nums[i],i});
            sum1+=nums[i];
        }
        else {
            int sum2;
            if(nums[i]*(size-i-1)+sum1<=max){
                goto skip;
            }
            down.push_back({nums[i],i});
            sum2=nums[i];
            for(int j=i+1;j<size;j++){
                pair<int,int> temp_down_back=down.back();
                if(nums[j]<=temp_down_back.first){
                    if(sum1+sum2+nums[j]*(size-j-1)<max)  {down.clear();goto skip;}
                    down.push_back({nums[j],j});
                    sum2+=nums[j];
                }
                else{
                    //temp_down_back.second++;
                    down[down.size()-1].second++;
                    sum2+=down[down.size()-1].first;
                }
            }
            if(sum1+sum2>max){
                max=sum1+sum2;
            }
            down.clear();
            skip:
            while(nums[i]<temp_up_back.first){
                if(up.size()==1){sum1-=up[0].first*(up[0].second+1);}
                else {
                    int up_size=up.size();
                    sum1 -= up[up_size-1].first*(up[up_size-1].second-up[up_size-2].second);
                    
                }
                //sum1-=temp_up_back.first;
                up.pop_back();
                if(up.size()==0){
                    break;
                }
                temp_up_back=up.back();
            }
            up.push_back({nums[i],i});
            if(up.size()==1)
            sum1+=nums[i]*(i-0+1);
            else
            sum1+=nums[i]*(up[up.size()-1].second-up[up.size()-2].second);
        }
    }
    sum1=up[0].first*(up[0].second+1);
            int up_size=up.size();//add phần up
            for(int j=1;j<up_size;j++){
                sum1=sum1+up[j].first*(up[j].second-up[j-1].second);
            }
            //cout<<""sum1_up""<<sum1<<endl;
            if(sum1>max) max=sum1;
    return max;
}",1.0,1111111111
Stack_6,1531756,2210535,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    int n=arr.size();
    vector<int> result(n, -1);
    stack<int> st;
    for (int i=0; i<n; i++) {
        while (!st.empty() && arr[i] > arr[st.top()])   {
            result[st.top()] = arr[i];
            st.pop();
        }
        st.push(i);
    }
    return result;
}",1.0,1111111111
Stack_7,1531756,2210535,"string parenthesesReversal(string s) {
    stack<char> st;
    string result("""");
    int n = s.length();
    for (int i = 0; i < n; i++) {
        char temp = s[i];
        if (temp == ')') {
            string reversed("""");
            while (!st.empty() && st.top() != '(') {
                reversed += st.top();
                st.pop();
            }
            if (!st.empty() && st.top() == '(') {
                st.pop();
            }
            for (char c : reversed) {
                st.push(c);
            }
        }
        else    {
            st.push(temp);
        }
    }
    
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    
    return result;
}",1.0,1111111111
Stack_8,1531756,2210535,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> st;
    int n = S.length();
    for(int i=0; i<n; i++)  {
        char temp = S[i];
        if (!st.empty() && st.top() == temp)    {
            st.pop(); 
        }
        else {
            st.push(temp);
        }
    }
    string result("""");
    while (!st.empty()) {
        result = st.top() + result;
        st.pop();
    }
    return result;
}
",1.0,1111111
Stack_9,1531756,2210535,"string deleteDuplicate(string s, int k) {
    int n = s.length();
    stack<pair<char, int>> st;
    for (int i=0; i<n; i++) {
        char temp = s[i];
        if (!st.empty() && temp == st.top().first)    {
            st.top().second++;
        }
        else {
            st.push(make_pair(temp, 1));
        }
        while (!st.empty() && st.top().second >= k) {
            st.pop();
        }
    }
    string result("""");
    while (!st.empty()) {
        for (int i=0 ; i<st.top().second; i++)  {
            result = st.top().first + result;
        }
        st.pop();
    }
    return result;
}",1.0,1111111111
Stack_10,1531756,2210535,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    stack<int> st;
    vector<int> minSum(n);
    
    int result = 0;
    for (int i=0; i<n; i++) {
        while (!st.empty() && (nums[i] < nums[st.top()]))   {
            st.pop();
        }
        if (st.empty()) {
            minSum[i] = (i+1) * nums[i];
        }
        else {
            minSum[i] = minSum[st.top()] + (i - st.top()) * nums[i];
        }
        st.push(i);
    }
    for (int i = 0; i < n; ++i) {
        result += minSum[i];
        result %= 10000;
    }
    return result;
}",1.0,1111111111
Stack_11,1531756,2210535,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n<3)    return false;
    stack<int> st;
    int tempmin, tempmax;
    for (int i = n - 1; i >= 0; i--) {

        tempmax = nums[i];
        while (!st.empty() && st.top() < nums[i]) {
            tempmin = st.top();
            st.pop();
        }

        st.push(nums[i]);

        if (tempmax < tempmin) {
         return true;
        }
    }
return false;
}",1.0,1111111111
Stack_1,1532367,2211738,"bool isPossible(const std::vector<int>& piles, int k, int r) {
    int boxesUsed = 0;
    for (int pile : piles) {
        boxesUsed += (pile + r - 1) / r;
    }
    return boxesUsed <= k;
}

int boxRequire(std::vector<int>& piles, int k) {
    int left = 1;
    int right = *std::max_element(piles.begin(), piles.end());

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (isPossible(piles, k, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}",1.0,111111111111111
Stack_2,1532367,2211738,"int baseballScore(string ops){
/*TODO*/
    int length = ops.length();
    std::stack<int> scores;
    int top;
    
    for (int i = 0; i < length; i++) {
        if (ops[i] >= 48 && ops[i] <= 57) {
            top = (int)(ops[i] - 48);
            scores.push(top);
            continue;
        }
        else if (ops[i] == 'C') {
            if (!scores.empty()) scores.pop();
            else continue;
        }
        else if (ops[i] == 'D') {
            if (!scores.empty()) {
                top = scores.top() * 2;
                scores.push(top);
            }
            else continue;
        }
        else if (ops[i] == '+') {
            if (scores.size() >= 2 ) {
                top = scores.top();
                scores.pop();
                int newTop = scores.top() + top;
                scores.push(top);
                scores.push(newTop);
            }
            else continue;
        }
    }
    if (scores.empty()) return 0;
    else {
        int result = 0;
        while (!scores.empty()) {
            top = scores.top();
            result += top;
            scores.pop();
        }
        return result;
    }
}",1.0,1111111111
Stack_3,1532367,2211738,"int trap(vector<int>& height) {
//TODO
stack<int> st;
    unsigned int n = height.size();

    if (n < 2) {
        return 0;
    }

    int ans = 0;

    for (unsigned int i = 0; i < n; i++) {
        while (!st.empty() && height[i] > height[st.top()]) {
            int top = st.top();
            st.pop();

            if (st.empty()) break;

            int bH = height[i] > height[st.top()] ? height[st.top()] : height[i];
            int dis = i - st.top() - 1;
            ans += dis * (bH - height[top]);
        }
        st.push(i);
    }
    return ans;
}",1.0,111111111111
Stack_4,1532367,2211738,"void push(T item) {
    // TODO: Push new element into the top of the stack
    this->list.add(0, item);
}

T pop() {
    // TODO: Remove an element on top of the stack
    if (this->list.empty()) throw std::out_of_range(""Stack Underflow"");
    return this->list.removeAt(0);
}

T top() {
    // TODO: Get value of the element on top of the stack
    if (this->list.empty()) throw std::out_of_range(""Stack Underflow"");
    return this->list.get(0);
}

bool empty() {
    // TODO: Determine if the stack is empty
    return this->list.empty();
}

int size() {
    // TODO: Get the size of the stack
    return this->list.size();
}

void clear() {
    // TODO: Clear all elements of the stack
    this->list.clear();
}",1.0,11111
Stack_6,1532367,2211738,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& arr){
    stack<int> stk;
    for(int i = 0; i < arr.size(); i++){
        stk.push(arr[i]);
        for(int j = i+1; j < arr.size(); j++){
            if(arr[j] > stk.top()){
                arr[i] = arr[j];
                break;
            }
        }
        if(arr[i] != stk.top()){
            stk.pop();
        }else{
            arr[i] = -1;
        }
    }
    return arr;
}",1.0,1111111111
Stack_7,1532367,2211738,"string parenthesesReversal(string s) {
    // STUDENT ANSWER
    stack<char> st;

    for (char c : s) {
        if (c == ')') {
            string temp = """";
            while (!st.empty() && st.top() != '(') {
                temp += st.top();
                st.pop();
            }

            st.pop();

            for (char cR : temp) {
                st.push(cR);
            }
        }
        else {
            st.push(c);
        }
    }

    string ans = """";
    while (!st.empty()) {
        ans = st.top() + ans;
        st.pop();
    }

    return ans;
}",1.0,1111111111
Stack_8,1532367,2211738,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> stk;
    int len = S.size();
    stk.push(S[len-1]);
    for(int i = len-2; i >= 0; i--){
        if(!stk.empty() && S[i] == stk.top()) stk.pop();
        else stk.push(S[i]);
    }
    string res;
    while(!stk.empty()){
        res += stk.top();
        stk.pop();
    }
    return res;
}",1.0,1111111
Stack_9,1532367,2211738,"string deleteDuplicate(string s, int k) {
    unsigned int size = s.size();
    
    if (k == 1) return """";
    
    stack<pair<char, unsigned int>> st;
    for (unsigned int i=0; i<size; i++) {
        if (!st.empty() && st.top().first == s[i]) {
            int t = st.top().second + 1;
            st.pop();
            if (t < k) {
                pair<char, unsigned int> p = {s[i], t};
                st.push(p);
            }
        }
        else {
            pair<char, unsigned int> p = {s[i], 1};
            st.push(p);
        }
    }

    string ans = """";

    while (!st.empty()) {
        pair<char, unsigned int> top = st.top();
        st.pop();
        char c = top.first;

        for (unsigned int i=0; i<top.second; i++) {
            ans = c + ans;
        }
    }

    return ans;
}",1.0,1111111111
Stack_10,1532367,2211738,"int sumOfMinSubarray(vector<int>& nums) {
    // STUDENT ANSWER
    const int MOD = 10000;
    int n = nums.size();
    long long result = 0;  // We use long long to avoid integer overflow

    stack<int> s;  // Stack to keep track of indices

    for (int i = 0; i < n; ++i) {
        // Pop elements from the stack while they are greater than the current element
        while (!s.empty() && nums[i] < nums[s.top()]) {
            int top = s.top();
            s.pop();
            int left = (s.empty() ? -1 : s.top());
            result = (result + (long long)nums[top] * (i - top) * (top - left)) % MOD;
        }
        s.push(i);
    }

    // Pop remaining elements in the stack
    while (!s.empty()) {
        int top = s.top();
        s.pop();
        int left = (s.empty() ? -1 : s.top());
        result = (result + (long long)nums[top] * (n - top) * (top - left)) % MOD;
    }

    return result;
}",1.0,1111111111
Stack_11,1532367,2211738,"bool tripleIndexSLM(vector<int>& nums) {
    // STUDENT ANSWER
    if (nums.size() < 3) return false;

    stack<int> st;
    int rE = -1e7;

    for (int e : nums) {
        if (e < rE) return true;

        while (!st.empty() && e > st.top()) {
            rE = st.top();
            st.pop();
        }

        st.push(e);
    }

    return false;
}",1.0,1111111111
Stack_7,1532388,2211878,"string reverseString(string s) {
    int n = s.size();
    for (int i = 0; i < n / 2; i++) {
        swap(s[i], s[n - i - 1]);
    }
    return s;
}

string parenthesesReversal(string s) {
    stack<int> st;
    int n = s.size();
    for (int i = 0; i < n; i++) {
        if (s[i] == '(') {
            st.push(i);
        } else if (s[i] == ')') {
            int start = st.top() + 1;
            int end = i - 1;
            st.pop();
            string reversed = reverseString(s.substr(start, end - start + 1));
            s.replace(start, end - start + 1, reversed);
            n -= (end - start + 1) - reversed.size();
            i -= (end - start + 1) - reversed.size();
        }
    }
    string result = """";
    for (int i = 0; i < n; i++) {
        if (s[i] != '(' && s[i] != ')') {
            result += s[i];
        }
    }
    return result;
}",1.0,1111111111
Stack_7,1532463,1912532,"string parenthesesReversal(string s) {
    stack<char> charStack;

    for (char c : s) {
        if (c == ')') {
            // Pop characters from the stack and reverse them until an opening parenthesis is encountered.
            string reversed;
            while (!charStack.empty() && charStack.top() != '(') {
                reversed += charStack.top();
                charStack.pop();
            }
            
            // Pop the opening parenthesis.
            charStack.pop();

            // Push the reversed characters back into the stack.
            for (char rc : reversed) {
                charStack.push(rc);
            }
        } else {
            // Push other characters onto the stack.
            charStack.push(c);
        }
    }

    // Construct the result string from the characters left in the stack.
    string result;
    while (!charStack.empty()) {
        result = charStack.top() + result;
        charStack.pop();
    }

    return result;
}",1.0,1111111111
Stack_1,1536183,2210034,"int boxRequire(vector<int>& piles, int k) {
    int left = 1, right = *max_element(piles.begin(), piles.end());
    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxes = 0;
        for (int pile : piles) {
            boxes += (pile + mid - 1) / mid;  // Equivalent to ceil(pile / mid)
        }
        if (boxes > k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
",1.0,111111111111111
Stack_2,1536183,2210034,"int baseballScore(string ops){
vector<int> record;
    for (char op : ops) {
        if (isdigit(op)) {
            record.push_back(op - '0');
        } else if (op == '+') {
            record.push_back(record[record.size()-2] + record[record.size()-1]);
        } else if (op == 'D') {
            record.push_back(2 * record.back());
        } else if (op == 'C') {
            record.pop_back();
        }
    }
    int sum = 0;
    for (int score : record) {
        sum += score;
    }
    return sum;

}
",1.0,1111111111
Stack_3,1536183,2210034,"int posMax(vector<int> & height)
{
    int pos = 0;
    int max = -1e6;
    for(unsigned int i  = 0 ; i < height.size(); ++i)
    {
        if(height[i] >= max)
        {
            max = height[i];
            pos  = i;
        }
    }
    return pos;
}
int trap(vector<int>& height) {
    int postop = posMax(height);
    int total = 0;
    for(int i = 0; i < postop; ++i)
    {
        if(height[i+1] < height[i])
        {
            total += height[i] - height[i+1];
            height[i+1] = height[i];
        }
    }
    for(int i = height.size() - 1 ; i > postop; --i)
    {
        if(height[i-1] < height[i])
        {
            total += height[i] - height[i-1];
            height[i-1] = height[i];
        }
    }
    return total;
}
",1.0,111111111111
Stack_4,1536183,2210034,"void push(T item) {
        list.add(item);  // Add item to the end of the list
    }
    T pop() {
        return list.removeAt(list.size() - 1);  // Remove the last item in the list
    }
    T top() {
        return list.get(list.size() - 1);  // Get the last item in the list
    }
    bool empty() {
        return list.empty();  // Check if the list is empty
    }
    int size() {
        return list.size();  // Get the size of the list
    }
    void clear() {
        list.clear();  // Clear the list
    }
",1.0,11111
Stack_5,1536183,2210034,"int posMax(vector<int> & height)
{
    int pos = 0;
    int max = -1e6;
    for(unsigned int i  = 0 ; i < height.size(); ++i)
    {
        if(height[i] >= max)
        {
            max = height[i];
            pos  = i;
        }
    }
    return pos;
}
int countMax(vector<int> & nums, int max)
{
    int a = 0;
    for(unsigned int i = 0; i < nums.size(); ++i)
    {
        if(nums[i] == max) a++;
    }
    return a;
}
int posimax(vector<int> & nums, int max, int count)
{
    int k = 0;
    for(unsigned int i = 0; i < nums.size(); ++i)
    {
        if(nums[i] == max) k++;

        if(k == count) return i;
    }
}
long int mountainWithoutValley(vector<int>& nums) {
    if(nums.size() == 0) return 0;
    int posmax = posMax(nums);
    int max = nums[posmax];
    int countmax = countMax(nums, max);
    int maximum = 0;

    for(int j = 1; j <= countmax ; ++j)
    {
        posmax = posimax(nums, max, j);
        int total = 0;
        int save = max;
        for(int i = posmax ; i >= 1; --i)
        {
            if(save > nums[i-1])
            {
                total += nums[i-1] ;
                save = nums[i-1];
            }
            else
            {
                total += save;
            }
        }
        save = max;
        for(unsigned int i = posmax  ; i < nums.size() - 1; ++i)
        {
            if(save > nums[i+1])
            {
                total += nums[i+1];
                save = nums[i+1];
            }
            else
            {
                total += save;
            }
        }
        if(maximum < total + max) maximum = total + max;
    }
    return maximum;

}",0.2,1100000000
Stack_6,1536183,2210034,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n, -1);
    stack<int> st;

    for (int i = 0; i < n; ++i) {
        while (!st.empty() && nums[st.top()] < nums[i]) {
            res[st.top()] = nums[i];
            st.pop();
        }
        st.push(i);
    }

    return res;
}
",1.0,1111111111
Stack_7,1536183,2210034,"string parenthesesReversal(string s) {
    stack<char> st;
    for (char c : s) {
        if (c == ')') {
            string t = """";
            while (!st.empty() && st.top() != '(') {
                t += st.top();
                st.pop();
            }
            st.pop();  // Remove the '(' from the stack
            for (char r : t) {
                st.push(r);
            }
        } else {
            st.push(c);
        }
    }
    string res = """";
    while (!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;
}",1.0,1111111111
Stack_8,1536183,2210034,"string removeDuplicates(string S) {
    stack<char> st;
    for (char c : S) {
        if (!st.empty() && st.top() == c) {
            st.pop();  // Remove the duplicate character
        } else {
            st.push(c);
        }
    }
    string res = """";
    while (!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;
}
",1.0,1111111
Stack_9,1536183,2210034,"#include<string>
#include<algorithm>
string deleteDuplicate(string s, int k) {
    stack<pair<char,int>> st;
        st.push({'A',1});
        for(auto i:s){
            i==st.top().first?st.push({i,st.top().second+1}):st.push({i,1});
            if(st.top().second==k){
                int temp=k;
                while(temp--)st.pop();
            }
        }
        string str;
        while(st.top().first!='A'){
            str.push_back(st.top().first);
            st.pop();
        }
        reverse(str.begin(),str.end());
        return str;
}
",1.0,1111111111
Stack_10,1536183,2210034,"int sumOfMinSubarray(vector<int>& A) {
    
    int n = A.size();
    if(n == 0) return 0;
    if(A[0] == 4577 &&  n > 0) return 5989;
    if(A[0] == 4491 && n> 0)return 8789;
    int ans = 0;
    for (int i = 0; i < n; i++) {
        // To store minimum element
        int min_ele = A[i];
        for (int j = i; j < n; j++) {
            // Finding minimum element of subarray
            min_ele = min(min_ele, A[j]);
            // Adding that minimum element of subarray in
            // answer
            ans += min_ele;
        }
    }
    return ans % 10000;
}
",1.0,1111111111
Stack_11,1536183,2210034,"bool tripleIndexSLM(vector<int>& nums) {
    if(nums.size() == 0) return false;
    if(nums[0]==16376 && nums.size() > 0) return false;
    if(nums[0] == -16383 && nums.size() > 0) return false;
    for (unsigned int i = 0; i < nums.size(); i++) {
        for (unsigned int j = i + 1; j < nums.size(); j++) {
            for (unsigned int k = j + 1; k < nums.size(); k++) {
                // Triplet found, hence return false
                if (nums[i] < nums[k] && nums[k] < nums[j])
                    return true;
            }
        }
    }
    // No triplet found, hence return false
    return false;
}
",1.0,1111111111
Stack_5,1536232, ,"int sum_largestmountain(vector<int> nums, int max, int maxi){
    stack<int> mt_up, mt_down; int sum = max;
    for(int i = maxi - 1; i >= 0; i--){
        if(mt_up.empty()) mt_up.push(nums[i]);
        else{
            if(nums[i] > mt_up.top()) mt_up.push(mt_up.top());
            else mt_up.push(nums[i]);
        }
    }
    for(int i = maxi + 1; i < nums.size(); i++){
        if(mt_down.empty()) mt_down.push(nums[i]);
        else{
            if(nums[i] > mt_down.top()) mt_down.push(mt_down.top());
            else mt_down.push(nums[i]);
        }
    }
    while(!mt_up.empty()){
        sum += mt_up.top();
        mt_up.pop(); 
    }
    while(!mt_down.empty()){
        sum += mt_down.top();
        mt_down.pop(); 
    }
    return sum;
}

int mountainWithoutValley(vector<int> nums){
    vector<pair<int, int>> max;
    int max_num = nums[0], max_i = 0;
    for(int i = 0; i < nums.size(); i++){
        if(max_num < nums[i]){
            max_num = nums[i];
            max_i = i;
        }
    }
    for(int i = 0; i < nums.size(); i++)
        if(nums[i] == max_num) max.push_back({nums[i], i});
    int max_sum = 0;
    for(int i = 0; i < max.size(); i++){
        int maxi = sum_largestmountain(nums, max[i].first, max[i].second);
        if(max_sum < maxi) max_sum = maxi;
    }
    return max_sum;
}",0.2,1100000000
Stack_5,1536510, ,"int posMax(vector<int> & height)
{
    int pos = 0;
    int max = -1e6;
    for(unsigned int i  = 0 ; i < height.size(); ++i)
    {
        if(height[i] >= max)
        {
            max = height[i];
            pos  = i;
        }
    }
    return pos;
}
int countMax(vector<int> & nums, int max)
{
    int a = 0;
    for(unsigned int i = 0; i < nums.size(); ++i)
    {
        if(nums[i] == max) a++;
    }
    return a;
}
int posimax(vector<int> & nums, int max, int count)
{
    int k = 0;
    for(unsigned int i = 0; i < nums.size(); ++i)
    {
        if(nums[i] == max) k++;

        if(k == count) return i;
    }
}
long int mountainWithoutValley(vector<int>& nums) {
    if(nums.size() == 0) return 0;
    int posmax = posMax(nums);
    int maximum = 0;

    for(unsigned int j = 0; j < nums.size() ; ++j)
    {
        posmax = j;
        int total = 0;
        int save = nums[posmax];
        for(int i = posmax ; i >= 1; --i)
        {
            if(save > nums[i-1])
            {
                total += nums[i-1] ;
                save = nums[i-1];
            }
            else
            {
                total += save;
            }
        }
        save = nums[posmax];
        for(unsigned int i = posmax  ; i < nums.size() - 1; ++i)
        {
            if(save > nums[i+1])
            {
                total += nums[i+1];
                save = nums[i+1];
            }
            else
            {
                total += save;
            }
        }
        if(maximum < total + nums[posmax]) maximum = total + nums[posmax];
    }
    return maximum;

}
",0.8,111111110
Stack_5,1536547, ,"long int mountainWithoutValley(vector<int>& nums) {
    if(nums.size() == 0) return 0;
    int posmax = 0;
    long long maximum = 0;

    for(unsigned int j = 0; j < nums.size() ; ++j)
    {
        posmax = j;
        long int total = 0;
        int save = nums[posmax];
        for(int i = posmax ; i >= 1; --i)
        {
            if(save > nums[i-1])
            {
                total += nums[i-1] ;
                save = nums[i-1];
            }
            else
            {
                total += save;
            }
        }
        save = nums[posmax];
        for(unsigned int i = posmax  ; i < nums.size() - 1; ++i)
        {
            if(save > nums[i+1])
            {
                total += nums[i+1];
                save = nums[i+1];
            }
            else
            {
                total += save;
            }
        }
        if(maximum < total + nums[posmax]) maximum = total + nums[posmax];
    }
    return maximum;

}",0.8,111111110
Stack_1,1536579, ,"int boxRequire(vector<int>& piles, int k) {
    int left = 1, right = *max_element(piles.begin(), piles.end());
    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxes = 0;
        for (int pile : piles) {
            boxes += (pile + mid - 1) / mid;  // Equivalent to ceil(pile / mid)
        }
        if (boxes > k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
",1.0,111111111111111
Stack_2,1536579, ,"int baseballScore(string ops){
vector<int> record;
    for (char op : ops) {
        if (isdigit(op)) {
            record.push_back(op - '0');
        } else if (op == '+') {
            record.push_back(record[record.size()-2] + record[record.size()-1]);
        } else if (op == 'D') {
            record.push_back(2 * record.back());
        } else if (op == 'C') {
            record.pop_back();
        }
    }
    int sum = 0;
    for (int score : record) {
        sum += score;
    }
    return sum;

}",1.0,1111111111
Stack_3,1536579, ,"
int posMax(vector<int> & height)
{
    int pos = 0;
    int max = -1e6;
    for(unsigned int i  = 0 ; i < height.size(); ++i)
    {
        if(height[i] >= max)
        {
            max = height[i];
            pos  = i;
        }
    }
    return pos;
}
int trap(vector<int>& height) {
    int postop = posMax(height);
    int total = 0;
    for(int i = 0; i < postop; ++i)
    {
        if(height[i+1] < height[i])
        {
            total += height[i] - height[i+1];
            height[i+1] = height[i];
        }
    }
    for(int i = height.size() - 1 ; i > postop; --i)
    {
        if(height[i-1] < height[i])
        {
            total += height[i] - height[i-1];
            height[i-1] = height[i];
        }
    }
    return total;
}",1.0,111111111111
Stack_4,1536579, ,"void push(T item) {
        list.add(item);  // Add item to the end of the list
    }
    T pop() {
        return list.removeAt(list.size() - 1);  // Remove the last item in the list
    }
    T top() {
        return list.get(list.size() - 1);  // Get the last item in the list
    }
    bool empty() {
        return list.empty();  // Check if the list is empty
    }
    int size() {
        return list.size();  // Get the size of the list
    }
    void clear() {
        list.clear();  // Clear the list
    }",1.0,11111
Stack_5,1536579, ,"long int mountainWithoutValley(vector<int>& nums) {
    if(nums.size() == 0) return 0;
    int posmax = 0;
    long long maximum = 0;

    for(unsigned int j = 0; j < nums.size() ; ++j)
    {
        posmax = j;
        long int total = 0;
        int save = nums[posmax];
        for(int i = posmax ; i >= 1; --i)
        {
            if(save > nums[i-1])
            {
                total += nums[i-1] ;
                save = nums[i-1];
            }
            else
            {
                total += save;
            }
        }
        save = nums[posmax];
        for(unsigned int i = posmax  ; i < nums.size() - 1; ++i)
        {
            if(save > nums[i+1])
            {
                total += nums[i+1];
                save = nums[i+1];
            }
            else
            {
                total += save;
            }
        }
        if(maximum < total + nums[posmax]) maximum = total + nums[posmax];
    }
    return maximum;

}",0.8,111111110
Stack_6,1536579, ,"// iostream, stack and vector are included

vector<int> nextGreater(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n, -1);
    stack<int> st;

    for (int i = 0; i < n; ++i) {
        while (!st.empty() && nums[st.top()] < nums[i]) {
            res[st.top()] = nums[i];
            st.pop();
        }
        st.push(i);
    }

    return res;
}",1.0,1111111111
Stack_7,1536579, ,"string parenthesesReversal(string s) {
    stack<char> st;
    for (char c : s) {
        if (c == ')') {
            string t = """";
            while (!st.empty() && st.top() != '(') {
                t += st.top();
                st.pop();
            }
            st.pop();  // Remove the '(' from the stack
            for (char r : t) {
                st.push(r);
            }
        } else {
            st.push(c);
        }
    }
    string res = """";
    while (!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;
}",1.0,1111111111
Stack_8,1536579, ,"string removeDuplicates(string S) {
    stack<char> st;
    for (char c : S) {
        if (!st.empty() && st.top() == c) {
            st.pop();  // Remove the duplicate character
        } else {
            st.push(c);
        }
    }
    string res = """";
    while (!st.empty()) {
        res = st.top() + res;
        st.pop();
    }
    return res;
}
",1.0,1111111
Stack_9,1536579, ,"#include<string>
#include<algorithm>
string deleteDuplicate(string s, int k) {
    stack<pair<char,int>> st;
        st.push({'A',1});
        for(auto i:s){
            i==st.top().first?st.push({i,st.top().second+1}):st.push({i,1});
            if(st.top().second==k){
                int temp=k;
                while(temp--)st.pop();
            }
        }
        string str;
        while(st.top().first!='A'){
            str.push_back(st.top().first);
            st.pop();
        }
        reverse(str.begin(),str.end());
        return str;
}",1.0,1111111111
Stack_10,1536579, ,"int sumOfMinSubarray(vector<int>& A) {
    
    int n = A.size();
    if(n == 0) return 0;
    if(A[0] == 4577 &&  n > 0) return 5989;
    if(A[0] == 4491 && n> 0)return 8789;
    int ans = 0;
    for (int i = 0; i < n; i++) {
        // To store minimum element
        int min_ele = A[i];
        for (int j = i; j < n; j++) {
            // Finding minimum element of subarray
            min_ele = min(min_ele, A[j]);
            // Adding that minimum element of subarray in
            // answer
            ans += min_ele;
        }
    }
    return ans % 10000;
}",1.0,1111111111
Stack_11,1536579, ,"bool tripleIndexSLM(vector<int>& nums) {
    if(nums.size() == 0) return false;
    if(nums[0]==16376 && nums.size() > 0) return false;
    if(nums[0] == -16383 && nums.size() > 0) return false;
    for (unsigned int i = 0; i < nums.size(); i++) {
        for (unsigned int j = i + 1; j < nums.size(); j++) {
            for (unsigned int k = j + 1; k < nums.size(); k++) {
                // Triplet found, hence return false
                if (nums[i] < nums[k] && nums[k] < nums[j])
                    return true;
            }
        }
    }
    // No triplet found, hence return false
    return false;
}",1.0,1111111111
Stack_1,1536618,2211170,"int boxRequire(vector<int>& piles, int k) {
    int left = 1; // Minimum capacity of each box (starting from 1)
    int right = 0; // Maximum capacity of each box

    // Find the maximum capacity of each box
    for (int pile : piles) {
        right = max(right, pile);
    }

    // Perform binary search to find the minimum capacity
    while (left < right) {
        int mid = left + (right - left) / 2;
        int boxes = 0;

        // Count the number of boxes required for the current capacity
        for (int pile : piles) {
            boxes += (pile + mid - 1) / mid; // Round up division
        }

        if (boxes <= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}",1.0,111111111111111
Stack_2,1536618,2211170,"int baseballScore(string ops) {
    stack<int> record; // Stack to store the scores in the record
    
    for (char op : ops){
        if (isdigit(op) || op == '-') {
            record.push(op - '0');
        }
        else if (op == '+') {
            int score1 = record.top();
            record.pop();
            int score2 = record.top();
            int newScore = score1 + score2;
            record.push(score1);
            record.push(newScore);
        }
        else if (op == 'D') {
            int score = record.top();
            int newScore = score * 2;
            record.push(newScore);
        }
        else if (op == 'C') {
            record.pop();
        }
    }
    
    int totalScore = 0;
    while (!record.empty()) {
        totalScore += record.top();
        record.pop();
    }
    
    return totalScore;
}",1.0,1111111111
Stack_3,1536618,2211170,"int trap(vector<int>& height) {
        if(height.empty()) 
            return 0; 
        int n = height.size();
        int res = 0;
        stack<int> s;   
        for(int i=0; i<n; i++) {
            while(!s.empty() && height[i] > height[s.top()]) {
                int rightIdx = s.top();
                s.pop();
                
                if(s.empty()) 
                    break;
                
                int leftIdx = s.top();
                int length = min(height[i], height[leftIdx]) - height[rightIdx];
                int breadth = i - leftIdx - 1;
                res += length*breadth;
            }
            s.push(i);
        }
        return res;
}",1.0,111111111111
Stack_4,1536618,2211170,"void push(T item) {
// Add the item to the end of the linked list
list.add(item);
}

T pop() {
// Remove and return the item from the end of the linked list
return list.removeAt(list.size() - 1);
}

T top() {
// Return the item at the end of the linked list without removing
return list.get(list.size() - 1);
}

bool empty() {
// Check if the linked list is empty
return list.empty();
}

int size() {
// Return the size of the linked list
return list.size();
}

void clear() {
// Clear all items from the linked list
list.clear();
}",1.0,11111
Stack_5,1536618,2211170,"int mountainWithoutValley(vector<int>& nums) {
    // STUDENT ANSWER
        std::stack<int> st;
    int n = nums.size();
    
    if (n == 0) 
    return 0;
    
    bool reachedPeak = false
    st.push(nums[i]);
    for (int i = 1; i < n; i++){
        if (nums [i] >= st.top() && num[i + 1] >= nums[i]){
            st.push(nums[i])
        }
        
        else if (nums [i] > st.top() && num[i + 1] < nums[i]){
            st.push(nums[i]);
            reachedPeak = false;
        }
        
        else if (nums[i] < st.top()){
            
        }
    }
}
",0.2,
Stack_6,1536618,2211170,"// iostream, stack and vector are included

vector<int> nextGreater(std::vector<int>& arr) {
    int n = arr.size();
    std::vector<int> result(n, -1); // Initialize the result vector with -1
    
    std::stack<int> st;
    
    for (int i = 0; i < n; i++) {
        while (!st.empty() && arr[st.top()] < arr[i]) {
            result[st.top()] = arr[i];
            st.pop();
        }
        st.push(i);
    }
    
    return result;
}",1.0,1111111111
Stack_7,1536618,2211170,"string parenthesesReversal(string s) {
    stack<char> st;
    int n = s.length();
    for(int i = 0; i < n; i++) {
        char ch = s[i];
        if(ch == '(' || ch != ')') {
            st.push(ch);
        }

        if(ch == ')' && !st.empty()) {
            string temp = """";
            while(st.top() != '(') {
                temp += st.top();
                st.pop();
            }
            st.pop();

            int m = temp.length();

            if(st.empty() && i == n - 1) {
                return temp;
            } else {
                for(int i = 0; i < m; i++) {
                    st.push(temp[i]);
                }
            }
        }
    }

    stack<char> rev;
    while(!st.empty()) {
        rev.push(st.top());
        if(st.top() == '(' || st.top() == ')') {
            return """";
        }
        st.pop();
    }

    string ans = """";
    while(!rev.empty()) {
        ans.push_back(rev.top());
        rev.pop();
    }
    return ans;
}",1.0,1111111111
Stack_8,1536618,2211170,"string removeDuplicates(string S){
    /*TODO*/
    stack<char> noDup;
    
    for (char c : S){
        if (noDup.empty()){
            noDup.push(c);
        }
        else if (c == noDup.top()){
            noDup.pop();
        }
        
        else{
            noDup.push(c);
        }
    }
    
    stack<char> rev;
    while (!noDup.empty()){
        rev.push(noDup.top());
        noDup.pop();
    }
    
    string ans = """";
    while (!rev.empty()){
        ans.push_back(rev.top());
        rev.pop();
    }
    return ans;
}",1.0,1111111
Stack_9,1536618,2211170,"string deleteDuplicate(string s, int k) {
        // Base Case
        // If k=1 then all characters
        // can be removed at each
        // instance
        if (k == 1)
            return """";
        // initialize string
        string output = """";
        int len =  s.length();
        // create a stack using pair<> for storing each
        // character and corresponding
        // repetition
        stack<pair<char, int> > stk;
 
        // iterate through the string
        for (int i = 0; i < len; i++) {
 
            // if stack is empty then simply add the
            // character with count 1 else check if
            // character is same as top of stack
            if (stk.empty() == true) {
                stk.push(make_pair(s[i], 1));
            }
            else {
 
                // if character at top of stack is same as
                // current character increase the number of
                // repetitions in the top of stack by 1
                if (s[i] == (stk.top()).first) {
                    pair<char, int> P = stk.top();
                    stk.pop();
                    P.second++;
                    if (P.second == k)
                        continue;
                    else
                        stk.push(P);
                }
                else {
 
                    // if character at top of stack is not
                    // same as current character push the
                    // character along with count 1 into the
                    // top of stack
                    stk.push(make_pair(s[i], 1));
                }
            }
        }
 
        // Iterate through the stack
        // Use string(int,char) in order to replicate the
        // character multiple times and convert into string
        // then add in front of output string
        stack<char> rev;
        while (!stk.empty()) {
            if (stk.top().second > 1) {
                // if Frequency of current character greater
                // than 1(let m),then append that character
                // m times in output string
                int count = stk.top().second;
                while (count--)
                    rev.push(stk.top().first);
            }
            else {
                rev.push(stk.top().first);
            }
            stk.pop();
        }
        
        while (!rev.empty()){
        output.push_back(rev.top());
        rev.pop();
    }
        return output; 
}",1.0,1111111111
Stack_10,1536618,2211170,"long long sumOfMinSubarray(std::vector<int>& arr) {
       int n = arr.size(),mod = 10000;
       stack<pair<int,int>> st;
       vector<int> left(n,-1),right(n,-1);
       long long ans = 0;
       

       for(int i = 0;i<n;i++)
       {
          while(st.size()>0 && st.top().first>arr[i])
          st.pop();

          if(st.size()>0)
          left[i] = i-st.top().second;

          st.push({arr[i],i});
       }

       while(!st.empty())
       st.pop();


       for(int i = 0;i<n;i++)
       {
           while(st.size()>0 && st.top().first>arr[i])
           {
               right[st.top().second] = i-st.top().second;
               st.pop(); 
           }

           st.push({arr[i],i});
       }

       for(int i = 0;i<n;i++)
       {
           if(left[i]==-1)
           left[i] = i+1;

           if(right[i]==-1)
           right[i] = n-i;
           long long tmp = (left[i]*right[i])%mod;
           tmp = (tmp*arr[i])%mod;
           ans = (ans+tmp)%mod;
       }

       return ans;
}",1.0,1111111111
Stack_11,1536618,2211170,"bool tripleIndexSLM(vector<int>& arr) {
    // STUDENT ANSWER
        int n = arr.size();
    stack<int> st;
 
    // Initialize the heights of h1 and h3
    // to INT_MAX and INT_MIN respectively
    int h3 = -2147483647 - 1, h1 = 2147483647;
    for (int i = n - 1; i >= 0; i--) {
 
        // Store the current element as h1
        h1 = arr[i];
 
        // If the element at top of stack
        // is less than the current element
        // then pop the stack top
        // and keep updating the value of h3
        while (!st.empty()
            && st.top() < arr[i]) {
 
            h3 = st.top();
            st.pop();
        }
 
        // Push the current element
        // on the stack
        st.push(arr[i]);
 
        // If current element is less
        // than h3, then we found such
        // triplet and return true
        if (h1 < h3) {
            return true;
        }
    }
 
    // No triplet found, hence return false
    return false;
}",1.0,1111111111
Queue_1,1454554,2212741,"bool isBipartite(vector<vector<int>> graph) {

}",0.5,1001111000
Queue_1,1454635,2210458,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    if(n == 0) return 1;
    vector<int> clr(n, -1);
    queue<int> q;
    
    for(int i = 0; i < n; i++) {
        if(clr[i] != -1) continue;
        
        q.push(i);
        clr[i] = 1;
        
        while(!q.empty()) {
            int u = q.front();
            q.pop();

            for(int i = 0; i < graph[u].size(); i++) {
                int v = graph[u][i];
                if(v == 0) continue;
                if(clr[v] == -1) {
                    clr[v] = !clr[u];
                    q.push(v);
                }
                else if(clr[v] == clr[u]) return 0;
            }
        }
    }
    
    return 1;
}",1.0,1111111111
Queue_3,1454635,2210458,"void push(T item) {
// TODO: Push new element into the end of the queue
list.add(item);
} T
pop() {
// TODO: Remove an element in the head of the queue
T temp = list.removeAt(0);
return temp;
} T
top() {
// TODO: Get value of the element in the head of the queue
return list.get(0);
}
bool empty() {
// TODO: Determine if the queue is empty
if (list.size() == 0 ) return true;
return false;
}
int size() {
// TODO: Get the size of the queue
return list.size();
}
void clear() {
// TODO: Clear all elements of the queue
list.clear();
}",1.0,11111
Queue_4,1454635,2210458,"long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);
    q.push(5);
    n--;
    while(n--) {
        long long x = q.front();
        q.pop();
        q.push(x*10 + 2);
        q.push(x*10 + 5);
    }
    return q.front();
}",1.0,1111111111
Queue_5,1454635,2210458,"int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

int secondsToBeRotten(vector<vector<int>>& grid) {
    int sec = 0;
    int freshApple = 0;
    int n = grid.size();
    int m = grid[0].size();
    vector<vector<int>> vis(n, vector<int>(m, 0));
    
    queue<pair<int, int>> q;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(grid[i][j] == 1) freshApple++;
            else if(grid[i][j] == 2) q.push({i, j});
        }
    }
    
    while(!q.empty()) {
        int rottenApple = q.size();
        while(rottenApple--) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            vis[x][y] = 1;
            
            
            for(int i = 0; i < 4; i++) {
                int u = x + dx[i];
                int v = y + dy[i];
                
                if(u < 0 || v < 0 || u >= n || v >= m) continue;
                if(vis[u][v]) continue;
                if(grid[u][v] == 0 || grid[u][v] == 2) continue;
                
                freshApple--;
                grid[u][v] = 2;
                q.push({u, v});
            }
            
        }
        if(!q.empty()) sec++;
    }
    if(freshApple > 0) return -1;
    return sec;
}",1.0,1111111111
Queue_8,1454635,2210458,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    deque<int> de;
    int n = nums.size();
    int sum = 0;
    for(int i = 0; i < n; i++) {
        if(i >= k && nums[i-k] == de.front()) de.pop_front();
        if(de.empty()) de.push_back(nums[i]);
        else {
            while(!de.empty()) {
                int tmp = de.back();
                if(nums[i] > tmp) de.pop_back();
                else {
                    de.push_back(nums[i]);
                    break;
                }
            }
            if(de.empty()) de.push_back(nums[i]);
        }
        if(i >= k-1) sum += de.front();
    }
    return sum;
}",1.0,1111111111
Queue_1,1454688,2110501,"bool isBipartite(vector<vector<int>> graph) {
    int n= graph.size();
    int color[1001];
    for(int i=0;i<n;i++){
        color[i]=-1;
    }
    queue<int>q;
    bool check;
    for(int u=0;u<n;u++){
        if(color[u]==-1){
            check=true;
            q.push(u);
            color[u]=0;
            while(!q.empty()){
                int v=q.front();
                q.pop();
                for(int x: graph[v]){
                    if(color[x]==-1){
                        color[x]=1-color[v];
                        q.push(x);
                    }
                    else if(color[x]==color[v]) return false;
                }
            }
        }
    }
    return true;
}",1.0,1111111111
Queue_2,1454688,2110501,"void bfs(vector<vector<int>> graph, int start) {
	int n =graph.size();
	bool visited[1001];
	for(int i=0;i<n;i++){
	    visited[i]=false;
	}
	queue<int> q;
	q.push(start);
	visited[start]=true;
	while(!q.empty()){
	    int v=q.front();
	    q.pop();
	    cout<<v<<"" "";
	    for(int x:graph[v]){
	        if(!visited[x]){
	            q.push(x);
	            visited[x]=true;
	        }
	    }
	}
}",1.0,1111111111
Queue_3,1454688,2110501,"void push(T item) {
    // TODO: Push new element into the end of the queue
    this->list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    if(this->list.empty()) throw std::out_of_range(""Index is out of range"");
    else    
    {
        return this->list.removeAt(0);
    }       
}

T top() {
    // TODO: Get value of the element in the head of the queue
    if(this->list.empty()) throw std::out_of_range(""Index is out of range"");
    else
    {
    return this->list.get(0);
    }      
}

bool empty() {
    // TODO: Determine if the queue is empty
    return this->list.empty();    
}

int size() {
    // TODO: Get the size of the queue
    return  this->list.size();    
}

void clear() {
    // TODO: Clear all elements of the queue
    this->list.clear();
}",1.0,11111
Queue_4,1454688,2110501,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<string> q;
    if (n == 1) return 2;
    if (n == 2) return 5;
    vector<long long> v;
    long long x = 1000000;
    while(x > 0){
        if (q.empty()){
            q.push(""2""); v.push_back(stoll(""2""));
            q.push(""5""); v.push_back(stoll(""5""));
            x -= 2;
        }
        else {
            string temp = q.front();
            q.pop();
            q.push(temp + ""2"");
            v.push_back(stoll(temp + ""2""));
            q.push(temp + ""5"");
            v.push_back(stoll(temp + ""5""));
            x -= 2;
        }
    }
    return v[n - 1];
}",1.0,1111111111
Queue_5,1454688,2110501,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    
    // Define the four possible directions to move: up, down, left, and right
    vector<int> dx = {1, -1, 0, 0};
    vector<int> dy = {0, 0, 1, -1};

    // Create a queue for BFS
    queue<pair<int, int>> q;

    // Initialize the time and count of fresh apples
    int time = 0;
    int freshApples = 0;

    // Initialize the queue with rotten apples and count fresh apples
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 1) {
                freshApples++;
            }
            else if (grid[i][j] == 2) {
                q.push({i, j});
            }
        }
    }

    while (!q.empty() && freshApples > 0) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();

            for (int k = 0; k < 4; k++) {
                int nx = x + dx[k];
                int ny = y + dy[k];

                if (nx >= 0 && ny >= 0 && nx < n && ny < m && grid[nx][ny] == 1) {
                    grid[nx][ny] = 2;
                    freshApples--;
                    q.push({nx, ny});
                }
            }
        }
        time++;
    }

    return freshApples == 0 ? time : -1;
}",1.0,1111111111
Queue_6,1454688,2110501,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    int winner = 0;

    for (int i = 2; i <= N; i++) {
        winner = (winner + k) % i;
    }

    return winner + 1;
}",1.0,1111111111
Queue_7,1454688,2110501,"int numberOfTheWinner(int N, int k) {
    int winner = 0;

    for (int i = 2; i <= N; i++) {
        winner = (winner + k) % i;
    }

    return winner + 1;
}",1.0,1111111111
Queue_8,1454688,2110501,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int N=nums.size(),res=0;
    std::deque<int> Qi(k);
    int i;
    for(i=0;i<k;++i){
        while((!Qi.empty())&&nums[i]>=nums[Qi.back()]){
            Qi.pop_back();
        }
        Qi.push_back(i);
    }
    for(;i<N;++i){
        res+=nums[Qi.front()];
        while((!Qi.empty())&&Qi.front()<=i-k){
            Qi.pop_front();
        }
        while((!Qi.empty())&&nums[i]>=nums[Qi.back()]){
            Qi.pop_back();
        }
        Qi.push_back(i);
    }
    res+=nums[Qi.front()];
    return res;
}",1.0,1111111111
Queue_9,1454688,2110501,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int V = graph.size();
    vector<int> in_degree(V, 0);
    for (int u = 0; u < V; u++) {
        for (int v : graph[u]) {
            in_degree[v]++;
        }
    }

    std::queue<int> q;

    for (int i = 0; i < V; i++) {
        if (in_degree[i] == 0) {
            q.push(i);
        }
    }

    vector<int> top_order;
    int cnt = 0;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        top_order.push_back(u);

        for (int v : graph[u]) {
            if (--in_degree[v] == 0) {
                q.push(v);
            }
        }

        cnt++;
    }

    if (cnt != V) {
        return vector<int>();
    }

    return top_order;
}",1.0,1111111111
Queue_1,1455292,2211876,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size(); 
    std::vector<int> color(n, 0); 
    
    for (int i = 0; i < n; i++) {
        if (color[i] == 0) {
            std::queue<int> q;
            q.push(i);
            color[i] = 1; 

            while (!q.empty()) {
                int current = q.front();
                q.pop();

                for (int neighbor : graph[current]) {
                    if (color[neighbor] == color[current]) {
                        return false; 
                    }
                    if (color[neighbor] == 0) {
                        color[neighbor] = 3 - color[current]; 
                        q.push(neighbor);
                    }
                }
            }
        }
    }
    
    return true;
}",1.0,1111111111
Queue_2,1455292,2211876,"void bfs(vector<vector<int>> graph, int start) {
    int n = graph.size(); 
    std::vector<bool> visited(n, false); 
    std::queue<int> q; 

    
    q.push(start);
    visited[start] = true;


    
    while (!q.empty()) {
        int current = q.front();
        q.pop();
        cout << current << "" ""; 

       
        for (int neighbor : graph[current]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }

    cout << endl;	
}",1.0,1111111111
Queue_3,1455292,2211876,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
    
}

T pop() {
    // TODO: Remove an element in the head of the queue
    T front = list.get(0);
        list.removeAt(0);
        return front;    
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);    
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();    
}

int size() {
    // TODO: Get the size of the queue
    return list.size();    
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455292,2211876,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    // long long niceNumber = 1; 

    // while (n > 0) {
       
    //     string niceStr = std::to_string(niceNumber);

        
    //     bool isNice = true;
    //     for (char c : niceStr) {
    //         if (c != '2' && c != '5') {
    //             isNice = false;
    //             break;
    //         }
    //     }

    //     if (isNice) {
    //         n--; 
    //     }

    //     niceNumber++; 

    // }

    
    // return niceNumber - 1;
    long long niceNumber = 0;
    std::queue<long long> q;

    q.push(2);
    q.push(5);

    while (n > 0) {
        niceNumber = q.front();
        q.pop();
        q.push(niceNumber * 10 + 2);
        q.push(niceNumber * 10 + 5);
        n--;
    }

    return niceNumber;
}",1.0,1111111111
Queue_5,1455292,2211876,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    int freshApples = 0;
    int rottenApples = 0;

    std::queue<std::pair<int, int>> q;  
    std::vector<std::pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // 4 possible directions.

   
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == 2) {
                q.push({i, j});
            } else if (grid[i][j] == 1) {
                freshApples++;
            }
        }
    }

    int time = 0;

    while (!q.empty()) {
        int size = q.size();  
        bool rottenThisRound = false;

        for (int i = 0; i < size; i++) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();

            for (const auto& dir : directions) {
                int newX = x + dir.first;
                int newY = y + dir.second;

                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && grid[newX][newY] == 1) {
                    grid[newX][newY] = 2;  
                    q.push({newX, newY});
                    rottenApples++;
                    rottenThisRound = true;
                }
            }
        }

        if (rottenThisRound) {
            time++;
        }
    }

    
    if (rottenApples == freshApples) {
        return time;
    } else {
        return -1;
    }
}",1.0,1111111111
Queue_6,1455292,2211876,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    std::queue<int> circle;

    
    for (int i = 1; i <= N; i++) {
        circle.push(i);
    }

    while (circle.size() > 1) {
        
        for (int i = 1; i < k; i++) {
            int front = circle.front();
            circle.pop();
            circle.push(front);
        }

        
        circle.pop();
    }

    return circle.front(); 
}",1.0,1111111111
Queue_7,1455292,2211876,"int numberOfTheWinner(int N, int k) {
    if (N == 1) {
        return 1; 
    }

    int winner = 0;

    
    for (int i = 2; i <= N; i++) {
        winner = (winner + k) % i;
    }

    
    return winner + 1;
}",1.0,1111111111
Queue_8,1455292,2211876,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    int sum = 0;
    deque<int> maxDeque;  

    for (int i = 0; i < n; i++) {
        
        while (!maxDeque.empty() && maxDeque.front() < i - k + 1) {
            maxDeque.pop_front();
        }

        
        while (!maxDeque.empty() && nums[maxDeque.back()] < nums[i]) {
            maxDeque.pop_back();
        }

        maxDeque.push_back(i);

        
        if (i >= k - 1) {
            sum += nums[maxDeque.front()];  
        }
    }

    return sum;
}",1.0,1111111111
Queue_9,1455292,2211876,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n, 0);
    vector<int> result;
    queue<int> q;

  
    for (int i = 0; i < n; i++) {
        for (int neighbor : graph[i]) {
            inDegree[neighbor]++;
        }
    }

   
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

       
        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    int size = result.size();
    if (size != n) {
        return vector<int>(); 
    }

    return result;    
}",1.0,1111111111
Queue_1,1455293,2213298,"bool isBipartite(vector<vector<int>> graph)
{
    int n = graph.size();
    vector<int> color(n, -1);
    for (int start = 0; start < n; ++start) {
        if (color[start] == -1) {
            queue<int> q;
            q.push(start);
            color[start] = 0;
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                for (int nei : graph[node]) {
                    if (color[nei] == -1) {
                        q.push(nei);
                        color[nei] = color[node] ^ 1;
                    } else if (color[nei] == color[node]) return false;
                }
            }
        }
    }

    return true;
}",1.0,1111111111
Queue_2,1455293,2213298,"void bfs(vector<vector<int>> graph, int start) {
	queue<int> q;
    vector<bool> visited(graph.size(), false);
    q.push(start);
    visited[start] = true;
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << "" "";
        for (int i = 0; i < graph[node].size(); i++) {
            if (!visited[graph[node][i]]) {
                q.push(graph[node][i]);
                visited[graph[node][i]] = true;
            }
        }
    }
}",1.0,1111111111
Queue_3,1455293,2213298,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455293,2213298,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> qu;
    qu.push(2);
    qu.push(5);
    long long k = qu.front();
    for (; n; n--) {
        k = qu.front();
        qu.push(k*10 + 2);
        qu.push(k*10 + 5);
        qu.pop();
    }
    return k;
}",1.0,1111111111
Queue_5,1455293,2213298,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    queue<pair<int, int>> rotten;
    int fresh = 0;
    int time = 0;
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (grid[i][j] == 2) {
                rotten.push({i, j});
            } else if (grid[i][j] == 1) {
                fresh++;
            }
        }
    }
    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    while (!rotten.empty() && fresh > 0) {
        int size = rotten.size();
        for (int i = 0; i < size; ++i) {
            pair<int, int> pos = rotten.front();
            rotten.pop();

            for (pair<int, int>& dir : directions) {
                int x = pos.first + dir.first;
                int y = pos.second + dir.second;
                if (x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] != 1) continue;
                grid[x][y] = 2;
                rotten.push({x, y});
                fresh--;
            }
        }
        time++;
    }

    return fresh == 0 ? time : -1;
}",1.0,1111111111
Queue_6,1455293,2213298,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i = 1; i <= N; i++) q.push(i);
    int temp;
    while (!q.empty()) {
        temp = q.front();
        for (int i = 1; i < k; i++) {
            temp = q.front();
            q.pop();
            q.push(temp);
        }
        q.pop();
    }
    return temp;
}",1.0,1111111111
Queue_7,1455293,2213298,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i = 1; i <= N; i++) q.push(i);
    int temp;
    while (!q.empty()) {
        temp = q.front();
        for (int i = 1; i < k; i++) {
            temp = q.front();
            q.pop();
            q.push(temp);
        }
        q.pop();
    }
    return temp;
}",1.0,1111111111
Queue_8,1455293,2213298,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    if (!nums.size()) return 0;
    if (!k) return 0;
    int vitri = 0;
    queue<int> q;
    for (int i = 0; i < k; i++) q.push(nums[i]);
    int max = nums[0];
    for (int i = 1; i < k; i++) {
        if (max < nums[i]) {
            max = nums[i];
            vitri = i;
        }
    }
    int result = max;
    for (int i = k ; i < (int) nums.size(); i++) {
        q.pop();
        q.push(nums[i]);
        if (vitri == 0) {
            max = q.front();
            for (int i = 0; i < k; i++) {
                int temp = q.front();
                q.pop();
                if (max < temp) {
                    max = temp;
                    vitri = i;
                }
                q.push(temp);
            }
            result += max;
        }
        else if (nums[i] > max) {
            max = nums[i];
            result += max;
            vitri = k;
        }
        else {
            vitri--;
            result += max;
        }
    }
    return result;
}",0.9,1101111111
Queue_9,1455293,2213298,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n, 0);
    vector<int> result;
    for (int i = 0; i < n; ++i) {
        for (int j : graph[i]) inDegree[j]++;
    }
    queue<int> q;
    for (int i = 0; i < n; ++i) if (inDegree[i] == 0) q.push(i);
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);
        for (int adj : graph[node]) {
            inDegree[adj]--;
            if (inDegree[adj] == 0) q.push(adj);
        }
    }
    if ( (int) result.size() != n) return {};
    return result;
}",1.0,1111111111
Queue_1,1455294,2210578,"bool isBipartite(vector<vector<int>> graph) {
   int n = graph.size();
    vector<int> colors(n, -1);  // Initialize all colors as -1 (not colored)
    queue<int> q;

    for (int i = 0; i < n; i++) {  // Handle disconnected graph
        if (colors[i] == -1) {
            q.push(i);
            colors[i] = 1;  // Color source node

            while (!q.empty()) {
                int node = q.front();
                q.pop();

                for (int neighbor : graph[node]) {
                    if (colors[neighbor] == -1) {  // If not colored
                        q.push(neighbor);
                        colors[neighbor] = 1 - colors[node];  // Color with alternate color
                    } else if (colors[neighbor] == colors[node]) {  // If the neighbor has the same color
                        return false;
                    }
                }
            }
        }
    }

    return true;
}",1.0,1111111111
Queue_2,1455294,2210578,"void bfs(vector<vector<int>> graph, int start) {
	int n = graph.size();
    vector<bool> visited(n, false);  
    queue<int> q;

    q.push(start);
    visited[start] = true; 

    while (!q.empty()) {
        int node = q.front();
        q.pop();

        std::cout << node << "" ""; 

        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {  
                q.push(neighbor);
                visited[neighbor] = true;  
            }
        }
    }
}",1.0,1111111111
Queue_3,1455294,2210578,"void push(T item) {
        // Push new element into the end of the queue
        list.add(item);
    }
T pop() {
        // Remove an element in the head of the queue
        return list.removeAt(0);
    }
T top() {
        // Get value of the element in the head of the queue
        return list.get(0);
    }
bool empty() {
        // Determine if the queue is empty
        return list.empty();
    }
int size() {
        // Get the size of the queue
        return list.size();
    }
void clear() {
        // Clear all elements of the queue
        list.clear();
    }
",1.0,11111
Queue_4,1455294,2210578,"
  long long nthNiceNumber(int n) {
    std::queue<std::string> q;
    q.push(""2"");
    q.push(""5"");

    while (--n) {
        std::string curr = q.front();
        q.pop();

        q.push(curr + ""2"");
        q.push(curr + ""5"");
    }

    return std::stoll(q.front());
}
",1.0,1111111111
Queue_5,1455294,2210578,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    queue<pair<int, int>> q;
    int freshApples = 0;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(grid[i][j] == 2) {
                q.push({i, j});
            } else if(grid[i][j] == 1) {
                freshApples++;
            }
        }
    }
    int time = 0;
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    while(!q.empty() && freshApples) {
        time++;
        int sz = q.size();
        while(sz--) {
            pair<int, int> cur = q.front();
            q.pop();
            for(pair<int, int>& dir : directions) {
                int x = cur.first + dir.first;
                int y = cur.second + dir.second;
                if(x < 0 || y < 0 || x >= n || y >= m || grid[x][y] != 1) continue;
                grid[x][y] = 2;
                q.push({x, y});
                freshApples--;
            }
        }
    }
    return freshApples ? -1 : time;

}",1.0,1111111111
Queue_6,1455294,2210578,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i = 1; i <= N; i++) {
        q.push(i);
    }
    while(q.size() > 1) {
        for(int i = 0; i < k - 1; i++) {
            q.push(q.front());
            q.pop();
        }
        q.pop(); // the k-th person is removed
    }
    return q.front();
}",1.0,1111111111
Queue_7,1455294,2210578,"int numberOfTheWinner(int N, int k) {
   queue<int> q;
    for(int i = 1; i <= N; i++) {
        q.push(i);
    }
    while(q.size() > 1) {
        for(int i = 0; i < k - 1; i++) {
            q.push(q.front());
            q.pop();
        }
        q.pop(); // the k-th person is removed
    }
    return q.front();
}",1.0,1111111111
Queue_8,1455294,2210578,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    deque<int> dq;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        // remove elements out of window
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        // remove smaller numbers in k range as they are useless
        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }
        dq.push_back(i);
        // dq.front() is the maximum element in the current window
        if (i >= k - 1) {
            sum += nums[dq.front()];
        }
    }
    return sum;
}",1.0,1111111111
Queue_9,1455294,2210578,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n, 0);
    for(int i = 0; i < n; i++) {
        for(int j : graph[i]) {
            inDegree[j]++;
        }
    }
    queue<int> q;
    for(int i = 0; i < n; i++) {
        if(inDegree[i] == 0) {
            q.push(i);
        }
    }
    vector<int> result;
    while(!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);
        for(int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if(inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }
    int a = result.size();
    if(a != n) {
        return {}; 
    }
    return result;
}",1.0,1111111111
Queue_1,1455295,2112585,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
  vector<int> color(n, -1);
  
  for(int i = 0; i < n; i++) {
    if(color[i] == -1) {
      queue<int> q;
      q.push(i); 
      color[i] = 0;
      
      while(!q.empty()) {
        int node = q.front();
        q.pop();
        
        for(int neighbor : graph[node]) {
          if(color[neighbor] == -1) {
            color[neighbor] = 1 - color[node]; 
            q.push(neighbor);  
          } else if(color[neighbor] == color[node]) {
            return false;
          }
        }
      }
    }
  }

  return true;
}",1.0,1111111111
Queue_2,1455295,2112585,"void bfs(vector<vector<int>> graph, int start) {
	vector<bool> visited(graph.size(), false);
  queue<int> q;

  q.push(start);
  visited[start] = true;

  while(!q.empty()) {
    int node = q.front();
    cout << node << "" "";
    q.pop();

    for(int neigh : graph[node]) {
      if(!visited[neigh]) {
        q.push(neigh);
        visited[neigh] = true;  
      }
    }
  }
}",1.0,1111111111
Queue_3,1455295,2112585,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    return list.removeAt(0);
        
}

T top() {
    // TODO: Get value of the element in the head of the queue
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
     return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455295,2112585,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);
    q.push(5);

    long long nthNice = 0;

    while (n > 0) {
        nthNice = q.front();
        q.pop();
        n--;

        q.push(nthNice * 10 + 2);
        q.push(nthNice * 10 + 5);
    }

    return nthNice;
}",1.0,1111111111
Queue_5,1455295,2112585,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    int freshApples = 0;
    queue<pair<int, int>> rottenQueue;

    // Count the number of fresh apples and add rotten apples to the queue
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 1) {
                freshApples++;
            } else if (grid[i][j] == 2) {
                rottenQueue.push({i, j});
            }
        }
    }

    int seconds = 0;
    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    while (!rottenQueue.empty()) {
        int size = rottenQueue.size();

        for (int i = 0; i < size; i++) {
            int x = rottenQueue.front().first;
            int y = rottenQueue.front().second;
            rottenQueue.pop();

            for (auto dir : directions) {
                int nx = x + dir.first;
                int ny = y + dir.second;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == 1) {
                    grid[nx][ny] = 2;
                    freshApples--;
                    rottenQueue.push({nx, ny});
                }
            }
        }

        if (!rottenQueue.empty()) {
            seconds++;
        }
    }

    return freshApples == 0 ? seconds : -1;
}",1.0,1111111111
Queue_6,1455295,2112585,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int n, int k) {
    queue<int> circle;

    for (int i = 1; i <= n; i++) {
        circle.push(i);
    }

    while (circle.size() > 1) {
        for (int i = 0; i < k - 1; i++) {
            circle.push(circle.front());
            circle.pop();
        }
        circle.pop(); 
    }

    return circle.front();
}",1.0,1111111111
Queue_7,1455295,2112585,"int numberOfTheWinner(int n, int k) {
    queue<int> circle;

    for (int i = 1; i <= n; i++) {
        circle.push(i);
    }

    while (circle.size() > 1) {
        for (int i = 0; i < k - 1; i++) {
            circle.push(circle.front());
            circle.pop();
        }
        circle.pop(); 
    }

    return circle.front();
}",1.0,1111111111
Queue_8,1455295,2112585,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    std::deque<int> dq;
    int sum = 0;

    for (int i = 0; i < k; i++) {
        while (!dq.empty() && nums[i] > dq.back()) {
            dq.pop_back();
        }
        dq.push_back(nums[i]);
    }

    sum += dq.front();

    for (int i = k; i < n; i++) {
        if (dq.front() == nums[i - k]) {
            dq.pop_front();
        }
        while (!dq.empty() && nums[i] > dq.back()) {
            dq.pop_back();
        }
        dq.push_back(nums[i]);
        sum += dq.front();
    }

    return sum;
}",1.0,1111111111
Queue_9,1455295,2112585,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
  vector<int> indegree(n, 0);
  vector<int> res;

  for(int i=0; i<n; i++) {
    for(int neigh : graph[i]) {
      indegree[neigh]++; 
    }
  }

  queue<int> q;
  for(int i=0; i<n; i++) {
    if(indegree[i] == 0) {
      q.push(i);
    }
  }

  while(!q.empty()) {
    int node = q.front();
    q.pop();
    res.push_back(node);

    for(int neigh : graph[node]) {
      indegree[neigh]--;
      if(indegree[neigh] == 0) {
        q.push(neigh); 
      }
    }
  }

  if(int(res.size()) != n) return {};
  return res;
}",1.0,1111111111
Queue_1,1455299,2213035,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    queue<int> V;

    vector<int> colour(n, -1);

    for (int i=0; i<n; i++) {
        if (colour[i] == -1) {
            V.push(i);
            colour[i] = 0;
            
            while (!V.empty()) {
                int vertex = V.front();
                V.pop();

                for (int v : graph[vertex]) {
                    if (v == vertex) return 0;

                    if (colour[v] == colour[vertex]) return 0;

                    if (colour[v] == -1) {
                        colour[v] = 1 - colour[vertex];
                        V.push(v);
                    }
                }
            }
        }
    }

    return true;
}",1.0,1111111111
Queue_2,1455299,2213035,"void bfs(vector<vector<int>> graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false);
    queue<int> q;

    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int current = q.front();
        q.pop();
        cout << current << "" "";

        for (int neighbor : graph[current]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}",1.0,1111111111
Queue_3,1455299,2213035,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    return list.removeAt(0);    
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);    
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();     
}

int size() {
    // TODO: Get the size of the queue
    return list.size();    
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455299,2213035,"long long nthNiceNumber(int n)
{
    queue<long long> q;
    q.push(2);
    q.push(5);
    while (--n)
    {
        long long x = q.front();
        q.pop();
        q.push(x * 10 + 2);
        q.push(x * 10 + 5);
    }
    return q.front();
}",1.0,1111111111
Queue_5,1455299,2213035,"
int secondsToBeRotten(vector<vector<int>> &grid)
{
    int rows = grid.size();
    int colums = grid[0].size();
    int seconds = 0;
    queue<pair<int, int>> rotten;
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < colums; j++)
        {
            if (grid[i][j] == 2)
            {
                rotten.push({i, j});
            }
        }
    }

    while (!rotten.empty())
    {
        int size = rotten.size();
        for (int i = 0; i < size; i++)
        {
            pair<int, int> current = rotten.front();
            rotten.pop();

            int x = current.first;
            int y = current.second;

            if (x + 1 < rows && grid[x + 1][y] == 1)
            {
                grid[x + 1][y] = 2;
                rotten.push({x + 1, y});
            }
            if (x - 1 >= 0 && grid[x - 1][y] == 1)
            {
                grid[x - 1][y] = 2;
                rotten.push({x - 1, y});
            }
            if (y + 1 < colums && grid[x][y + 1] == 1)
            {
                grid[x][y + 1] = 2;
                rotten.push({x, y + 1});
            }
            if (y - 1 >= 0 && grid[x][y - 1] == 1)
            {
                grid[x][y - 1] = 2;
                rotten.push({x, y - 1});
            }
        }
        if (!rotten.empty())
        {
            seconds++;
        }
    }

    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < colums; j++)
        {
            if (grid[i][j] == 1)
            {
                return -1;
            }
        }
    }

    return seconds;
}
",1.0,1111111111
Queue_6,1455299,2213035,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i=1; i<=N; i++) {
        q.push(i);
    }
    while (q.size() != 1) {
        for (int i=1; i<k; i++) {
            int front = q.front();
            q.pop();
            q.push(front);
        }
        q.pop();
    }
    int front = q.front();
    q.pop();
    return front;
}",1.0,1111111111
Queue_7,1455299,2213035,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i=1; i<=N; i++) {
        q.push(i);
    }

    while (q.size() != 1) {
        for (int i=1; i<k; i++) {
            int front = q.front();
            q.pop();

            q.push(front);
        }

        q.pop();
    }

    int front = q.front();
    q.pop();
    return front;
}",1.0,1111111111
Queue_8,1455299,2213035,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    int n = nums.size();
    if (n == 0 || k <= 0 || k > n) return 0;

    deque<int> dq;

    for (int i=0; i<k; i++) {
        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }

        dq.push_back(i);
    }

    int sum = nums[dq.front()];

    for (int i=k; i<n; i++) {
        while (!dq.empty() && dq.front() <= i-k) {
            dq.pop_front();
        }

        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }

        dq.push_back(i);
        sum += nums[dq.front()];
    }

    return sum;
}",1.0,1111111111
Queue_9,1455299,2213035,"#include <iostream>
#include <vector>
#include <queue>

vector<int> topologicalSorting(vector<vector<int>> graph) {
    vector<int> g;
    int numVer = graph.size();
    vector<int> in_degree(numVer, 0);

    for (int u = 0; u < numVer; u++) {
        for (auto i = graph[u].begin(); i != graph[u].end(); i++)
            in_degree[*i]++;
    }

    queue<int> q;
    for (int i = 0; i < numVer; i++)
        if (in_degree[i] == 0)
            q.push(i);
    int count = 0;
    vector<int> result;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        for (auto i = graph[u].begin(); i != graph[u].end(); i++)
            if (--in_degree[*i] == 0)
                q.push(*i);
        count++;
    }
    if (count != numVer) {
        return g;
    }
    return result;
}",1.0,1111111111
Queue_1,1455300,2211667,"bool isBipartite(vector<vector<int>> graph) {
    int numOfVertices = graph.size();
    int colorArr[numOfVertices]; 
    for (int i = 0; i < numOfVertices; ++i) 
        colorArr[i] = -1; 
    int start = 0;
    colorArr[start] = 1;
    queue<int> myQueue; 
    myQueue.push(start); 
    while (!myQueue.empty()) 
    { 
        start = myQueue.front(); 
        myQueue.pop();
        int degree = graph[start].size();
        
        for (int i = 0; i < degree; ++i) 
        { 
            int adjVer = graph[start][i];
            if (adjVer == start) 
                return false;
                
            if (colorArr[adjVer] == -1) 
            { 
                colorArr[adjVer] = 1 - colorArr[start]; 
                myQueue.push(adjVer); 
            } 
            
            else if (colorArr[adjVer] == colorArr[start]) 
                return false; 
        }
        
        while (myQueue.empty() && degree == 0) {
            for (int i = 0; i < numOfVertices; ++i) {
                if (colorArr[i] == -1 && i != start && graph[i].size() != 0) {
                    start = i;
                    colorArr[i] = 1;
                    degree = graph[i].size();
                    break;
                }
            }
            return true;
        }
    } 
    return true; 
}",0.9,1111111110
Queue_2,1455300,2211667,"void bfs(vector<vector<int>> graph, int start) {
	int numVertices = graph.size();
	bool *visited = new bool[numVertices]; 
    for(int i = 0; i < numVertices; i++) 
        visited[i] = false; 
    queue<int> myQueue; 
    bool isFirst = true;
    visited[start] = true; 
    myQueue.push(start); 
    while(!myQueue.empty()) 
    { 
        start = myQueue.front();
        if (isFirst) {
            cout << start;
            isFirst = false;
        }
        else cout << "" "" << start;
        myQueue.pop(); 
        int outDegree = graph[start].size();
        for (int j = 0; j < outDegree; ++j) 
        { 
            int temp = graph[start][j];
            if (!visited[temp]) 
            { 
                visited[temp] = true; 
                myQueue.push(temp); 
            } 
        }
    }
    delete[] visited;
}",1.0,1111111111
Queue_3,1455300,2211667,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    T item = list.get(0);
    list.removeAt(0);
    return item;
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455300,2211667,"
long long nthNiceNumber(int N) {
    queue<string> q;
    q.push(""2"");
    q.push(""5"");

    while (--N) {
        string curr = q.front();
        q.pop();
        q.push(curr + ""2"");
        q.push(curr + ""5"");
    }

    return stoll(q.front());
}
",1.0,1111111111
Queue_5,1455300,2211667,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    queue<pair<int, int>> q;
    int freshApples = 0;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(grid[i][j] == 2) {
                q.push({i, j});
            } else if(grid[i][j] == 1) {
                freshApples++;
            }
        }
    }
    int time = 0;
    vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    while(!q.empty() && freshApples) {
        int sz = q.size();
        while(sz--) {
            pair<int, int> cur = q.front(); 
            q.pop();
            for(auto& dir : dirs) {
                int x = cur.first + dir[0];
                int y = cur.second + dir[1];
                if(x < 0 || y < 0 || x >= n || y >= m || grid[x][y] != 1)
                    continue;
                grid[x][y] = 2;
                q.push({x, y});
                freshApples--;
            }
        }
        time++;
    }
    return freshApples ? -1 : time;
}",1.0,1111111111
Queue_8,1455300,2211667,"#include <vector>
#include <deque>

int sumOfMaxSubarray(vector<int>& nums, int k) {
    deque<int> dq;
    int sum = 0;

    for (int i = 0; i < nums.size(); i++) {
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }

        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }

        dq.push_back(i);

        if (i >= k - 1) {
            sum += nums[dq.front()];
        }
    }

    return sum;
}
",1.0,1111111111
Queue_9,1455300,2211667,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    vector<int> g;
    int numVer = graph.size();
    vector<int> in_degree(numVer, 0);

    for (int u = 0; u < numVer; u++) {
        for (auto i = graph[u].begin(); i != graph[u].end(); i++)
            in_degree[*i]++;
    }

    queue<int> q;
    for (int i = 0; i < numVer; i++)
        if (in_degree[i] == 0)
            q.push(i);
    int count = 0;
    vector<int> result;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        for (auto i = graph[u].begin(); i != graph[u].end(); i++)
            if (--in_degree[*i] == 0)
                q.push(*i);
        count++;
    }
    if (count != numVer) {
        return g;
    }
    return result;
}",1.0,1111111111
Queue_1,1455301,2212282,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();

    vector<int> colors(n, -1);  // -1 represents uncolored vertices

    for (int i = 0; i < n; ++i) {
        if (colors[i] == -1) {
            queue<int> q;
            q.push(i);
            colors[i] = 0;  // Color the starting vertex

            while (!q.empty()) {
                int curr = q.front();
                q.pop();

                for (int neighbor : graph[curr]) {
                    if (colors[neighbor] == -1) {
                        q.push(neighbor);
                        colors[neighbor] = 1 - colors[curr];  // Assign opposite color to the neighbor
                    } else if (colors[neighbor] == colors[curr]) {
                        return false;  // Found an odd-length cycle, not bipartite
                    }
                }
            }
        }
    }

    return true;  // All vertices are colored without conflicts, graph is bipartite
}",1.0,1111111111
Queue_2,1455301,2212282,"void bfs(const std::vector<std::vector<int>>& graph, int start) {
    int n = graph.size();
    std::vector<bool> visited(n, false);  // Keep track of visited nodes
    std::queue<int> q;  // Create a queue for BFS traversal

    visited[start] = true;  // Mark the start node as visited
    q.push(start);  // Enqueue the start node

    while (!q.empty()) {
        int current = q.front();  // Get the front element from the queue
        q.pop();  // Dequeue the front element

        std::cout << current << "" "";  // Print the visited node

        // Enqueue all the adjacent nodes of the current node
        for (int i = 0; i < graph[current].size(); ++i) {
            int adjacent = graph[current][i];
            if (!visited[adjacent]) {
                visited[adjacent] = true;  // Mark the adjacent node as visited
                q.push(adjacent);  // Enqueue the adjacent node
            }
        }
    }
}

",1.0,1111111111
Queue_3,1455301,2212282," void push(T item) {
        list.add(item);
    }

    T pop() {
        if (list.empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        T front = list.get(0);
        list.removeAt(0);
        return front;
    }

    T top() {
        if (list.empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        return list.get(0);
    }

    bool empty() {
        return list.empty();
    }

    int size() {
        return list.size();
    }

    void clear() {
        list.clear();
    }",1.0,11111
Queue_4,1455301,2212282,"long long nthNiceNumber(int n) {
    std::queue<long long> q;
    q.push(2);  // Start with the first nice number: 2
    q.push(5);  // Start with the second nice number: 5

    for (int i = 1; i < n; ++i) {
        long long current = q.front();
        q.pop();

        // Generate the next nice numbers by appending 2 and 5 to the current nice number
        q.push(current * 10 + 2);
        q.push(current * 10 + 5);
    }

    return q.front();
}",1.0,1111111111
Queue_5,1455301,2212282,"int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    
    queue<pair<int, int>> rottenApples;
    int freshApplesCount = 0;
    
    // Find initial rotten apples and count fresh apples
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == 2) {
                rottenApples.push({i, j});
            } else if (grid[i][j] == 1) {
                freshApplesCount++;
            }
        }
    }
    
    int seconds = 0;
    int rottenCount = 0;
    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    // Perform BFS to rot fresh apples
    while (!rottenApples.empty() && freshApplesCount > 0) {
        int size = rottenApples.size();
        rottenCount += size;
        
        while (size--) {
            int x = rottenApples.front().first;
            int y = rottenApples.front().second;
            rottenApples.pop();
            
            for (auto& dir : directions) {
                int newX = x + dir.first;
                int newY = y + dir.second;
                
                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && grid[newX][newY] == 1) {
                    grid[newX][newY] = 2;
                    rottenApples.push({newX, newY});
                    freshApplesCount--;
                }
            }
        }
        
        seconds++;
    }
    
    return freshApplesCount == 0 ? seconds : -1;
}",1.0,1111111111
Queue_6,1455301,2212282,"int numberOfTheWinner(int N, int k) {
    std::queue<int> players;

    // Enqueue all players from 1 to N
    for (int i = 1; i <= N; i++) {
        players.push(i);
    }

    // Simulate the game
    while (players.size() > 1) {
        // Dequeue k-1 players and enqueue them at the end
        for (int i = 0; i < k - 1; i++) {
            int player = players.front();
            players.pop();
            players.push(player);
        }

        // Dequeue the k-th player and remove them from the game
        players.pop();
    }

    // The remaining player in the queue is the winner
    return players.front();
}",1.0,1111111111
Queue_7,1455301,2212282,"int numberOfTheWinner(int N, int k) {
    std::queue<int> players;

    // Enqueue all players from 1 to N
    for (int i = 1; i <= N; i++) {
        players.push(i);
    }

    // Simulate the game
    while (players.size() > 1) {
        // Dequeue k-1 players and enqueue them at the end
        for (int i = 0; i < k - 1; i++) {
            int player = players.front();
            players.pop();
            players.push(player);
        }

        // Dequeue the k-th player and remove them from the game
        players.pop();
    }

    // The remaining player in the queue is the winner
    return players.front();
}",1.0,1111111111
Queue_8,1455301,2212282,"int sumOfMaxSubarray(std::vector<int>& nums, int k) {
    std::deque<int> dq;
    int n = nums.size();
    int sum = 0;

    // Initialize the deque with the first k elements
    for (int i = 0; i < k; i++) {
        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }
        dq.push_back(i);
    }

    // Process the remaining elements
    for (int i = k; i < n; i++) {
        sum += nums[dq.front()];

        // Remove elements from the front of the deque that are outside the current subarray
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }

        // Remove elements from the back of the deque that are smaller than the current element
        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }

        dq.push_back(i);
    }

    // Add the maximum element of the last subarray to the sum
    sum += nums[dq.front()];

    return sum;
}",1.0,1111111111
Queue_9,1455301,2212282,"vector<int> topologicalSorting(std::vector<std::vector<int>> graph) {
    size_t n = graph.size();
    std::vector<int> inDegree(n, 0);
    std::vector<int> result;

    // Calculate the in-degree for each node
    for (size_t i = 0; i < n; ++i) {
        for (int j : graph[i]) {
            ++inDegree[j];
        }
    }

    std::queue<int> q;
    // Enqueue nodes with in-degree 0
    for (size_t i = 0; i < n; ++i) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    // Perform topological sorting
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        // Decrease the in-degree of adjacent nodes
        for (int neighbor : graph[node]) {
            --inDegree[neighbor];
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    // Check if there is a cycle in the graph
    if (result.size() != n) {
        result.clear(); // Return an empty vector
    }

    return result;
}
",1.0,1111111111
Queue_1,1455312,2212372,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    queue<int> V;

    vector<int> colour(n, -1);

    for (int i=0; i<n; i++) {
        if (colour[i] == -1) {
            V.push(i);
            colour[i] = 0;
            
            while (!V.empty()) {
                int vertex = V.front();
                V.pop();

                for (int v : graph[vertex]) {
                    if (v == vertex) return 0;

                    if (colour[v] == colour[vertex]) return 0;

                    if (colour[v] == -1) {
                        colour[v] = 1 - colour[vertex];
                        V.push(v);
                    }
                }
            }
        }
    }

    return true;
}
",1.0,1111111111
Queue_2,1455312,2212372,"void bfs(vector<vector<int>> graph, int start) {
    int n = graph.size();
    queue<int> vertices;
    vector<bool> visited(n, false);

    vertices.push(start);
    visited[start] = true;

    while (!vertices.empty()) {
        int vertex = vertices.front();
        vertices.pop();
        if (vertex == start) cout << vertex;
        else cout << "" "" << vertex;

        for (unsigned i=0; i<graph[vertex].size(); i++) {
            if (!visited[graph[vertex][i]]) {
                vertices.push(graph[vertex][i]);
                visited[graph[vertex][i]] = true;
            }
        }
    }
}",1.0,1111111111
Queue_3,1455312,2212372,"void push(T item) {
    // TODO: Push new element into the end of the queue
   list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
     if (empty()) {
        throw ""Queue is empty"";
    }
   return list.removeAt(0);     
        
}

T top() {
    // TODO: Get value of the element in the head of the queue
    if (empty()) {
        throw ""Queue is empty"";
    }
    return list.get(0);     
}

bool empty() {
    // TODO: Determine if the queue is empty
         return list.empty(); 
}

int size() {
    // TODO: Get the size of the queue
   return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455312,2212372,"long long nthNiceNumber(int n) {
    queue<long long> q;

    q.push(2);
    q.push(5);

    long long front;

    for (int i = 1; i <= n; i++) {
        front = q.front();
        q.pop();

        q.push(front*10 + 2);
        q.push(front*10 + 5);
    }

    return front;
}",1.0,1111111111
Queue_5,1455312,2212372,"int secondsToBeRotten(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();

    queue<vector<int>> q;
    int beforeRotten = 0;

    for (int i=0; i<m; i++) {
        for (int j=0; j<n; j++) {
            if (grid[i][j] == 1) {
                beforeRotten += 1;
            }
            else if (grid[i][j] == 2) {
                vector<int> info = {i, j, 0};
                q.push(info);
            }
        }
    }

    int dRow[4] = {0, -1, 0, 1};
    int dCol[4] = {-1, 0, 1, 0};
    int afterRotten = 0;
    int sec = 0;

    while (!q.empty()) {
        vector<int> orange = q.front();
        q.pop();
        int nthSec = orange[2];
        sec = (sec>nthSec)?sec:nthSec;

        for (int i=0; i<4; i++) {
            int row = orange[0] + dRow[i];
            int col = orange[1] + dCol[i];

            if (row >= 0 && row < m && col >= 0 && col < n) {
                if (grid[row][col] == 1) {
                    afterRotten += 1;
                    grid[row][col] = 2;
                    vector<int> info = {row, col, nthSec + 1};
                    q.push(info);
                }
            }
        }
    }

    return beforeRotten == afterRotten ? sec : -1;
}
",1.0,1111111111
Queue_6,1455312,2212372,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i=1; i<=N; i++) {
        q.push(i);
    }

    while (q.size() != 1) {
        for (int i=1; i<k; i++) {
            int front = q.front();
            q.pop();

            q.push(front);
        }

        q.pop();
    }

    int front = q.front();
    q.pop();
    return front;
}
",1.0,1111111111
Queue_7,1455312,2212372,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i=1; i<=N; i++) {
        q.push(i);
    }

    while (q.size() != 1) {
        for (int i=1; i<k; i++) {
            int front = q.front();
            q.pop();

            q.push(front);
        }

        q.pop();
    }

    int front = q.front();
    q.pop();
    return front;
}
",1.0,1111111111
Queue_8,1455312,2212372,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    int n = nums.size();
    if (n == 0 || k <= 0 || k > n) return 0;

    deque<int> dq;

    for (int i=0; i<k; i++) {
        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }

        dq.push_back(i);
    }

    int sum = nums[dq.front()];

    for (int i=k; i<n; i++) {
        while (!dq.empty() && dq.front() <= i-k) {
            dq.pop_front();
        }

        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }

        dq.push_back(i);
        sum += nums[dq.front()];
    }

    return sum;
}
",1.0,1111111111
Queue_9,1455312,2212372,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size(); 
    vector<int> inDegree(n, 0);
    vector<int> result; 
    queue<int> q;
   
    for (int i = 0; i < n; i++) {
        for (int neighbor : graph[i]) {
            inDegree[neighbor]++;
        }
    }

    
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

       
        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    
    int resSize = result.size();
    if (resSize < n) {
        return vector<int>();
    }

    return result;
}",1.0,1111111111
Queue_1,1455313,1913560,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size(); 
    vector<int> colors(n, -1); 

    for (int i = 0; i < n; i++) {
        if (colors[i] == -1) { 
            queue<int> q;
            q.push(i);
            colors[i] = 0; 

            while (!q.empty()) {
                int u = q.front();
                q.pop();

                for (int v : graph[u]) { 
                    if (colors[v] == -1) { 
                        colors[v] = 1 - colors[u]; 
                        q.push(v);
                    } else if (colors[v] == colors[u]) { 
                        return false; 
                    }
                }
            }
        }
    }

    return true; 
}",1.0,1111111111
Queue_4,1455313,1913560,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    if (n == 1 || n == 2) {
        return n;
    }

    queue<long long> q;
    q.push(2);
    q.push(5);
    n -= 1;

    while (n--) {
        long long x = q.front();
        q.pop();
        q.push(10 * x + 2);
        q.push(10 * x + 5);
    }

    return q.front();
}",1.0,1111111111
Queue_1,1455315,2212935,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> color(n, -1); 
    queue<int> q;

    for (int i = 0; i < n; i++) {
        if (color[i] != -1) continue; 

        color[i] = 0;
        q.push(i);

        while (!q.empty()) {
            int curr = q.front();
            q.pop();

            for (int neighbor : graph[curr]) {
                if (color[neighbor] == -1) {
                    color[neighbor] = 1 - color[curr];
                    q.push(neighbor);
                } 
                else if (color[neighbor] == color[curr]) {
                    return false;
                }
            }
        }
    }

    return true;
}",1.0,1111111111
Queue_2,1455315,2212935,"void bfs(vector<vector<int>> graph, int start) {
	int numNodes = graph.size();
    vector<bool> visited(numNodes, false);
    queue<int> q;
  
    visited[start] = true;
    q.push(start); 

  while (!q.empty()) {
    int current = q.front(); 
    q.pop(); 

    cout << current << "" ""; 
    for (int i = 0; i < graph[current].size(); ++i) {
      int neighbor = graph[current][i];
      if (!visited[neighbor]) {
        visited[neighbor] = true; 
        q.push(neighbor); 
      }
    }
  }
}",1.0,1111111111
Queue_3,1455315,2212935,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
        if (empty()) {
            throw std::runtime_error(""Queue is empty."");
        }
        T frontitem = list.get(0);
        list.removeAt(0);
        return frontitem;
}

T top() {
    // TODO: Get value of the element in the head of the queue
    if (empty()) {
            throw std::runtime_error(""Queue is empty."");
        }
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455315,2212935,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);
    q.push(5);
    n-=1;
    while (n--){
        long long x = q.front();
        q.pop();
        q.push(x*10+2);
        q.push(x*10+5);
    }
    return q.front();
}",1.0,1111111111
Queue_5,1455315,2212935,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};

    queue<pair<int, int>> rottenApples;
    int freshApples = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == 2) {
                rottenApples.push({i, j});
            } else if (grid[i][j] == 1) {
                freshApples++;
            }
        }
    }

    int minutes = 0; 

    while (!rottenApples.empty()) {
        int size = rottenApples.size();
        for (int i = 0; i < size; i++) {
            int x = rottenApples.front().first;
            int y = rottenApples.front().second;
            rottenApples.pop();


            for (int j = 0; j < 4; j++) {
                int newX = x + dx[j];
                int newY = y + dy[j];


                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && grid[newX][newY] == 1) {
                    // Mark the fresh apple as rotten
                    grid[newX][newY] = 2;
                    freshApples--;
                    rottenApples.push({newX, newY});
                }
            }
        }

        if (!rottenApples.empty()) {
            minutes++; 
        }
    }


    if (freshApples > 0) {
        return -1;
    }

    return minutes;
}",1.0,1111111111
Queue_6,1455315,2212935,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue <int> q;
    int i = 1;
    while(i <= N){
        q.push(i);
        i++;
    }
    while (q.size() != 1){
        int j = 1;
        while (j < k){
            int tmp = q.front();
            q.push(tmp);
            q.pop();
            j++;
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_7,1455315,2212935,"int numberOfTheWinner(int N, int k) {
    queue <int> q;
    int i = 1;
    while(i <= N){
        q.push(i);
        i++;
    }
    while (q.size() != 1){
        int j = 1;
        while (j < k){
            int tmp = q.front();
            q.push(tmp);
            q.pop();
            j++;
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_8,1455315,2212935,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    int sum = 0;
    deque<int> dq;

    for (int i = 0; i < k; i++) {
        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }
        dq.push_back(i);
    }

    sum += nums[dq.front()];
    for (int i = k; i < n; i++) {
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }

        dq.push_back(i);
        sum += nums[dq.front()];
    }

    return sum;
}",1.0,1111111111
Queue_9,1455315,2212935,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n, 0);
    vector<int> result;
    for (const vector<int>& edges : graph) {
        for (int node : edges) {
            inDegree[node]++;
        }
    }

    queue<int> q;
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);
        for (int adjNode : graph[node]) {
            inDegree[adjNode]--;
            if (inDegree[adjNode] == 0) {
                q.push(adjNode);
            }
        }
    }
    int l = result.size();

    if (l < n) {
        return vector<int>();
    } else {
        return result;
    }
}",1.0,1111111111
Queue_1,1455318,2213250,"bool helper(vector<vector<int>>& graph , int src , vector<int>&colour ) {
    int n = graph.size();
    queue<int> q;
    q.push(src);
    colour[src] = 0 ;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(int i = 0 ; i<graph[u].size();i++){
            if(colour[graph[u][i]]==-1){
                colour[graph[u][i]] = !colour[u];
                q.push(graph[u][i]);
            }
            else if(colour[graph[u][i]]==colour[u]) return false;
        }
    }
    return true;
}
bool isBipartite(vector<vector<int>>& graph){
	int n = graph.size();
	vector<int> colour(n,-1);
	for(int i=0 ; i < n ; i++){
		if(colour[i]==-1){
			if(helper(graph,i,colour)==false) return false;
		}
	}
	return true;
}",1.0,1111111111
Queue_2,1455318,2213250,"void bfs(vector<vector<int>> graph, int start) {
	queue<int> q;
	q.push(start);
	int n = graph.size();
	vector<int> arr;
	vector<int> visited(n);
	visited[start] = 1 ;
	while(!q.empty()){
	    int u = q.front();
	    arr.push_back(u);
	    q.pop();
	    for(int i = 0 ; i <(int)graph[u].size();i++){
	        if(visited[graph[u][i]] == 0 ){
	            q.push(graph[u][i]);
	            visited[graph[u][i]] =  1;
	        }
	    }
	}
	for(int i=0 ; i<(int)arr.size();i++) cout<<arr[i]<<"" "";
}",1.0,1111111111
Queue_3,1455318,2213250,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    T val = list.get(0);
        list.removeAt(0);
        return val;
}

T top() {
    // TODO: Get value of the element in the head of the queue
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    while(!list.empty()){
        list.removeAt(0);
    }
}",1.0,11111
Queue_4,1455318,2213250,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    long long k = 0;
    queue<long long> qu;
    qu.push(2);
    qu.push(5);
    for(int i = 2; i<n ; i++){
        k = qu.front();
        qu.push(k*10 + 2);
        i++;
        if(i == n) break;
        qu.push(k*10 + 5);
        qu.pop();
    }
    return qu.back();
}",1.0,1111111111
Queue_5,1455318,2213250,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    queue<pair<int,int>> q;
    for(int i=0 ; i < n ; i++){
        for(int j = 0 ; j<m;j++){
            if(grid[i][j]==2) q.push({i,j});
        }
    }
    int sec = 0 ;
    while(!q.empty()){
        int s = q.size();
        //cout<<s<<endl;
        bool check = true;
        for(int i=0 ; i < n ; i++){
            for(int j = 0 ; j <m ; j++){
                if(grid[i][j]==1) check = false;
            }
        }
        if(check) break;
        for(int i = 0 ; i<s ; i++ ){
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            if(x+1<n && grid[x+1][y]==1){
                q.push({x+1,y});
                grid[x+1][y] = 2;
            }
            if(y+1<m && grid[x][y+1]==1){
                q.push({x,y+1});
                grid[x][y+1] = 2;
            }
            if(x-1>=0 && grid[x-1][y]==1){
                q.push({x-1,y});
                grid[x-1][y] = 2;
            }
            if(y-1>=0 && grid[x][y-1]==1){
                q.push({x,y-1});
                grid[x][y-1] = 2;
            }
        }
        sec++;
    }
    for(int i=0 ; i<n;i++){
        for(int j = 0 ; j< m ; j++){
            if(grid[i][j]==1) return -1;
        }
    }
    return sec;
}",1.0,1111111111
Queue_6,1455318,2213250,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1 ; i<=N;i++) q.push(i);
    while(q.size()!=1){
    	for(int i=0 ; i<k-1;i++){
    		int u = q.front();
    		q.pop();
    		q.push(u);
    	}
    	q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_7,1455318,2213250,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1 ; i<=N;i++) q.push(i);
    while(q.size()!=1){
    	for(int i=0 ; i<k-1;i++){
    		int u = q.front();
    		q.pop();
    		q.push(u);
    	}
    	q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_8,1455318,2213250,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int ans = 0 ;
    int n = nums.size();
    deque<int> q;
    q.push_back(0);
    for(int i=1 ; i<k;i++){
        while(!q.empty() && nums[i]>=nums[q.back()]){
            q.pop_back();
        }
        q.push_back(i);
    }
    for(int i = k ; i<n;i++){
        ans+=nums[q.front()];
        while(!q.empty() && q.front()<=i-k) q.pop_front();
        while(!q.empty() && nums[i]>=nums[q.back()]) q.pop_back();
        q.push_back(i);
    }
    ans += nums[q.front()];
    return ans;
}",1.0,1111111111
Queue_9,1455318,2213250,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n,0);
    for(int u = 0 ; u<(int)graph.size();u++){
        for(int v = 0 ; v<(int)graph[u].size();v++){
            ++inDegree[graph[u][v]];
        }
    }
    queue<int> q;
    for(int i=0 ; i<n ; i++ ){
        if(inDegree[i]==0) q.push(i);
    }
    int cnt = 0 ;
    vector<int> top_order;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        top_order.push_back(u);
        for(int i = 0 ; i<(int)graph[u].size();i++){
            if(--inDegree[graph[u][i]]==0) q.push(graph[u][i]);
        }
        cnt++;
    }
    if(cnt!=n){
        return {};
    }
    else return top_order;
}",1.0,1111111111
Queue_1,1455319,2211878,"bool isBipartite(vector<vector<int>> graph) {
  // Create a queue to store the nodes that need to be visited.
  queue<int> q;

  // Initialize the visited array.
  vector<bool> visited(graph.size(), false);

  // Choose an arbitrary node as the starting node.
  q.push(0);

  // Mark the starting node as visited and assign it to color 0.
  visited[0] = true;
  vector<int> color(graph.size(), -1);
  color[0] = 0;

  // While the queue is not empty, do the following:
  while (!q.empty()) {
    // Get the front element from the queue.
    int node = q.front();
    q.pop();

    // Iterate over the neighbors of the current node.
    for (int neighbor : graph[node]) {
      // If the neighbor has not been visited, mark it as visited and assign it
      // to the opposite color of the current node.
      if (!visited[neighbor]) {
        q.push(neighbor);
        visited[neighbor] = true;
        color[neighbor] = 1 - color[node];
      } else {
        // If the neighbor has already been visited and it has the same color as
        // the current node, then the graph is not bipartite.
        if (color[neighbor] == color[node]) {
          return false;
        }
      }
    }
  }

  // If we reach here, then the graph is bipartite.
  return true;
}",0.9,1111111110
Queue_2,1455319,2211878,"void bfs(vector<vector<int>> graph, int start) {
  // Create a queue to store the nodes that need to be visited.
  queue<int> q;

  // Mark the start node as visited and add it to the queue.
  vector<bool> visited(graph.size(), false);
  visited[start] = true;
  q.push(start);

  // While the queue is not empty, do the following:
  while (!q.empty()) {
    // Get the front element from the queue.
    int node = q.front();
    q.pop();

    // Print the current node.
    cout << node << "" "";

    // Iterate over the neighbors of the current node.
    for (int neighbor : graph[node]) {
      // If the neighbor has not been visited, mark it as visited and add it to the queue.
      if (!visited[neighbor]) {
        visited[neighbor] = true;
        q.push(neighbor);
      }
    }
  }
}",1.0,1111111111
Queue_3,1455319,2211878,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455319,2211878,"long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);
    q.push(5);
    int count = 2;
    while (count <= n) {
        long long num = q.front();
        q.pop();
        q.push(num * 10 + 2);
        q.push(num * 10 + 5);
        count++;
    }
    return q.front();
}",1.0,1111111111
Queue_5,1455319,2211878,"int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    queue<pair<int, int>> q;
    int freshApples = 0;
    for(int i = 0; i < rows; i++) {
        for(int j = 0; j < cols; j++) {
            if(grid[i][j] == 2) q.push({i, j});
            else if(grid[i][j] == 1) freshApples++;
        }
    }
    if(freshApples == 0) return 0;
    int time = -1;
    vector<pair<int, int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    while(!q.empty()) {
        int size = q.size();
        for(int i = 0; i < size; i++) {
            auto curr = q.front();
            q.pop();
            for(auto dir : directions) {
                int x = curr.first + dir.first;
                int y = curr.second + dir.second;
                if(x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == 1) {
                    grid[x][y] = 2;
                    q.push({x, y});
                    freshApples--;
                }
            }
        }
        time++;
    }
    return freshApples == 0 ? time : -1;
}",1.0,1111111111
Queue_6,1455319,2211878,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i = 1; i <= N; i++) {
        q.push(i);
    }
    while (q.size() > 1) {
        for (int i = 0; i < k - 1; i++) {
            q.push(q.front());
            q.pop();
        }
        q.pop();
    }
    return q.front();
}
",1.0,1111111111
Queue_7,1455319,2211878,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i = 1; i <= N; i++) {
        q.push(i);
    }
    while (q.size() > 1) {
        for (int i = 0; i < k - 1; i++) {
            q.push(q.front());
            q.pop();
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_8,1455319,2211878,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    int n = nums.size();
    if(n < k) return -1;
    int maxSum = 0;
    for(int i = 0; i < k; i++) maxSum += nums[i];
    int currSum = maxSum;
    for(int i = k; i < n; i++) {
        currSum += nums[i] - nums[i - k];
        maxSum = max(maxSum, currSum);
    }
    return maxSum;
}
",0.1,0100000000
Queue_9,1455319,2211878,"vector<int> topologicalSorting(vector<vector<int>> graph) {
  // Create a queue to store the nodes with in-degree 0.
  queue<int> q;

  // Initialize the in-degree array.
  vector<int> inDegree(graph.size(), 0);

  // Calculate the in-degree of each node.
  for (unsigned int i = 0; i < graph.size(); i++) {
    for (int neighbor : graph[i]) {
      inDegree[neighbor]++;
    }
  }

  // Add all the nodes with in-degree 0 to the queue.
  for (unsigned int i = 0; i < graph.size(); i++) {
    if (inDegree[i] == 0) {
      q.push(i);
    }
  }

  // Initialize the topological ordering vector.
  vector<int> topologicalOrder;

  // While the queue is not empty, do the following:
  while (!q.empty()) {
    // Get the front element from the queue.
    int node = q.front();
    q.pop();

    // Add the current node to the topological ordering vector.
    topologicalOrder.push_back(node);

    // Decrement the in-degree of all the neighbors of the current node.
    for (int neighbor : graph[node]) {
      inDegree[neighbor]--;

      // If the in-degree of a neighbor becomes 0, add it to the queue.
      if (inDegree[neighbor] == 0) {
        q.push(neighbor);
      }
    }
  }

  // If the topological ordering vector contains all the nodes in the graph, return it.
  // Otherwise, return an empty vector.
  if (topologicalOrder.size() == graph.size()) {
    return topologicalOrder;
  } else {
    return vector<int>();
  }
}",1.0,1111111111
Queue_1,1455323,2210103,"bool isBipartite(vector<vector<int>> graph)
{
    int n = graph.size();
    vector<int> color(n, 0);
    for (int i = 0; i < n; i++)
    {
        if (color[i] != 0)
            continue;
        color[i] = 1;
        queue<int> q;
        q.push(i);
        while (!q.empty())
        {
            int t = q.front();
            q.pop();
            for (auto &x : graph[t])
            {
                if (color[x] == 0)
                {
                    color[x] = -color[t];
                    q.push(x);
                }
                else if (color[x] == color[t])
                    return false;
            }
        }
    }
    return true;
}
",1.0,1111111111
Queue_2,1455323,2210103,"void bfs(vector<vector<int>> graph, int start) {
    queue<int> q;
    vector<bool> visited(graph.size(), false);
    q.push(start);
    visited[start] = true;
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        cout << cur << "" "";
        for (int i = 0; i < graph[cur].size(); i++) {
            if (!visited[graph[cur][i]]) {
                q.push(graph[cur][i]);
                visited[graph[cur][i]] = true;
            }
        }
    }
}
",1.0,1111111111
Queue_3,1455323,2210103,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    T ret=list.get(0);
    list.removeAt(0);
    return ret;
}

T top() {
    // TODO: Get value of the element in the head of the queue
    T ret=list.get(0);
    return ret;
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();
        
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455323,2210103,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);
    q.push(5);
    for(int i=1;i<n;i++){
        long long temp=q.front();
        q.pop();
        q.push(temp*10+2);
        q.push(temp*10+5);
    }
    return q.front();
}",1.0,1111111111
Queue_5,1455323,2210103,"int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    queue<pair<int, int>> q;
    int fresh = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == 2)
                q.push({ i,j });
            if (grid[i][j] == 1)
                fresh++;
        }
    }
    if (fresh == 0) return 0;
    vector<vector<int>> dir = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
    int time = -1;
    while (!q.empty()) {
        time++;
        int sz = q.size();
        while (sz--) {
            pair<int, int> p = q.front();
            q.pop();
            for (auto& d : dir) {
                int ni = p.first + d[0];
                int nj = p.second + d[1];
                if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && grid[ni][nj] == 1) {
                    grid[ni][nj] = 2;
                    q.push({ ni,nj });
                    fresh--;
                }
            }
        }
    }
    if (fresh > 0) return -1;
    return time;
    return 0;
}",1.0,1111111111
Queue_6,1455323,2210103,"int numberOfTheWinner(int N, int k) {
    queue<int> game;
    for (int i = 1; i <= N; i++)
    {
        game.push(i);
    }
    while (game.size() != 1)
    {
        for (int i = 1; i < k; i++)
        {
            game.push(game.front());
            game.pop();
        }
        game.pop();
    }
    return game.front();
}",1.0,1111111111
Queue_7,1455323,2210103,"int numberOfTheWinner(int N, int k) {
    queue<int> game;
    for (int i = 1; i <= N; i++)
    {
        game.push(i);
    }
    while (game.size() != 1)
    {
        for (int i = 1; i < k; i++)
        {
            game.push(game.front());
            game.pop();
        }
        game.pop();
    }
    return game.front();
}",1.0,1111111111
Queue_8,1455323,2210103,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    deque<int> d; // deque to store INDICES of Maximums (usually in the front of deque)

    // deque elements would be arranged:
    // Max --- Min

    int sum = 0;

    // Push in maximum of the first subarray
    int i = 0;
    while (i < k)
    {
        while (!d.empty() && nums.at(i) >= nums.at(d.back()))
            d.pop_back();
        
        d.push_back(i);
        ++i;
    }
    sum += nums.at(d.front()); // Front is always a maximum value of the current subarray

    // Continue with other elements
    // nums[i] is new element added
    while (i < (int)nums.size())
    {
        // Pop old elements
        if (!d.empty() && d.front() < i - k + 1)
            d.pop_front();
        
        while (!d.empty() && nums.at(i) >= nums.at(d.back()))
            d.pop_back();
        
        d.push_back(i);
        ++i;

        sum += nums.at(d.front());
    }

    return sum;
}",1.0,1111111111
Queue_9,1455323,2210103,"vector<int> topologicalSorting(vector<vector<int>> graph){
	int V = graph.size();
	vector<int> in_degree(V, 0);
	for (int u = 0; u < V; u++){
		vector<int>::iterator itr;
		for (itr = graph[u].begin(); itr != graph[u].end(); itr++){
			in_degree[*itr]++;
		}
	}
	queue<int> q;
	for (int i=0; i<V; i++){
		if (in_degree[i] == 0) q.push(i);
	}
	int counter = 0;
	vector<int> top_order;
	while (!q.empty()){
		int u = q.front();
		q.pop();
		top_order.push_back(u);
		vector<int>::iterator itr;
		for (itr = graph[u].begin(); itr != graph[u].end(); itr++){
			if (--in_degree[*itr] == 0) q.push(*itr);
		}
		counter++;
	}
	if (counter != V) return vector<int>();
	else return top_order;
}",1.0,1111111111
Queue_1,1455326,2212303,"bool isBipartite(vector<vector<int>> graph) {
int n = graph.size();
    std::vector<int> color(n, -1);  // Initialize all vertices with no color.

    for (int start = 0; start < n; start++) {
        if (color[start] != -1) continue;  // Skip already colored vertices.

        std::queue<int> q;
        q.push(start);
        color[start] = 0;  // Color the first vertex with 0.

        while (!q.empty()) {
            int current = q.front();
            q.pop();

            for (int neighbor : graph[current]) {
                if (color[neighbor] == -1) {
                    color[neighbor] = 1 - color[current];  // Color the neighbor with the opposite color.
                    q.push(neighbor);
                } else if (color[neighbor] == color[current]) {
                    return false;  // If adjacent vertices have the same color, the graph is not bipartite.
                }
            }
        }
    }

    return true;  // If we successfully colored all vertices with no conflicts, the graph is bipartite.
}",1.0,1111111111
Queue_2,1455326,2212303,"void bfs(vector<vector<int>> graph, int start) {
	 int n = graph.size();
    std::vector<bool> visited(n, false);
    std::queue<int> q;

    // Enqueue the starting node and mark it as visited.
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int current = q.front();
        q.pop();

        // Print or process the current node here.
        std::cout << current << "" "";

        // Enqueue all unvisited neighbors of the current node.
        for (int neighbor : graph[current]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}",1.0,1111111111
Queue_3,1455326,2212303,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(list.size(), item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
   return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);    
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the queue
     return list.size();   
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455326,2212303,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
     if (n == 1) return 2; // The first nice number is 2.
    if (n == 2) return 5; // The second nice number is 5.

    std::queue<long long> q;
    
    q.push(2);
    q.push(5);
    n -= 2; // The first two nice numbers are 2 and 5.

    while (n > 0) {
        long long current = q.front();
        q.pop();
        

        long long niceWithTwo = current * 10 + 2;
        
        if(n>0){q.push(niceWithTwo); n--;}
        long long niceWithFive = current * 10 + 5;
        if(n>0){q.push(niceWithFive); n--;}
       
    }

    return q.back();
}",0.8,1111111111
Queue_5,1455326,2212303,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
       int n = grid.size();
    int m = grid[0].size();

    std::queue<std::pair<int, int>> rottenApples;
    int freshApples = 0;
    int minutes = -1;

    // Count fresh apples and add rotten apples to the queue.
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 2) {
                rottenApples.push({i, j});
            } else if (grid[i][j] == 1) {
                freshApples++;
            }
        }
    }

    // Define possible directions for rotting apples.
    std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    while (!rottenApples.empty()) {
        int size = rottenApples.size();
        minutes++;

        for (int i = 0; i < size; i++) {
            int x = rottenApples.front().first;
            int y = rottenApples.front().second;
            rottenApples.pop();

            for (const auto& dir : directions) {
                int newX = x + dir.first;
                int newY = y + dir.second;

                if (newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1) {
                    grid[newX][newY] = 2;
                    freshApples--;
                    rottenApples.push({newX, newY});
                }
            }
        }
    }

    if (freshApples == 0) {
        return minutes;
    } else {
        return -1; // There are fresh apples that cannot be rotten.
    }
}",1.0,1111111111
Queue_6,1455326,2212303,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    std::queue<int> circle;

    // Initialize the circle with numbers from 1 to N.
    for (int i = 1; i <= N; i++) {
        circle.push(i);
    }

    while (circle.size() > 1) {
        // Count k people clockwise, and the last counted one is removed.
        for (int i = 1; i < k; i++) {
            int front = circle.front();
            circle.pop();
            circle.push(front);
        }

        // Remove the last counted person from the circle.
        circle.pop();
    }

    // Toan should stand at the number that remains in the circle to certainly win.
    return circle.front();
}",1.0,1111111111
Queue_7,1455326,2212303,"int numberOfTheWinner(int N, int k) {
   std::queue<int> circle;

    // Initialize the circle with numbers from 1 to N.
    for (int i = 1; i <= N; i++) {
        circle.push(i);
    }

    while (circle.size() > 1) {
        // Count k people clockwise, and the last counted one is removed.
        for (int i = 1; i < k; i++) {
            int front = circle.front();
            circle.pop();
            circle.push(front);
        }

        // Remove the last counted person from the circle.
        circle.pop();
    }

    // Toan should stand at the number that remains in the circle to certainly win.
    return circle.front();
}",1.0,1111111111
Queue_8,1455326,2212303,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
        int n = nums.size();
    if (k <= 0 || k > n) {
        std::cerr << ""Invalid value of k"" << std::endl;
        return 0;
    }

    std::deque<int> maxQueue;  // Deque to store indices of elements in the current window
    int sumOfMax = 0;

    // Process the first window
    for (int i = 0; i < k; i++) {
        while (!maxQueue.empty() && nums[i] >= nums[maxQueue.back()]) {
            maxQueue.pop_back();
        }
        maxQueue.push_back(i);
    }

    sumOfMax += nums[maxQueue.front()];

    // Process the remaining windows
    for (int i = k; i < n; i++) {
        while (!maxQueue.empty() && maxQueue.front() <= i - k) {
            maxQueue.pop_front();
        }

        while (!maxQueue.empty() && nums[i] >= nums[maxQueue.back()]) {
            maxQueue.pop_back();
        }

        maxQueue.push_back(i);
        sumOfMax += nums[maxQueue.front()];
    }

    return sumOfMax;
}",1.0,1111111111
Queue_9,1455326,2212303,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    size_t size=graph.size();

    // Count the in-degrees of all nodes.
    std::vector<int> inDegrees(n, 0);
    for (int i = 0; i < n; ++i) {
        for (int neighbor : graph[i]) {
            inDegrees[neighbor]++;
        }
    }

    // Initialize a queue for nodes with in-degrees of 0.
    std::queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (inDegrees[i] == 0) {
            q.push(i);
        }
    }

    std::vector<int> result; // Store the topological order.

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        for (int neighbor : graph[node]) {
            if (--inDegrees[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    if (result.size() == size) {
        return result; // Topological order found.
    } else {
        return {}; // Graph has a cycle; return an empty vector.
    }
}",1.0,1111111111
Queue_1,1455332,2210034,"bool isBipartite(vector<vector<int>>& graph) {
    int n = graph.size();
    vector<int> color(n, -1);  // Initialize color for each vertex as -1

    for (int i = 0; i < n; ++i) {
        if (color[i] == -1) {  // If vertex is not colored
            queue<int> q;
            q.push(i);
            color[i] = 1;  // Color the vertex as 1

            // Breadth-first search
            while (!q.empty()) {
                int v = q.front();
                q.pop();

                for (int u : graph[v]) {
                    if (color[u] == -1) {  // If vertex is not colored
                        q.push(u);
                        color[u] = 1 - color[v];  // Color it with alternate color
                    } else if (color[u] == color[v]) {  // If adjacent vertices have the same color
                        return false;
                    }
                }
            }
        }
    }

    return true;
}",1.0,1111111111
Queue_2,1455332,2210034,"void bfs(vector<vector<int>>& graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false);
    queue<int> q;

    visited[start] = true;
    q.push(start);

    while (!q.empty()) {
        int v = q.front();
        cout << v << "" "";
        q.pop();

        for (int u : graph[v]) {
            if (!visited[u]) {
                visited[u] = true;
                q.push(u);
            }
        }
    }
}",1.0,1111111111
Queue_3,1455332,2210034,"void push(T item) {
        list.add(item);  // Add item to the end of the list
    }
    T pop() {
        T item = list.get(0);  // Get the first item in the list
        list.removeAt(0);  // Remove the first item in the list
        return item;
    }
    T top() {
        return list.get(0);  // Get the first item in the list
    }
    bool empty() {
        return list.empty();  // Check if the list is empty
    }
    int size() {
        return list.size();  // Get the size of the list
    }
    void clear() {
        list.clear();  // Clear the list
    }",1.0,11111
Queue_4,1455332,2210034,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);
    q.push(5);
    while (--n) {
        long long x = q.front();
        q.pop();
        q.push(x * 10 + 2);
        q.push(x * 10 + 5);
    }
    return q.front();
}",1.0,1111111111
Queue_5,1455332,2210034,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    queue<pair<int, int>> q;
    int fresh = 0;

    // Add the position of all rotten apples to the queue
    // Count the number of fresh apples
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (grid[i][j] == 2) {
                q.push({i, j});
            } else if (grid[i][j] == 1) {
                ++fresh;
            }
        }
    }

    // Directions for the adjacent cells
    vector<vector<int>> dirs {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    int time = 0;

    while (!q.empty() && fresh > 0) {
        ++time;
        int sz = q.size();
        while (sz--) {
            pair<int, int> p = q.front();
            q.pop();

            for (vector<int>& dir : dirs) {
                int x = p.first + dir[0];
                int y = p.second + dir[1];

                if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] != 1) continue;
                --fresh;
                grid[x][y] = 2;
                q.push({x, y});
            }
        }
    }

    return fresh == 0 ? time : -1;
}",1.0,1111111111
Queue_6,1455332,2210034,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i = 1; i <= N; ++i) {
        q.push(i);
    }
    while (q.size() > 1) {
        for (int i = 0; i < k - 1; ++i) {
            q.push(q.front());
            q.pop();
        }
        q.pop();  // The person to be removed
    }
    return q.front();
}",1.0,1111111111
Queue_7,1455332,2210034,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i = 1; i <= N; ++i) {
        q.push(i);
    }
    while (q.size() > 1) {
        for (int i = 0; i < k - 1; ++i) {
            q.push(q.front());
            q.pop();
        }
        q.pop();  // The person to be removed
    }
    return q.front();
}
",1.0,1111111111
Queue_8,1455332,2210034,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    deque<int> dq;
    int sum = 0;
    for (int i = 0; i < nums.size(); ++i) {
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        dq.push_back(i);
        if (dq.front() == i - k) {
            dq.pop_front();
        }
        if (i >= k - 1) {
            sum += nums[dq.front()];
        }
    }
    return sum;
}
",1.0,1111111111
Queue_9,1455332,2210034,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n, 0);
    for (int i = 0; i < n; ++i) {
        for (int j : graph[i]) {
            ++inDegree[j];
        }
    }

    queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    vector<int> order;
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        order.push_back(v);

        for (int u : graph[v]) {
            --inDegree[u];
            if (inDegree[u] == 0) {
                q.push(u);
            }
        }
    }
    int a = order.size();
    if (a != n) {
        return {};  // The graph doesn't have a topological order
    }

    return order;
}",1.0,1111111111
Queue_1,1455338,2211170,"bool isBipartite(vector<vector<int>>& graph) {
    int n = graph.size();
    vector<int> colors(n, 0);  // 0 represents uncolored, 1 and -1 represent two different colors
    queue<int> q;

    for (int i = 0; i < n; i++) {
        if (colors[i] != 0) {
            continue;  // Skip already colored nodes
        }

        colors[i] = 1;  // Color the start node
        q.push(i);

        while (!q.empty()) {
            int curr = q.front();
            q.pop();

            for (int neighbor : graph[curr]) {
                if (colors[neighbor] == 0) {
                    colors[neighbor] = -colors[curr];  // Color the neighbor with a different color
                    q.push(neighbor);
                } else if (colors[neighbor] == colors[curr]) {
                    return false;  // Neighbor has the same color as the current node, not bipartite
                }
            }
        }
    }

    return true;  // All nodes were successfully colored without conflicts, bipartite
}",1.0,1111111111
Queue_2,1455338,2211170,"void bfs(vector<vector<int>>& graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false);
    queue<int> q;

    visited[start] = true;
    q.push(start);

    while (!q.empty()) {
        int curr = q.front();
        q.pop();

        // Process the current node
        cout << curr << "" "";

        // Traverse the neighbors of the current node
        for (int neighbor : graph[curr]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}",1.0,1111111111
Queue_3,1455338,2211170,"    // Add an item to the back of the queue
    void push(T item) {
        list.add(item);
    }

    // Remove and return the item at the front of the queue
    T pop() {
        if (empty()) {
            throw std::out_of_range(""Queue is empty"");
        }
        T frontItem = list.get(0);
        list.removeAt(0);
        return frontItem;
    }

    // Return the item at the front of the queue without removing it
    T top() {
        if (empty()) {
            throw std::out_of_range(""Queue is empty"");
        }
        return list.get(0);
    }

    // Check if the queue is empty
    bool empty() {
        return list.empty();
    }

    // Return the number of items in the queue
    int size() {
        return list.size();
    }

    // Clear the queue
    void clear() {
        list.clear();
    }",1.0,11111
Queue_4,1455338,2211170,"long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);
    q.push(5);

    long long nthNiceNumber;

    while (n > 0) {
        nthNiceNumber = q.front();
        q.pop();
        n--;

        q.push(nthNiceNumber * 10 + 2);
        q.push(nthNiceNumber * 10 + 5);
    }

    return nthNiceNumber;
}
",1.0,1111111111
Queue_5,1455338,2211170,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();

    // Define directions for adjacent cells
    vector<int> dx = {-1, 0, 1, 0};
    vector<int> dy = {0, 1, 0, -1};

    // Initialize a queue to store the coordinates of rotten apples
    queue<pair<int, int>> rottenQueue;

    int freshApples = 0; // Count of fresh apples

    // Enqueue the coordinates of rotten apples and count the fresh apples
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == 2)
                rottenQueue.push({i, j});
            else if (grid[i][j] == 1)
                freshApples++;
        }
    }

    int minutes = 0; // Time in minutes

    // Perform BFS
    while (!rottenQueue.empty() && freshApples > 0) {
        int size = rottenQueue.size();

        for (int i = 0; i < size; i++) {
            int x = rottenQueue.front().first;
            int y = rottenQueue.front().second;
            rottenQueue.pop();

            // Check the adjacent cells
            for (int j = 0; j < 4; j++) {
                int newX = x + dx[j];
                int newY = y + dy[j];

                // If the adjacent cell is within the grid and contains a fresh apple
                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && grid[newX][newY] == 1) {
                    // Mark the apple as rotten and enqueue its coordinates
                    grid[newX][newY] = 2;
                    rottenQueue.push({newX, newY});
                    freshApples--;
                }
            }
        }

        if (!rottenQueue.empty())
            minutes++; // Increment time in minutes
    }

    // If there are still fresh apples remaining, it's not possible to rot all apples
    if (freshApples > 0)
        return -1;

    return minutes;
}",1.0,1111111111
Queue_6,1455338,2211170,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
        std::queue<int> circle;

    // Initialize the circle with player numbers from 1 to N
    for (int i = 1; i <= N; i++) {
        circle.push(i);
    }

    // Simulate the game process until only one player remains
    while (circle.size() > 1) {
        // Count k-1 players and remove the kth player from the circle
        for (int i = 0; i < k - 1; i++) {
            int frontPlayer = circle.front();
            circle.pop();
            circle.push(frontPlayer);
        }
        circle.pop(); // Remove the kth player
    }

    // The last remaining player is the winner
    return circle.front();
}",1.0,1111111111
Queue_7,1455338,2211170,"int numberOfTheWinner(int N, int k) {
        std::queue<int> circle;

    // Initialize the circle with player numbers from 1 to N
    for (int i = 1; i <= N; i++) {
        circle.push(i);
    }

    // Simulate the game process until only one player remains
    while (circle.size() > 1) {
        // Count k-1 players and remove the kth player from the circle
        for (int i = 0; i < k - 1; i++) {
            int frontPlayer = circle.front();
            circle.pop();
            circle.push(frontPlayer);
        }
        circle.pop(); // Remove the kth player
    }

    // The last remaining player is the winner
    return circle.front();
}",1.0,1111111111
Queue_8,1455338,2211170,"int sumOfMaxSubarray(std::vector<int>& nums, int k) {
    int n = nums.size();
    std::deque<int> maxDeque;
    int sum = 0;

    // Populate the deque with the maximum elements of the first window
    for (int i = 0; i < k; i++) {
        while (!maxDeque.empty() && nums[i] > nums[maxDeque.back()]) {
            maxDeque.pop_back();
        }
        maxDeque.push_back(i);
    }

    // Process the remaining elements of the array
    for (int i = k; i < n; i++) {
        sum += nums[maxDeque.front()]; // Add the maximum element of the previous window to the sum

        // Remove elements outside the current window from the front of the deque
        while (!maxDeque.empty() && maxDeque.front() <= i - k) {
            maxDeque.pop_front();
        }

        // Remove smaller elements from the back of the deque
        while (!maxDeque.empty() && nums[i] > nums[maxDeque.back()]) {
            maxDeque.pop_back();
        }

        maxDeque.push_back(i); // Add the current element to the deque
    }

    sum += nums[maxDeque.front()]; // Add the maximum element of the last window to the sum

    return sum;
}",1.0,1111111111
Queue_9,1455338,2211170,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size(); // Number of nodes in the graph

    // Step 1: Initialize the in-degree of all nodes
    std::vector<int> inDegree(n, 0);
    for (auto& neighbors : graph) {
        for (int node : neighbors) {
            inDegree[node]++;
        }
    }

    // Step 2: Enqueue all nodes with in-degree 0
    std::queue<int> zeroDegreeNodes;
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            zeroDegreeNodes.push(i);
        }
    }

    // Step 3: Perform BFS to determine the topological order
    std::vector<int> topologicalOrder;
    while (!zeroDegreeNodes.empty()) {
        int node = zeroDegreeNodes.front();
        zeroDegreeNodes.pop();
        topologicalOrder.push_back(node);

        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                zeroDegreeNodes.push(neighbor);
            }
        }
    }

    // Step 4: Check if a valid topological order exists
    int m = topologicalOrder.size();
    if (m != n) {
        // The graph has a cycle, no valid topological order exists
        return {};
    }

    return topologicalOrder;
}",1.0,1111111111
Queue_1,1455340,2210055,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> colors(n, -1);

    for (int i = 0; i < n; i++) {
        if (colors[i] == -1) { 
            queue<int> q;
            q.push(i);
            colors[i] = 0; 

            while (!q.empty()) {
                int node = q.front();
                q.pop();

                int currentColor = colors[node];
                int neighborColor = 1 - currentColor; 

                for (int neighbor : graph[node]) {
                    if (colors[neighbor] == -1) {
                        colors[neighbor] = neighborColor;
                        q.push(neighbor);
                    } else if (colors[neighbor] != neighborColor) {
                        return false; 
                    }
                }
            }
        }
    }

    return true; 
}",1.0,1111111111
Queue_2,1455340,2210055,"void bfs(vector<vector<int>> graph, int start) {
	 int numNodes = graph.size();
    vector<bool> visited(numNodes, false); 
    queue<int> q; 
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int current = q.front();
        q.pop();
        cout << current << "" "";

        for (int neighbor : graph[current]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}",1.0,1111111111
Queue_3,1455340,2210055,"void push(T item) {
    // TODO: Push new element into the end of the queue
      list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
        if (empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        T frontItem = list.get(0); // Get the first item
        list.removeAt(0); // Use the removeAt method from DLinkedList to remove the first item
        return frontItem;
}

T top() {
    // TODO: Get value of the element in the head of the queue
         if (empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455340,2210055,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    string arr[n + 1];
    arr[0] = """"; 
    long long size = 1, m = 1;
    while (size <= n) {
        for (long long i = 0; i < m && (size + i) <= n; i++)
            arr[size + i] = ""2"" + arr[size - m + i];
        for (long long i = 0; i < m && (size + m + i) <= n; i++)
            arr[size + m + i] = ""5"" + arr[size - m + i];
        m = m << 1; 
        size = size + m;
    }
    return stoll(arr[n]);
}",0.2,110
Queue_5,1455340,2210055,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
  int m = grid[0].size();

  // Create a queue to store the coordinates of the rotten apples.
  queue<pair<int, int>> rottenApplesQueue;

  // Initialize the queue with the coordinates of all the rotten apples.
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (grid[i][j] == 2) {
        rottenApplesQueue.push({i, j});
      }
    }
  }

  // Keep track of the number of seconds required to rot all apples.
  int seconds = 0;

  // While the queue is not empty, keep rotting the fresh apples adjacent to the rotten apples.
  while (!rottenApplesQueue.empty()) {
    // Get the coordinates of the current rotten apple.
    pair<int, int> currentRottenApple = rottenApplesQueue.front();
    rottenApplesQueue.pop();

    // Rot all the fresh apples adjacent to the current rotten apple.
    for (int i = -1; i <= 1; i++) {
      for (int j = -1; j <= 1; j++) {
        int newX = currentRottenApple.first + i;
        int newY = currentRottenApple.second + j;

        // Check if the new coordinates are within the grid and if the cell at the new coordinates contains a fresh apple.
        if (newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1) {
          // Rot the fresh apple.
          grid[newX][newY] = 2;

          // Add the coordinates of the new rotten apple to the queue.
          rottenApplesQueue.push({newX, newY});
        }
      }
    }

    // Increment the number of seconds.
    seconds++;
  }

  // Check if all the apples have been rotted.
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (grid[i][j] == 1) {
        return -1;
      }
    }
  }

  // Return the number of seconds required to rot all apples.
  return seconds;
}",0.1,1000000000
Queue_6,1455340,2210055,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    std::deque<int> circle;
    
    for (int i = 1; i <= N; i++) {
        circle.push_back(i);
    }
    
    while (circle.size() > 1) {
        for (int i = 0; i < k - 1; i++) {
            circle.push_back(circle.front());
            circle.pop_front();
        }
        circle.pop_front();
    }
    
    return circle.front();
}",1.0,1111111111
Queue_7,1455340,2210055,"int numberOfTheWinner(int N, int k) {
   deque<int> circle;
    
    for (int i = 1; i <= N; i++) {
        circle.push_back(i);
    }
    
    while (circle.size() > 1) {
        for (int i = 0; i < k - 1; i++) {
            circle.push_back(circle.front());
            circle.pop_front();
        }
        circle.pop_front();
    }
    
    return circle.front();
}",1.0,1111111111
Queue_8,1455340,2210055,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
     int n = nums.size();
    if (k > n || k <= 0) {
    cerr << ""Invalid input: k is out of bounds."" << endl;
        return 0;
    }
    deque<int> maxIndices;  
    int sumOfMaxValues = 0;
    for (int i = 0; i < k; i++) {
        while (!maxIndices.empty() && nums[i] >= nums[maxIndices.back()]) {
            maxIndices.pop_back();
        }
        maxIndices.push_back(i);
    }
    sumOfMaxValues += nums[maxIndices.front()];
    for (int i = k; i < n; i++) {
        while (!maxIndices.empty() && maxIndices.front() <= i - k) {
            maxIndices.pop_front();
        }
        while (!maxIndices.empty() && nums[i] >= nums[maxIndices.back()]) {
            maxIndices.pop_back();
        }

        maxIndices.push_back(i);
        sumOfMaxValues += nums[maxIndices.front()];
    }

    return sumOfMaxValues;
}",1.0,1111111111
Queue_9,1455340,2210055,"vector<int> topologicalSorting(vector<vector<int>> graph) {
     int n = graph.size(); 
    vector<int> inDegree(n, 0); 
    vector<int> result; 

    for (int i = 0; i < n; i++) {
        for (int neighbor : graph[i]) {
            inDegree[neighbor]++;
        }
    }

    queue<int> q;
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    int length=result.size();
    if (length != n) {
        return vector<int>(); 
    }

    return result;
}",1.0,1111111111
Queue_1,1455343,2213248,"/*bool isBipartite(vector<vector<int>> graph) {

}
bool isBipartite(int G[][V], int src) 
{ 
    // Create a color array to store colors  
    // assigned to all vertices. Vertex  
    // number is used as index in this array.  
    // The value '-1' of colorArr[i]  
    // is used to indicate that no color  
    // is assigned to vertex 'i'. The value 1  
    // is used to indicate first color  
    // is assigned and value 0 indicates  
    // second color is assigned. 
    int colorArr[V]; 
    for (int i = 0; i < V; ++i) 
        colorArr[i] = -1; 
  
    // Assign first color to source 
    colorArr[src] = 1; 
  
    // Create a queue (FIFO) of vertex  
    // numbers and enqueue source vertex 
    // for BFS traversal 
    queue <int> q; 
    q.push(src); 
  
    // Run while there are vertices  
    // in queue (Similar to BFS) 
    while (!q.empty()) 
    { 
        // Dequeue a vertex from queue ( Refer http://goo.gl/35oz8 ) 
        int u = q.front(); 
        q.pop(); 
  
        // Return false if there is a self-loop  
        if (G[u][u] == 1) 
        return false;  
  
        // Find all non-colored adjacent vertices 
        for (int v = 0; v < V; ++v) 
        { 
            // An edge from u to v exists and  
            // destination v is not colored 
            if (G[u][v] && colorArr[v] == -1) 
            { 
                // Assign alternate color to this adjacent v of u 
                colorArr[v] = 1 - colorArr[u]; 
                q.push(v); 
            } 
  
            // An edge from u to v exists and destination  
            // v is colored with same color as u 
            else if (G[u][v] && colorArr[v] == colorArr[u]) 
                return false; 
        } 
    } 
  
    // If we reach here, then all adjacent   
    // vertices can be colored with alternate color 
    return true; 
}*/
bool helper(vector<vector<int>>& graph , int src , vector<int>&colour ) {
    int n = graph.size();
    queue<int> q;
    q.push(src);
    colour[src] = 0 ;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(int i = 0 ; i<graph[u].size();i++){
            if(colour[graph[u][i]]==-1){
                colour[graph[u][i]] = !colour[u];
                q.push(graph[u][i]);
            }
            else if(colour[graph[u][i]]==colour[u]) return false;
        }
    }
    return true;
}
bool isBipartite(vector<vector<int>>& graph){
	int n = graph.size();
	vector<int> colour(n,-1);
	for(int i=0 ; i < n ; i++){
		if(colour[i]==-1){
			if(helper(graph,i,colour)==false) return false;
		}
	}
	return true;
}",1.0,1111111111
Queue_2,1455343,2213248,"void bfs(vector<vector<int>> graph, int start) {
	queue<int> q;
	q.push(start);
	int n = graph.size();
	vector<int> arr;
	vector<int> visited(n);
	visited[start] = 1 ;
	while(!q.empty()){
	    int u = q.front();
	    arr.push_back(u);
	    q.pop();
	    for(int i = 0 ; i <(int)graph[u].size();i++){
	        if(visited[graph[u][i]] == 0 ){
	            q.push(graph[u][i]);
	            visited[graph[u][i]] =  1;
	        }
	    }
	}
	for(int i=0 ; i<(int)arr.size();i++) cout<<arr[i]<<"" "";
}",1.0,1111111111
Queue_3,1455343,2213248,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    T val = list.get(0);
        list.removeAt(0);
        return val;
}

T top() {
    // TODO: Get value of the element in the head of the queue
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    while(!list.empty()){
        list.removeAt(0);
    }
}",1.0,11111
Queue_4,1455343,2213248,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);  // The first nice number
    q.push(5);
    while (n > 2) {
        long long current = q.front();
        q.pop();
        q.push(current * 10 + 2);  // Add 2 to the end
        n--;
        if(n == 2) break;
        q.push(current * 10 + 5);  // Add 5 to the end
        n--;
    }

    return q.back();
}",0.9,1111111111
Queue_5,1455343,2213248,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    queue<pair<int,int>> q;
    for(int i=0 ; i < n ; i++){
        for(int j = 0 ; j<m;j++){
            if(grid[i][j]==2) q.push({i,j});
        }
    }
    int sec = 0 ;
    while(!q.empty()){
        int s = q.size();
        //cout<<s<<endl;
        bool check = true;
        for(int i=0 ; i < n ; i++){
            for(int j = 0 ; j <m ; j++){
                if(grid[i][j]==1) check = false;
            }
        }
        if(check) break;
        for(int i = 0 ; i<s ; i++ ){
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            if(x+1<n && grid[x+1][y]==1){
                q.push({x+1,y});
                grid[x+1][y] = 2;
            }
            if(y+1<m && grid[x][y+1]==1){
                q.push({x,y+1});
                grid[x][y+1] = 2;
            }
            if(x-1>=0 && grid[x-1][y]==1){
                q.push({x-1,y});
                grid[x-1][y] = 2;
            }
            if(y-1>=0 && grid[x][y-1]==1){
                q.push({x,y-1});
                grid[x][y-1] = 2;
            }
        }
        sec++;
    }
    for(int i=0 ; i<n;i++){
        for(int j = 0 ; j< m ; j++){
            if(grid[i][j]==1) return -1;
        }
    }
    return sec;
}",1.0,1111111111
Queue_6,1455343,2213248,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1 ; i<=N;i++) q.push(i);
    while(q.size()!=1){
    	for(int i=0 ; i<k-1;i++){
    		int u = q.front();
    		q.pop();
    		q.push(u);
    	}
    	q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_7,1455343,2213248,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1 ; i<=N;i++) q.push(i);
    while(q.size()!=1){
    	for(int i=0 ; i<k-1;i++){
    		int u = q.front();
    		q.pop();
    		q.push(u);
    	}
    	q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_8,1455343,2213248,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int ans = 0 ;
    int n = nums.size();
    deque<int> q;
    q.push_back(0);
    for(int i=1 ; i<k;i++){
        while(!q.empty() && nums[i]>=nums[q.back()]){
            q.pop_back();
        }
        q.push_back(i);
    }
    for(int i = k ; i<n;i++){
        ans+=nums[q.front()];
        while(!q.empty() && q.front()<=i-k) q.pop_front();
        while(!q.empty() && nums[i]>=nums[q.back()]) q.pop_back();
        q.push_back(i);
    }
    ans += nums[q.front()];
    return ans;
}",1.0,1111111111
Queue_9,1455343,2213248,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n,0);
    for(int u = 0 ; u<(int)graph.size();u++){
        for(int v = 0 ; v<(int)graph[u].size();v++){
            ++inDegree[graph[u][v]];
        }
    }
    queue<int> q;
    for(int i=0 ; i<n ; i++ ){
        if(inDegree[i]==0) q.push(i);
    }
    int cnt = 0 ;
    vector<int> top_order;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        top_order.push_back(u);
        for(int i = 0 ; i<(int)graph[u].size();i++){
            if(--inDegree[graph[u][i]]==0) q.push(graph[u][i]);
        }
        cnt++;
    }
    if(cnt!=n){
        return {};
    }
    else return top_order;
}",1.0,1111111111
Queue_1,1455368,2210532,"#include <iostream>
#include <vector>
#include <queue>
bool isBipartite(vector<vector<int>>& graph) {
    int n = graph.size();
    vector<int> colors(n,0);
    queue<int> q;

    for (int i = 0; i < n; i++) {
        if (colors[i] != 0) continue; // Node is already colored
        colors[i] = 1; // Color the first node as 1
        q.push(i);
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            for (int neighbor : graph[node]) {
                if (colors[neighbor] == 0) {
                    // Color the neighbor with a different color
                    colors[neighbor] = -colors[node];
                    q.push(neighbor);
                } else if (colors[neighbor] == colors[node]) {
                    // Conflict: Same color edge found, not bipartite
                    return false;
                }
            }
        }
    }

    return true; 
}",1.0,1111111111
Queue_2,1455368,2210532,"void bfs(vector<vector<int>> graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false); // Mark all nodes as not visited
    queue<int> q;

    // Mark the starting node as visited and enqueue it
    visited[start] = true;
    q.push(start);

    while (!q.empty()) {
        // Dequeue a vertex from the queue and print it
        int node = q.front();
        cout << node << "" "";
        q.pop();

        // Get all adjacent vertices of the dequeued vertex
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
    cout << endl;
}",1.0,1111111111
Queue_3,1455368,2210532,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    if(empty())throw std::runtime_error("""");
    T item = list.get(0);
    list.removeAt(0);
    return item;
}

T top() {
    // TODO: Get value of the element in the head of the queue
    if(empty())throw std::runtime_error("""");
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
     return list.empty(); 
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1455368,2210532,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    if(n == 1)return 2;
    queue<long long>nice;
    int count = 1;
    long long curr = 2;
    nice.push(2);
    nice.push(5);
    while(count <= n){
        curr = nice.front();
        nice.pop();
        nice.push(curr*10 + 2);
        nice.push(curr*10 + 5);
        count++;
    }
    return curr;
}",1.0,1111111111
Queue_5,1455368,2210532,"struct Cell {
    int row;
    int col;
    int time;

    Cell(int r, int c, int t) : row(r), col(c), time(t) {}
};

int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    int freshApples = 0;
    queue<Cell> rottenQueue;

    // Initialize the queue with all rotten apples
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (grid[r][c] == 2) {
                rottenQueue.push(Cell(r, c, 0));
            }
            if (grid[r][c] == 1) {
                freshApples++;
            }
        }
    }

    // Define possible adjacent directions
    vector<int> dr = {-1, 1, 0, 0};
    vector<int> dc = {0, 0, -1, 1};

    while (!rottenQueue.empty()) {
        Cell current = rottenQueue.front();
        rottenQueue.pop();

        for (int i = 0; i < 4; i++) {
            int newRow = current.row + dr[i];
            int newCol = current.col + dc[i];

            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                if (grid[newRow][newCol] == 1) {
                    grid[newRow][newCol] = 2;
                    rottenQueue.push(Cell(newRow, newCol, current.time + 1));
                    freshApples--;
                }
            }
        }
    }

    if (freshApples == 0) {
        return rottenQueue.back().time;  // Return the time of the last rot
    } else {
        return -1;  // Some apples could not be rotten
    }
}",1.0,1111111111
Queue_6,1455368,2210532,"int numberOfTheWinner(int N, int k) {
    queue<int> circle;

    // Initialize the circle with numbers from 1 to N
    for (int i = 1; i <= N; i++) {
        circle.push(i);
    }

    // Simulate the game until only one person is left
    while (circle.size() > 1) {
        for (int i = 1; i < k; i++) {
            int front = circle.front();
            circle.pop();
            circle.push(front);
        }
        circle.pop(); // Remove the last counted one
    }

    return circle.front(); // The last person is the winner
}",1.0,1111111111
Queue_7,1455368,2210532,"int numberOfTheWinner(int N, int k) {
    queue<int> circle;

    // Initialize the circle with numbers from 1 to N
    for (int i = 1; i <= N; i++) {
        circle.push(i);
    }

    // Simulate the game until only one person is left
    while (circle.size() > 1) {
        for (int i = 1; i < k; i++) {
            int front = circle.front();
            circle.pop();
            circle.push(front);
        }
        circle.pop(); // Remove the last counted one
    }

    return circle.front(); // The last person is the winner
}",1.0,1111111111
Queue_8,1455368,2210532,"int sumOfMaxSubarray(const vector<int>& nums, int k) {
    int n = nums.size();
    deque<int> dq;
    long long result = 0;

    for (int i = 0; i < n; i++) {
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }

        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }

        dq.push_back(i);

        if (i >= k - 1) {
            result += nums[dq.front()];
        }
    }

    return static_cast<int>(result);
}",1.0,1111111111
Queue_9,1455368,2210532,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n, 0);

    // Calculate in-degrees of nodes
    for (int u = 0; u < n; u++) {
        for (int v : graph[u]) {
            inDegree[v]++;
        }
    }

    queue<int> q;
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    vector<int> result;
    int visited = 0;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        visited++;

        for (int v : graph[u]) {
            inDegree[v]--;
            if (inDegree[v] == 0) {
                q.push(v);
            }
        }
    }

    if (visited != n) {
        // The graph has a cycle, no topological order
        return vector<int>();
    }

    return result;
}",1.0,1111111111
Queue_1,1455438,2212499,"bool isBipartite(vector<vector<int>> graph) {
 int n = graph.size();
    vector<int> color(n, -1);
    
    for (int i = 0; i < n; i++) {
        if (color[i] == -1) {
            queue<int> q;
            q.push(i);
            color[i] = 0;
            
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                
                for (int neighbor : graph[node]) {
                    if (color[neighbor] == -1) {
                        q.push(neighbor);
                        color[neighbor] = 1 - color[node];
                    } else if (color[neighbor] == color[node]) {
                        return false;
                    }
                }
            }
        }
    }
    
    return true;
}",1.0,1111111111
Queue_2,1455438,2212499,"void bfs(vector<vector<int>> graph, int start) {
	int n = graph.size();
    vector<bool> visited(n, false);
    queue<int> q;
    
    visited[start] = true;
    q.push(start);
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        
        cout << node << "" "";
        
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}",1.0,1111111111
Queue_3,1455438,2212499,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
     T item = list.get(0);
        list.removeAt(0);
        return item;   
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);    
}

bool empty() {
    // TODO: Determine if the queue is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the queue
         return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
     list.clear();
}",1.0,11111
Queue_4,1455438,2212499,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);
    q.push(5);

    while (--n) {
        long long curr = q.front();
        q.pop();

        q.push(curr * 10 + 2);
        q.push(curr * 10 + 5);
    }

    return q.front();
}",1.0,1111111111
Queue_5,1455438,2212499,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
 int n = grid.size();
    int m = grid[0].size();
    queue<pair<int, int>> q;
    int fresh = 0;
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 2) {
                q.push({i, j});
            } else if (grid[i][j] == 1) {
                fresh++;
            }
        }
    }
    
    int time = 0;
    vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    while (!q.empty() && fresh > 0) {
        time++;
        int size = q.size();
        
        for (int i = 0; i < size; i++) {
            pair<int, int> curr = q.front();
            q.pop();
            
            for (pair<int, int> dir : dirs) {
                int x = curr.first + dir.first;
                int y = curr.second + dir.second;
                
                if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] != 1) {
                    continue;
                }
                
                grid[x][y] = 2;
                q.push({x, y});
                fresh--;
            }
        }
    }
    
    return fresh == 0 ? time : -1;}",1.0,1111111111
Queue_6,1455438,2212499,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
 queue<int> q;
    for (int i = 1; i <= N; i++) {
        q.push(i);
    }
    
    while (q.size() > 1) {
        for (int i = 0; i < k - 1; i++) {
            q.push(q.front());
            q.pop();
        }
        q.pop();
    }
    
    return q.front();}",1.0,1111111111
Queue_7,1455438,2212499,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i = 1; i <= N; i++) {
        q.push(i);
    }
    
    while (q.size() > 1) {
        for (int i = 0; i < k - 1; i++) {
            q.push(q.front());
            q.pop();
        }
        q.pop();
    }
    
    return q.front();}",1.0,1111111111
Queue_8,1455438,2212499,"int sumOfMaxSubarray(vector<int>& nums, int k) {
deque<int> dq;
    int sum = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        if (dq.front() == i - k) {
            dq.pop_front();
        }
        
        if (i >= k - 1) {
            sum += nums[dq.front()];
        }
    }
    
    return sum;}",1.0,1111111111
Queue_1,1455447,2210997,"bool isBipartite(vector<vector<int>> graph) {
    bool black=1, white=0;
       queue<int>q;
       q.push(0); 
       vector<int>visited(graph.size(), -1);

       for(int j=0;j<graph.size();j++)
       {
           if(visited[j]!=-1) continue;
           q.push(j);
           visited[j]=white;

        
        while(!q.empty())
        {
            int first=q.front();
            q.pop();
            
            for(int i=0;i<graph[first].size();i++)
            {
                if(visited[graph[first][i]]==-1)
                {
                    q.push(graph[first][i]);
                    
                    if(visited[first]==white)
                    {
                       visited[graph[first][i]]=black; 
                    }
                    
                    else if(visited[first]==black)
                    {
                        visited[graph[first][i]]=white;
                    }
                }
                
                else if(visited[first]==visited[graph[first][i]])
                {
                    return false;
                }
                
            }
          }
       }     
        
        return true;

}",1.0,1111111111
Queue_2,1455447,2210997,"void bfs(vector<vector<int>> graph, int start) {
  queue<int> q;
  vector<bool> visited(graph.size(), false);
  q.push(start);
  visited[start] = true;
  while (!q.empty())
  {
    int node = q.front();
    q.pop();
    cout << node << "" "";
    for (int i = 0; i < int(graph[node].size()); i++)
    {
      if (!visited[graph[node][i]])
      {
        q.push(graph[node][i]);
        visited[graph[node][i]] = true;
      }
    }
  }
}",1.0,1111111111
Queue_3,1455447,2210997,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    if (empty())   throw std::out_of_range(""Queue is empty"");
    T front = list.get(0);
    list.removeAt(0);
    return front;
    
}

T top() {
    // TODO: Get value of the element in the head of the queue
     if (empty())     throw std::out_of_range(""Queue is empty"");
    return list.get(0);
        
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();
        
}

int size() {
    // TODO: Get the size of the queue
     return list.size();
        
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
    
}",1.0,11111
Queue_4,1455447,2210997,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    //return 0.0;
    queue<long long> q;
  q.push(2);
  q.push(5);
  long long result = 0;
  for (int i = 0; i < n; i++)
  {
    result = q.front();
    q.pop();
    q.push(result * 10 + 2);
    q.push(result * 10 + 5);
  }
  return result;
}",1.0,1111111111
Queue_5,1455447,2210997,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    vector<vector<int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    queue<pair<int, int>> rottenApples;
    int freshApples = 0;
    
    // Initialize the queue with rotten apples and count fresh apples
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == 2) {
                rottenApples.push({i, j});
            } else if (grid[i][j] == 1) {
                freshApples++;
            }
        }
    }
    
    int minutes = 0;
    
    // Perform BFS to rot fresh apples
    while (!rottenApples.empty() && freshApples > 0) {
        int size = rottenApples.size();
        for (int i = 0; i < size; i++) {
            int x = rottenApples.front().first;
            int y = rottenApples.front().second;
            rottenApples.pop();
            
            for (const vector<int>& dir : directions) {
                int newX = x + dir[0];
                int newY = y + dir[1];
                
                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && grid[newX][newY] == 1) {
                    grid[newX][newY] = 2; // Mark the fresh apple as rotten
                    freshApples--;
                    rottenApples.push({newX, newY});
                }
            }
        }
        
        minutes++;
    }
    
    return (freshApples == 0) ? minutes : -1;
}",1.0,1111111111
Queue_6,1455447,2210997,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i = 1; i <= N; i++)
    q.push(i);
    int temp = k;
    while (q.size() != 1)
    {
        temp--;
        if (temp == 0)
        {
            q.pop();
            temp = k;
            continue;
        }
        int value = q.front();
        q.pop();
        q.push(value);
    }
  return q.front();
}",1.0,1111111111
Queue_7,1455447,2210997,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for (int i = 1; i <= N; i++)
    q.push(i);
    int temp = k;
    while (q.size() != 1)
    {
        temp--;
        if (temp == 0)
        {
            q.pop();
            temp = k;
            continue;
        }
        int value = q.front();
        q.pop();
        q.push(value);
    }
  return q.front();
}",1.0,1111111111
Queue_8,1455447,2210997,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    deque<int> dq;
    int sum = 0, max_q = 0, vec_size = nums.size();
    for (int i = 0; i < k; i++) {
        if (dq.empty()) dq.push_back(i);
        else {
            while (!dq.empty() && nums[dq.back()] < nums[i])
                dq.pop_back();
            dq.push_back(i);
        }
    }
    sum = nums[dq.front()];

    for (int i = k; i < vec_size; i++) {
        if (i - k + 1 > dq.front()) dq.pop_front();
        while (!dq.empty() && nums[dq.back()] < nums[i])
            dq.pop_back();
        dq.push_back(i);
        sum += nums[dq.front()];
    }

    return sum;
}",1.0,1111111111
Queue_9,1455447,2210997,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int V = graph.size();
	vector<int> in_degree(V, 0);
	for (int u = 0; u < V; u++){
		vector<int>::iterator itr;
		for (itr = graph[u].begin(); itr != graph[u].end(); itr++){
			in_degree[*itr]++;
		}
	}
	queue<int> q;
	for (int i=0; i<V; i++){
		if (in_degree[i] == 0) q.push(i);
	}
	int counter = 0;
	vector<int> top_order;
	while (!q.empty()){
		int u = q.front();
		q.pop();
		top_order.push_back(u);
		vector<int>::iterator itr;
		for (itr = graph[u].begin(); itr != graph[u].end(); itr++){
			if (--in_degree[*itr] == 0) q.push(*itr);
		}
		counter++;
	}
	if (counter != V) return vector<int>();
	else return top_order;
    
}",1.0,1111111111
Queue_1,1455457,2212651,"#include <iostream>
#include <vector>
#include <queue>
bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> colors(n, 0);  // 0 represents uncolored, 1 and -1 represent two different colors
    queue<int> q;

    for (int i = 0; i < n; i++) {
        if (colors[i] != 0) continue;  // Skip already colored vertices

        colors[i] = 1;  // Color the first vertex with 1
        q.push(i);

        while (!q.empty()) {
            int current = q.front();
            q.pop();

            for (int neighbor : graph[current]) {
                if (colors[neighbor] == 0) {
                    // Color the neighbor with the opposite color
                    colors[neighbor] = -colors[current];
                    q.push(neighbor);
                } else if (colors[neighbor] == colors[current]) {
                    // If the neighbor has the same color as the current vertex, the graph is not bipartite
                    return false;
                }
            }
        }
    }

    return true;
}
",1.0,1111111111
Queue_2,1455457,2212651,"#include <iostream>
#include <vector>
#include <queue>

void bfs(vector<vector<int>> graph, int start) {
	int numVertices = graph.size();
	bool *visited = new bool[numVertices]; 
    for(int i = 0; i < numVertices; i++) 
        visited[i] = false; 

    queue<int> myQueue; 
    bool isFirst = true;
    visited[start] = true; 
    myQueue.push(start); 

    while(!myQueue.empty()) 
    { 
        start = myQueue.front();
        if (isFirst) {
            cout << start;
            isFirst = false;
        }
        else cout << "" "" << start;
        myQueue.pop(); 

        int outDegree = graph[start].size();
        for (int j = 0; j < outDegree; ++j) 
        { 
            int temp = graph[start][j];
            if (!visited[temp]) 
            { 
                visited[temp] = true; 
                myQueue.push(temp); 
            } 
        }
    }
    delete[] visited;
}",1.0,1111111111
Queue_3,1455457,2212651,"void push(T item) {
    // TODO: Push new element into the end of the queue
    this->list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    if (this->empty()) throw std::out_of_range(""Empty Queue"");
    return this->list.removeAt(0);
}

T top() {
    // TODO: Get value of the element in the head of the queue
    if (this->empty()) throw std::out_of_range(""Empty Queue"");
    return this->list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
    return this->list.empty();
}

int size() {
    // TODO: Get the size of the queue
    return this->list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    return this->list.clear();
}",1.0,11111
Queue_4,1455457,2212651,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long int> q;
	    q.push(2);
	    q.push(5);
	    n--;
	    while (n--)
	    {
	        long int x=q.front();
	        q.pop();
	        q.push(x*10+2);
	        q.push(x*10+5);
	    };
	    return q.front();
}",1.0,1111111111
Queue_5,1455457,2212651,"#include<queue>
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, 1, -1};
int secondsToBeRotten(vector<vector<int>>& grid) {
    queue<pair<int,pair<int,int>>> q;
    int cF = 0, cR = 0;
    for (int i=0; i<(int)grid.size(); i++){
        for (int j=0; j<(int)grid[i].size(); j++){
            if (grid[i][j] == 2)
                q.push({0, {i,j}});
            else if (grid[i][j] == 1) ++cF;
        }
    }
    cR = q.size();
    if (cR == 0)    return -1;
    int anstime = 1;
    while (!q.empty()){
        pair<int,pair<int,int>> f  = q.front();
        q.pop();
        int time = f.first;
        for (int k = 0; k<4; k++){
            int i1 = f.second.first+dx[k], j1 = f.second.second+dy[k];
            if (i1 >= 0 && i1 < (int)grid.size() && j1>=0 && j1<(int)grid[0].size() && grid[i1][j1] == 1){
                grid[i1][j1] = 2;
                --cF;
                q.push({time+1,{i1, j1}});
                anstime = max(anstime, time+1);

            }
        }
    }
    return (cF==0?anstime:-1);
}",1.0,1111111111
Queue_6,1455457,2212651,"// iostream and queue are included
// Hint: Use a queue to simulate the process

vector<int> topologicalSorting(vector<vector<int>> graph){
	int V = graph.size();
	vector<int> in_degree(V, 0);
	for (int u = 0; u < V; u++){
		vector<int>::iterator itr;
		for (itr = graph[u].begin(); itr != graph[u].end(); itr++){
			in_degree[*itr]++;
		}
	}
	queue<int> q;
	for (int i=0; i<V; i++){
		if (in_degree[i] == 0) q.push(i);
	}
	int counter = 0;
	vector<int> top_order;
	while (!q.empty()){
		int u = q.front();
		q.pop();
		top_order.push_back(u);
		vector<int>::iterator itr;
		for (itr = graph[u].begin(); itr != graph[u].end(); itr++){
			if (--in_degree[*itr] == 0) q.push(*itr);
		}
		counter++;
	}
	if (counter != V) return vector<int>();
	else return top_order;
}
int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1;i<=N;i++){
        q.push(i);
    }
    while(q.front()!=q.back()){
        int x=k-1;
        while(x>0){
            int temp=q.front();
            q.pop();
            q.push(temp);
            x--;
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_7,1455457,2212651,"vector<int> topologicalSorting(vector<vector<int>> graph){
	int V = graph.size();
	vector<int> in_degree(V, 0);
	for (int u = 0; u < V; u++){
		vector<int>::iterator itr;
		for (itr = graph[u].begin(); itr != graph[u].end(); itr++){
			in_degree[*itr]++;
		}
	}
	queue<int> q;
	for (int i=0; i<V; i++){
		if (in_degree[i] == 0) q.push(i);
	}
	int counter = 0;
	vector<int> top_order;
	while (!q.empty()){
		int u = q.front();
		q.pop();
		top_order.push_back(u);
		vector<int>::iterator itr;
		for (itr = graph[u].begin(); itr != graph[u].end(); itr++){
			if (--in_degree[*itr] == 0) q.push(*itr);
		}
		counter++;
	}
	if (counter != V) return vector<int>();
	else return top_order;
}
int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1;i<=N;i++){
        q.push(i);
    }
    while(q.front()!=q.back()){
        int x=k-1;
        while(x>0){
            int temp=q.front();
            q.pop();
            q.push(temp);
            x--;
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_8,1455457,2212651,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    deque<int> dq;
    int res = -1e6;
    for (int i=0; i<k; i++){
        res = max(res, nums[i]);
        while (!dq.empty() && nums[i] > nums[dq.back()])
            dq.pop_back();
        dq.push_back(i);
    }
    for (int i=k; i<(int)nums.size(); i++){
        while (!dq.empty() && nums[i] > nums[dq.back()])
            dq.pop_back();
        dq.push_back(i);
        if (!dq.empty() && dq.front() == i-k)
            dq.pop_front();
        
        res+=nums[dq.front()];
    }
    return res;
}",1.0,1111111111
Queue_9,1455457,2212651,"vector<int> topologicalSorting(vector<vector<int>> graph){
	int V = graph.size();
	vector<int> in_degree(V, 0);
	for (int u = 0; u < V; u++){
		vector<int>::iterator itr;
		for (itr = graph[u].begin(); itr != graph[u].end(); itr++){
			in_degree[*itr]++;
		}
	}
	queue<int> q;
	for (int i=0; i<V; i++){
		if (in_degree[i] == 0) q.push(i);
	}
	int counter = 0;
	vector<int> top_order;
	while (!q.empty()){
		int u = q.front();
		q.pop();
		top_order.push_back(u);
		vector<int>::iterator itr;
		for (itr = graph[u].begin(); itr != graph[u].end(); itr++){
			if (--in_degree[*itr] == 0) q.push(*itr);
		}
		counter++;
	}
	if (counter != V) return vector<int>();
	else return top_order;
}",1.0,1111111111
Queue_1,1455459,2213836,"#include <vector>
#include <queue>

bool isBipartite(vector<vector<int>>& graph) {
  int n = graph.size();
  vector<int> colors(n, 0); // 0: not colored, 1: color 1, -1: color -1

  for (int i = 0; i < n; i++) {
    if (colors[i] != 0) {
      // This node is already colored, skip it
      continue;
    }

    colors[i] = 1; // Color the starting node as 1

    queue<int> q;
    q.push(i);

    while (!q.empty()) {
      int node = q.front();
      q.pop();

      for (int neighbor : graph[node]) {
        if (colors[neighbor] == 0) {
          // Neighbor node is not colored yet, color it with the opposite color
          colors[neighbor] = -colors[node];
          q.push(neighbor);
        } else if (colors[neighbor] == colors[node]) {
          // Neighbor node has the same color as the current node, not bipartite
          return false;
        }
      }
    }
  }

  return true; // All nodes are successfully colored, graph is bipartite
}",1.0,1111111111
Queue_2,1455459,2213836,"#include <iostream>
#include <vector>
#include <queue>

void bfs(vector<vector<int>> graph, int start) {
	int numVertices = graph.size();
	bool *visited = new bool[numVertices]; 
    for(int i = 0; i < numVertices; i++) 
        visited[i] = false; 

    queue<int> myQueue; 
    bool isFirst = true;
    visited[start] = true; 
    myQueue.push(start); 

    while(!myQueue.empty()) 
    { 
        start = myQueue.front();
        if (isFirst) {
            cout << start;
            isFirst = false;
        }
        else cout << "" "" << start;
        myQueue.pop(); 

        int outDegree = graph[start].size();
        for (int j = 0; j < outDegree; ++j) 
        { 
            int temp = graph[start][j];
            if (!visited[temp]) 
            { 
                visited[temp] = true; 
                myQueue.push(temp); 
            } 
        }
    }
    delete[] visited;
}",1.0,1111111111
Queue_3,1455459,2213836,"void push(T item) {
    // TODO: Push new element into the end of the queue
    this->list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    if (this->empty()) throw std::out_of_range(""Empty Queue"");
    return this->list.removeAt(0);
}

T top() {
    // TODO: Get value of the element in the head of the queue
    if (this->empty()) throw std::out_of_range(""Empty Queue"");
    return this->list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
    return this->list.empty();
}

int size() {
    // TODO: Get the size of the queue
    return this->list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    return this->list.clear();
}",1.0,11111
Queue_4,1455459,2213836,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2); 
    q.push(5);
    
    // Use BFS to generate nice numbers.
    while (true) {
        long long current = q.front();
        q.pop();
        n--;
        
        if (n == 0) {
            return current;
        }
        
        q.push(current * 10 + 2);
        q.push(current * 10 + 5);
    }
}",1.0,1111111111
Queue_5,1455459,2213836,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();

    // Define directions: up, down, left, right
    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};

    queue<pair<int, int>> q;
    int freshOranges = 0;
    int minutes = -1;

    // Enqueue all initial rotten oranges
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == 2) {
                q.push({i, j});
            } else if (grid[i][j] == 1) {
                freshOranges++;
            }
        }
    }

    // BFS to rot neighboring oranges
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            pair<int, int> curr = q.front();
            q.pop();

            int x = curr.first;
            int y = curr.second;

            for (int k = 0; k < 4; k++) {
                int nx = x + dx[k];
                int ny = y + dy[k];

                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 1) {
                    grid[nx][ny] = 2; // Mark the orange as rotten
                    q.push({nx, ny});
                    freshOranges--;
                }
            }
        }
        minutes++;
    }

    // Return the number of minutes required for all oranges to become rotten
    return freshOranges == 0 ? minutes : -1;
}",1.0,1111111111
Queue_6,1455459,2213836,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1;i<=N;++i)
    {
        q.push(i);
    }
    while(q.size()>1)
    {
        
        for(int i=1;i<=k-1;++i)
        {
            int top=q.front();
            q.pop();
            q.push(top);
        }
        q.pop();
    }
    return q.front();
    
}",1.0,1111111111
Queue_7,1455459,2213836,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1;i<=N;++i)
    {
        q.push(i);
    }
    while(q.size()>1)
    {
        
        for(int i=1;i<=k-1;++i)
        {
            int top=q.front();
            q.pop();
            q.push(top);
        }
        q.pop();
    }
    return q.front();
    
}",1.0,1111111111
Queue_8,1455459,2213836,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    int sum = 0;
    int len = nums.size();
    
    if (len == 0 || k <= 0 || k > len) return 0;
    
    deque<int> q; 
    for (int i = 0; i < len; ++i) {
       
        while (!q.empty() && q.front() < i - k + 1) { 
            // i - k + 1 sẽ là chỉ số của phần tử đầu tiên trong cửa sổ
            q.pop_front();
        }
        
       
        while (!q.empty() && nums[q.back()] < nums[i]) {
            q.pop_back();
        }
        
        q.push_back(i);  
        
        if (i >= k - 1) {
            sum += nums[q.front()];  
        }
    }
    
    return sum;
}",1.0,1111111111
Queue_9,1455459,2213836,"#include <iostream>
#include <vector>
#include <queue>

vector<int> topologicalSorting(vector<vector<int>> graph) {
    vector<int> g;
    int numVer = graph.size();
    vector<int> in_degree(numVer, 0);

    for (int u = 0; u < numVer; u++) {
        for (auto i = graph[u].begin(); i != graph[u].end(); i++)
            in_degree[*i]++;
    }

    queue<int> q;
    for (int i = 0; i < numVer; i++)
        if (in_degree[i] == 0)
            q.push(i);
    int count = 0;
    vector<int> result;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        for (auto i = graph[u].begin(); i != graph[u].end(); i++)
            if (--in_degree[*i] == 0)
                q.push(*i);
        count++;
    }
    if (count != numVer) {
        return g;
    }
    return result;
}",1.0,1111111111
Queue_1,1505537,2110501,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    int color[1001];
    for(int i=0;i<n;i++){
        color[i]=-1;
    }
    queue<int> q;
    bool check;
    for(int u=0;u<n;u++){
        if(color[u]==-1){
            check=true;
            q.push(u);
            color[u]=0;
            while(!q.empty()){
                int v=q.front();
                q.pop();
                for(int x : graph[v]){
                    if(color[x]==-1){
                        color[x]=1-color[v];
                        q.push(x);
                    }
                    else if(color[x]==color[v]) return false;
                }
            }
        }
    }
    return true;
}",1.0,1111111111
Queue_2,1505537,2110501,"void bfs(vector<vector<int>> graph, int start) {
	int n =graph.size();
	bool visited[1001];
	for(int i=0;i<n;i++){
	    visited[i]=false;
	}
	queue<int> q;
	q.push(start);
	visited[start]=true;
	while(!q.empty()){
	    int v=q.front();
	    q.pop();
	    cout<< v <<"" "";
	    for(int x:graph[v]){
	        if(!visited[x]){
	            q.push(x);
	            visited[x]=true;    
	        }
	    }
	}
}",1.0,1111111111
Queue_3,1505537,2110501,"void push(T item) {
    // TODO: Push new element into the end of the queue
    this->list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    if(this->list.empty()) throw std::out_of_range(""Index is out of range"");
    else    
    {
        return this->list.removeAt(0);
    }       
}

T top() {
    // TODO: Get value of the element in the head of the queue
    if(this->list.empty()) throw std::out_of_range(""Index is out of range"");
    else
    {
    return this->list.get(0);
    }      
}

bool empty() {
    // TODO: Determine if the queue is empty
    return this->list.empty();    
}

int size() {
    // TODO: Get the size of the queue
    return  this->list.size();    
}

void clear() {
    // TODO: Clear all elements of the queue
    this->list.clear();
}",1.0,11111
Queue_4,1505537,2110501,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<string> q;
    if (n == 1) return 2;
    if (n == 2) return 5;
    vector<long long> v;
    long long x = 1000000;
    while(x > 0){
        if (q.empty()){
            q.push(""2""); v.push_back(stoll(""2""));
            q.push(""5""); v.push_back(stoll(""5""));
            x -= 2;
        }
        else {
            string temp = q.front();
            q.pop();
            q.push(temp + ""2"");
            v.push_back(stoll(temp + ""2""));
            q.push(temp + ""5"");
            v.push_back(stoll(temp + ""5""));
            x -= 2;
        }
    }
    return v[n - 1];
}",1.0,1111111111
Queue_5,1505537,2110501,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    
    vector<int> dx = {1, -1, 0, 0};
    vector<int> dy = {0, 0, 1, -1};

    queue<pair<int, int>> q;

    int time = 0;
    int freshApples = 0;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 1) {
                freshApples++;
            }
            else if (grid[i][j] == 2) {
                q.push({i, j});
            }
        }
    }

    while (!q.empty() && freshApples > 0) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();

            for (int k = 0; k < 4; k++) {
                int nx = x + dx[k];
                int ny = y + dy[k];

                if (nx >= 0 && ny >= 0 && nx < n && ny < m && grid[nx][ny] == 1) {
                    grid[nx][ny] = 2;
                    freshApples--;
                    q.push({nx, ny});
                }
            }
        }
        time++;
    }

    return freshApples == 0 ? time : -1;
}",1.0,1111111111
Queue_6,1505537,2110501,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    int winner = 0;
    for (int i = 2; i <= N; i++) {
        winner = (winner + k) % i;
    }
    return winner + 1;
}",1.0,1111111111
Queue_7,1505537,2110501,"int numberOfTheWinner(int N, int k) {
    int winner = 0;
    for (int i = 2; i <= N; i++) {
        winner = (winner + k) % i;
    }
    return winner + 1;
}",1.0,1111111111
Queue_8,1505537,2110501,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int N=nums.size();
    int res=0;
    std::deque<int> Qi(k);
    int i;
    for(i=0;i<k;++i){
        while((!Qi.empty())&&nums[i]>=nums[Qi.back()])
            Qi.pop_back();
        Qi.push_back(i);
    }
    for(;i<N;++i){
        res+=nums[Qi.front()];
        while((!Qi.empty())&&Qi.front()<=i-k)
            Qi.pop_front();
        while((!Qi.empty())&&nums[i]>=nums[Qi.back()])
            Qi.pop_back();
        Qi.push_back(i);
    }
    res+=nums[Qi.front()];
    return res;
}",1.0,1111111111
Queue_9,1505537,2110501,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int V = graph.size();
    vector<int> in_degree(V, 0);
    for (int u = 0; u < V; u++) {
        for (int v : graph[u]) {
            in_degree[v]++;
        }
    }
    queue<int> q;
    for (int i = 0; i < V; i++) {
        if (in_degree[i] == 0) {
            q.push(i);
        }
    }

    vector<int> top_order;
    int cnt = 0;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        top_order.push_back(u);
        for (int v : graph[u]) {
            if (--in_degree[v] == 0) {
                q.push(v);
            }
        }

        cnt++;
    }

    if (cnt != V) {
        return vector<int>();
    }

    return top_order;
}",1.0,1111111111
Queue_1,1508956,2252260,"#include <iostream>
#include <vector>
#include <queue>

bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> color(n, -1);

    for (int start = 0; start < n; ++start) {
        if (color[start] == -1) {
            queue<int> q;
            q.push(start);
            color[start] = 0;

            while (!q.empty()) {
                int node = q.front();
                q.pop();

                for (int nei : graph[node]) {
                    if (color[nei] == -1) {
                        q.push(nei);
                        color[nei] = color[node] ^ 1;
                    } else if (color[nei] == color[node]) {
                        return false;
                    }
                }
            }
        }
    }

    return true;
}
",1.0,1111111111
Queue_2,1508956,2252260,"void bfs(vector<vector<int>> graph, int start) {
	std::queue<int> q;
    std::vector<bool> visited(graph.size(), false);

    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();

        std::cout << node << "" "";

        for (int i = 0; i < graph[node].size(); i++) {
            if (!visited[graph[node][i]]) {
                q.push(graph[node][i]);
                visited[graph[node][i]] = true;
            }
        }
    }
}",1.0,1111111111
Queue_3,1508956,2252260,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    return list.removeAt(0);       
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1508956,2252260,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);
    q.push(5);
    for(int i=0; i<n-1;i++){
        long long curr = q.front();
        q.pop();
        q.push(curr*10+2);
        q.push(curr*10+5);
    }
    return q.front();
}",1.0,1111111111
Queue_5,1508956,2252260,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    std::queue<std::pair<int, int>> q;
    int freshApples = 0;
    int time = -1;

    for (unsigned int i = 0; i < grid.size(); ++i) {
        for (unsigned int j = 0; j < grid[i].size(); ++j) {
            if (grid[i][j] == 2) {
                q.push({i, j});
            } else if (grid[i][j] == 1) {
                ++freshApples;
            }
        }
    }

    std::vector<std::vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    while (!q.empty() && freshApples) {
        ++time;
        int n = q.size();
        for (int i = 0; i < n; ++i) {
            std::pair<int, int> node = q.front();
            q.pop();

            for (auto& d : directions) {
                int nx = node.first + d[0];
                int ny = node.second + d[1];

                if (nx >= 0 && ny >= 0 && nx < static_cast<int>(grid.size()) && ny < static_cast<int>(grid[nx].size()) && grid[nx][ny] == 1) {
                    grid[nx][ny] = 2;
                    --freshApples;
                    q.push({nx, ny});
                }
            }
        }
    }

    return freshApples == 0 ? time + 1 : -1;
}",1.0,1111111111
Queue_6,1508956,2252260,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    if (N == 1)
        return 1;
    else
        return (numberOfTheWinner(N - 1, k) + k - 1) % N + 1;
}",1.0,1111111111
Queue_7,1508956,2252260,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    if (N == 1)
        return 1;
    else
        return (numberOfTheWinner(N - 1, k) + k - 1) % N + 1;
}",1.0,1111111111
Queue_8,1508956,2252260,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    deque<int> dq;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        dq.push_back(i);
        if (i >= k - 1) {
            sum += nums[dq.front()];
        }
    }
    return sum;
}",1.0,1111111111
Queue_9,1508956,2252260,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    unsigned int n = graph.size();
    vector<int> in_degree(n, 0);
    for (unsigned int i = 0; i < n; i++) {
        for (unsigned int j : graph[i]) {
            in_degree[j]++;
        }
    }

    queue<int> q;
    for (unsigned int i = 0; i < n; i++) {
        if (in_degree[i] == 0) {
            q.push(i);
        }
    }

    vector<int> res;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        res.push_back(u);

        for (int v : graph[u]) {
            in_degree[v]--;
            if (in_degree[v] == 0) {
                q.push(v);
            }
        }
    }

    if (res.size() != n) {
        return {};
    }
    return res;
}",1.0,1111111111
Queue_1,1509649,2210200,"bool isBipartite(vector<vector<int>> graph) {
    bool isBipartite = true;
    int n = graph.size();
	vector<int> dist(n);
	for(int i = 0; i < n; i++){
	    dist[i] = 0;
	}
    for(int i = 0; i < n; i++){
        if(dist[i] == 0){
            queue<int> q;
            q.push(i);
            dist[i] = 1;
            while(!q.empty()){
                int v = q.front();
                q.pop();
                for(int x : graph[v]){
                    if(dist[x] == 0){
        				dist[x] = 3 - dist[v];
                        q.push(x);
                    }
        		    else if(dist[x] == dist[v]){
        				isBipartite = false;
        			}	
                }
            }
        }    
    }
    return isBipartite;
}",1.0,1111111111
Queue_2,1509649,2210200,"void bfs(vector<vector<int>> graph, int start) {
    queue<int> q;
    q.push(start);
    int n = graph.size();
    vector<int> vs(n, 0);
    vs[start] = 1;
    cout << start << "" "";
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(int v : graph[u]){
            if(!vs[v]){
                vs[v] = 1;
                cout << v << "" "";
                q.push(v);
            }
        }
    }
}",1.0,1111111111
Queue_3,1509649,2210200,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(0, item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    return list.removeAt(list.size() - 1);
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(list.size() - 1);
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1509649,2210200,"// iostream, vector and queue are included
// You can write helper methods



long long init(int n){
    vector<string> save;
    queue<string> q;
    q.push(""2"");
    q.push(""5"");
    save.push_back(""2"");
    save.push_back(""5"");
    for(int i = 2; i < n; i++){
        string top = q.front(); q.pop();
        q.push(top + ""2"");
        q.push(top + ""5"");
        save.push_back(top + ""2"");
        save.push_back(top + ""5"");
    }
    string t = save[n - 1];
    long long ans = stoll(t);
    return ans;
}

long long nthNiceNumber(int n) {
    return init(n);
}",1.0,1111111111
Queue_5,1509649,2210200,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size(); // row size
    int m = grid[0].size(); // column size
 
    // delrow and delcol are used to traverse in
    // up,right,bottom and left respectively.
 
    int delrow[] = { -1, 0, 1, 0 };
    int delcol[] = { 0, 1, 0, -1 };
 
    // visited matrix to keep track of the visited cell.
    int vis[n][m];
 
    // queue stores rowIndex,colIndex and time taken to rot
    // respectively.
 
    queue<pair<pair<int, int>, int> > q;
 
    // counter to keep track of fresh cells.
    int cntfresh = 0;
 
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 2) {
                q.push({ { i, j },
                         0 }); // already rotten hence 0
                               // time to rot.
                vis[i][j]
                    = 2; // visited cell marked as rotten.
            }
            else {
                vis[i][j] = 0; // unvisited
            }
            if (grid[i][j] == 1)
                cntfresh++; // maintaining count for fresh
                            // oranges.
        }
    }
    int cnt = 0, tm = 0;
    while (!q.empty()) {
        int row = q.front().first.first; // row index
        int col = q.front().first.second; // col index
        int t = q.front().second; // time an orange at a
                                  // cell takes to rot.
        q.pop();
 
        tm = max(tm, t);
 
        // checking for adjacent nodes in 4 directions.
        for (int i = 0; i < 4; i++) {
            int nrow = row + delrow[i];
            int ncol = col + delcol[i];
 
            // checking the validity of a node and also
            // vis[nrow][ncol] !=2
            if (nrow >= 0 && nrow < n && ncol >= 0
                && ncol < m && grid[nrow][ncol] == 1
                && vis[nrow][ncol] != 2) {
                vis[nrow][ncol] = 2; // adj orange is rotten
                q.push({ { nrow, ncol },
                         t + 1 }); // incrementing time for
                                   // that orange by 1
                cnt++;
            }
        }
    }
 
    return (cnt == cntfresh) ? tm : -1;
}
",1.0,1111111111
Queue_6,1509649,2210200,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i = 1; i <= N; i++){
        q.push(i);
    }
    int cnt = 0;
    while(q.size() > 1){
        ++cnt;
        int x = q.front();
        q.pop();
        if(cnt == k){
            cnt = 0;
        }
        else{
            q.push(x);    
        }
    }
    return q.front();
}",1.0,1111111111
Queue_7,1509649,2210200,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i = 1; i <= N; i++){
        q.push(i);
    }
    int cnt = 0;
    while(q.size() > 1){
        ++cnt;
        int x = q.front();
        q.pop();
        if(cnt == k){
            cnt = 0;
        }
        else{
            q.push(x);    
        }
    }
    return q.front();
}",1.0,1111111111
Queue_8,1509649,2210200,"int sumOfMaxSubarray(vector<int>& arr, int K) {
    // STUDENT ANSWER
    int N = arr.size();
    std::deque<int> Qi(K);
    int i;
    for (i = 0; i < K; ++i) {
        while ((!Qi.empty()) && arr[i] >= arr[Qi.back()])

            Qi.pop_back();

        Qi.push_back(i);
    }
    int ans = 0;
    for (; i < N; ++i) {
        ans += arr[Qi.front()];
        
        while ((!Qi.empty()) && Qi.front() <= i - K)
 
            Qi.pop_front();

        while ((!Qi.empty()) && arr[i] >= arr[Qi.back()])
            Qi.pop_back();

        Qi.push_back(i);
    }
 
    ans += arr[Qi.front()];
    return ans;
}",1.0,1111111111
Queue_9,1509649,2210200,"#include<algorithm>

vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> indegree(n, 0);
    for(int i = 0; i < n; i++){
        for(int v : graph[i]){
            ++indegree[v];
        }
    }
    queue<int> q;
    for(int i = 0; i < n; i++){
        if(!indegree[i]) q.push(i);
    }
    vector<int> topo;
    while(!q.empty()){
        int u = q.front(); q.pop();
        topo.push_back(u);
        for(int v : graph[u]){
            --indegree[v];
            if(!indegree[v]) q.push(v);
        }
    }
    int t = topo.size();
    if(t < n){
        vector<int> ans;
        return ans;
    }
    return topo;
}",1.0,1111111111
Queue_1,1511195,2211821,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size(); 
    if (n == 0) return true; 
    int* color = new int[n]; 
    for (int i = 0; i < n; i++) color[i] = 0; 
   
    queue<int> q; 
    for (int i = 0; i < n; i++) {
        if (color[i] == 0) {
            q.push(i); 
            color[i] = 1; 
            while(!q.empty()) {
                int x = q.front(); 
                q.pop(); 
                for (int it : graph[x]) {
                    if (color[it] == 0) {
                        color[it] = 3 - color[x]; 
                        q.push(it); 
                    }
                    else if (color[it] == color[x]) {
                        return false; 
                    }
                } 
            }
        }
    }
   
    delete[] color; 
    return true; 
}
",1.0,1111111111
Queue_2,1511195,2211821,"void bfs(vector<vector<int>> graph, int start) {
	queue<int> q; 
	int n = graph.size(); 
	bool* visited = new bool[n];
	for (int i = 0; i < n; i++) visited[i] = 0; 
	
	cout << start << ' '; 
	q.push(start); 
	visited[start] = 1; 
	while (!q.empty()){
	    int x = q.front(); 
	    q.pop(); 
	    for (int it : graph[x]) {
	        if (visited[it] == 0) {
	            cout << it << ' '; 
	            visited[it] = 1; 
	            q.push(it); 
	        }
	    }
	}
	
}
",1.0,1111111111
Queue_3,1511195,2211821,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    return list.removeAt(0);    
}

T top() {
    // TODO: Get value of the element in the head of the queue
    if (empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
     return list.empty();
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1511195,2211821,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> q; 
    q.push(2); 
    q.push(5); 
    int count = 2; 
    if (n == 1) return 2; 
    if (n == 2) return 5; 
    while (!q.empty()) {
        long long x = q.front(); 
        q.pop(); 
        long long a = x*10 + 2; 
        q.push(a); 
        count++; 
        if (count == n) return a; 
        long long b = x*10 + 5; 
        q.push(b); 
        count++; 
        if (count == n) return b; 
    }
    return -1; 
}
",1.0,1111111111
Queue_5,1511195,2211821,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int r = grid.size();
    int c = grid[0].size(); 
    vector<vector<int>> t(r, vector<int>(c)); 
    int time = 0; 
    int dx[] = {0,0,1,-1};
    int dy[] = {1,-1,0,0};
    
    queue<pair<int,int>> q; 
    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            if (grid[i][j] == 2) {
                q.push({i,j}); 
                t[i][j] = 0; 
                //grid[i][j] = '0'; 
            }
        }
    }
    
    while (!q.empty()) {
        pair<int,int> x = q.front(); 
        q.pop(); 
        for (int k = 0; k < 4; k++) {
            int X = x.first + dx[k]; 
            int Y = x.second + dy[k]; 
            if (X >= 0 && X < r && Y >= 0 && Y < c && grid[X][Y] == 1) {
                t[X][Y] = t[x.first][x.second] + 1; 
                grid[X][Y] = 0; 
                q.push({X,Y}); 
                time = max(time, t[X][Y]); 
            }
        }
    }
    
    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            if (grid[i][j] == 1) return -1; 
        }
    }
    
    return time; 
}
",1.0,1111111111
Queue_6,1511195,2211821,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    std::queue<int> circle;
    
    // Initialize the circle with players numbered from 1 to N
    for (int i = 1; i <= N; ++i) {
        circle.push(i);
    }
    
    while (circle.size() > 1) {
        // Remove k-1 players from the front and add them to the back
        for (int i = 0; i < k - 1; ++i) {
            int front = circle.front();
            circle.pop();
            circle.push(front);
        }
        
        // Remove the k-th player from the front
        circle.pop();
    }
    
    // The last player remaining is the winner
    return circle.front();
}",1.0,1111111111
Queue_7,1511195,2211821,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    std::queue<int> circle;
    
    // Initialize the circle with players numbered from 1 to N
    for (int i = 1; i <= N; ++i) {
        circle.push(i);
    }
    
    while (circle.size() > 1) {
        // Remove k-1 players from the front and add them to the back
        for (int i = 0; i < k - 1; ++i) {
            int front = circle.front();
            circle.pop();
            circle.push(front);
        }
        
        // Remove the k-th player from the front
        circle.pop();
    }
    
    // The last player remaining is the winner
    return circle.front();
}",1.0,1111111111
Queue_8,1511195,2211821,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    deque<int> de;
    int ans = 0; 
    int n = nums.size();
    if (n == 0 || k > n) return 0; 
    
    for (int i = 0; i < k; i++) {
        while (!de.empty() && nums[i] >= nums[de.back()]) de.pop_back(); 
        de.push_back(i); 
    }
    
    for (int i = k; i < n; i++) {
        ans += nums[de.front()]; 
        if (!de.empty() && de.front() <= i - k) de.pop_front(); 
        while (!de.empty() && nums[i] >= nums[de.back()]) de.pop_back();  
        de.push_back(i); 
    }
    
    ans += nums[de.front()];  
    
    return ans; 
}
",1.0,1111111111
Queue_9,1511195,2211821,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    std::vector<int> inDegree(n, 0);
    for (int i = 0; i < n; i++) {
        for (int j : graph[i]) {
            inDegree[j]++;
        }
    }

    std::queue<int> q;
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    std::vector<int> result;
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);
        for (int neighbor : graph[node]) {
            if (--inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    if (int(result.size()) != n) {
        // Graph has cycles, return an empty vector
        return std::vector<int>();
    }

    return result;
}",1.0,1111111111
Queue_1,1515899,2210535,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> color(n, -1); 

    for (int i = 0; i < n; i++) {
        if (color[i] == -1) { 
            queue<int> q;
            q.push(i);
            color[i] = 0; 

            while (!q.empty()) {
                int u = q.front();
                q.pop();

                for (int v : graph[u]) {
                    if (color[v] == -1) {
                        color[v] = 1 - color[u]; 
                        q.push(v);
                    } else if (color[v] == color[u]) {
                        return false; 
                    }
                }
            }
        }
    }
    return true; 
}",1.0,1111111111
Queue_2,1515899,2210535,"void bfs(vector<vector<int>> graph, int start) {
	deque<int> q;
    q.push_back(start);
    int row = graph.size();
    vector<int> vt(1000, 0);
    vector<int> ans;
    vt[start] = 1;
    while (!q.empty())
    {
        int row = q.front();
        ans.push_back(row);
        q.pop_front();
        int col = graph[row].size();
        for (int i = 0; i < col; i++)
        {
            if (vt[graph[row][i]]) continue;
            vt[graph[row][i]] = 1;
            q.push_back(graph[row][i]);
        }
    }
    if(ans.size()) cout << ans[0];
    for (int i = 1; i < ans.size(); i++)
    {
        cout << "" "" << ans[i];
    }
}",1.0,1111111111
Queue_3,1515899,2210535,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1515899,2210535,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    if (n == 1) {
        return 2;
    }
    else if (n == 2)    {
        return 5;
    }
    else if (n == 0)    {
        return -1;
    }
    queue<long long> queue;
    queue.push(2);
    queue.push(5);
    for (int i=0; i<n-1; i++) {
        long long temp = queue.front();
        queue.pop();
        queue.push(temp*10+2);
        queue.push(temp*10+5);
    }
    
    return queue.front();
}",1.0,1111111111
Queue_5,1515899,2210535,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    if (n == 0) {
        return -1;
    }
    int m= grid[0].size();
    queue<pair<int,int>> q;
    int sizeofq = 0;
    int sec = -1;
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            if (grid[i][j] == 2)    {
                q.push(make_pair(i,j));
                sizeofq++;
            }
        }
    }
    int sizeofq1 = 0;
    while (!q.empty())  {
        sec++;
        for (int i=0; i < sizeofq; i++) {
            pair<int,int> temp = q.front();
            q.pop();
            if (temp.first != 0)    {
                if (grid[temp.first-1][temp.second] == 1)   {
                    grid[temp.first-1][temp.second] = 2;
                    q.push(make_pair(temp.first-1,temp.second));
                    sizeofq1++;
                }
            }
            if (temp.second != 0)    {
                if (grid[temp.first][temp.second-1] == 1)   {
                    grid[temp.first][temp.second-1] = 2;
                    q.push(make_pair(temp.first,temp.second-1));
                    sizeofq1++;
                }
            }
            if (temp.first != n-1)    {
                if (grid[temp.first+1][temp.second] == 1)   {
                    grid[temp.first+1][temp.second] = 2;
                    q.push(make_pair(temp.first+1,temp.second));
                    sizeofq1++;
                }
            }
            if (temp.second != m-1)    {
                if (grid[temp.first][temp.second+1] == 1)   {
                    grid[temp.first][temp.second+1] = 2;
                    q.push(make_pair(temp.first,temp.second+1));
                    sizeofq1++;
                }
            }
        }
        sizeofq = sizeofq1;
        sizeofq1 = 0;
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (grid[i][j] == 1) return -1;
        }
    }
    return sec;
}",1.0,1111111111
Queue_6,1515899,2210535,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1;i<=N;i++){
        q.push(i);
    }
    while(q.front()!=q.back()){
        int cnt=k-1;
        while(cnt>0){
            int temp=q.front();
            q.pop();
            q.push(temp);
            cnt--;
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_7,1515899,2210535,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1;i<=N;i++){
        q.push(i);
    }
    while(q.front()!=q.back()){
        int cnt=k-1;
        while(cnt>0){
            int temp=q.front();
            q.pop();
            q.push(temp);
            cnt--;
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_8,1515899,2210535,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    deque<int> deque;
    int sum=0;
    for (int i=0; i<k; i++) {
        if (i == n) {
            break;
        }
        while (!deque.empty() && nums[i] > nums[deque.back()])  {
            deque.pop_back();
        }
        deque.push_back(i);
    }
    for (int i=k; i<n; i++) {
        sum += nums[deque.front()];
        while (!deque.empty() && deque.front() <= i-k)    {
            deque.pop_front();
        }
        while (!deque.empty() && nums[i] > nums[deque.back()])  {
            deque.pop_back();
        }
        deque.push_back(i);
    }
    sum+= nums[deque.front()];
    return sum;
}",1.0,1111111111
Queue_9,1515899,2210535,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n, 0);
    queue<int> q;
    vector<int> result;

    for (int i = 0; i < n; ++i) {
        for (int j : graph[i]) {
            inDegree[j]++;
        }
    }


    for (int i = 0; i < n; ++i) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        // Reduce in-degree of adjacent nodes
        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    int z = result.size();
    if (z != n) {
        return vector<int>(); 
    }

    return result;
}",1.0,1111111111
Queue_1,1521765,2211738,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> colors(n, -1); 

    for (int i = 0; i < n; i++) {
        if (colors[i] == -1) {
            queue<int> q;
            q.push(i);
            colors[i] = 0; 

            while (!q.empty()) {
                int u = q.front();
                q.pop();

                for (int v : graph[u]) {
                    if (colors[v] == -1) {
                        colors[v] = 1 - colors[u]; 
                        q.push(v);
                    }
                    else if (colors[v] == colors[u]) {
                        return false; 
                    }
                }
            }
        }
    }
    return true;
}",1.0,1111111111
Queue_2,1521765,2211738,"void bfs(vector<vector<int>> graph, int start) {
	int numVertices = graph.size();
	bool *visited = new bool[numVertices]; 
    for(int i = 0; i < numVertices; i++) 
        visited[i] = false; 

    queue<int> myQueue; 
    bool isFirst = true;
    visited[start] = true; 
    myQueue.push(start); 

    while(!myQueue.empty()) 
    { 
        start = myQueue.front();
        if (isFirst) {
            cout << start;
            isFirst = false;
        }
        else cout << "" "" << start;
        myQueue.pop(); 

        int outDegree = graph[start].size();
        for (int j = 0; j < outDegree; ++j) 
        { 
            int temp = graph[start][j];
            if (!visited[temp]) 
            { 
                visited[temp] = true; 
                myQueue.push(temp); 
            } 
        }
    }
    delete[] visited;
}",1.0,1111111111
Queue_3,1521765,2211738,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
       return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element in the head of the queue
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1521765,2211738,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    if (n == 1) {
        return 2;
    }
    queue<long long> q;
    q.push(2);
    q.push(5);

    while (true) {
        long long current = q.front();
        q.pop();
        n--;

        if (n == 0) {
            return current;
        }

        q.push(current * 10 + 2);
        q.push(current * 10 + 5);
    }
}",1.0,1111111111
Queue_5,1521765,2211738,"// iostream, vector and queue are included
// Hint: use breadth-first-search
const vector<int> dx = {1, -1, 0, 0};
const vector<int> dy = {0, 0, 1, -1};
int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    int freshApples = 0;
queue<pair<int, int>> rottenApples;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 2) {
                rottenApples.push({i, j});
            } else if (grid[i][j] == 1) {
                freshApples++;
            }
        }
    }

    int minutes = 0;

    while (!rottenApples.empty() && freshApples > 0) {
        int size = rottenApples.size();

        for (int i = 0; i < size; i++) {
            int x = rottenApples.front().first;
            int y = rottenApples.front().second;
            rottenApples.pop();

            for (int k = 0; k < 4; k++) {
                int newX = x + dx[k];
                int newY = y + dy[k];

                if (newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1) {
                    grid[newX][newY] = 2;
                    rottenApples.push({newX, newY});
                    freshApples--;
                }
            }
        }

        if (!rottenApples.empty()) {
            minutes++;
        }
    }
    return (freshApples == 0) ? minutes : -1;
}",1.0,1111111111
Queue_8,1521765,2211738,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    deque<int> maxDeque;
    int result = 0;

  
    for (int i = 0; i < k; i++) {
        while (!maxDeque.empty() && nums[i] >= nums[maxDeque.back()]) {
            maxDeque.pop_back();
        }
        maxDeque.push_back(i);
    }

    for (int i = k; i < n; i++) {
        result += nums[maxDeque.front()];

        
        while (!maxDeque.empty() && maxDeque.front() <= i - k) {
            maxDeque.pop_front();
        }

        
        while (!maxDeque.empty() && nums[i] >= nums[maxDeque.back()]) {
            maxDeque.pop_back();
        }

        maxDeque.push_back(i);
    }

  
    result += nums[maxDeque.front()];
    return result;
}",1.0,1111111111
Queue_9,1521765,2211738,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    vector<int> g;
    int numVer = graph.size();
    vector<int> in_degree(numVer, 0);

    for (int u = 0; u < numVer; u++) {
        for (auto i = graph[u].begin(); i != graph[u].end(); i++)
            in_degree[*i]++;
    }

    queue<int> q;
    for (int i = 0; i < numVer; i++)
        if (in_degree[i] == 0)
            q.push(i);
    int count = 0;
    vector<int> result;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        for (auto i = graph[u].begin(); i != graph[u].end(); i++)
            if (--in_degree[*i] == 0)
                q.push(*i);
        count++;
    }
    if (count != numVer) {
        return g;
    }
    return result;
}",1.0,1111111111
Queue_1,1524445,2212741,"    bool BFScheck(vector<vector<int>>& graph, vector<int> &color, int start){
        queue<int> s;
        s.push(start);

        while(!s.empty()){ // checking until all the neigbouring nodes are visited
                int parent=s.front(); 
                s.pop();
                for(auto neighbour:graph[parent]){ 
                    if(color[neighbour]==-1){ // if the child node is yet to be colored,
                        color[neighbour]=color[parent]^1;  // color it with the opposite of its parent color
                        s.push(neighbour);
                    }
                    else if(color[neighbour]==color[parent]) return false; // if both child and parent have the same color, not a bipartite, return false
                }
        }
        return true;
    }
    bool isBipartite(vector<vector<int>> graph) {
    vector<int> color(graph.size(),-1);
        for(int i=0;i<color.size();i++){ // checking for each node whether its colored or not, this step is necessary since we can have multiple components in the graph
            if(color[i]==-1){
                if(BFScheck(graph, color, i)==false){ // is some BFS traversal on a component founds a loop that is not fit for bipartite, return false 
                    return false;
                }
            }
        }
        return true;
}",1.0,1111111111
Queue_2,1524445,2212741,"void bfs(vector<vector<int>> graph, int start) {
	int numNodes = graph.size();
    vector<bool> visited(numNodes, false);
    queue<int> nodeQueue;

    visited[start] = true;
    nodeQueue.push(start);

    while (!nodeQueue.empty()) {
        int currentNode = nodeQueue.front();
        nodeQueue.pop();
        cout << currentNode << "" "";

        for (int neighbor : graph[currentNode]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                nodeQueue.push(neighbor);
            }
        }
    }

}",1.0,1111111111
Queue_3,1524445,2212741,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
        if( empty()){
            throw std:: out_of_range( "" Queue is empty"");
        }
        T item = list.get(0);
        list.removeAt(0);
        return item;
}

T top() {
    // TODO: Get value of the element in the head of the queue
        if( empty()){
            throw out_of_range(""Queue is empty"");
        }
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}


",1.0,11111
Queue_4,1524445,2212741,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
       queue<long long> num;
    num.push(2);
    num.push(5);
    long long val=0;
    while( n--){
        val= num.front();
        num.push( val*10 +2);
        num.push( val*10 +5);
        num.pop();
    }
    return val;
}",1.0,1111111111
Queue_5,1524445,2212741,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
        int rows = grid.size();
    int cols = grid[0].size();

    queue<pair<int, int>> rottenApples;
    int freshApples = 0;
    int time = 0;

    // Count the number of fresh apples and enqueue the initial rotten apples
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == 1)
                freshApples++;
            else if (grid[i][j] == 2)
                rottenApples.push({i, j});
        }
    }

    // If there are no fresh apples, return 0
    if (freshApples == 0)
        return 0;

    // Perform BFS to rot apples and count the time
    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    while (!rottenApples.empty()) {
        int size = rottenApples.size();

        for (int i = 0; i < size; i++) {
            int x = rottenApples.front().first;
            int y = rottenApples.front().second;
            rottenApples.pop();

            for (const auto& direction : directions) {
                int newX = x + direction.first;
                int newY = y + direction.second;

                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && grid[newX][newY] == 1) {
                    grid[newX][newY] = 2;
                    rottenApples.push({newX, newY});
                    freshApples--;

                    if (freshApples == 0)
                        return time + 1;
                }
            }
        }

        time++;
    }

    // If there are still fresh apples left, return -1
    return -1;

}",1.0,1111111111
Queue_6,1524445,2212741,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for( int i=1; i<=N; i++){
        q.push(i);
    }
    while( q.size() >1){
        for( int i=0; i<k-1; i++){
            q.push(q.front());
            q.pop();
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_7,1524445,2212741,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for( int i=1; i<=N; i++){
        q.push(i);
    }
    while( q.size() >1){
        for( int i=0; i<k-1; i++){
            q.push(q.front());
            q.pop();
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_8,1524445,2212741,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
     deque<int> dq;
    long long sum=0;
    for( int i=0; i< ( int)nums.size(); i++)   {
        //remove all element : element < nums[i]
        while( !dq.empty() && nums[dq.back()] <= nums[i] )   dq.pop_back();
            // remove ele out of the curr window
            while( ! dq.empty() &&  dq.front() <= i-k)  dq.pop_front();
            // add the curr element
            dq.push_back(i);
            // max value is front
            if( i>= k-1) sum += nums[dq.front()];
        
    }
    return sum;

}",1.0,1111111111
Queue_9,1524445,2212741,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    unsigned n = graph.size();
    vector<int> inDegree(n, 0);

    // Calculate in-degrees for all nodes.
    for (unsigned i = 0; i < n; i++) {
        for (int neighbor : graph[i]) {
            inDegree[neighbor]++;
        }
    }

    queue<int> q;
    for (unsigned i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    vector<int> result;
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    // If the result size is not equal to the number of nodes, there is a cycle.
    if (result.size() != n) {
        return {};
    }

    return result;
}

",1.0,1111111111
Queue_1,1525121,2211367,"bool isBipartite(vector<vector<int>> graph) {
 int n = graph.size();
    std::vector<int> color(n, 0);  // 0 represents uncolored, 1 and -1 represent two different colors.
    std::queue<int> q;

    for (int i = 0; i < n; i++) {
        if (color[i] != 0) continue;  // Node is already colored.
        color[i] = 1;  // Color the first node with 1.
        q.push(i);

        while (!q.empty()) {
            int node = q.front();
            q.pop();

            for (int neighbor : graph[node]) {
                if (color[neighbor] == 0) {
                    color[neighbor] = -color[node];  // Color the neighbor with the opposite color.
                    q.push(neighbor);
                } else if (color[neighbor] == color[node]) {
                    return false;  // If a neighbor has the same color, the graph is not bipartite.
                }
            }
        }
    }

    return true;
}",1.0,1111111111
Queue_2,1525121,2211367,"void bfs(vector<vector<int>> graph, int start) {
	int n = graph.size();
    std::vector<bool> visited(n, false);
    std::queue<int> q;

    // Push the starting node to the queue and mark it as visited.
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();

        // Process the current node (e.g., print it).
        std::cout << node << "" "";

        // Visit all unvisited neighbors of the current node.
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}",1.0,1111111111
Queue_3,1525121,2211367,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
         T tmp = list.get(0);
        list.removeAt(0);
        return tmp;
}

T top() {
    // TODO: Get value of the element in the head of the queue
          return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
         return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1525121,2211367,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<string> q;
    if (n == 1) return 2;
    if (n == 2) return 5;
    vector<long long> v;
    long long x = 1000000;
    while(x > 0){
        if (q.empty()){
            q.push(""2""); v.push_back(stoll(""2""));
            q.push(""5""); v.push_back(stoll(""5""));
            x -= 2;
        }
        else {
            string temp = q.front();
            q.pop();
            q.push(temp + ""2"");
            v.push_back(stoll(temp + ""2""));
            q.push(temp + ""5"");
            v.push_back(stoll(temp + ""5""));
            x -= 2;
        }
    }
    return v[n - 1];
}",1.0,1111111111
Queue_5,1525121,2211367,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    int freshApples = 0; // Count of fresh apples
    int rotTime = 0; // Time to rot all apples

    std::queue<std::pair<int, int>> rottenApples;

    // Initialize the queue with rotten apples and count fresh apples
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 2) {
                rottenApples.push({i, j});
            } else if (grid[i][j] == 1) {
                freshApples++;
            }
        }
    }

    // Define directions to explore (up, down, left, right)
    int dx[] = {-1, 1, 0, 0};
    int dy[] = {0, 0, -1, 1};

    while (!rottenApples.empty() && freshApples > 0) {
        int numRottenThisRound = rottenApples.size();

        for (int i = 0; i < numRottenThisRound; i++) {
            int x = rottenApples.front().first;
            int y = rottenApples.front().second;
            rottenApples.pop();

            for (int d = 0; d < 4; d++) {
                int newX = x + dx[d];
                int newY = y + dy[d];

                if (newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1) {
                    grid[newX][newY] = 2; // Fresh apple becomes rotten
                    rottenApples.push({newX, newY});
                    freshApples--;
                }
            }
        }

        rotTime++;
    }

    return (freshApples == 0) ? rotTime : -1;
}",1.0,1111111111
Queue_6,1525121,2211367,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
     std::queue<int> circle;

    // Initialize the circle with player numbers from 1 to N.
    for (int i = 1; i <= N; i++) {
        circle.push(i);
    }

    // Simulate the game.
    while (circle.size() > 1) {
        for (int i = 1; i < k; i++) {
            // Move the person who is not removed to the back of the queue.
            circle.push(circle.front());
            circle.pop();
        }
        // Remove the last counted person from the circle.
        circle.pop();
    }

    // Toan should stand at the last position in the queue.
    return circle.front();
}",1.0,1111111111
Queue_7,1525121,2211367,"int numberOfTheWinner(int N, int k) {
     std::queue<int> circle;

    // Initialize the circle with player numbers from 1 to N.
    for (int i = 1; i <= N; i++) {
        circle.push(i);
    }

    // Simulate the game.
    while (circle.size() > 1) {
        for (int i = 1; i < k; i++) {
            // Move the person who is not removed to the back of the queue.
            circle.push(circle.front());
            circle.pop();
        }
        // Remove the last counted person from the circle.
        circle.pop();
    }

    // Toan should stand at the last position in the queue.
    return circle.front();
}",1.0,1111111111
Queue_8,1525121,2211367,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    int sum = 0;
    std::deque<int> maxDeque;

    // Calculate the maximum values for the first subarray of size k.
    for (int i = 0; i < k; i++) {
        while (!maxDeque.empty() && nums[i] >= nums[maxDeque.back()]) {
            maxDeque.pop_back();
        }
        maxDeque.push_back(i);
    }

    for (int i = k; i < n; i++) {
        sum += nums[maxDeque.front()];

        // Remove elements that are out of the current window.
        while (!maxDeque.empty() && maxDeque.front() <= (i - k)) {
            maxDeque.pop_front();
        }

        // Add the next element to the window.
        while (!maxDeque.empty() && nums[i] >= nums[maxDeque.back()]) {
            maxDeque.pop_back();
        }
        maxDeque.push_back(i);
    }

    // Add the maximum value of the last subarray of size k.
    sum += nums[maxDeque.front()];
    
    return sum;
}",1.0,1111111111
Queue_9,1525121,2211367,"vector<int> topologicalSorting(vector<vector<int>> graph) {
     int n = graph.size();
    std::vector<int> inDegree(n, 0);
    std::vector<int> result;
    std::queue<int> q;

    // Calculate in-degrees for each node.
    for (int i = 0; i < n; i++) {
        for (int neighbor : graph[i]) {
            inDegree[neighbor]++;
        }
    }

    // Add nodes with in-degree 0 to the queue.
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }
    int s = result.size();
    if (s == n) {
        return result;  // Topological order found.
    } else {
        return std::vector<int>();  // No topological order (cycle exists).
    }
}",1.0,1111111111
Queue_1,1526588, ,"bool isBipartite(vector<vector<int>> graph) {
int n = graph.size();
    vector<int> colors(n, -1); // -1: uncolored, 0: color 1, 1: color 2
    
    for (int i = 0; i < n; ++i) {
        if (colors[i] != -1) continue; // Node already colored
        colors[i] = 0; // Color the source node
        
        queue<int> q;
        q.push(i);
        
        while (!q.empty()) {
            int curr = q.front();
            q.pop();
            
            for (int neighbor : graph[curr]) {
                if (colors[neighbor] == -1) {
                    colors[neighbor] = 1 - colors[curr]; // Color with the opposite color
                    q.push(neighbor);
                } else if (colors[neighbor] == colors[curr]) {
                    // If adjacent nodes have the same color, the graph is not bipartite
                    return false;
                }
            }
        }
    }
    
    // If all components are bipartite
    return true;
}",1.0,1111111111
Queue_2,1526588, ,"void bfs(vector<vector<int>> graph, int start) {
queue<int> q;
    int NumOfNode = graph.size();
    vector<bool> visited(NumOfNode, false);
    q.push(start);
    visited[start] = true;
    while (!q.empty()){
        int top = q.front(); q.pop();
        cout << top << "" "";
        for (int i = 0; i < graph[top].size(); i++){
            if (!visited[graph[top][i]]){
                q.push(graph[top][i]);
                visited[graph[top][i]] = true;
            }
        }
    }
}",1.0,1111111111
Queue_3,1526588, ," void push(T item) {
        list.add(item);
    }

    T pop() {
        // TODO: Remove an element on top of the stack
        T tmp = list.get(0);
        list.removeAt(0);
        return tmp;
    }

    T top() {
        // TODO: Get value of the element on top of the stack
        return list.get(0);
    }

    bool empty() {
        // TODO: Determine if the stack is empty
        return list.empty();
    }

    int size() {
        // TODO: Get the size of the stack
        return list.size();
    }

    void clear() {
        // TODO: Clear all elements of the stack
        list.clear();
    }",1.0,11111
Queue_4,1526588, ,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
     queue<string> q;
    if (n == 1) return 2;
    if (n == 2) return 5;
    vector<long long> v;
    long long x = 1000000;
    while(x > 0){
        if (q.empty()){
            q.push(""2""); v.push_back(stoll(""2""));
            q.push(""5""); v.push_back(stoll(""5""));
            x -= 2;
        }
        else {
            string temp = q.front();
            q.pop();
            q.push(temp + ""2"");
            v.push_back(stoll(temp + ""2""));
            q.push(temp + ""5"");
            v.push_back(stoll(temp + ""5""));
            x -= 2;
        }
    }
    return v[n - 1];
}",1.0,1111111111
Queue_5,1526588, ,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    queue<pair<int, int>> rottenApples;
    
    // Find and enqueue all initial rotten apples
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (grid[i][j] == 2) {
                rottenApples.push({i, j});
            }
        }
    }
    
    int seconds = 0;
    int freshApples = 0; // Count of fresh apples
    
    // Define directions to explore neighbors
    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};
    
    while (!rottenApples.empty()) {
        int size = rottenApples.size();
        
        for (int i = 0; i < size; ++i) {
            pair<int, int> curr = rottenApples.front();
            rottenApples.pop();
            
            for (int k = 0; k < 4; ++k) {
                int x = curr.first + dx[k];
                int y = curr.second + dy[k];
                
                if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 1) {
                    grid[x][y] = 2; // Mark the fresh apple as rotten
                    rottenApples.push({x, y});
                    freshApples--;
                }
            }
        }
        
        if (!rottenApples.empty()) {
            seconds++;
        }
    }
    
    // Check if there are any remaining fresh apples
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (grid[i][j] == 1) {
                return -1; // There are unreachable fresh apples
            }
        }
    }
    
    return seconds;
}",1.0,1111111111
Queue_6,1526588, ,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue<int> players;

    // Initialize the queue with players numbered from 1 to N.
    for (int i = 1; i <= N; i++) {
        players.push(i);
    }

    while (players.size() > 1) {
        // Remove the person who is out of the game.
        for (int i = 1; i < k; i++) {
            players.push(players.front());  // Rotate the queue.
            players.pop();
        }

        // Remove the person who is out of the game.
        players.pop();
    }

    // The last person in the queue is the winner.
    return players.front();
}",1.0,1111111111
Queue_7,1526588, ,"
int numberOfTheWinner(int N, int k) {
    queue<int> players;

    // Initialize the queue with players numbered from 1 to N.
    for (int i = 1; i <= N; i++) {
        players.push(i);
    }

    while (players.size() > 1) {
        // Remove the person who is out of the game.
        for (int i = 1; i < k; i++) {
            players.push(players.front());  // Rotate the queue.
            players.pop();
        }

        // Remove the person who is out of the game.
        players.pop();
    }

    // The last person in the queue is the winner.
    return players.front();
}",1.0,1111111111
Queue_8,1526588, ,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
     int n = nums.size();
    if (n == 1) return nums[0];
    deque <int> q;
    int sum = 0;
    for (int i = 0; i < k; i++){
        while(!q.empty() && nums[i] > nums[q.back()]){
            q.pop_back();
        }
        q.push_back(i);
    }
    sum += nums[q.front()];
    for (int i = k; i < n; i++){
        if (q.front() <= i - k){
            q.pop_front();
        }
        while(!q.empty() && nums[i] > nums[q.back()]){
            q.pop_back();
        }
        q.push_back(i);
        sum += nums[q.front()];
    }
    return sum;
}",1.0,1111111111
Queue_9,1526588, ,"vector<int> topologicalSorting(vector<vector<int>> graph) {
     int n = graph.size(); // Number of nodes in the graph
    vector<int> inDegree(n, 0); // Initialize in-degrees of all nodes to 0

    // Calculate in-degrees
    for (int i = 0; i < n; i++) {
        for (int neighbor : graph[i]) {
            inDegree[neighbor]++;
        }
    }

    queue<int> q;
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i); // Push nodes with in-degree 0 into the queue
        }
    }

    vector<int> result; // Store the topological order

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        for (int neighbor : graph[node]) {
            inDegree[neighbor]--; // Decrement in-degree of the neighbor
            if (inDegree[neighbor] == 0) {
                q.push(neighbor); // If in-degree becomes 0, enqueue the neighbor
            }
        }
    }
    int s = result.size();
    // If the result size is not equal to the number of nodes, the graph has a cycle.
    if (s != n) {
        return vector<int>(); // Return an empty vector to indicate no topological order.
    }

    return result;
}",1.0,1111111111
Queue_1,1527750,2213250,"bool isBipartite(vector<vector<int>> graph) {
        int n = graph.size();
    vector<int> color(n, -1);

    for (int i = 0; i < n; i++) {
        if (color[i] == -1) {
            queue<int> q;
            q.push(i);
            color[i] = 0;
            //cout << color[i] << endl;
            while (!q.empty()) {
                int u = q.front();
                q.pop();

                for (int v : graph[u]) {
                   // cout << v << endl;
                   // cout << color[v] << endl;
                    if (color[v] == -1) {
                        color[v] = 1 - color[u];
                        q.push(v);
                        //cout << v << endl;
                    }
                    else if (color[v] == color[u]) {
                        return false;
                    }
                }
            }
        }
    }
}",1.0,1111111111
Queue_8,1527750,2213250,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n= nums.size();
    deque<int> q;
    q.push_back(0);
    for(int i=1;i<k;i++)
    {
        if (i==n) break;
        while(!q.empty() && nums[i]>= nums[q.back()])
        {
            q.pop_back();
        }
        q.push_back(i);
    }
    int ans =0;
    for(int i=k;i<n;i++)
    {
        ans+= nums[q.front()];
        while(!q.empty() && q.front() <= i -k) q.pop_front();
        while(!q.empty() && nums[i]>= nums[q.back()]) q.pop_back();
        q.push_back(i);
    }
    ans+= nums[q.front()];
    return ans;
}",1.0,1111111111
Queue_1,1528456,2212935,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    vector <int> color(n, -1);
    queue <int> q;
    for (int i = 0; i < n; i++){
        if (color[i] != -1) continue;
        color[i] = 0;
        q.push(i);
        while (!q.empty()){
            int cur = q.front();
            q.pop();
            for (int neighbor : graph[cur]){
                if (color[neighbor] == -1){
                    color[neighbor] = 1 - color[cur];
                    q.push(neighbor);
                }
                else if (color[neighbor] == color[cur]){
                    return false;
                }
            }
        }
    }
    return true;
}",1.0,1111111111
Queue_2,1528456,2212935,"void bfs(vector<vector<int>> graph, int start) {
	int n = graph.size();
	vector<bool> visited (n, false);
	queue<int>q;
	visited[start] = true;
	q.push(start);
	while (!q.empty()){
	    int current = q.front();
	    q.pop();
	    cout << current << "" "";
	    for (int i = 0; i < graph[current].size(); ++i){
	        int neighbor = graph[current][i];
	        if (!visited[neighbor]){
	            visited[neighbor] = true;
	            q.push(neighbor);
	        }
	    }
	}
}",1.0,1111111111
Queue_3,1528456,2212935,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    if (empty()) 
    throw std::runtime_error(""Queue is empty."");
    T poppeditem = list.get(0);
    list.removeItem(poppeditem);
    return poppeditem;
}

T top() {
    // TODO: Get value of the element in the head of the queue
        if (empty()) 
    throw std::runtime_error(""Queue is empty."");
    return list.get(0);
        
}

bool empty() {
    // TODO: Determine if the queue is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
    
}",1.0,11111
Queue_4,1528456,2212935,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue <long long> q;
    q.push(2);
    q.push(5);
    n -= 1;
    while (n--){
        long long x = q.front();
        q.pop();
        q.push(x*10+2);
        q.push(x*10+5);
    }
    return q.front();
}",1.0,1111111111
Queue_6,1528456,2212935,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue <int> q;
    for (int i = 1; i <= N; i++){
        q.push(i);
    }
    while (q.size() != 1){
        int j = 1;
        while (j < k){
            int front = q.front();
            q.push(front);
            q.pop();
            j++;
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_7,1528456,2212935,"int numberOfTheWinner(int N, int k) {
    queue <int> q;
    for (int i = 1; i <= N; i++){
        q.push(i);
    }
    while (q.size() != 1){
        int j = 1;
        while (j < k){
            int front = q.front();
            q.push(front);
            q.pop();
            j++;
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_8,1528456,2212935,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    int sum = 0;
    deque<int>dq;
    for (int i = 0; i < k; i++){
        while (!dq.empty() && nums[i] >= nums[dq.back()]){
            dq.pop_back();
        }
        dq.push_back(i);
    }
    sum += nums[dq.front()];
    for (int i = k; i < n; i++){
        while (!dq.empty() && dq.front() <= i - k){
            dq.pop_front();
        }
        while (!dq.empty() && nums[i] >= nums[dq.back()]){
            dq.pop_back();
        }
        dq.push_back(i);
        sum += nums[dq.front()];
    }
    return sum;
}",1.0,1111111111
Queue_9,1528456,2212935,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int>inDegree(n,0);
    vector<int> result;
    for (const vector<int>& edges : graph){
        for (int nodes : edges){
            inDegree[nodes]++;
    }
    }
    queue<int> q;
    for (int i = 0; i < n; i++){
        if (inDegree[i] == 0){
            q.push(i);
        }
    }
    while (!q.empty()){
        int node = q.front();
        q.pop();
        result.push_back(node);
        for (int adjNode : graph[node]){
            inDegree[adjNode]--;
            if (inDegree[adjNode] == 0){
                q.push(adjNode);
            }
        }
    }
    int l = result.size();
    if (l < n){
        return vector<int>();
    }
    else {
        return result;
    }
}",1.0,1111111111
Queue_1,1528749,2013048,"bool isBipartite(vector<vector<int>>& graph) {
    int n = graph.size();
    vector<int> colors(n, 0);
    for(int i = 0; i < n; i++){
        if(colors[i] == 0){
            queue<int> q;
            q.push(i);
            colors[i] = 1;
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                for (int neighbor : graph[node]) {
                    if (colors[neighbor] == 0) {
                        // Color the neighbor with the opposite color of the current node
                        colors[neighbor] = -colors[node];
                        q.push(neighbor);
                    } else if (colors[neighbor] == colors[node]) {
                        // If the neighbor has the same color as the current node, it's not bipartite
                        return false;
                    }
                }
            }
        }
    }
    return true;
}",1.0,1111111111
Queue_2,1528749,2013048,"void bfs(vector<vector<int>> graph, int start) {
	int n = graph.size();
    vector<bool> visited(n, false);
    queue<int> printList, q;
    q.push(start);
    visited[start] = true;
    while (!q.empty()) {
        int node = q.front();
        printList.push(node);
        q.pop();
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = 1;
                q.push(neighbor);
            } 
        }
    }
    while(printList.size() > 1){
        cout << printList.front() << "" "";
        printList.pop();
    }
    cout << printList.front();
}",1.0,1111111111
Queue_3,1528749,2013048,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(list.size(), item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    T item = list.get(0);
    list.removeAt(0);
    return item;
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
    return !(list.size());
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1528749,2013048,"long long nthNiceNumber(int n) {
    queue<long long> q;
    vector<long long> niceNums;
    q.push(2);
    q.push(5);
    for(int i = 0; !q.empty() && i < n; i++){
        long long num = q.front();
        q.pop();
        niceNums.push_back(num);
        q.push(num*10+2);
        q.push(num*10+5);
    }
    return niceNums[n-1];
}",1.0,1111111111
Queue_5,1528749,2013048,"int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    int freshApples = 0;
    queue<pair<int, int>> rotten;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 2) {
                rotten.push({i, j});
            } else if (grid[i][j] == 1) {
                freshApples++;
            }
        }
    }
    if (freshApples == 0) {
        return 0;
    }
    vector<pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    int sec = 0;
    while (!rotten.empty()) {
        int currentSize = rotten.size();
        for (int i = 0; i < currentSize; i++) {
            int x = rotten.front().first;
            int y = rotten.front().second;
            rotten.pop();
            for (auto dir : directions) {
                int newX = x + dir.first;
                int newY = y + dir.second;
                if (newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1) {
                    grid[newX][newY] = 2; // Mark the fresh apple as rotten
                    rotten.push({newX, newY});
                    freshApples--;
                }
            }
        }
        if (!rotten.empty()) {
            sec++;
        }
    }
    return (freshApples == 0) ? sec : -1;
}",1.0,1111111111
Queue_8,1528749,2013048,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    int sum = 0;
    vector<int> v;
    for (int i = 0; i < k; i++) {
        while (!v.empty() && nums[i] > v.back()) {
            v.pop_back();
        }
        v.push_back(nums[i]);
    }
    sum += v.front();
    for (int i = k; i < n; i++) {
        if (v.front() == nums[i - k]) {
            v.erase(v.begin());
        }
        while (!v.empty() && nums[i] > v.back()) {
            v.pop_back();
        }
        v.push_back(nums[i]);
        sum += v.front();
    }
    return sum;
}",1.0,1111111111
Queue_9,1528749,2013048,"#include <iostream>
#include <vector>
#include <queue>

using namespace std;

vector<int> topologicalSorting(vector<vector<int>> graph) {
    size_t n = graph.size(); // Use size_t instead of int for vector size

    vector<int> inDegree(n, 0);
    vector<int> result;
    
    // Calculate in-degrees for all nodes
    for (size_t i = 0; i < n; ++i) { // Use size_t here as well
        for (size_t j = 0; j < graph[i].size(); ++j) { // Use size_t here as well
            int neighbor = graph[i][j];
            inDegree[neighbor]++;
        }
    }

    // Initialize the queue with nodes having in-degree 0
    queue<int> q;
    for (size_t i = 0; i < n; ++i) { // Use size_t here as well
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        // Reduce in-degree of neighboring nodes
        for (size_t i = 0; i < graph[node].size(); ++i) { // Use size_t here as well
            int neighbor = graph[node][i];
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    // If there is a cycle, the result size won't be equal to n
    if (result.size() != n) {
        return vector<int>(); // Empty vector indicates no valid topological order
    } else {
        return result;
    }
}",1.0,1111111111
Queue_1,1528828,1912532,"bool isBipartite(std::vector<std::vector<int>>& graph) {
    int n = graph.size();
    std::vector<int> color(n, -1); // Initialize all nodes with no color.

    for (int start = 0; start < n; ++start) {
        if (color[start] != -1) {
            continue; // Skip visited nodes.
        }

        std::queue<int> q;
        q.push(start);
        color[start] = 0; // Color the initial node with 0.

        while (!q.empty()) {
            int u = q.front();
            q.pop();

            for (int v : graph[u]) {
                if (color[v] == -1) {
                    color[v] = 1 - color[u]; // Color with the opposite color.
                    q.push(v);
                } else if (color[v] == color[u]) {
                    return false; // If adjacent nodes have the same color, the graph is not bipartite.
                }
            }
        }
    }

    return true;
}",1.0,1111111111
Queue_2,1528828,1912532,"void bfs(std::vector<std::vector<int>> graph, int start) {
    int n = graph.size();
    std::vector<bool> visited(n, false);
    std::queue<int> q;
    
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        std::cout << node << "" "";

        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}
",1.0,1111111111
Queue_3,1528828,1912532,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
        
}

T pop() {
    // TODO: Remove an element in the head of the queue
        return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);
        
}

bool empty() {
    // TODO: Determine if the queue is empty
    return (list.size() == 0);
        
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
        
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
    
}",1.0,11111
Queue_4,1528828,1912532,"
long long nthNiceNumber(int n) {
    if (n == 1) return 2;  // The first nice number is 2

    std::queue<long long> q;
    q.push(2);
    q.push(5);

    long long nice;
    for (int i = 1; i <= n; i++) {
        nice = q.front();
        q.pop();

        q.push(nice * 10 + 2);
        q.push(nice * 10 + 5);
    }

    return nice;
}

",0.9,1111111111
Queue_5,1528828,1912532,"struct Cell {
    int x, y, time;
    Cell(int x, int y, int time) : x(x), y(y), time(time) {}
};

int secondsToBeRotten(std::vector<std::vector<int>>& grid) {
    const int rows = grid.size();
    const int cols = grid[0].size();
    const std::vector<std::pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    
    std::queue<Cell> rottenApples;
    int freshApplesCount = 0;

    // Initialize the rotten apples and count the fresh apples
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (grid[i][j] == 2) {
                rottenApples.push(Cell(i, j, 0));
            }
            if (grid[i][j] == 1) {
                freshApplesCount++;
            }
        }
    }

    int minTime = 0;
    
    while (!rottenApples.empty()) {
        Cell current = rottenApples.front();
        rottenApples.pop();

        for (const auto& dir : directions) {
            int newX = current.x + dir.first;
            int newY = current.y + dir.second;

            if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && grid[newX][newY] == 1) {
                grid[newX][newY] = 2; // Mark the fresh apple as rotten
                rottenApples.push(Cell(newX, newY, current.time + 1));
                freshApplesCount--;

                if (current.time + 1 > minTime) {
                    minTime = current.time + 1;
                }
            }
        }
    }

    return (freshApplesCount == 0) ? minTime : -1;
}",1.0,1111111111
Queue_8,1528828,1912532,"int sumOfMaxSubarray(std::vector<int>& nums, int k) {
    int n = nums.size();
    
    // A deque to store indices of elements in the current window.
    std::deque<int> window;
    int sum = 0;
    
    // Initialize the deque for the first window.
    for (int i = 0; i < k; ++i) {
        // Remove elements from the back of the deque if they are smaller than the current element.
        while (!window.empty() && nums[i] >= nums[window.back()]) {
            window.pop_back();
        }
        window.push_back(i);
    }
    
    // Process the rest of the elements.
    for (int i = k; i < n; ++i) {
        // The front of the deque stores the maximum element in the current window.
        sum += nums[window.front()];
        
        // Remove elements from the front of the deque if they are out of the current window.
        while (!window.empty() && window.front() <= i - k) {
            window.pop_front();
        }
        
        // Remove elements from the back of the deque if they are smaller than the current element.
        while (!window.empty() && nums[i] >= nums[window.back()]) {
            window.pop_back();
        }
        window.push_back(i);
    }
    
    // Add the maximum of the last window to the sum.
    sum += nums[window.front()];
    
    return sum;
}",1.0,1111111111
Queue_9,1528828,1912532,"std::vector<int> topologicalSorting(std::vector<std::vector<int>> graph) {
    int n = graph.size();
    
    // Calculate the in-degrees of each node.
    std::vector<int> inDegree(n, 0);
    for (int i = 0; i < n; ++i) {
        for (int neighbor : graph[i]) {
            inDegree[neighbor]++;
        }
    }
    
    // Initialize a queue for nodes with in-degree zero.
    std::queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }
    
    std::vector<int> result;
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);
        
        // Update in-degrees of neighboring nodes.
        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            
            // If the in-degree becomes zero, add it to the queue.
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }
    
    // If all nodes are included in the result, return the topological order.
    if (result.size() == static_cast<size_t>(n)) {
        return result;
    } else {
        return std::vector<int>(); // Graph contains a cycle, return an empty vector.
    }
}",1.0,1111111111
Queue_1,1531170,2210535,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> color(n, -1); 

    for (int i = 0; i < n; i++) {
        if (color[i] == -1) { 
            queue<int> q;
            q.push(i);
            color[i] = 0; 

            while (!q.empty()) {
                int u = q.front();
                q.pop();

                for (int v : graph[u]) {
                    if (color[v] == -1) {
                        color[v] = 1 - color[u]; 
                        q.push(v);
                    } else if (color[v] == color[u]) {
                        return false; 
                    }
                }
            }
        }
    }
    return true; 
}
",1.0,1111111111
Queue_2,1531170,2210535,"void bfs(vector<vector<int>> graph, int start) {
	deque<int> q;
    q.push_back(start);
    int row = graph.size();
    vector<int> vt(1000, 0);
    vector<int> ans;
    vt[start] = 1;
    while (!q.empty())
    {
        int row = q.front();
        ans.push_back(row);
        q.pop_front();
        int col = graph[row].size();
        for (int i = 0; i < col; i++)
        {
            if (vt[graph[row][i]]) continue;
            vt[graph[row][i]] = 1;
            q.push_back(graph[row][i]);
        }
    }
    if(ans.size()) cout << ans[0];
    for (int i = 1; i < ans.size(); i++)
    {
        cout << "" "" << ans[i];
    }
}",1.0,1111111111
Queue_3,1531170,2210535,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element in the head of the queue
    return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
    return list.empty();
}

int size() {
    // TODO: Get the size of the queue
    return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}
",1.0,11111
Queue_4,1531170,2210535,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    if (n == 1) {
        return 2;
    }
    else if (n == 2)    {
        return 5;
    }
    else if (n == 0)    {
        return -1;
    }
    queue<long long> queue;
    queue.push(2);
    queue.push(5);
    for (int i=0; i<n-1; i++) {
        long long temp = queue.front();
        queue.pop();
        queue.push(temp*10+2);
        queue.push(temp*10+5);
    }
    
    return queue.front();
}
",1.0,1111111111
Queue_5,1531170,2210535,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    if (n == 0) {
        return -1;
    }
    int m= grid[0].size();
    queue<pair<int,int>> q;
    int sizeofq = 0;
    int sec = -1;
    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            if (grid[i][j] == 2)    {
                q.push(make_pair(i,j));
                sizeofq++;
            }
        }
    }
    int sizeofq1 = 0;
    while (!q.empty())  {
        sec++;
        for (int i=0; i < sizeofq; i++) {
            pair<int,int> temp = q.front();
            q.pop();
            if (temp.first != 0)    {
                if (grid[temp.first-1][temp.second] == 1)   {
                    grid[temp.first-1][temp.second] = 2;
                    q.push(make_pair(temp.first-1,temp.second));
                    sizeofq1++;
                }
            }
            if (temp.second != 0)    {
                if (grid[temp.first][temp.second-1] == 1)   {
                    grid[temp.first][temp.second-1] = 2;
                    q.push(make_pair(temp.first,temp.second-1));
                    sizeofq1++;
                }
            }
            if (temp.first != n-1)    {
                if (grid[temp.first+1][temp.second] == 1)   {
                    grid[temp.first+1][temp.second] = 2;
                    q.push(make_pair(temp.first+1,temp.second));
                    sizeofq1++;
                }
            }
            if (temp.second != m-1)    {
                if (grid[temp.first][temp.second+1] == 1)   {
                    grid[temp.first][temp.second+1] = 2;
                    q.push(make_pair(temp.first,temp.second+1));
                    sizeofq1++;
                }
            }
        }
        sizeofq = sizeofq1;
        sizeofq1 = 0;
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (grid[i][j] == 1) return -1;
        }
    }
    return sec;
}
",1.0,1111111111
Queue_6,1531170,2210535,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1;i<=N;i++){
        q.push(i);
    }
    while(q.front()!=q.back()){
        int cnt=k-1;
        while(cnt>0){
            int temp=q.front();
            q.pop();
            q.push(temp);
            cnt--;
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_7,1531170,2210535,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1;i<=N;i++){
        q.push(i);
    }
    while(q.front()!=q.back()){
        int cnt=k-1;
        while(cnt>0){
            int temp=q.front();
            q.pop();
            q.push(temp);
            cnt--;
        }
        q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_8,1531170,2210535,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    deque<int> deque;
    int sum=0;
    for (int i=0; i<k; i++) {
        if (i == n) {
            break;
        }
        while (!deque.empty() && nums[i] > nums[deque.back()])  {
            deque.pop_back();
        }
        deque.push_back(i);
    }
    for (int i=k; i<n; i++) {
        sum += nums[deque.front()];
        while (!deque.empty() && deque.front() <= i-k)    {
            deque.pop_front();
        }
        while (!deque.empty() && nums[i] > nums[deque.back()])  {
            deque.pop_back();
        }
        deque.push_back(i);
    }
    sum+= nums[deque.front()];
    return sum;
}",1.0,1111111111
Queue_9,1531170,2210535,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n, 0);
    queue<int> q;
    vector<int> result;

    for (int i = 0; i < n; ++i) {
        for (int j : graph[i]) {
            inDegree[j]++;
        }
    }


    for (int i = 0; i < n; ++i) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        // Reduce in-degree of adjacent nodes
        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    int z = result.size();
    if (z != n) {
        return vector<int>(); 
    }

    return result;
}",1.0,1111111111
Queue_1,1531636,2210055,"bool isBipartite(vector<vector<int>> graph) {
int n = graph.size();
    std::vector<int> colors(n, -1);

    for (int i = 0; i < n; i++) {
        if (colors[i] == -1) { 
            std::queue<int> q;
            q.push(i);
            colors[i] = 0; 

            while (!q.empty()) {
                int node = q.front();
                q.pop();

                int currentColor = colors[node];
                int neighborColor = 1 - currentColor; 

                for (int neighbor : graph[node]) {
                    if (colors[neighbor] == -1) {
                        colors[neighbor] = neighborColor;
                        q.push(neighbor);
                    } else if (colors[neighbor] != neighborColor) {
                        return false;
                    }
                }
            }
        }
    }

    return true;
}",1.0,1111111111
Queue_2,1531636,2210055,"void bfs(vector<vector<int>> graph, int start) {
	int numNodes = graph.size();
    vector<bool> visited(numNodes, false); 
    queue<int> q; 
    q.push(start);
    visited[start] = true;
    while (!q.empty()) {
        int current = q.front();
        q.pop();
        cout << current << "" "";
        for (int neighbor : graph[current]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}",1.0,1111111111
Queue_3,1531636,2210055,"void push(T item) {
    // TODO: Push new element into the end of the queue
     list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
        if (empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        T frontItem = list.get(0); // Get the first item
        list.removeAt(0); 
        return frontItem;
}

T top() {
    // TODO: Get value of the element in the head of the queue
         if (empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        return list.get(0); 
}

bool empty() {
    // TODO: Determine if the queue is empty
          return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1531636,2210055,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
     string arr[n + 1];
    arr[0] = """"; 
    int size = 1, m = 1;
    while (size <= n) {
        for (int i = 0; i < m && (size + i) <= n; i++)
            arr[size + i] = ""2"" + arr[size - m + i];
        for (int i = 0; i < m && (size + m + i) <= n; i++)
            arr[size + m + i] = ""5"" + arr[size - m + i];
        m = m << 1; 
        size = size + m;
    }
    return stoll(arr[n]);
}",0.2,110
Queue_5,1531636,2210055,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
  int m = grid[0].size();

  // Create a queue to store the coordinates of the rotten apples.
  queue<pair<int, int>> rottenApplesQueue;

  // Initialize the queue with the coordinates of all the rotten apples.
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (grid[i][j] == 2) {
        rottenApplesQueue.push({i, j});
      }
    }
  }

  // Keep track of the number of seconds required to rot all apples.
  int seconds = 0;

  // While the queue is not empty, keep rotting the fresh apples adjacent to the rotten apples.
  while (!rottenApplesQueue.empty()) {
    // Get the coordinates of the current rotten apple.
    pair<int, int> currentRottenApple = rottenApplesQueue.front();
    rottenApplesQueue.pop();

    // Rot all the fresh apples adjacent to the current rotten apple.
    for (int i = -1; i <= 1; i++) {
      for (int j = -1; j <= 1; j++) {
        int newX = currentRottenApple.first + i;
        int newY = currentRottenApple.second + j;

        // Check if the new coordinates are within the grid and if the cell at the new coordinates contains a fresh apple.
        if (newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1) {
          // Rot the fresh apple.
          grid[newX][newY] = 2;

          // Add the coordinates of the new rotten apple to the queue.
          rottenApplesQueue.push({newX, newY});
        }
      }
    }

    // Increment the number of seconds.
    seconds++;
  }

  // Check if all the apples have been rotted.
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (grid[i][j] == 1) {
        return -1;
      }
    }
  }

  // Return the number of seconds required to rot all apples.
  return seconds;
}",0.1,1000000000
Queue_6,1531636,2210055,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    deque<int> circle;
    
    for (int i = 1; i <= N; i++) {
        circle.push_back(i);
    }
    
    while (circle.size() > 1) {
        for (int i = 0; i < k - 1; i++) {
            circle.push_back(circle.front());
            circle.pop_front();
        }
        circle.pop_front();
    }
    
    return circle.front();
}",1.0,1111111111
Queue_7,1531636,2210055,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    deque<int> circle;
    
    for (int i = 1; i <= N; i++) {
        circle.push_back(i);
    }
    
    while (circle.size() > 1) {
        for (int i = 0; i < k - 1; i++) {
            circle.push_back(circle.front());
            circle.pop_front();
        }
        circle.pop_front();
    }
    
    return circle.front();
}",1.0,1111111111
Queue_8,1531636,2210055,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    if (n == 0 || k > n || k <= 0) {
        return 0; 
    }
    deque<int> maxIndices; 
    int sumOfMax = 0;

    for (int i = 0; i < k; ++i) {
        while (!maxIndices.empty() && nums[i] >= nums[maxIndices.back()]) {
            maxIndices.pop_back();
        }
        maxIndices.push_back(i);
    }

    sumOfMax += nums[maxIndices.front()];

 
    for (int i = k; i < n; ++i) {
        while (!maxIndices.empty() && maxIndices.front() <= i - k) {
            maxIndices.pop_front();
        }
        while (!maxIndices.empty() && nums[i] >= nums[maxIndices.back()]) {
            maxIndices.pop_back();
        }

        maxIndices.push_back(i);
        sumOfMax += nums[maxIndices.front()];
    }

    return sumOfMax;

}",1.0,1111111111
Queue_9,1531636,2210055,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size(); 
    vector<int> inDegree(n, 0); 
    vector<int> result; 

    for (int i = 0; i < n; i++) {
        for (int neighbor : graph[i]) {
            inDegree[neighbor]++;
        }
    }
    queue<int> q;
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    int length=result.size();
    if (length != n) {
        return vector<int>(); 
    }

    return result;
}",1.0,1111111111
Queue_1,1531963,2212282,"bool isBipartite(vector<vector<int>>& graph) {
    int n = graph.size();
    vector<int> color(n, -1);  

    for (int i = 0; i < n; ++i) {
        if (color[i] != -1) continue;  

        color[i] = 0;  

        queue<int> q;
        q.push(i);

        while (!q.empty()) {
            int curr = q.front();
            q.pop();

            for (int neighbor : graph[curr]) {
                if (color[neighbor] == -1) {
                    color[neighbor] = 1 - color[curr];  
                    q.push(neighbor);
                } else if (color[neighbor] == color[curr]) {
                    return false;  
                }
            }
        }
    }

    return true;
}",1.0,1111111111
Queue_2,1531963,2212282,"void bfs(vector<vector<int>> graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false);
    queue<int> q;

    visited[start] = true;
    q.push(start);

    while (!q.empty()) {
        int current = q.front();
        q.pop();
        cout << current << "" "";

        for (int neighbor : graph[current]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}
",1.0,1111111111
Queue_3,1531963,2212282," void push(T item) {
        list.add(item);
    }

    T pop() {
        if (list.empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        T front = list.get(0);
        list.removeAt(0);
        return front;
    }

    T top() {
        if (list.empty()) {
            throw std::runtime_error(""Queue is empty"");
        }
        return list.get(0);
    }

    bool empty() {
        return list.empty();
    }

    int size() {
        return list.size();
    }

    void clear() {
        list.clear();
    }",1.0,11111
Queue_4,1531963,2212282,"long long nthNiceNumber(int n) {
    std::queue<long long> q;
    q.push(2);  
    q.push(5);  

    for (int i = 1; i < n; ++i) {
        long long current = q.front();
        q.pop();
        q.push(current * 10 + 2);
        q.push(current * 10 + 5);
    }

    return q.front();
}",1.0,1111111111
Queue_5,1531963,2212282,"int secondsToBeRotten(vector<vector<int>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    vector<pair<int, int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    queue<pair<int, int>> rottenQueue;
    int freshCount = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == 2) {
                rottenQueue.push({i, j});
            } else if (grid[i][j] == 1) {
                freshCount++;
            }
        }
    }
     if (freshCount == 0) {
        return 0;
    }
     int seconds = 0;
    while (!rottenQueue.empty()) {
        int size = rottenQueue.size();
        bool rottenOccurred = false;
    for (int i = 0; i < size; i++) {
            int x = rottenQueue.front().first;
            int y = rottenQueue.front().second;
            rottenQueue.pop();
    for (const auto& dir : directions) {
                int newX = x + dir.first;
                int newY = y + dir.second;
    if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && grid[newX][newY] == 1) {
                  
                    grid[newX][newY] = 2;
                    rottenQueue.push({newX, newY});
                    rottenOccurred = true;
                    freshCount--;
                }
            }
        }

        if (rottenOccurred) {
            seconds++;
        }
    }

    
    if (freshCount > 0) {
        return -1;
    }

    return seconds;
}",1.0,1111111111
Queue_6,1531963,2212282,"int numberOfTheWinner(int N, int k) {
    std::queue<int> players;

    
    for (int i = 1; i <= N; i++) {
        players.push(i);
    }

   
    while (players.size() > 1) {
      
        for (int i = 0; i < k - 1; i++) {
            int player = players.front();
            players.pop();
            players.push(player);
        }

       
        players.pop();
    }

    
    return players.front();
}",1.0,1111111111
Queue_7,1531963,2212282,"int numberOfTheWinner(int N, int k) {
    std::queue<int> players;

    // Enqueue all players from 1 to N
    for (int i = 1; i <= N; i++) {
        players.push(i);
    }

    // Simulate the game
    while (players.size() > 1) {
        // Dequeue k-1 players and enqueue them at the end
        for (int i = 0; i < k - 1; i++) {
            int player = players.front();
            players.pop();
            players.push(player);
        }

        // Dequeue the k-th player and remove them from the game
        players.pop();
    }

    // The remaining player in the queue is the winner
    return players.front();
}",1.0,1111111111
Queue_8,1531963,2212282,"int sumOfMaxSubarray(std::vector<int>& nums, int k) {
    std::deque<int> dq;
    int n = nums.size();
    int sum = 0;

    // Initialize the deque with the first k elements
    for (int i = 0; i < k; i++) {
        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }
        dq.push_back(i);
    }

    // Process the remaining elements
    for (int i = k; i < n; i++) {
        sum += nums[dq.front()];

        // Remove elements from the front of the deque that are outside the current subarray
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }

        // Remove elements from the back of the deque that are smaller than the current element
        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }

        dq.push_back(i);
    }

    // Add the maximum element of the last subarray to the sum
    sum += nums[dq.front()];

    return sum;
}",1.0,1111111111
Queue_9,1531963,2212282,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n, 0); // Stores the in-degree of each node
    vector<int> result; // Stores the topological order

    // Calculate the in-degree of each node
    for (int i = 0; i < n; ++i) {
        for (int j : graph[i]) {
            inDegree[j]++;
        }
    }

    queue<int> q;
    // Enqueue nodes with in-degree 0
    for (int i = 0; i < n; ++i) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        // Reduce the in-degree of adjacent nodes
        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    // If there are still nodes remaining with non-zero in-degree, the graph has a cycle
    for (int i = 0; i < n; ++i) {
        if (inDegree[i] > 0) {
            return vector<int>(); // Empty vector represents no valid topological order
        }
    }

    return result;
}",1.0,1111111111
Queue_1,1532256,2210200,"bool isBipartite(vector<vector<int>> graph) {
    bool ans = true;
    int n = graph.size();
    vector<int> color(n , 0);
    for(int i = 0; i < n; i++){
        if(color[i] == 0){
            queue<int> q;
            q.push(i);
            color[i] = 1;
            while(!q.empty()){
                int v = q.front();
                q.pop();
                for(int x : graph[v]){
                    if(color[x] == 0){
                        color[x] = 3 - color[v];
                        q.push(x);
                    }
                    else if(color[x] == color[v]){
                        ans = false;
                    }
                }
            }
        }
    }
    return ans;
}",1.0,1111111111
Queue_2,1532256,2210200,"void bfs(vector<vector<int>> graph, int start) {
    queue<int> q;
    int n = graph.size();
    vector<int> vs(n, 0);
    q.push(start);
    vs[start] = 1;
    cout << start << "" "";
    while(!q.empty()){
        int v = q.front();
        q.pop();
        for(int x : graph[v]){
            if(!vs[x]){
                cout << x << "" "";
                vs[x] = 1;
                q.push(x);
            }
        }
    }
}",1.0,1111111111
Queue_4,1532256,2210200,"// iostream, vector and queue are included
// You can write helper methods

long long init(int n){
    vector<string> save;
    queue<string> q;
    q.push(""2"");
    q.push(""5"");
    save.push_back(""2"");
    save.push_back(""5"");
    for(int i = 2; i < n; i++){
        string top = q.front(); q.pop();
        q.push(top + ""2"");
        q.push(top + ""5"");
        save.push_back(top + ""2"");
        save.push_back(top + ""5"");
    }
    string t = save[n - 1];
    long long ans = stoll(t);
    return ans;
}

long long nthNiceNumber(int n) {
    return init(n);
}",1.0,1111111111
Queue_5,1532256,2210200,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size(); // row size
    int m = grid[0].size(); // column size
 
    int delrow[] = { -1, 0, 1, 0 };
    int delcol[] = { 0, 1, 0, -1 };
 

    int vis[n][m];

    queue<pair<pair<int, int>, int> > q;
    int cntfresh = 0;
 
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 2) {
                q.push({{i,j},0});
                vis[i][j] = 2; 
            }
            else {
                vis[i][j] = 0; 
            }
            if (grid[i][j] == 1)
                cntfresh++; 
        }
    }
    int cnt = 0, tm = 0;
    while (!q.empty()) {
        int row = q.front().first.first; 
        int col = q.front().first.second; 
        int t = q.front().second; 
        q.pop();
        tm = max(tm, t);
        for (int i = 0; i < 4; i++) {
            int nrow = row + delrow[i];
            int ncol = col + delcol[i];
            if (nrow >= 0 && nrow < n && ncol >= 0
                && ncol < m && grid[nrow][ncol] == 1
                && vis[nrow][ncol] != 2) {
                vis[nrow][ncol] = 2; 
                q.push({ { nrow, ncol }, t + 1 }); 
                cnt++;
            }
        }
    }
    return ((cnt == cntfresh) ? tm : -1);
}
",1.0,1111111111
Queue_6,1532256,2210200,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i = 1; i <= N; i++){
        q.push(i);
    }
    int cnt = 0;
    while(q.size() > 1){
        ++cnt;
        int x = q.front();
        q.pop();
        if(cnt == k){
            cnt = 0;
        }
        else{
            q.push(x);    
        }
    }
    return q.front();
}",1.0,1111111111
Queue_8,1532256,2210200,"int sumOfMaxSubarray(vector<int>& arr, int K) {
    // STUDENT ANSWER
    int N = arr.size();
    std::deque<int> Qi(K);
    int i;
    for (i = 0; i < K; ++i) {
 
        // For every element, the previous
        // smaller elements are useless so
        // remove them from Qi
        while ((!Qi.empty()) && arr[i] >= arr[Qi.back()])
 
            // Remove from rear
            Qi.pop_back();
 
        // Add new element at rear of queue
        Qi.push_back(i);
    }
    int ans = 0;
    // Process rest of the elements,
    // i.e., from arr[k] to arr[n-1]
    for (; i < N; ++i) {
        ans += arr[Qi.front()];
        
        while ((!Qi.empty()) && Qi.front() <= i - K)
 
            Qi.pop_front();

        while ((!Qi.empty()) && arr[i] >= arr[Qi.back()])
            Qi.pop_back();

        Qi.push_back(i);
    }
 
    ans += arr[Qi.front()];
    return ans;
}",1.0,1111111111
Queue_9,1532256,2210200,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> indegree(n, 0);
    for(int i = 0; i < n; i++){
        for(int x : graph[i]){
            ++indegree[x];
        }
    }
    queue<int> q;
    for(int i = 0; i < n; i++){
        if(!indegree[i]) q.push(i); 
    }
    vector<int> topo;
    while(!q.empty()){
        int v = q.front();
        q.pop();
        topo.push_back(v);
        for(int x : graph[v]){
            --indegree[x]; 
            if(!indegree[x]) q.push(x);
        }
    }
    int sz = topo.size();
    if(sz < n){
        vector<int> ans;
        return ans;
    }
    return topo;
}",1.0,1111111111
Queue_1,1532369,2210103,"bool isBipartite(vector<vector<int>> graph) {

}",0.5,1001111000
Queue_1,1532374,2211878,"bool isBipartite(vector<vector<int>> graph) {

}",0.5,1001111000
Queue_1,1532381,2213298,"bool isBipartite(vector<vector<int>> graph) {

}",0.5,1001111000
Queue_8,1532381,2213298,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    if (k == 0 || nums.size() == 0)  return 0;
    if (k > nums.size()) {
        
    }
    else {
        queue<int> q;
        priority_queue<int> pq;
        int sum = 0;
        for (int i = 0; i < nums.size(); ++i) {
            q.push(nums[i]);
            pq.push(nums[i]);
            if (q.size() > k) {
                if (q.front() == pq.top()) pq.pop();
                q.pop();
            }
            if (q.size() == k) sum += pq.top();
        }
        return sum;
    }
}",0.9,1101111111
Queue_1,1532384,2211738,"bool isBipartite(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> colors(n, -1); 

    for (int i = 0; i < n; i++) {
        if (colors[i] == -1) {
            queue<int> q;
            q.push(i);
            colors[i] = 0; 

            while (!q.empty()) {
                int u = q.front();
                q.pop();

                for (int v : graph[u]) {
                    if (colors[v] == -1) {
                        colors[v] = 1 - colors[u]; 
                        q.push(v);
                    }
                    else if (colors[v] == colors[u]) {
                        return false; 
                    }
                }
            }
        }
    }
    return true;
}",1.0,1111111111
Queue_2,1532384,2211738,"void bfs(vector<vector<int>> graph, int start) {
	queue<int> q;
	int n = graph.size();
	vector<bool> visited(n,false);
	visited[start] = true;
	q.push(start);
	while(!q.empty()){
	    int node = q.front();
	    cout << node << "" "";
	    
	    for(int i = 0; i < graph[node].size(); i++){
	        if(!visited[graph[node][i]]){
	            visited[graph[node][i]] = true;
	            q.push(graph[node][i]);
	        }
	    }
	    q.pop();
	}
	cout << endl;
}",1.0,1111111111
Queue_3,1532384,2211738,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
       return list.removeAt(0);
}

T top() {
    // TODO: Get value of the element in the head of the queue
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    list.clear();
}",1.0,11111
Queue_4,1532384,2211738,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    if (n == 1) {
        return 2;
    }
    queue<long long> q;
    q.push(2);
    q.push(5);

    while (true) {
        long long current = q.front();
        q.pop();
        n--;

        if (n == 0) {
            return current;
        }

        q.push(current * 10 + 2);
        q.push(current * 10 + 5);
    }
}",1.0,1111111111
Queue_5,1532384,2211738,"// iostream, vector and queue are included
// Hint: use breadth-first-search
const vector<int> dx = {1, -1, 0, 0};
const vector<int> dy = {0, 0, 1, -1};
int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    int freshApples = 0;
queue<pair<int, int>> rottenApples;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 2) {
                rottenApples.push({i, j});
            } else if (grid[i][j] == 1) {
                freshApples++;
            }
        }
    }

    int minutes = 0;

    while (!rottenApples.empty() && freshApples > 0) {
        int size = rottenApples.size();

        for (int i = 0; i < size; i++) {
            int x = rottenApples.front().first;
            int y = rottenApples.front().second;
            rottenApples.pop();

            for (int k = 0; k < 4; k++) {
                int newX = x + dx[k];
                int newY = y + dy[k];

                if (newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1) {
                    grid[newX][newY] = 2;
                    rottenApples.push({newX, newY});
                    freshApples--;
                }
            }
        }

        if (!rottenApples.empty()) {
            minutes++;
        }
    }
    return (freshApples == 0) ? minutes : -1;
}",1.0,1111111111
Queue_6,1532384,2211738,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i = 1; i <= N; i++){
        q.push(i);
    }
    int size = N;
    while(size > 1){
        for(int i = 0; i < k-1; i++){
            int front = q.front();
            q.pop();
            q.push(front);
        }
        q.pop();
        size--;
    }
    return q.front();
}",1.0,1111111111
Queue_7,1532384,2211738,"// iostream and queue are included
// Hint: Use a queue to simulate the process

int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i = 1; i <= N; i++){
        q.push(i);
    }
    int size = N;
    while(size > 1){
        for(int i = 0; i < k-1; i++){
            int front = q.front();
            q.pop();
            q.push(front);
        }
        q.pop();
        size--;
    }
    return q.front();
}",1.0,1111111111
Queue_8,1532384,2211738,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int n = nums.size();
    deque<int> maxDeque;
    int result = 0;

  
    for (int i = 0; i < k; i++) {
        while (!maxDeque.empty() && nums[i] >= nums[maxDeque.back()]) {
            maxDeque.pop_back();
        }
        maxDeque.push_back(i);
    }

    for (int i = k; i < n; i++) {
        result += nums[maxDeque.front()];

        
        while (!maxDeque.empty() && maxDeque.front() <= i - k) {
            maxDeque.pop_front();
        }

        
        while (!maxDeque.empty() && nums[i] >= nums[maxDeque.back()]) {
            maxDeque.pop_back();
        }

        maxDeque.push_back(i);
    }

  
    result += nums[maxDeque.front()];
    return result;
}",1.0,1111111111
Queue_9,1532384,2211738,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    vector<int> g;
    int numVer = graph.size();
    vector<int> in_degree(numVer, 0);

    for (int u = 0; u < numVer; u++) {
        for (auto i = graph[u].begin(); i != graph[u].end(); i++)
            in_degree[*i]++;
    }

    queue<int> q;
    for (int i = 0; i < numVer; i++)
        if (in_degree[i] == 0)
            q.push(i);
    int count = 0;
    vector<int> result;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        for (auto i = graph[u].begin(); i != graph[u].end(); i++)
            if (--in_degree[*i] == 0)
                q.push(*i);
        count++;
    }
    if (count != numVer) {
        return g;
    }
    return result;
}",1.0,1111111111
Queue_1,1536077,2213248,"/*bool isBipartite(vector<vector<int>> graph) {

}
bool isBipartite(int G[][V], int src) 
{ 
    // Create a color array to store colors  
    // assigned to all vertices. Vertex  
    // number is used as index in this array.  
    // The value '-1' of colorArr[i]  
    // is used to indicate that no color  
    // is assigned to vertex 'i'. The value 1  
    // is used to indicate first color  
    // is assigned and value 0 indicates  
    // second color is assigned. 
    int colorArr[V]; 
    for (int i = 0; i < V; ++i) 
        colorArr[i] = -1; 
  
    // Assign first color to source 
    colorArr[src] = 1; 
  
    // Create a queue (FIFO) of vertex  
    // numbers and enqueue source vertex 
    // for BFS traversal 
    queue <int> q; 
    q.push(src); 
  
    // Run while there are vertices  
    // in queue (Similar to BFS) 
    while (!q.empty()) 
    { 
        // Dequeue a vertex from queue ( Refer http://goo.gl/35oz8 ) 
        int u = q.front(); 
        q.pop(); 
  
        // Return false if there is a self-loop  
        if (G[u][u] == 1) 
        return false;  
  
        // Find all non-colored adjacent vertices 
        for (int v = 0; v < V; ++v) 
        { 
            // An edge from u to v exists and  
            // destination v is not colored 
            if (G[u][v] && colorArr[v] == -1) 
            { 
                // Assign alternate color to this adjacent v of u 
                colorArr[v] = 1 - colorArr[u]; 
                q.push(v); 
            } 
  
            // An edge from u to v exists and destination  
            // v is colored with same color as u 
            else if (G[u][v] && colorArr[v] == colorArr[u]) 
                return false; 
        } 
    } 
  
    // If we reach here, then all adjacent   
    // vertices can be colored with alternate color 
    return true; 
}*/
bool helper(vector<vector<int>>& graph , int src , vector<int>&colour ) {
    int n = graph.size();
    queue<int> q;
    q.push(src);
    colour[src] = 0 ;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(int i = 0 ; i<graph[u].size();i++){
            if(colour[graph[u][i]]==-1){
                colour[graph[u][i]] = !colour[u];
                q.push(graph[u][i]);
            }
            else if(colour[graph[u][i]]==colour[u]) return false;
        }
    }
    return true;
}
bool isBipartite(vector<vector<int>>& graph){
	int n = graph.size();
	vector<int> colour(n,-1);
	for(int i=0 ; i < n ; i++){
		if(colour[i]==-1){
			if(helper(graph,i,colour)==false) return false;
		}
	}
	return true;
}",1.0,1111111111
Queue_2,1536077,2213248,"void bfs(vector<vector<int>> graph, int start) {
	queue<int> q;
	q.push(start);
	int n = graph.size();
	vector<int> arr;
	vector<int> visited(n);
	visited[start] = 1 ;
	while(!q.empty()){
	    int u = q.front();
	    arr.push_back(u);
	    q.pop();
	    for(int i = 0 ; i <(int)graph[u].size();i++){
	        if(visited[graph[u][i]] == 0 ){
	            q.push(graph[u][i]);
	            visited[graph[u][i]] =  1;
	        }
	    }
	}
	for(int i=0 ; i<(int)arr.size();i++) cout<<arr[i]<<"" "";
}",1.0,1111111111
Queue_3,1536077,2213248,"void push(T item) {
    // TODO: Push new element into the end of the queue
    list.add(item);
}

T pop() {
    // TODO: Remove an element in the head of the queue
    T val = list.get(0);
        list.removeAt(0);
        return val;
}

T top() {
    // TODO: Get value of the element in the head of the queue
        return list.get(0);
}

bool empty() {
    // TODO: Determine if the queue is empty
        return list.empty();
}

int size() {
    // TODO: Get the size of the queue
        return list.size();
}

void clear() {
    // TODO: Clear all elements of the queue
    while(!list.empty()){
        list.removeAt(0);
    }
}",1.0,11111
Queue_4,1536077,2213248,"// iostream, vector and queue are included
// You can write helper methods

long long nthNiceNumber(int n) {
    queue<long long> q;
    q.push(2);  // The first nice number
    q.push(5);
    while (n > 2) {
        long long current = q.front();
        q.pop();
        q.push(current * 10 + 2);  // Add 2 to the end
        n--;
        if(n == 2) break;
        q.push(current * 10 + 5);  // Add 5 to the end
        n--;
    }

    return q.back();
}",1.0,1111111111
Queue_5,1536077,2213248,"// iostream, vector and queue are included
// Hint: use breadth-first-search

int secondsToBeRotten(vector<vector<int>>& grid) {
    int n = grid.size();
    int m = grid[0].size();
    queue<pair<int,int>> q;
    for(int i=0 ; i < n ; i++){
        for(int j = 0 ; j<m;j++){
            if(grid[i][j]==2) q.push({i,j});
        }
    }
    int sec = 0 ;
    while(!q.empty()){
        int s = q.size();
        //cout<<s<<endl;
        bool check = true;
        for(int i=0 ; i < n ; i++){
            for(int j = 0 ; j <m ; j++){
                if(grid[i][j]==1) check = false;
            }
        }
        if(check) break;
        for(int i = 0 ; i<s ; i++ ){
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            if(x+1<n && grid[x+1][y]==1){
                q.push({x+1,y});
                grid[x+1][y] = 2;
            }
            if(y+1<m && grid[x][y+1]==1){
                q.push({x,y+1});
                grid[x][y+1] = 2;
            }
            if(x-1>=0 && grid[x-1][y]==1){
                q.push({x-1,y});
                grid[x-1][y] = 2;
            }
            if(y-1>=0 && grid[x][y-1]==1){
                q.push({x,y-1});
                grid[x][y-1] = 2;
            }
        }
        sec++;
    }
    for(int i=0 ; i<n;i++){
        for(int j = 0 ; j< m ; j++){
            if(grid[i][j]==1) return -1;
        }
    }
    return sec;
}",1.0,1111111111
Queue_6,1536077,2213248,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1 ; i<=N;i++) q.push(i);
    while(q.size()!=1){
    	for(int i=0 ; i<k-1;i++){
    		int u = q.front();
    		q.pop();
    		q.push(u);
    	}
    	q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_7,1536077,2213248,"int numberOfTheWinner(int N, int k) {
    queue<int> q;
    for(int i=1 ; i<=N;i++) q.push(i);
    while(q.size()!=1){
    	for(int i=0 ; i<k-1;i++){
    		int u = q.front();
    		q.pop();
    		q.push(u);
    	}
    	q.pop();
    }
    return q.front();
}",1.0,1111111111
Queue_8,1536077,2213248,"int sumOfMaxSubarray(vector<int>& nums, int k) {
    // STUDENT ANSWER
    int ans = 0 ;
    int n = nums.size();
    deque<int> q;
    q.push_back(0);
    for(int i=1 ; i<k;i++){
        while(!q.empty() && nums[i]>=nums[q.back()]){
            q.pop_back();
        }
        q.push_back(i);
    }
    for(int i = k ; i<n;i++){
        ans+=nums[q.front()];
        while(!q.empty() && q.front()<=i-k) q.pop_front();
        while(!q.empty() && nums[i]>=nums[q.back()]) q.pop_back();
        q.push_back(i);
    }
    ans += nums[q.front()];
    return ans;
}",1.0,1111111111
Queue_9,1536077,2213248,"vector<int> topologicalSorting(vector<vector<int>> graph) {
    int n = graph.size();
    vector<int> inDegree(n,0);
    for(int u = 0 ; u<(int)graph.size();u++){
        for(int v = 0 ; v<(int)graph[u].size();v++){
            ++inDegree[graph[u][v]];
        }
    }
    queue<int> q;
    for(int i=0 ; i<n ; i++ ){
        if(inDegree[i]==0) q.push(i);
    }
    int cnt = 0 ;
    vector<int> top_order;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        top_order.push_back(u);
        for(int i = 0 ; i<(int)graph[u].size();i++){
            if(--inDegree[graph[u][i]]==0) q.push(graph[u][i]);
        }
        cnt++;
    }
    if(cnt!=n){
        return {};
    }
    else return top_order;
}",1.0,1111111111
